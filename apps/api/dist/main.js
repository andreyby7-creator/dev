/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {

module.exports = require("@nestjs/common");

/***/ }),
/* 2 */
/***/ ((module) => {

module.exports = require("@nestjs/core");

/***/ }),
/* 3 */
/***/ ((module) => {

module.exports = require("@nestjs/swagger");

/***/ }),
/* 4 */
/***/ ((module) => {

module.exports = require("compression");

/***/ }),
/* 5 */
/***/ ((module) => {

module.exports = require("fs");

/***/ }),
/* 6 */
/***/ ((module) => {

module.exports = require("helmet");

/***/ }),
/* 7 */
/***/ ((module) => {

module.exports = require("path");

/***/ }),
/* 8 */
/***/ ((module) => {

module.exports = require("reflect-metadata");

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppModule: () => (/* binding */ AppModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ai_ai_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _analytics_analytics_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _app_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var _app_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/* harmony import */ var _auth_auth_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27);
/* harmony import */ var _automation_automation_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
/* harmony import */ var _cache_cache_module__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58);
/* harmony import */ var _cards_cards_module__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64);
/* harmony import */ var _config_configuration_module__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(70);
/* harmony import */ var _devops_devops_module__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(75);
/* harmony import */ var _disaster_recovery_disaster_recovery_module__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(86);
/* harmony import */ var _features_feature_flags_module__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(115);
/* harmony import */ var _gateway_gateway_module__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(137);
/* harmony import */ var _monitoring_monitoring_module__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(154);
/* harmony import */ var _network_network_module__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(164);
/* harmony import */ var _observability_observability_module__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(176);
/* harmony import */ var _performance_performance_module__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(195);
/* harmony import */ var _regional_architecture_regional_architecture_module__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(199);
/* harmony import */ var _security_security_module__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(206);
/* harmony import */ var _supabase_supabase_module__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(46);
/* harmony import */ var _prisma_prisma_module__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(226);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};























let AppModule = class AppModule {
};
AppModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule.forRoot({
                isGlobal: true,
            }),
            _prisma_prisma_module__WEBPACK_IMPORTED_MODULE_22__.PrismaModule,
            _supabase_supabase_module__WEBPACK_IMPORTED_MODULE_21__.SupabaseModule,
            _auth_auth_module__WEBPACK_IMPORTED_MODULE_6__.AuthModule,
            _ai_ai_module__WEBPACK_IMPORTED_MODULE_2__.AiModule,
            _cards_cards_module__WEBPACK_IMPORTED_MODULE_9__.CardsModule,
            _observability_observability_module__WEBPACK_IMPORTED_MODULE_17__.ObservabilityModule,
            _security_security_module__WEBPACK_IMPORTED_MODULE_20__.SecurityModule,
            _devops_devops_module__WEBPACK_IMPORTED_MODULE_11__.DevOpsModule,
            _cache_cache_module__WEBPACK_IMPORTED_MODULE_8__.AppCacheModule,
            _features_feature_flags_module__WEBPACK_IMPORTED_MODULE_13__.FeatureFlagsModule,
            _network_network_module__WEBPACK_IMPORTED_MODULE_16__.NetworkModule,
            _regional_architecture_regional_architecture_module__WEBPACK_IMPORTED_MODULE_19__.RegionalArchitectureModule,
            _automation_automation_module__WEBPACK_IMPORTED_MODULE_7__.AutomationModule,
            _disaster_recovery_disaster_recovery_module__WEBPACK_IMPORTED_MODULE_12__.DisasterRecoveryModule,
            _gateway_gateway_module__WEBPACK_IMPORTED_MODULE_14__.GatewayModule,
            _config_configuration_module__WEBPACK_IMPORTED_MODULE_10__.ConfigurationModule,
            _monitoring_monitoring_module__WEBPACK_IMPORTED_MODULE_15__.MonitoringModule,
            _performance_performance_module__WEBPACK_IMPORTED_MODULE_18__.PerformanceModule,
            _analytics_analytics_module__WEBPACK_IMPORTED_MODULE_3__.AnalyticsModule,
        ],
        controllers: [_app_controller__WEBPACK_IMPORTED_MODULE_4__.AppController],
        providers: [_app_service__WEBPACK_IMPORTED_MODULE_5__.AppService],
    })
], AppModule);



/***/ }),
/* 10 */
/***/ ((module) => {

module.exports = require("@nestjs/config");

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiModule: () => (/* binding */ AiModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ai_code_assistant_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
/* harmony import */ var _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _ai_commit_analyzer_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17);
/* harmony import */ var _ai_docstring_generator_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18);
/* harmony import */ var _ai_code_optimizer_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(19);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








let AiModule = class AiModule {
};
AiModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        controllers: [_ai_code_assistant_controller__WEBPACK_IMPORTED_MODULE_1__.AiCodeAssistantController],
        providers: [
            _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__.AiCodeAssistantService,
            _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_3__.DynamicTypeChecksService,
            _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_4__.AstCodeModService,
            _ai_commit_analyzer_service__WEBPACK_IMPORTED_MODULE_5__.AiCommitAnalyzerService,
            _ai_docstring_generator_service__WEBPACK_IMPORTED_MODULE_6__.AiDocstringGeneratorService,
            _ai_code_optimizer_service__WEBPACK_IMPORTED_MODULE_7__.AiCodeOptimizerService,
        ],
        exports: [
            _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__.AiCodeAssistantService,
            _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_3__.DynamicTypeChecksService,
            _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_4__.AstCodeModService,
            _ai_commit_analyzer_service__WEBPACK_IMPORTED_MODULE_5__.AiCommitAnalyzerService,
            _ai_docstring_generator_service__WEBPACK_IMPORTED_MODULE_6__.AiDocstringGeneratorService,
            _ai_code_optimizer_service__WEBPACK_IMPORTED_MODULE_7__.AiCodeOptimizerService,
        ],
    })
], AiModule);



/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiCodeAssistantController: () => (/* binding */ AiCodeAssistantController),
/* harmony export */   BulkTransformationDto: () => (/* binding */ BulkTransformationDto),
/* harmony export */   GenerateApiContractDto: () => (/* binding */ GenerateApiContractDto),
/* harmony export */   GenerateCodeDto: () => (/* binding */ GenerateCodeDto),
/* harmony export */   GenerateDtoRequestDto: () => (/* binding */ GenerateDtoRequestDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
/* harmony import */ var _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;





class GenerateCodeDto {
}
class BulkTransformationDto {
}
class GenerateDtoRequestDto {
}
class GenerateApiContractDto {
}
let AiCodeAssistantController = class AiCodeAssistantController {
    constructor(aiCodeAssistantService, astCodeModService, dynamicTypeChecksService) {
        this.aiCodeAssistantService = aiCodeAssistantService;
        this.astCodeModService = astCodeModService;
        this.dynamicTypeChecksService = dynamicTypeChecksService;
    }
    async generateCode(request) {
        return this.aiCodeAssistantService.generateCode(request);
    }
    async getTemplates() {
        return {
            templates: this.aiCodeAssistantService.getAvailableTemplates(),
        };
    }
    async getGenerationHistory() {
        return {
            history: this.aiCodeAssistantService.getGenerationHistory(),
        };
    }
    async performBulkTransformation(request) {
        return this.astCodeModService.performBulkTransformation(request);
    }
    async getTransformationRules() {
        return {
            rules: this.astCodeModService.getPredefinedRules(),
        };
    }
    async getTransformationHistory() {
        return {
            history: this.astCodeModService.getTransformationHistory(),
        };
    }
    async generateDto(request) {
        return this.dynamicTypeChecksService.generateDto(request);
    }
    async generateApiContract(request) {
        return this.dynamicTypeChecksService.generateApiContract(request);
    }
    async getValidationTypes() {
        return {
            types: this.dynamicTypeChecksService.getAvailableValidationTypes(),
            validationTemplates: Object.fromEntries(this.dynamicTypeChecksService.getValidationTemplates()),
            swaggerTemplates: Object.fromEntries(this.dynamicTypeChecksService.getSwaggerTemplates()),
        };
    }
    async inferType(data) {
        return this.dynamicTypeChecksService.inferTypeFromData(data.data, data.propertyName);
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('generate-code'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate code using AI templates' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Code generated successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: GenerateCodeDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GenerateCodeDto]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], AiCodeAssistantController.prototype, "generateCode", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('templates'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get available code templates' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Templates retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "getTemplates", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('generation-history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get code generation history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'History retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "getGenerationHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('bulk-transform'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform bulk code transformations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Bulk transformation completed' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: BulkTransformationDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [BulkTransformationDto]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], AiCodeAssistantController.prototype, "performBulkTransformation", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('transformation-rules'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get available transformation rules' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Rules retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "getTransformationRules", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('transformation-history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get transformation history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'History retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "getTransformationHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('generate-dto'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate DTO with validation' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'DTO generated successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: GenerateDtoRequestDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GenerateDtoRequestDto]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], AiCodeAssistantController.prototype, "generateDto", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('generate-api-contract'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate API contract with DTOs' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'API contract generated successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: GenerateApiContractDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GenerateApiContractDto]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], AiCodeAssistantController.prototype, "generateApiContract", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('validation-types'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get available validation types' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Validation types retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "getValidationTypes", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('infer-type'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Infer type from data' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Type inferred successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AiCodeAssistantController.prototype, "inferType", null);
AiCodeAssistantController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('AI Code Assistant'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('ai/code-assistant'),
    __metadata("design:paramtypes", [typeof (_a = typeof _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__.AiCodeAssistantService !== "undefined" && _ai_code_assistant_service__WEBPACK_IMPORTED_MODULE_2__.AiCodeAssistantService) === "function" ? _a : Object, typeof (_b = typeof _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_3__.AstCodeModService !== "undefined" && _ast_code_mod_service__WEBPACK_IMPORTED_MODULE_3__.AstCodeModService) === "function" ? _b : Object, typeof (_c = typeof _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_4__.DynamicTypeChecksService !== "undefined" && _dynamic_type_checks_service__WEBPACK_IMPORTED_MODULE_4__.DynamicTypeChecksService) === "function" ? _c : Object])
], AiCodeAssistantController);



/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiCodeAssistantService: () => (/* binding */ AiCodeAssistantService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AiCodeAssistantService_1;

let AiCodeAssistantService = AiCodeAssistantService_1 = class AiCodeAssistantService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AiCodeAssistantService_1.name);
        this.templates = new Map();
        this.generationHistory = [];
        this.initializeTemplates();
    }
    initializeTemplates() {
        const templates = [
            {
                id: 'nestjs-service',
                name: 'NestJS Service',
                type: 'SERVICE',
                framework: 'nestjs',
                template: `import { Injectable, Logger } from '@nestjs/common';

export interface I{{entityName}} {
  id: string;
  {{#each properties}}
  {{@key}}: {{this}};
  {{/each}}
  createdAt: string;
  updatedAt: string;
}

@Injectable()
export class {{entityName}}Service {
  private readonly logger = new Logger({{entityName}}Service.name);

  constructor() {}

  async create(data: Omit<I{{entityName}}, 'id' | 'createdAt' | 'updatedAt'>): Promise<I{{entityName}}> {
    this.logger.log('Creating {{entityName}}');
    // TODO: Implement creation logic
    throw new Error('Not implemented');
  }

  async findAll(): Promise<I{{entityName}}[]> {
    this.logger.log('Finding all {{entityName}}s');
    // TODO: Implement find all logic
    throw new Error('Not implemented');
  }

  async findOne(id: string): Promise<I{{entityName}} | null> {
    this.logger.log('Finding {{entityName}} by id: ' + id);
    // TODO: Implement find one logic
    throw new Error('Not implemented');
  }

  async update(id: string, data: Partial<I{{entityName}}>): Promise<I{{entityName}} | null> {
    this.logger.log('Updating {{entityName}} with id: ' + id);
    // TODO: Implement update logic
    throw new Error('Not implemented');
  }

  async delete(id: string): Promise<boolean> {
    this.logger.log('Deleting {{entityName}} with id: ' + id);
    // TODO: Implement delete logic
    throw new Error('Not implemented');
  }
}`,
                variables: ['entityName', 'properties'],
                description: 'Генерирует NestJS сервис с CRUD операциями',
            },
            {
                id: 'nestjs-controller',
                name: 'NestJS Controller',
                type: 'CONTROLLER',
                framework: 'nestjs',
                template: `import { Controller, Get, Post, Put, Delete, Body, Param, Query, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { {{entityName}}Service } from './{{entityName}}.service';
import { Create{{entityName}}Dto, Update{{entityName}}Dto } from './dto/{{entityName}}.dto';
import { I{{entityName}} } from './{{entityName}}.service';

@ApiTags('{{entityName}}s')
@Controller('{{entityName}}s')
export class {{entityName}}Controller {
  constructor(private readonly {{entityName}}Service: {{entityName}}Service) {}

  @Post()
  @ApiOperation({ summary: 'Create {{entityName}}' })
  @ApiResponse({ status: 201, description: '{{entityName}} created successfully' })
  async create(@Body() createDto: Create{{entityName}}Dto): Promise<I{{entityName}}> {
    return this.{{entityName}}Service.create(createDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all {{entityName}}s' })
  @ApiResponse({ status: 200, description: 'Return all {{entityName}}s' })
  async findAll(@Query() query: unknown): Promise<I{{entityName}}[]> {
    return this.{{entityName}}Service.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get {{entityName}} by id' })
  @ApiResponse({ status: 200, description: 'Return {{entityName}} by id' })
  async findOne(@Param('id') id: string): Promise<I{{entityName}} | null> {
    return this.{{entityName}}Service.findOne(id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update {{entityName}}' })
  @ApiResponse({ status: 200, description: '{{entityName}} updated successfully' })
  async update(@Param('id') id: string, @Body() updateDto: Update{{entityName}}Dto): Promise<I{{entityName}} | null> {
    return this.{{entityName}}Service.update(id, updateDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete {{entityName}}' })
  @ApiResponse({ status: 200, description: '{{entityName}} deleted successfully' })
  async delete(@Param('id') id: string): Promise<boolean> {
    return this.{{entityName}}Service.delete(id);
  }
}`,
                variables: ['entityName'],
                description: 'Генерирует NestJS контроллер с CRUD эндпоинтами',
            },
            {
                id: 'nestjs-dto',
                name: 'NestJS DTO',
                type: 'DTO',
                framework: 'nestjs',
                template: `import { IsString, IsOptional, IsNumber, IsBoolean, IsDate, IsArray, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class Create{{entityName}}Dto {
  {{#each properties}}
  @ApiProperty({ description: '{{@key}} field' })
  {{#if (eq this 'string')}}
  @IsString()
  {{else if (eq this 'number')}}
  @IsNumber()
  {{else if (eq this 'boolean')}}
  @IsBoolean()
  {{else if (eq this 'Date')}}
  @IsDate()
  @Type(() => Date)
  {{else if (eq this 'string[]')}}
  @IsArray()
  @IsString({ each: true })
  {{/if}}
  {{@key}}: {{this}};
  {{/each}}
}

export class Update{{entityName}}Dto {
  {{#each properties}}
  @ApiPropertyOptional({ description: '{{@key}} field' })
  @IsOptional()
  {{#if (eq this 'string')}}
  @IsString()
  {{else if (eq this 'number')}}
  @IsNumber()
  {{else if (eq this 'boolean')}}
  @IsBoolean()
  {{else if (eq this 'Date')}}
  @IsDate()
  @Type(() => Date)
  {{else if (eq this 'string[]')}}
  @IsArray()
  @IsString({ each: true })
  {{/if}}
  {{@key}}?: {{this}};
  {{/each}}
}`,
                variables: ['entityName', 'properties'],
                description: 'Генерирует NestJS DTO с валидацией',
            },
            {
                id: 'nestjs-module',
                name: 'NestJS Module',
                type: 'MODULE',
                framework: 'nestjs',
                template: `import { Module } from '@nestjs/common';
import { {{entityName}}Controller } from './{{entityName}}.controller';
import { {{entityName}}Service } from './{{entityName}}.service';

@Module({
  controllers: [{{entityName}}Controller],
  providers: [{{entityName}}Service],
  exports: [{{entityName}}Service],
})
export class {{entityName}}Module {}`,
                variables: ['entityName'],
                description: 'Генерирует NestJS модуль',
            },
            {
                id: 'nestjs-test',
                name: 'NestJS Test',
                type: 'TEST',
                framework: 'nestjs',
                template: `import { Test, TestingModule } from '@nestjs/testing';
import { {{entityName}}Service } from './{{entityName}}.service';
import { {{entityName}}Controller } from './{{entityName}}.controller';

describe('{{entityName}}Controller', () => {
  let controller: {{entityName}}Controller;
  let service: {{entityName}}Service;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [{{entityName}}Controller],
      providers: [{{entityName}}Service],
    }).compile();

    controller = module.get<{{entityName}}Controller>({{entityName}}Controller);
    service = module.get<{{entityName}}Service>({{entityName}}Service);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a {{entityName}}', async () => {
      const createDto = {
        {{#each properties}}
        {{@key}}: {{#if (eq this 'string')}}'test'{{else if (eq this 'number')}}123{{else if (eq this 'boolean')}}true{{else if (eq this 'Date')}}new Date(){{else if (eq this 'string[]')}}['test']{{/if}},
        {{/each}}
      };

      const expectedResult = {
        id: '1',
        ...createDto,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      jest.spyOn(service, 'create').mockResolvedValue(expectedResult);

      expect(await controller.create(createDto)).toBe(expectedResult);
      expect(service.create).toHaveBeenCalledWith(createDto);
    });
  });

  describe('findAll', () => {
    it('should return an array of {{entityName}}s', async () => {
      const expectedResult = [
        {
          id: '1',
          {{#each properties}}
          {{@key}}: {{#if (eq this 'string')}}'test'{{else if (eq this 'number')}}123{{else if (eq this 'boolean')}}true{{else if (eq this 'Date')}}new Date(){{else if (eq this 'string[]')}}['test']{{/if}},
          {{/each}}
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
      ];

      jest.spyOn(service, 'findAll').mockResolvedValue(expectedResult);

      expect(await controller.findAll({})).toBe(expectedResult);
      expect(service.findAll).toHaveBeenCalled();
    });
  });

  describe('findOne', () => {
    it('should return a {{entityName}} by id', async () => {
      const expectedResult = {
        id: '1',
        {{#each properties}}
        {{@key}}: {{#if (eq this 'string')}}'test'{{else if (eq this 'number')}}123{{else if (eq this 'boolean')}}true{{else if (eq this 'Date')}}new Date(){{else if (eq this 'string[]')}}['test']{{/if}},
        {{/each}}
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      jest.spyOn(service, 'findOne').mockResolvedValue(expectedResult);

      expect(await controller.findOne('1')).toBe(expectedResult);
      expect(service.findOne).toHaveBeenCalledWith('1');
    });
  });

  describe('update', () => {
    it('should update a {{entityName}}', async () => {
      const updateDto = {
        {{#each properties}}
        {{@key}}: {{#if (eq this 'string')}}'updated'{{else if (eq this 'number')}}456{{else if (eq this 'boolean')}}false{{else if (eq this 'Date')}}new Date(){{else if (eq this 'string[]')}}['updated']{{/if}},
        {{/each}}
      };

      const expectedResult = {
        id: '1',
        ...updateDto,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      jest.spyOn(service, 'update').mockResolvedValue(expectedResult);

      expect(await controller.update('1', updateDto)).toBe(expectedResult);
      expect(service.update).toHaveBeenCalledWith('1', updateDto);
    });
  });

  describe('delete', () => {
    it('should delete a {{entityName}}', async () => {
      jest.spyOn(service, 'delete').mockResolvedValue(true);

      expect(await controller.delete('1')).toBe(true);
      expect(service.delete).toHaveBeenCalledWith('1');
    });
  });
});`,
                variables: ['entityName', 'properties'],
                description: 'Генерирует NestJS тесты для контроллера',
            },
        ];
        templates.forEach(template => {
            this.templates.set(template.id, template);
        });
    }
    async generateCode(request) {
        this.logger.log(`Generating ${request.type} code for ${request.entityName}`);
        try {
            const template = this.findBestTemplate(request);
            if (!template) {
                throw new Error(`No template found for type: ${request.type}`);
            }
            const code = this.processTemplate(template, request);
            const fileName = this.generateFileName(request);
            const filePath = this.generateFilePath(request);
            const imports = this.extractImports(code);
            const dependencies = this.extractDependencies(code);
            const analysis = this.analyzeCode(code);
            const result = {
                success: true,
                code,
                fileName,
                filePath,
                imports,
                dependencies,
                suggestions: analysis.suggestions,
                warnings: analysis.warnings,
            };
            this.generationHistory.push(result);
            this.logger.log(`Code generated successfully: ${fileName}`);
            return result;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            this.logger.error(`Code generation failed: ${errorMessage}`);
            return {
                success: false,
                code: '',
                fileName: '',
                filePath: '',
                imports: [],
                dependencies: [],
                suggestions: [],
                warnings: [errorMessage],
            };
        }
    }
    findBestTemplate(request) {
        const templateKey = `${request.framework}-${request.type.toLowerCase()}`;
        return this.templates.get(templateKey);
    }
    processTemplate(template, request) {
        let code = template.template;
        code = code.replace(/\{\{entityName\}\}/g, request.entityName);
        code = code.replace(/\{\{type\}\}/g, request.type);
        code = code.replace(/\{\{language\}\}/g, request.language);
        if (request.properties) {
            const propertiesCode = Object.entries(request.properties)
                .map(([key, type]) => `  ${key}: ${type};`)
                .join('\n');
            code = code.replace(/\{\{#each properties\}\}([\s\S]*?)\{\{\/each\}\}/g, propertiesCode);
        }
        if (request.methods) {
            const methodsCode = request.methods
                .map(method => `  ${method}() {\n    // TODO: Implement ${method}\n    throw new Error('Not implemented');\n  }`)
                .join('\n\n');
            code = code.replace(/\{\{#each methods\}\}([\s\S]*?)\{\{\/each\}\}/g, methodsCode);
        }
        return code;
    }
    generateFileName(request) {
        const entityName = request.entityName.charAt(0).toLowerCase() + request.entityName.slice(1);
        switch (request.type) {
            case 'SERVICE':
                return `${entityName}.service.ts`;
            case 'CONTROLLER':
                return `${entityName}.controller.ts`;
            case 'DTO':
                return `${entityName}.dto.ts`;
            case 'MODULE':
                return `${entityName}.module.ts`;
            case 'TEST':
                return `${entityName}.controller.spec.ts`;
            case 'INTERFACE':
                return `${entityName}.interface.ts`;
            case 'TYPE':
                return `${entityName}.types.ts`;
            default:
                return `${entityName}.${request.type.toLowerCase()}.ts`;
        }
    }
    generateFilePath(request) {
        const entityName = request.entityName.charAt(0).toLowerCase() + request.entityName.slice(1);
        switch (request.type) {
            case 'SERVICE':
            case 'CONTROLLER':
            case 'MODULE':
                return `src/${entityName}/${this.generateFileName(request)}`;
            case 'DTO':
                return `src/${entityName}/dto/${this.generateFileName(request)}`;
            case 'TEST':
                return `src/${entityName}/__tests__/${this.generateFileName(request)}`;
            case 'INTERFACE':
            case 'TYPE':
                return `src/types/${this.generateFileName(request)}`;
            default:
                return `src/${this.generateFileName(request)}`;
        }
    }
    extractImports(code) {
        const importRegex = /import\s+.*?from\s+['"]([^'"]+)['"]/g;
        const imports = [];
        let match;
        while ((match = importRegex.exec(code)) !== null) {
            if (match[1] != null) {
                imports.push(match[1]);
            }
        }
        return [...new Set(imports)];
    }
    extractDependencies(code) {
        const dependencies = [];
        if (code.includes('@nestjs/common'))
            dependencies.push('@nestjs/common');
        if (code.includes('@nestjs/swagger'))
            dependencies.push('@nestjs/swagger');
        if (code.includes('class-validator'))
            dependencies.push('class-validator');
        if (code.includes('class-transformer'))
            dependencies.push('class-transformer');
        return [...new Set(dependencies)];
    }
    analyzeCode(code) {
        const analysis = {
            complexity: this.calculateComplexity(code),
            maintainability: this.calculateMaintainability(code),
            testability: this.calculateTestability(code),
            performance: this.calculatePerformance(code),
            security: this.calculateSecurity(code),
            suggestions: [],
            improvements: [],
            warnings: [],
        };
        if (analysis.complexity > 7) {
            analysis.suggestions.push('Consider breaking down complex methods into smaller ones');
        }
        if (analysis.maintainability < 60) {
            analysis.suggestions.push('Add more comments and improve code structure');
        }
        if (analysis.testability < 70) {
            analysis.suggestions.push('Consider dependency injection for better testability');
        }
        if (analysis.security < 80) {
            analysis.suggestions.push('Add input validation and sanitization');
        }
        return analysis;
    }
    calculateComplexity(code) {
        const cyclomaticComplexity = (code.match(/if|else|for|while|switch|case|catch|&&|\|\|/g) ?? [])
            .length + 1;
        return Math.min(100, Math.max(1, 100 - cyclomaticComplexity * 5));
    }
    calculateMaintainability(code) {
        const lines = code.split('\n').length;
        const comments = (code.match(/\/\/|\/\*|\*/g) ?? []).length;
        const commentRatio = comments / lines;
        return Math.min(100, Math.max(1, 50 + commentRatio * 100));
    }
    calculateTestability(code) {
        const hasDependencyInjection = code.includes('constructor') && code.includes('private readonly');
        const hasInterfaces = code.includes('interface') || code.includes('export type');
        const hasErrorHandling = code.includes('try') || code.includes('catch');
        let score = 50;
        if (hasDependencyInjection)
            score += 20;
        if (hasInterfaces)
            score += 15;
        if (hasErrorHandling)
            score += 15;
        return Math.min(100, Math.max(1, score));
    }
    calculatePerformance(code) {
        const hasAsyncAwait = code.includes('async') || code.includes('await');
        const hasEfficientLoops = !code.includes('forEach') && code.includes('for');
        const hasProperErrorHandling = code.includes('try') || code.includes('catch');
        let score = 70;
        if (hasAsyncAwait)
            score += 10;
        if (hasEfficientLoops)
            score += 10;
        if (hasProperErrorHandling)
            score += 10;
        return Math.min(100, Math.max(1, score));
    }
    calculateSecurity(code) {
        const hasValidation = code.includes('@IsString') ||
            code.includes('@IsNumber') ||
            code.includes('@IsOptional');
        const hasSanitization = code.includes('sanitize') || code.includes('escape');
        const hasAuthentication = code.includes('@UseGuards') || code.includes('@ApiBearerAuth');
        let score = 60;
        if (hasValidation)
            score += 20;
        if (hasSanitization)
            score += 10;
        if (hasAuthentication)
            score += 10;
        return Math.min(100, Math.max(1, score));
    }
    getGenerationHistory() {
        return this.generationHistory;
    }
    getAvailableTemplates() {
        return Array.from(this.templates.values());
    }
    addCustomTemplate(template) {
        this.templates.set(template.id, template);
        this.logger.log(`Custom template added: ${template.name}`);
    }
};
AiCodeAssistantService = AiCodeAssistantService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AiCodeAssistantService);



/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AstCodeModService: () => (/* binding */ AstCodeModService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AstCodeModService_1;


let AstCodeModService = AstCodeModService_1 = class AstCodeModService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AstCodeModService_1.name);
        this.transformationHistory = [];
        this.predefinedRules = new Map();
        this.initializePredefinedRules();
    }
    initializePredefinedRules() {
        const rules = [
            {
                id: 'add-logger-to-service',
                name: 'Add Logger to Service',
                type: 'ADD_PROPERTY',
                targetType: 'CLASS',
                pattern: 'class\\s+(\\w+)Service\\s*{',
                replacement: 'class $1Service {\n  private readonly logger = new Logger($1Service.name);',
                conditions: { hasLogger: false },
                description: 'Добавляет Logger в сервисы NestJS',
            },
            {
                id: 'add-swagger-decorators',
                name: 'Add Swagger Decorators',
                type: 'ADD_DECORATOR',
                targetType: 'CLASS',
                pattern: '@Controller\\(([^)]+)\\)',
                replacement: "@ApiTags('$1')\n@Controller($1)",
                conditions: { hasApiTags: false },
                description: 'Добавляет ApiTags декораторы к контроллерам',
            },
            {
                id: 'add-validation-decorators',
                name: 'Add Validation Decorators',
                type: 'ADD_DECORATOR',
                targetType: 'CLASS',
                pattern: '(\\w+):\\s*(string|number|boolean)',
                replacement: '@Is$2()\n  $1: $2',
                conditions: { hasValidation: false },
                description: 'Добавляет валидационные декораторы к DTO',
            },
            {
                id: 'rename-service-method',
                name: 'Rename Service Method',
                type: 'RENAME',
                targetType: 'FUNCTION',
                pattern: 'async\\s+(\\w+)\\([^)]*\\)\\s*:\\s*Promise<[^>]+>',
                replacement: 'async $1$2',
                conditions: { methodType: 'service' },
                description: 'Переименовывает методы в сервисах',
            },
            {
                id: 'add-error-handling',
                name: 'Add Error Handling',
                type: 'ADD_METHOD',
                targetType: 'CLASS',
                pattern: 'async\\s+(\\w+)\\([^)]*\\)\\s*{[^}]*}',
                replacement: 'async $1($2) {\n    try {\n      $3\n    } catch (error) {\n      this.logger.error(`Error in $1: ${error.message}`);\n      throw error;\n    }\n  }',
                conditions: { hasErrorHandling: false },
                description: 'Добавляет обработку ошибок в методы',
            },
            {
                id: 'add-interface-properties',
                name: 'Add Interface Properties',
                type: 'ADD_PROPERTY',
                targetType: 'INTERFACE',
                pattern: 'interface\\s+(\\w+)\\s*{',
                replacement: 'interface $1 {\n  id: string;\n  createdAt: string;\n  updatedAt: string;',
                conditions: { hasId: false },
                description: 'Добавляет базовые свойства к интерфейсам',
            },
            {
                id: 'add-import-statement',
                name: 'Add Import Statement',
                type: 'IMPORT_CHANGE',
                targetType: 'IMPORT',
                pattern: 'import\\s+{[^}]*}\\s+from\\s+[\'"]([^\'"]+)[\'"]',
                replacement: "import { $1 } from '$2';",
                conditions: { hasImport: false },
                description: 'Добавляет импорты',
            },
            {
                id: 'add-export-statement',
                name: 'Add Export Statement',
                type: 'EXPORT_CHANGE',
                targetType: 'EXPORT',
                pattern: 'class\\s+(\\w+)',
                replacement: 'export class $1',
                conditions: { hasExport: false },
                description: 'Добавляет экспорты к классам',
            },
            {
                id: 'add-type-annotations',
                name: 'Add Type Annotations',
                type: 'CHANGE_TYPE',
                targetType: 'VARIABLE',
                pattern: 'const\\s+(\\w+)\\s*=\\s*([^;]+);',
                replacement: 'const $1: $2 = $2;',
                conditions: { hasTypeAnnotation: false },
                description: 'Добавляет типизацию к переменным',
            },
            {
                id: 'add-async-await',
                name: 'Add Async/Await',
                type: 'CHANGE_TYPE',
                targetType: 'FUNCTION',
                pattern: 'function\\s+(\\w+)\\([^)]*\\)\\s*{[^}]*}',
                replacement: 'async function $1($2) {\n    $3\n  }',
                conditions: { hasAsync: false },
                description: 'Добавляет async/await к функциям',
            },
        ];
        rules.forEach(rule => {
            this.predefinedRules.set(rule.id, rule);
        });
    }
    async performBulkTransformation(request) {
        this.logger.log(`Starting bulk transformation with ${request.rules.length} rules`);
        const result = {
            success: false,
            totalFiles: 0,
            processedFiles: 0,
            successfulFiles: 0,
            failedFiles: 0,
            transformations: [],
            summary: {
                addedLines: 0,
                removedLines: 0,
                modifiedLines: 0,
                renamedItems: 0,
            },
            errors: [],
        };
        try {
            const files = await this.findFilesByPatterns();
            result.totalFiles = files.length;
            for (const filePath of files) {
                try {
                    const transformation = await this.transformFile(filePath, request.rules, request.dryRun ?? false);
                    if (transformation.success) {
                        result.successfulFiles++;
                        result.transformations.push(transformation);
                        transformation.changes.forEach(change => {
                            switch (change.type) {
                                case 'ADD':
                                    result.summary.addedLines +=
                                        change.newText.split('\n').length;
                                    break;
                                case 'REMOVE':
                                    result.summary.removedLines +=
                                        change.originalText.split('\n').length;
                                    break;
                                case 'MODIFY':
                                    result.summary.modifiedLines++;
                                    break;
                                case 'RENAME':
                                    result.summary.renamedItems++;
                                    break;
                            }
                        });
                    }
                    else {
                        result.failedFiles++;
                        result.errors.push(`Failed to transform ${filePath}: ${transformation.errors.join(', ')}`);
                    }
                    result.processedFiles++;
                }
                catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
                    result.failedFiles++;
                    result.errors.push(`Error processing ${filePath}: ${errorMessage}`);
                }
            }
            result.success = result.failedFiles === 0;
            this.logger.log(`Bulk transformation completed: ${result.successfulFiles}/${result.totalFiles} files processed successfully`);
            return result;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            this.logger.error(`Bulk transformation failed: ${errorMessage}`);
            result.errors.push(errorMessage);
            return result;
        }
    }
    async transformFile(filePath, rules, dryRun) {
        const transformation = {
            id: this.generateTransformationId(),
            ruleId: rules.map(r => r.id).join(','),
            filePath,
            originalCode: '',
            transformedCode: '',
            changes: [],
            success: false,
            errors: [],
            timestamp: new Date().toISOString(),
        };
        try {
            const originalCode = await this.readFile();
            transformation.originalCode = originalCode;
            typescript__WEBPACK_IMPORTED_MODULE_1__.createSourceFile(filePath, originalCode, typescript__WEBPACK_IMPORTED_MODULE_1__.ScriptTarget.Latest, true);
            let transformedCode = originalCode;
            const changes = [];
            for (const rule of rules) {
                const ruleChanges = this.applyTransformationRule(rule, transformedCode);
                changes.push(...ruleChanges);
                transformedCode = this.applyChangesToCode(transformedCode, ruleChanges);
            }
            transformation.changes = changes;
            transformation.transformedCode = transformedCode;
            transformation.success = true;
            if (!dryRun) {
                await this.writeFile();
            }
            this.transformationHistory.push(transformation);
            this.logger.log(`File transformed successfully: ${filePath} (${changes.length} changes)`);
            return transformation;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            transformation.errors.push(errorMessage);
            this.logger.error(`File transformation failed: ${filePath} - ${errorMessage}`);
            return transformation;
        }
    }
    applyTransformationRule(rule, code) {
        const changes = [];
        try {
            switch (rule.type) {
                case 'RENAME':
                    changes.push(...this.applyRenameTransformation(rule, code));
                    break;
                case 'ADD_PROPERTY':
                    changes.push(...this.applyAddPropertyTransformation(rule, code));
                    break;
                case 'REMOVE_PROPERTY':
                    changes.push(...this.applyRemovePropertyTransformation(rule, code));
                    break;
                case 'CHANGE_TYPE':
                    changes.push(...this.applyChangeTypeTransformation(rule, code));
                    break;
                case 'ADD_METHOD':
                    changes.push(...this.applyAddMethodTransformation(rule, code));
                    break;
                case 'REMOVE_METHOD':
                    changes.push(...this.applyRemoveMethodTransformation(rule, code));
                    break;
                case 'ADD_DECORATOR':
                    changes.push(...this.applyAddDecoratorTransformation(rule, code));
                    break;
                case 'REMOVE_DECORATOR':
                    changes.push(...this.applyRemoveDecoratorTransformation(rule, code));
                    break;
                case 'IMPORT_CHANGE':
                    changes.push(...this.applyImportChangeTransformation(rule, code));
                    break;
                case 'EXPORT_CHANGE':
                    changes.push(...this.applyExportChangeTransformation(rule, code));
                    break;
                default:
                    this.logger.warn(`Unknown transformation type: ${rule.type}`);
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            this.logger.error(`Error applying rule ${rule.id}: ${errorMessage}`);
        }
        return changes;
    }
    applyRenameTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'RENAME',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Renamed using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyAddPropertyTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'ADD',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Added property using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyRemovePropertyTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            changes.push({
                type: 'REMOVE',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText: '',
                description: `Removed property using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyChangeTypeTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'MODIFY',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Changed type using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyAddMethodTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'ADD',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Added method using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyRemoveMethodTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            changes.push({
                type: 'REMOVE',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText: '',
                description: `Removed method using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyAddDecoratorTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'ADD',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Added decorator using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyRemoveDecoratorTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            changes.push({
                type: 'REMOVE',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText: '',
                description: `Removed decorator using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyImportChangeTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'MODIFY',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Changed import using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyExportChangeTransformation(rule, code) {
        const changes = [];
        const regex = new RegExp(rule.pattern, 'g');
        let match;
        while ((match = regex.exec(code)) !== null) {
            const newText = match[0].replace(new RegExp(rule.pattern), rule.replacement);
            changes.push({
                type: 'MODIFY',
                line: this.getLineNumber(code, match.index),
                column: match.index,
                originalText: match[0],
                newText,
                description: `Changed export using rule: ${rule.name}`,
            });
        }
        return changes;
    }
    applyChangesToCode(code, changes) {
        let result = code;
        const sortedChanges = [...changes].sort((a, b) => {
            const aIndex = this.getIndexFromLineColumn(code, a.line, a.column);
            const bIndex = this.getIndexFromLineColumn(code, b.line, b.column);
            return bIndex - aIndex;
        });
        for (const change of sortedChanges) {
            const index = this.getIndexFromLineColumn(result, change.line, change.column);
            if (index !== -1) {
                result =
                    result.slice(0, index) +
                        change.newText +
                        result.slice(index + change.originalText.length);
            }
        }
        return result;
    }
    getLineNumber(code, index) {
        return code.substring(0, index).split('\n').length;
    }
    getIndexFromLineColumn(code, line, column) {
        const lines = code.split('\n');
        let index = 0;
        for (let i = 0; i < line - 1; i++) {
            index += lines[i]?.length ?? 0 + 1;
        }
        return index + column - 1;
    }
    async findFilesByPatterns() {
        return [];
    }
    async readFile() {
        return '';
    }
    async writeFile() {
    }
    generateTransformationId() {
        return `transformation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    getPredefinedRules() {
        return Array.from(this.predefinedRules.values());
    }
    addCustomRule(rule) {
        this.predefinedRules.set(rule.id, rule);
        this.logger.log(`Custom rule added: ${rule.name}`);
    }
    getTransformationHistory() {
        return this.transformationHistory;
    }
};
AstCodeModService = AstCodeModService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AstCodeModService);



/***/ }),
/* 15 */
/***/ ((module) => {

module.exports = require("typescript");

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicTypeChecksService: () => (/* binding */ DynamicTypeChecksService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DynamicTypeChecksService_1;

let DynamicTypeChecksService = DynamicTypeChecksService_1 = class DynamicTypeChecksService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DynamicTypeChecksService_1.name);
        this.typePatterns = new Map();
        this.validationTemplates = new Map();
        this.swaggerTemplates = new Map();
        this.initializeTypePatterns();
        this.initializeValidationTemplates();
        this.initializeSwaggerTemplates();
    }
    initializeTypePatterns() {
        this.typePatterns.set('email', /^[^\s@]+@[^\s@]+\.[^\s@]+$/);
        this.typePatterns.set('url', /^https?:\/\/.+/);
        this.typePatterns.set('uuid', /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);
        this.typePatterns.set('date', /^\d{4}-\d{2}-\d{2}$/);
        this.typePatterns.set('datetime', /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/);
        this.typePatterns.set('phone', /^\+?[\d\s-()]+$/);
        this.typePatterns.set('postal_code', /^\d{5}(-\d{4})?$/);
        this.typePatterns.set('credit_card', /^\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}$/);
    }
    initializeValidationTemplates() {
        this.validationTemplates.set('string', '@IsString()');
        this.validationTemplates.set('number', '@IsNumber()');
        this.validationTemplates.set('boolean', '@IsBoolean()');
        this.validationTemplates.set('date', '@IsDate()');
        this.validationTemplates.set('array', '@IsArray()');
        this.validationTemplates.set('object', '@IsObject()');
        this.validationTemplates.set('enum', '@IsEnum()');
        this.validationTemplates.set('uuid', '@IsUUID()');
        this.validationTemplates.set('email', '@IsEmail()');
        this.validationTemplates.set('url', '@IsUrl()');
    }
    initializeSwaggerTemplates() {
        this.swaggerTemplates.set('string', "@ApiProperty({ type: 'string' })");
        this.swaggerTemplates.set('number', "@ApiProperty({ type: 'number' })");
        this.swaggerTemplates.set('boolean', "@ApiProperty({ type: 'boolean' })");
        this.swaggerTemplates.set('date', "@ApiProperty({ type: 'string', format: 'date-time' })");
        this.swaggerTemplates.set('array', "@ApiProperty({ type: 'array' })");
        this.swaggerTemplates.set('object', "@ApiProperty({ type: 'object' })");
        this.swaggerTemplates.set('enum', '@ApiProperty({ enum: [] })');
        this.swaggerTemplates.set('uuid', "@ApiProperty({ type: 'string', format: 'uuid' })");
        this.swaggerTemplates.set('email', "@ApiProperty({ type: 'string', format: 'email' })");
        this.swaggerTemplates.set('url', "@ApiProperty({ type: 'string', format: 'uri' })");
    }
    inferTypeFromData(data, propertyName) {
        const result = {
            type: 'string',
            confidence: 0,
            suggestions: [],
            validationRules: [],
        };
        if (data == null) {
            result.type = 'string';
            result.confidence = 0.5;
            result.suggestions.push('Consider making this field optional');
            return result;
        }
        const dataType = typeof data;
        const propertyNameLower = propertyName.toLowerCase();
        if (this.checkPropertyNamePatterns(propertyNameLower, result)) {
            return result;
        }
        switch (dataType) {
            case 'string':
                this.analyzeStringType(data, propertyNameLower, result);
                break;
            case 'number':
                this.analyzeNumberType(data, propertyNameLower, result);
                break;
            case 'boolean':
                result.type = 'boolean';
                result.confidence = 0.9;
                break;
            case 'object':
                this.analyzeObjectType(data, propertyNameLower, result);
                break;
            default:
                result.type = 'string';
                result.confidence = 0.3;
                result.suggestions.push('Unable to determine type, defaulting to string');
        }
        return result;
    }
    checkPropertyNamePatterns(propertyName, result) {
        if (propertyName.includes('email') || propertyName.includes('mail')) {
            result.type = 'email';
            result.confidence = 0.95;
            result.validationRules.push({
                type: 'pattern',
                value: 'email',
                message: 'Invalid email format',
            });
            return true;
        }
        if (propertyName.includes('url') ||
            propertyName.includes('link') ||
            propertyName.includes('href')) {
            result.type = 'url';
            result.confidence = 0.9;
            result.validationRules.push({
                type: 'pattern',
                value: 'url',
                message: 'Invalid URL format',
            });
            return true;
        }
        if (propertyName.includes('id') &&
            (propertyName.includes('uuid') || propertyName.includes('guid'))) {
            result.type = 'uuid';
            result.confidence = 0.9;
            result.validationRules.push({
                type: 'pattern',
                value: 'uuid',
                message: 'Invalid UUID format',
            });
            return true;
        }
        if (propertyName.includes('date') ||
            propertyName.includes('time') ||
            propertyName.includes('created') ||
            propertyName.includes('updated')) {
            result.type = 'date';
            result.confidence = 0.85;
            result.validationRules.push({
                type: 'pattern',
                value: 'date',
                message: 'Invalid date format',
            });
            return true;
        }
        if (propertyName.startsWith('is') ||
            propertyName.startsWith('has') ||
            propertyName.startsWith('can') ||
            propertyName.startsWith('should')) {
            result.type = 'boolean';
            result.confidence = 0.8;
            return true;
        }
        if (propertyName.includes('count') ||
            propertyName.includes('amount') ||
            propertyName.includes('price') ||
            propertyName.includes('quantity')) {
            result.type = 'number';
            result.confidence = 0.75;
            result.validationRules.push({
                type: 'min',
                value: 0,
                message: 'Value must be positive',
            });
            return true;
        }
        return false;
    }
    analyzeStringType(data, _propertyName, result) {
        for (const [patternName, pattern] of this.typePatterns.entries()) {
            if (pattern.test(data)) {
                result.type = patternName;
                result.confidence = 0.9;
                result.validationRules.push({
                    type: 'pattern',
                    value: patternName,
                    message: `Invalid ${patternName} format`,
                });
                return;
            }
        }
        if (data.length > 100) {
            result.validationRules.push({
                type: 'max',
                value: 1000,
                message: 'String too long',
            });
        }
        else if (data.length < 3) {
            result.validationRules.push({
                type: 'min',
                value: 1,
                message: 'String too short',
            });
        }
        result.type = 'string';
        result.confidence = 0.7;
    }
    analyzeNumberType(data, _propertyName, result) {
        result.type = 'number';
        result.confidence = 0.9;
        if (data < 0) {
            result.validationRules.push({
                type: 'min',
                value: 0,
                message: 'Value must be positive',
            });
        }
        if (data > 1000000) {
            result.validationRules.push({
                type: 'max',
                value: 1000000,
                message: 'Value too large',
            });
        }
        if (Number.isInteger(data)) {
            result.suggestions.push('Consider using integer type for whole numbers');
        }
    }
    analyzeObjectType(data, _propertyName, result) {
        if (Array.isArray(data)) {
            result.type = 'array';
            result.confidence = 0.8;
            result.validationRules.push({
                type: 'min',
                value: 0,
                message: 'Array cannot be empty',
            });
        }
        else if (data instanceof Date) {
            result.type = 'date';
            result.confidence = 0.9;
        }
        else {
            result.type = 'object';
            result.confidence = 0.6;
            result.suggestions.push('Consider defining a specific interface for this object');
        }
    }
    async generateDto(request) {
        this.logger.log(`Generating DTO: ${request.name}`);
        const dtoName = this.generateDtoName(request);
        const properties = Object.entries(request.properties);
        const imports = this.generateImports(properties);
        const validationCode = this.generateValidationCode(properties);
        const swaggerCode = this.generateSwaggerCode(properties);
        const code = `import { ${imports.join(', ')} } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class ${dtoName} {
${swaggerCode}
${validationCode}
}`;
        const fileName = `${dtoName.toLowerCase()}.dto.ts`;
        const filePath = `src/dto/${fileName}`;
        const dependencies = this.extractDependencies(imports);
        const validationRules = this.extractValidationRules(properties);
        const swaggerDecorators = this.extractSwaggerDecorators(properties);
        return {
            name: dtoName,
            code,
            fileName,
            filePath,
            imports,
            dependencies,
            validationRules,
            swaggerDecorators,
        };
    }
    generateDtoName(request) {
        let suffix = 'Dto';
        if (request.isCreate === true)
            suffix = 'CreateDto';
        if (request.isUpdate === true)
            suffix = 'UpdateDto';
        if (request.isResponse === true)
            suffix = 'ResponseDto';
        return `${request.name}${suffix}`;
    }
    generateImports(properties) {
        const imports = new Set();
        for (const [, definition] of properties) {
            const template = this.validationTemplates.get(definition.type);
            if (template != null && template !== '') {
                const decorator = template.replace('@', '').replace('()', '');
                imports.add(decorator);
            }
            if (definition.validationRules) {
                for (const rule of definition.validationRules) {
                    switch (rule.type) {
                        case 'min':
                        case 'max':
                            imports.add('Min');
                            imports.add('Max');
                            break;
                        case 'length':
                            imports.add('Length');
                            break;
                        case 'pattern':
                            imports.add('Matches');
                            break;
                        case 'enum':
                            imports.add('IsEnum');
                            break;
                    }
                }
            }
        }
        return Array.from(imports);
    }
    generateValidationCode(properties) {
        return properties
            .map(([name, definition]) => {
            const decorators = [];
            const template = this.validationTemplates.get(definition.type);
            if (template != null && template !== '') {
                decorators.push(template);
            }
            if (definition.validationRules) {
                for (const rule of definition.validationRules) {
                    switch (rule.type) {
                        case 'min':
                            decorators.push(`@Min(${String(rule.value)}, { message: '${rule.message ?? `Minimum value is ${rule.value}`}' })`);
                            break;
                        case 'max':
                            decorators.push(`@Max(${String(rule.value)}, { message: '${rule.message ?? `Maximum value is ${rule.value}`}' })`);
                            break;
                        case 'length': {
                            const lengthValue = rule.value;
                            decorators.push(`@Length(${lengthValue.min}, ${lengthValue.max}, { message: '${rule.message ?? `Length must be between ${lengthValue.min} and ${lengthValue.max}`}' })`);
                            break;
                        }
                        case 'pattern':
                            decorators.push(`@Matches(/${String(rule.value)}/, { message: '${rule.message ?? `Invalid format`}' })`);
                            break;
                        case 'enum':
                            decorators.push(`@IsEnum(${String(rule.value)}, { message: '${rule.message ?? `Invalid enum value`}' })`);
                            break;
                    }
                }
            }
            if (!definition.required) {
                decorators.push('@IsOptional()');
            }
            const decoratorsCode = decorators.map(d => `  ${d}`).join('\n');
            const propertyCode = `  ${name}: ${this.mapTypeToTypeScript(definition.type)};`;
            return `${decoratorsCode}\n${propertyCode}`;
        })
            .join('\n\n');
    }
    generateSwaggerCode(properties) {
        return properties
            .map(([, definition]) => {
            const template = this.swaggerTemplates.get(definition.type);
            if (template == null || template === '')
                return '';
            let swaggerCode = template;
            if (definition.description != null && definition.description !== '') {
                swaggerCode = swaggerCode.replace(')', `, description: '${definition.description}' )`);
            }
            if (definition.example != null) {
                swaggerCode = swaggerCode.replace(')', `, example: ${JSON.stringify(definition.example)} )`);
            }
            if (definition.format != null && definition.format !== '') {
                swaggerCode = swaggerCode.replace(')', `, format: '${definition.format}' )`);
            }
            if (!definition.required) {
                swaggerCode = swaggerCode.replace('ApiProperty', 'ApiPropertyOptional');
            }
            return `  ${swaggerCode}`;
        })
            .filter(code => code.length > 0)
            .join('\n');
    }
    mapTypeToTypeScript(type) {
        const typeMap = {
            string: 'string',
            number: 'number',
            boolean: 'boolean',
            date: 'Date',
            array: 'unknown[]',
            object: 'Record<string, unknown>',
            enum: 'string',
            uuid: 'string',
            email: 'string',
            url: 'string',
        };
        return typeMap[type] || 'unknown';
    }
    extractDependencies(imports) {
        const dependencies = [];
        if (imports.length > 0) {
            dependencies.push('class-validator');
            dependencies.push('class-transformer');
        }
        if (imports.some(imp => imp.includes('Api'))) {
            dependencies.push('@nestjs/swagger');
        }
        return dependencies;
    }
    extractValidationRules(properties) {
        const rules = [];
        for (const [, definition] of properties) {
            if (definition.validationRules) {
                rules.push(...definition.validationRules);
            }
        }
        return rules;
    }
    extractSwaggerDecorators(properties) {
        const decorators = [];
        for (const [, definition] of properties) {
            const template = this.swaggerTemplates.get(definition.type);
            if (template != null && template !== '') {
                decorators.push(template);
            }
        }
        return decorators;
    }
    async generateApiContract(contract) {
        this.logger.log(`Generating API contract: ${contract.method} ${contract.path}`);
        const controllerName = this.generateControllerName(contract.path);
        const methodName = this.generateMethodName(contract.method, contract.path);
        let requestDto;
        let responseDto;
        if (contract.requestBody) {
            requestDto = await this.generateDto(contract.requestBody);
        }
        if (contract.responseBody) {
            responseDto = await this.generateDto(contract.responseBody);
        }
        const code = this.generateControllerCode(contract, methodName, requestDto, responseDto);
        const swaggerDocumentation = this.generateSwaggerDocumentation(contract, requestDto, responseDto);
        const result = {
            controllerName,
            methodName,
            code,
            swaggerDocumentation,
        };
        if (requestDto != null) {
            result.requestDto = requestDto;
        }
        if (responseDto != null) {
            result.responseDto = responseDto;
        }
        return result;
    }
    generateControllerName(path) {
        const segments = path.split('/').filter(Boolean);
        const resource = segments[segments.length - 1] ?? 'default';
        return `${resource.charAt(0).toUpperCase() + resource.slice(1)}Controller`;
    }
    generateMethodName(method, path) {
        const segments = path.split('/').filter(Boolean);
        switch (method) {
            case 'GET':
                return segments.length > 1 ? `findOne` : `findAll`;
            case 'POST':
                return `create`;
            case 'PUT':
            case 'PATCH':
                return `update`;
            case 'DELETE':
                return `remove`;
        }
    }
    generateControllerCode(contract, methodName, requestDto, responseDto) {
        const decorators = this.generateMethodDecorators(contract);
        const parameters = this.generateMethodParameters(contract, requestDto);
        const returnType = responseDto ? responseDto.name : 'unknown';
        return `${decorators}
  async ${methodName}(${parameters}): Promise<${returnType}> {
    // TODO: Implement ${methodName}
    throw new Error('Not implemented');
  }`;
    }
    generateMethodDecorators(contract) {
        const decorators = [];
        decorators.push(`@${contract.method}('${contract.path}')`);
        decorators.push(`@ApiOperation({ summary: '${contract.summary}' })`);
        if (contract.description != null && contract.description !== '') {
            decorators.push(`@ApiOperation({ summary: '${contract.summary}', description: '${contract.description}' })`);
        }
        if (contract.tags.length > 0) {
            const tagsString = contract.tags.map(tag => `'${tag}'`).join(', ');
            decorators.push(`@ApiTags(${tagsString})`);
        }
        if (contract.security != null && contract.security.length > 0) {
            decorators.push(`@ApiBearerAuth()`);
        }
        if (contract.deprecated === true) {
            decorators.push(`@ApiDeprecated()`);
        }
        return decorators.map(d => `  ${d}`).join('\n');
    }
    generateMethodParameters(contract, requestDto) {
        const parameters = [];
        const pathParams = contract.parameters?.filter(p => p.in === 'path') ?? [];
        pathParams.forEach(param => {
            parameters.push(`@Param('${param.name}') ${param.name}: ${this.mapTypeToTypeScript(param.type)}`);
        });
        const queryParams = contract.parameters?.filter(p => p.in === 'query') ?? [];
        if (queryParams.length > 0) {
            parameters.push(`@Query() query: unknown`);
        }
        if (requestDto) {
            parameters.push(`@Body() createDto: ${requestDto.name}`);
        }
        return parameters.join(', ');
    }
    generateSwaggerDocumentation(contract, requestDto, responseDto) {
        const doc = {
            path: contract.path,
            method: contract.method.toLowerCase(),
            summary: contract.summary,
            tags: contract.tags,
        };
        if (contract.description != null && contract.description !== '') {
            doc.description = contract.description;
        }
        if (requestDto) {
            doc.requestBody = {
                content: {
                    'application/json': {
                        schema: {
                            $ref: `#/components/schemas/${requestDto.name}`,
                        },
                    },
                },
            };
        }
        if (responseDto) {
            doc.responses = {
                '200': {
                    description: 'Success',
                    content: {
                        'application/json': {
                            schema: {
                                $ref: `#/components/schemas/${responseDto.name}`,
                            },
                        },
                    },
                },
            };
        }
        return JSON.stringify(doc, null, 2);
    }
    getAvailableValidationTypes() {
        return Array.from(this.validationTemplates.keys());
    }
    getValidationTemplates() {
        return new Map(this.validationTemplates);
    }
    getSwaggerTemplates() {
        return new Map(this.swaggerTemplates);
    }
};
DynamicTypeChecksService = DynamicTypeChecksService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DynamicTypeChecksService);



/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiCommitAnalyzerService: () => (/* binding */ AiCommitAnalyzerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AiCommitAnalyzerService_1;

let AiCommitAnalyzerService = AiCommitAnalyzerService_1 = class AiCommitAnalyzerService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AiCommitAnalyzerService_1.name);
        this.commitHistory = [];
    }
    async analyzeCommit(request) {
        this.logger.log(`Анализ коммита: ${request.commitHash}`);
        const analysis = await this.performCommitAnalysis(request);
        const validation = this.validateCommit(analysis);
        this.commitHistory.push(analysis);
        return {
            isValid: validation.isValid,
            analysis,
            canCommit: validation.canCommit,
            warnings: validation.warnings,
            errors: validation.errors,
            recommendations: validation.recommendations,
        };
    }
    async performCommitAnalysis(request) {
        const issues = [];
        const suggestions = [];
        let score = 100;
        if (request.message.trim()) {
            const messageAnalysis = this.analyzeCommitMessage(request.message);
            issues.push(...messageAnalysis.issues);
            suggestions.push(...messageAnalysis.suggestions);
            score -= messageAnalysis.scoreReduction;
        }
        if (request.files.length > 0) {
            const fileAnalysis = this.analyzeChangedFiles(request.files);
            issues.push(...fileAnalysis.issues);
            suggestions.push(...fileAnalysis.suggestions);
            score -= fileAnalysis.scoreReduction;
        }
        if (request.diff != null && request.diff.trim() !== '') {
            const diffAnalysis = this.analyzeDiff(request.diff);
            issues.push(...diffAnalysis.issues);
            suggestions.push(...diffAnalysis.suggestions);
            score -= diffAnalysis.scoreReduction;
        }
        const { type, scope } = this.extractCommitMetadata(request.message || '');
        const severity = this.calculateSeverity(issues);
        return {
            commitHash: request.commitHash,
            message: request.message,
            type,
            scope: scope ?? 'general',
            severity,
            issues,
            suggestions,
            score: Math.max(0, score),
            timestamp: new Date().toISOString(),
        };
    }
    analyzeCommitMessage(message) {
        const issues = [];
        const suggestions = [];
        let scoreReduction = 0;
        const conventionalCommitRegex = /^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\([a-z-]+\))?: .+/;
        if (!conventionalCommitRegex.test(message)) {
            issues.push({
                type: 'convention',
                description: 'Сообщение коммита не соответствует формату conventional commits',
                severity: 'high',
                fix: 'Используйте формат: type(scope): description',
            });
            scoreReduction += 30;
        }
        if (message.length > 72) {
            issues.push({
                type: 'convention',
                description: 'Сообщение коммита слишком длинное (>72 символов)',
                severity: 'medium',
                fix: 'Сократите сообщение до 72 символов',
            });
            scoreReduction += 15;
        }
        if (!message.includes(':')) {
            suggestions.push({
                type: 'message',
                current: message,
                suggested: `${this.extractCommitMetadata(message).type}: ${message}`,
                reason: 'Добавьте описание после двоеточия',
                priority: 'medium',
            });
            scoreReduction += 10;
        }
        const validTypes = [
            'feat',
            'fix',
            'docs',
            'style',
            'refactor',
            'test',
            'chore',
            'perf',
            'ci',
            'build',
            'revert',
        ];
        const messageType = this.extractCommitMetadata(message).type;
        if (!validTypes.includes(messageType)) {
            issues.push({
                type: 'convention',
                description: `Неизвестный тип коммита: ${messageType}`,
                severity: 'medium',
                fix: `Используйте один из: ${validTypes.join(', ')}`,
            });
            scoreReduction += 20;
        }
        return { issues, suggestions, scoreReduction };
    }
    analyzeChangedFiles(files) {
        const issues = [];
        const suggestions = [];
        let scoreReduction = 0;
        if (files.length > 20) {
            issues.push({
                type: 'quality',
                description: 'Слишком много измененных файлов в одном коммите',
                severity: 'medium',
                fix: 'Разделите изменения на несколько коммитов',
            });
            scoreReduction += 25;
        }
        const hasSourceFiles = files.some(f => f.endsWith('.ts') ||
            f.endsWith('.tsx') ||
            f.endsWith('.js') ||
            f.endsWith('.jsx'));
        const hasConfigFiles = files.some(f => f.endsWith('.json') || f.endsWith('.yml') || f.endsWith('.yaml'));
        const hasDocsFiles = files.some(f => f.endsWith('.md') || f.endsWith('.txt'));
        if (hasSourceFiles && (hasConfigFiles || hasDocsFiles)) {
            suggestions.push({
                type: 'scope',
                current: 'mixed',
                suggested: 'separate',
                reason: 'Разделите изменения исходного кода и конфигурации на разные коммиты',
                priority: 'medium',
            });
            scoreReduction += 15;
        }
        return { issues, suggestions, scoreReduction };
    }
    analyzeDiff(diff) {
        const issues = [];
        const suggestions = [];
        let scoreReduction = 0;
        if (diff.includes('TODO') || diff.includes('FIXME')) {
            issues.push({
                type: 'quality',
                description: 'Обнаружены TODO/FIXME комментарии в коде',
                severity: 'low',
                fix: 'Уберите TODO/FIXME перед коммитом',
            });
            scoreReduction += 10;
        }
        if (diff.includes('console.log') || diff.includes('console.error')) {
            issues.push({
                type: 'quality',
                description: 'Обнаружены console.log/console.error в коде',
                severity: 'medium',
                fix: 'Замените на proper logging',
            });
            scoreReduction += 20;
        }
        const hardcodedPatterns = [
            'localhost:3000',
            'password',
            'secret',
            'api_key',
        ];
        for (const pattern of hardcodedPatterns) {
            if (diff.includes(pattern)) {
                issues.push({
                    type: 'security',
                    description: `Обнаружены hardcoded значения: ${pattern}`,
                    severity: 'high',
                    fix: 'Используйте environment variables',
                });
                scoreReduction += 30;
            }
        }
        return { issues, suggestions, scoreReduction };
    }
    extractCommitMetadata(message) {
        const match = message.match(/^(\w+)(?:\(([a-z-]+)\))?:/);
        if (match) {
            const type = match[1];
            const scope = match[2];
            return { type, scope };
        }
        return { type: 'chore' };
    }
    calculateSeverity(issues) {
        if (issues.some(issue => issue.severity === 'critical')) {
            return 'critical';
        }
        if (issues.some(issue => issue.severity === 'high')) {
            return 'high';
        }
        if (issues.some(issue => issue.severity === 'medium')) {
            return 'medium';
        }
        return 'low';
    }
    validateCommit(analysis) {
        const warnings = [];
        const errors = [];
        const recommendations = [];
        const criticalIssues = analysis.issues.filter(issue => issue.severity === 'critical');
        const highIssues = analysis.issues.filter(issue => issue.severity === 'high');
        if (criticalIssues.length > 0) {
            errors.push('Критические проблемы в коммите');
            criticalIssues.forEach(issue => errors.push(`- ${issue.description}`));
        }
        if (highIssues.length > 0) {
            errors.push('Высокие проблемы в коммите');
            highIssues.forEach(issue => errors.push(`- ${issue.description}`));
        }
        const mediumIssues = analysis.issues.filter(issue => issue.severity === 'medium');
        if (mediumIssues.length > 0) {
            warnings.push('Средние проблемы в коммите');
            mediumIssues.forEach(issue => warnings.push(`- ${issue.description}`));
        }
        if (analysis.score < 70) {
            recommendations.push('Низкий балл коммита. Рассмотрите исправления перед коммитом.');
        }
        if (analysis.suggestions.length > 0) {
            recommendations.push('Доступны предложения по улучшению коммита.');
        }
        const isValid = errors.length === 0;
        const canCommit = isValid && warnings.length < 3;
        return { isValid, canCommit, warnings, errors, recommendations };
    }
    getCommitHistory() {
        return [...this.commitHistory];
    }
    getCommitStatistics() {
        const total = this.commitHistory.length;
        const valid = this.commitHistory.filter(commit => commit.score >= 70).length;
        const invalid = total - valid;
        const averageScore = total > 0
            ? this.commitHistory.reduce((sum, commit) => sum + commit.score, 0) /
                total
            : 0;
        return { total, valid, invalid, averageScore: Math.round(averageScore) };
    }
};
AiCommitAnalyzerService = AiCommitAnalyzerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], AiCommitAnalyzerService);



/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiDocstringGeneratorService: () => (/* binding */ AiDocstringGeneratorService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AiDocstringGeneratorService_1;

let AiDocstringGeneratorService = AiDocstringGeneratorService_1 = class AiDocstringGeneratorService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AiDocstringGeneratorService_1.name);
        this.templates = new Map();
        this.generationHistory = [];
        this.initializeTemplates();
    }
    initializeTemplates() {
        const templates = [
            {
                id: 'jsdoc-function',
                type: 'function',
                style: 'jsdoc',
                template: `/**
 * {{description}}
 * 
 * @param {string} {{paramName}} - {{paramDescription}}
 * @returns {string} {{returnDescription}}
 * @throws {Error} {{throwsDescription}}
 * @example
 * {{example}}
 */`,
                variables: [
                    'description',
                    'paramName',
                    'paramDescription',
                    'returnDescription',
                    'throwsDescription',
                    'example',
                ],
                description: 'JSDoc шаблон для функций',
            },
            {
                id: 'jsdoc-class',
                type: 'class',
                style: 'jsdoc',
                template: `/**
 * {{description}}
 * 
 * @class {{className}}
 * @description {{classDescription}}
 * @example
 * {{example}}
 */`,
                variables: ['description', 'className', 'classDescription', 'example'],
                description: 'JSDoc шаблон для классов',
            },
            {
                id: 'jsdoc-method',
                type: 'method',
                style: 'jsdoc',
                template: `/**
 * {{description}}
 * 
 * @param {string} {{paramName}} - {{paramDescription}}
 * @returns {Promise<{{returnType}}>} {{returnDescription}}
 * @throws {Error} {{throwsDescription}}
 */`,
                variables: [
                    'description',
                    'paramName',
                    'paramDescription',
                    'returnType',
                    'returnDescription',
                    'throwsDescription',
                ],
                description: 'JSDoc шаблон для методов',
            },
            {
                id: 'tsdoc-function',
                type: 'function',
                style: 'tsdoc',
                template: `/**
 * {{description}}
 * 
 * @param {{paramName}} - {{paramDescription}}
 * @returns {{returnDescription}}
 * @throws {{throwsDescription}}
 * 
 * @example
 * {{example}}
 */`,
                variables: [
                    'description',
                    'paramName',
                    'paramDescription',
                    'returnDescription',
                    'throwsDescription',
                    'example',
                ],
                description: 'TSDoc шаблон для функций',
            },
            {
                id: 'tsdoc-interface',
                type: 'interface',
                style: 'tsdoc',
                template: `/**
 * {{description}}
 * 
 * @interface {{interfaceName}}
 * @description {{interfaceDescription}}
 */`,
                variables: ['description', 'interfaceName', 'interfaceDescription'],
                description: 'TSDoc шаблон для интерфейсов',
            },
            {
                id: 'tsdoc-class',
                type: 'class',
                style: 'tsdoc',
                template: `/**
 * {{description}}
 * 
 * @class {{className}}
 * @description {{description}}
 */`,
                variables: ['description', 'className'],
                description: 'TSDoc шаблон для классов',
            },
            {
                id: 'google-function',
                type: 'function',
                style: 'google',
                template: `/**
 * {{description}}
 * 
 * Args:
 *   {{paramName}}: {{paramDescription}}
 * 
 * Returns:
 *   {{returnDescription}}
 * 
 * Raises:
 *   {{throwsDescription}}
 * 
 * Example:
 *   {{example}}
 */`,
                variables: [
                    'description',
                    'paramName',
                    'paramDescription',
                    'returnDescription',
                    'throwsDescription',
                    'example',
                ],
                description: 'Google стиль для функций',
            },
        ];
        templates.forEach(template => {
            this.templates.set(template.id, template);
        });
    }
    async generateDocstring(request) {
        this.logger.log(`Генерация docstring для ${request.type}: ${request.name}`);
        try {
            const template = this.findTemplate(request.type, request.style);
            if (!template) {
                throw new Error(`Шаблон не найден для типа ${request.type} и стиля ${request.style}`);
            }
            const docstring = this.processTemplate(template, request);
            const formatted = this.formatDocstring(docstring, request.language);
            const suggestions = this.generateSuggestions(request);
            const warnings = this.generateWarnings(request);
            const metadata = this.calculateMetadata(docstring);
            const result = {
                success: true,
                docstring,
                formatted,
                suggestions,
                warnings,
                metadata,
            };
            this.generationHistory.push(result);
            return result;
        }
        catch (error) {
            this.logger.error(`Ошибка генерации docstring: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                docstring: '',
                formatted: '',
                suggestions: ['Проверьте входные параметры'],
                warnings: [error instanceof Error ? error.message : String(error)],
                metadata: { lineCount: 0, characterCount: 0, complexity: 'low' },
            };
        }
    }
    findTemplate(type, style) {
        const templateId = `${style}-${type}`;
        return this.templates.get(templateId);
    }
    processTemplate(template, request) {
        let result = template.template;
        result = result.replace(/\{\{description\}\}/g, request.description ?? 'Описание отсутствует');
        result = result.replace(/\{\{className\}\}/g, request.name);
        result = result.replace(/\{\{classDescription\}\}/g, request.description ?? 'Описание класса');
        result = result.replace(/\{\{interfaceName\}\}/g, request.name);
        result = result.replace(/\{\{interfaceDescription\}\}/g, request.description ?? 'Описание интерфейса');
        if (request.parameters != null && request.parameters.length > 0) {
            const param = request.parameters[0];
            if (param) {
                result = result.replace(/\{\{paramName\}\}/g, param.name);
                result = result.replace(/\{\{paramDescription\}\}/g, param.description ?? 'Описание параметра');
            }
        }
        else {
            result = result.replace(/\{\{paramName\}\}/g, 'paramName');
            result = result.replace(/\{\{paramDescription\}\}/g, 'Описание отсутствует');
        }
        if (request.returnType != null && request.returnType.trim() !== '') {
            const returnType = request.returnType;
            result = result.replace(/\{\{returnType\}\}/g, returnType);
            result = result.replace(/\{\{returnDescription\}\}/g, 'Описание возвращаемого значения');
        }
        if (request.throws && request.throws.length > 0) {
            result = result.replace(/\{\{throwsDescription\}\}/g, request.throws.join(', '));
        }
        if (request.examples && request.examples.length > 0) {
            result = result.replace(/\{\{example\}\}/g, request.examples[0] ?? '');
        }
        return result;
    }
    formatDocstring(docstring, language) {
        if (language === 'typescript') {
            return docstring.replace(/@param \{([^}]+)\}/g, '@param $1');
        }
        return docstring;
    }
    generateSuggestions(request) {
        const suggestions = [];
        if (request.description == null || request.description.trim() === '') {
            suggestions.push('Добавьте подробное описание функциональности');
        }
        if (request.parameters != null && request.parameters.length > 0) {
            const paramsWithoutDescription = request.parameters.filter(p => p.description == null || p.description.trim() === '');
            if (paramsWithoutDescription.length > 0) {
                suggestions.push(`Добавьте описания для параметров: ${paramsWithoutDescription.map(p => p.name).join(', ')}`);
            }
        }
        if (request.returnType == null || request.returnType.trim() === '') {
            suggestions.push('Укажите тип возвращаемого значения');
        }
        if (request.examples == null || request.examples.length === 0) {
            suggestions.push('Добавьте примеры использования');
        }
        return suggestions;
    }
    generateWarnings(request) {
        const warnings = [];
        if (request.parameters != null && request.parameters.length > 10) {
            warnings.push('Слишком много параметров. Рассмотрите использование объекта конфигурации');
        }
        if (request.description != null && request.description.trim().length < 10) {
            warnings.push('Описание слишком короткое. Добавьте больше деталей');
        }
        if (request.description != null &&
            request.description.trim().length > 500) {
            warnings.push('Описание слишком длинное. Разделите на несколько частей');
        }
        return warnings;
    }
    calculateMetadata(docstring) {
        const lines = docstring.split('\n');
        const lineCount = lines.length;
        const characterCount = docstring.length;
        let complexity = 'low';
        if (lineCount > 15 || characterCount > 800) {
            complexity = 'high';
        }
        else if (lineCount > 12 || characterCount > 600) {
            complexity = 'medium';
        }
        else {
            complexity = 'low';
        }
        return { lineCount, characterCount, complexity };
    }
    async generateNestJSServiceDocstring(serviceName) {
        const docstring = `/**
 * Сервис ${serviceName} для управления бизнес-логикой
 *
 * @class ${serviceName}
 * @description Сервис ${serviceName} для управления бизнес-логикой
 * @Injectable
 * @scope request
 */`;
        return {
            success: true,
            docstring,
            formatted: docstring,
            suggestions: [
                'Добавьте бизнес-логику',
                'Используйте dependency injection',
            ],
            warnings: [],
            metadata: { lineCount: 8, characterCount: 200, complexity: 'low' },
        };
    }
    async generateNestJSControllerDocstring(controllerName) {
        const docstring = `/**
 * Контроллер ${controllerName} для обработки HTTP запросов
 *
 * @class ${controllerName}
 * @description Контроллер ${controllerName} для обработки HTTP запросов
 * @Controller
 * @prefix ${controllerName.toLowerCase()}
 */`;
        return {
            success: true,
            docstring,
            formatted: docstring,
            suggestions: ['Добавьте валидацию входных данных', 'Используйте DTOs'],
            warnings: [],
            metadata: { lineCount: 8, characterCount: 250, complexity: 'low' },
        };
    }
    async generateDTODocstring(dtoName) {
        const docstring = `/**
 * DTO ${dtoName} для передачи данных
 *
 * @interface ${dtoName}
 * @description DTO ${dtoName} для передачи данных
 * @DTO
 * @validation
 */`;
        return {
            success: true,
            docstring,
            formatted: docstring,
            suggestions: ['Добавьте валидацию полей', 'Используйте class-validator'],
            warnings: [],
            metadata: { lineCount: 8, characterCount: 200, complexity: 'low' },
        };
    }
    getGenerationHistory() {
        return [...this.generationHistory];
    }
    getGenerationStatistics() {
        const total = this.generationHistory.length;
        const successful = this.generationHistory.filter(result => result.success).length;
        const failed = total - successful;
        const complexities = this.generationHistory.map(result => result.metadata.complexity);
        const lowCount = complexities.filter(c => c === 'low').length;
        const mediumCount = complexities.filter(c => c === 'medium').length;
        const highCount = complexities.filter(c => c === 'high').length;
        let averageComplexity = 'low';
        if (highCount > lowCount + mediumCount) {
            averageComplexity = 'high';
        }
        else if (mediumCount > lowCount) {
            averageComplexity = 'medium';
        }
        return { total, successful, failed, averageComplexity };
    }
};
AiDocstringGeneratorService = AiDocstringGeneratorService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AiDocstringGeneratorService);



/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AiCodeOptimizerService: () => (/* binding */ AiCodeOptimizerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AiCodeOptimizerService_1;

let AiCodeOptimizerService = AiCodeOptimizerService_1 = class AiCodeOptimizerService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AiCodeOptimizerService_1.name);
        this.optimizationHistory = [];
    }
    async optimizeCode(request) {
        this.logger.log(`Оптимизация кода на ${request.language}`);
        try {
            const metrics = this.analyzeCodeMetrics(request.code);
            const suggestions = await this.generateOptimizationSuggestions(request, metrics);
            const optimizedCode = this.applyOptimizations(request.code, suggestions);
            const summary = this.generateSummary(metrics, suggestions);
            const result = {
                success: true,
                originalCode: request.code,
                optimizedCode,
                suggestions,
                metrics,
                summary,
                warnings: this.generateWarnings(metrics, suggestions),
            };
            this.optimizationHistory.push(result);
            return result;
        }
        catch (error) {
            this.logger.error(`Ошибка оптимизации кода: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                originalCode: request.code,
                optimizedCode: request.code,
                suggestions: [],
                metrics: this.getDefaultMetrics(),
                summary: 'Ошибка при оптимизации кода',
                warnings: [error instanceof Error ? error.message : String(error)],
            };
        }
    }
    analyzeCodeMetrics(code) {
        if (!code || code.trim() === '') {
            return {
                linesOfCode: 0,
                cyclomaticComplexity: 0,
                maintainabilityIndex: 100,
                performanceScore: 100,
                securityScore: 100,
                readabilityScore: 100,
                overallQuality: 'excellent',
                issues: 0,
                suggestions: 0,
            };
        }
        const lines = code.split('\n');
        const linesOfCode = lines.length;
        const cyclomaticComplexity = this.calculateCyclomaticComplexity(code);
        const maintainabilityIndex = this.calculateMaintainabilityIndex(code, cyclomaticComplexity);
        const performanceScore = this.assessPerformance(code);
        const securityScore = this.assessSecurity(code);
        const readabilityScore = this.assessReadability(code);
        const overallQuality = this.calculateOverallQuality(maintainabilityIndex, performanceScore, securityScore, readabilityScore);
        const issues = this.countIssues(code);
        const suggestions = this.countPotentialSuggestions(code);
        return {
            linesOfCode,
            cyclomaticComplexity,
            maintainabilityIndex,
            performanceScore,
            securityScore,
            readabilityScore,
            overallQuality,
            issues,
            suggestions,
        };
    }
    calculateCyclomaticComplexity(code) {
        let complexity = 1;
        const conditionalPatterns = [
            /\bif\b/g,
            /\belse\b/g,
            /\bfor\b/g,
            /\bwhile\b/g,
            /\bdo\b/g,
            /\bcase\b/g,
            /\bcatch\b/g,
            /\b\?\b/g,
            /\b&&\b/g,
            /\b\|\|\b/g,
        ];
        conditionalPatterns.forEach(pattern => {
            const matches = code.match(pattern);
            if (matches) {
                complexity += matches.length;
            }
        });
        return complexity;
    }
    calculateMaintainabilityIndex(code, cyclomaticComplexity) {
        const lines = code.split('\n');
        const linesOfCode = lines.length;
        const halsteadVolume = this.calculateHalsteadVolume(code);
        const maintainabilityIndex = Math.max(0, 171 -
            5.2 * Math.log(halsteadVolume) -
            0.23 * cyclomaticComplexity -
            16.2 * Math.log(linesOfCode));
        return Math.min(100, Math.max(0, maintainabilityIndex));
    }
    calculateHalsteadVolume(code) {
        const operators = code.match(/[+\-*=<>!?&|:;,()[\]{}]/g) ?? [];
        const operands = code.match(/\b[a-zA-Z_][a-zA-Z0-9_]*\b/g) ?? [];
        const uniqueOperators = new Set(operators).size;
        const uniqueOperands = new Set(operands).size;
        const totalOperators = operators.length;
        const totalOperands = operands.length;
        if (uniqueOperators === 0 || uniqueOperands === 0)
            return 0;
        return ((totalOperators + totalOperands) *
            Math.log2(uniqueOperators + uniqueOperands));
    }
    assessPerformance(code) {
        let score = 100;
        const performanceIssues = [
            {
                pattern: /\.forEach\(/g,
                penalty: 5,
                description: 'forEach может быть медленнее for...of',
            },
            {
                pattern: /\.map\(/g,
                penalty: 3,
                description: 'map создает новый массив',
            },
            {
                pattern: /\.filter\(/g,
                penalty: 3,
                description: 'filter создает новый массив',
            },
            {
                pattern: /new RegExp\(/g,
                penalty: 10,
                description: 'Динамическое создание RegExp',
            },
            {
                pattern: /JSON\.parse\(/g,
                penalty: 5,
                description: 'JSON.parse может быть медленным',
            },
            {
                pattern: /eval\(/g,
                penalty: 50,
                description: 'eval крайне неэффективен',
            },
        ];
        performanceIssues.forEach(issue => {
            const matches = code.match(issue.pattern);
            if (matches) {
                score -= issue.penalty * matches.length;
            }
        });
        return Math.max(0, score);
    }
    assessSecurity(code) {
        let score = 100;
        const securityIssues = [
            {
                pattern: /eval\(/g,
                penalty: 100,
                description: 'eval крайне небезопасен',
            },
            {
                pattern: /innerHTML\s*=/g,
                penalty: 50,
                description: 'innerHTML может привести к XSS',
            },
            {
                pattern: /document\.write\(/g,
                penalty: 40,
                description: 'document.write может привести к XSS',
            },
            {
                pattern: /setTimeout\(/g,
                penalty: 10,
                description: 'setTimeout с строкой может быть небезопасен',
            },
            {
                pattern: /setInterval\(/g,
                penalty: 10,
                description: 'setInterval с строкой может быть небезопасен',
            },
            {
                pattern: /password\s*[:=]/g,
                penalty: 30,
                description: 'Возможное хранение паролей в коде',
            },
            {
                pattern: /api_key\s*[:=]/g,
                penalty: 30,
                description: 'Возможное хранение API ключей в коде',
            },
        ];
        securityIssues.forEach(issue => {
            const matches = code.match(issue.pattern);
            if (matches) {
                score -= issue.penalty * matches.length;
            }
        });
        return Math.max(0, score);
    }
    assessReadability(code) {
        let score = 100;
        const lines = code.split('\n');
        lines.forEach(line => {
            if (line.length > 120)
                score -= 5;
            if (line.trim().length === 0)
                score += 2;
            if (line.includes('// TODO') || line.includes('// FIXME'))
                score -= 3;
            if (line.includes('console.log') || line.includes('console.error'))
                score -= 2;
        });
        const commentLines = lines.filter(line => line.trim().startsWith('//') || line.trim().startsWith('/*'));
        const commentRatio = commentLines.length / lines.length;
        if (commentRatio < 0.1)
            score -= 10;
        if (commentRatio > 0.5)
            score -= 5;
        return Math.max(0, score);
    }
    calculateOverallQuality(maintainability, performance, security, readability) {
        const average = (maintainability + performance + security + readability) / 4;
        if (average >= 90)
            return 'excellent';
        if (average >= 80)
            return 'good';
        if (average >= 70)
            return 'fair';
        if (average >= 60)
            return 'poor';
        return 'critical';
    }
    countIssues(code) {
        let issues = 0;
        const issuePatterns = [
            /TODO|FIXME|HACK|XXX/g,
            /console\.(log|error|warn|info)/g,
            /debugger;/g,
            /eval\(/g,
            /innerHTML\s*=/g,
        ];
        issuePatterns.forEach(pattern => {
            const matches = code.match(pattern);
            if (matches) {
                issues += matches.length;
            }
        });
        return issues;
    }
    countPotentialSuggestions(code) {
        let suggestions = 0;
        const suggestionPatterns = [
            /\.forEach\(/g,
            /\.map\(/g,
            /\.filter\(/g,
            /new RegExp\(/g,
            /JSON\.parse\(/g,
            /setTimeout\(/g,
            /setInterval\(/g,
        ];
        suggestionPatterns.forEach(pattern => {
            const matches = code.match(pattern);
            if (matches) {
                suggestions += matches.length;
            }
        });
        return suggestions;
    }
    async generateOptimizationSuggestions(request, metrics) {
        const suggestions = [];
        if (metrics.performanceScore <= 100) {
            suggestions.push({
                id: 'perf-001',
                type: 'performance',
                priority: 'high',
                title: 'Оптимизация производительности',
                description: 'Код содержит неэффективные паттерны',
                currentCode: '// Текущий код',
                suggestedCode: '// Оптимизированный код',
                explanation: 'Используйте более эффективные алгоритмы и паттерны',
                impact: 'high',
                effort: 'medium',
                tags: ['performance', 'optimization'],
            });
        }
        if (metrics.securityScore < 80) {
            suggestions.push({
                id: 'sec-001',
                type: 'security',
                priority: 'critical',
                title: 'Проблемы безопасности',
                description: 'Обнаружены потенциальные уязвимости',
                currentCode: '// Небезопасный код',
                suggestedCode: '// Безопасный код',
                explanation: 'Исправьте уязвимости безопасности',
                impact: 'high',
                effort: 'high',
                tags: ['security', 'vulnerability'],
            });
        }
        if (metrics.readabilityScore <= 100) {
            suggestions.push({
                id: 'read-001',
                type: 'readability',
                priority: 'medium',
                title: 'Улучшение читаемости',
                description: 'Код может быть более читаемым',
                currentCode: '// Сложный код',
                suggestedCode: '// Упрощенный код',
                explanation: 'Разбейте сложные функции на более простые',
                impact: 'medium',
                effort: 'low',
                tags: ['readability', 'refactoring'],
            });
        }
        if (metrics.cyclomaticComplexity > 10) {
            suggestions.push({
                id: 'comp-001',
                type: 'complexity',
                priority: 'high',
                title: 'Высокая сложность',
                description: 'Функция слишком сложная',
                currentCode: '// Сложная функция',
                suggestedCode: '// Разбитая на части функция',
                explanation: 'Разбейте функцию на более простые части',
                impact: 'high',
                effort: 'medium',
                tags: ['complexity', 'refactoring'],
            });
        }
        return suggestions.slice(0, request.maxSuggestions ?? 10);
    }
    applyOptimizations(code, suggestions) {
        let optimizedCode = code;
        suggestions.forEach(suggestion => {
            if (suggestion.type === 'performance') {
                optimizedCode = optimizedCode.replace(/\.forEach\(/g, 'for...of');
            }
            if (suggestion.type === 'security') {
                optimizedCode = optimizedCode.replace(/eval\(/g, '// eval removed for security');
            }
            if (suggestion.type === 'readability') {
                optimizedCode = optimizedCode.replace(/\/\/ TODO/g, '// TODO: Implement this');
            }
        });
        return optimizedCode;
    }
    generateSummary(metrics, suggestions) {
        const quality = metrics.overallQuality;
        const issues = metrics.issues;
        const suggestionCount = suggestions.length;
        let summary = `Качество кода: ${quality}. `;
        if (issues > 0) {
            summary += `Обнаружено ${issues} проблем. `;
        }
        if (suggestionCount > 0) {
            summary += `Предложено ${suggestionCount} улучшений. `;
        }
        if (quality === 'excellent') {
            summary += 'Код в отличном состоянии!';
        }
        else if (quality === 'good') {
            summary += 'Код хорошего качества, есть возможности для улучшения.';
        }
        else if (quality === 'fair') {
            summary += 'Код приемлемого качества, рекомендуется рефакторинг.';
        }
        else if (quality === 'poor') {
            summary += 'Код требует значительного улучшения.';
        }
        else {
            summary +=
                'Код критического качества, необходим немедленный рефакторинг.';
        }
        return summary;
    }
    generateWarnings(metrics, suggestions) {
        const warnings = [];
        if (metrics.cyclomaticComplexity > 10) {
            warnings.push('Высокая цикломатическая сложность кода');
        }
        if (metrics.maintainabilityIndex < 50) {
            warnings.push('Низкий индекс поддерживаемости');
        }
        if (suggestions.length > 5) {
            warnings.push('Много предложений по улучшению. Рассмотрите приоритизацию.');
        }
        return warnings;
    }
    getDefaultMetrics() {
        return {
            linesOfCode: 0,
            cyclomaticComplexity: 1,
            maintainabilityIndex: 100,
            performanceScore: 100,
            securityScore: 100,
            readabilityScore: 100,
            overallQuality: 'excellent',
            issues: 0,
            suggestions: 0,
        };
    }
    getOptimizationHistory() {
        return [...this.optimizationHistory];
    }
    getOptimizationStatistics() {
        const total = this.optimizationHistory.length;
        const successful = this.optimizationHistory.filter(result => result.success).length;
        const failed = total - successful;
        const qualities = this.optimizationHistory.map(result => result.metrics.overallQuality);
        const qualityCounts = qualities.reduce((acc, quality) => {
            acc[quality] = (acc[quality] ?? 0) + 1;
            return acc;
        }, {});
        let averageQuality = 'excellent';
        if ((qualityCounts['critical'] ?? 0) > 0)
            averageQuality = 'critical';
        else if ((qualityCounts['poor'] ?? 0) > 0)
            averageQuality = 'poor';
        else if ((qualityCounts['fair'] ?? 0) > 0)
            averageQuality = 'fair';
        else if ((qualityCounts['good'] ?? 0) > 0)
            averageQuality = 'good';
        return { total, successful, failed, averageQuality };
    }
};
AiCodeOptimizerService = AiCodeOptimizerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AiCodeOptimizerService);



/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnalyticsModule: () => (/* binding */ AnalyticsModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _business_intelligence_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _user_analytics_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _analytics_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






let AnalyticsModule = class AnalyticsModule {
};
AnalyticsModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule, _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitterModule],
        providers: [_business_intelligence_service__WEBPACK_IMPORTED_MODULE_3__.BusinessIntelligenceService, _user_analytics_service__WEBPACK_IMPORTED_MODULE_4__.UserAnalyticsService],
        controllers: [_analytics_controller__WEBPACK_IMPORTED_MODULE_5__.AnalyticsController],
        exports: [_business_intelligence_service__WEBPACK_IMPORTED_MODULE_3__.BusinessIntelligenceService, _user_analytics_service__WEBPACK_IMPORTED_MODULE_4__.UserAnalyticsService],
    })
], AnalyticsModule);



/***/ }),
/* 21 */
/***/ ((module) => {

module.exports = require("@nestjs/event-emitter");

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BusinessIntelligenceService: () => (/* binding */ BusinessIntelligenceService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var BusinessIntelligenceService_1;
var _a, _b;



let BusinessIntelligenceService = BusinessIntelligenceService_1 = class BusinessIntelligenceService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(BusinessIntelligenceService_1.name);
        this.businessMetrics = new Map();
        this.userAnalytics = new Map();
        this.performanceAnalytics = new Map();
        this.businessReports = new Map();
        this.predictiveAnalytics = new Map();
        this.dataVisualizations = new Map();
        this._configService.get('BUSINESS_INTELLIGENCE_ENABLED');
        this.eventEmitter.emit('analytics.initialized');
        this.initializeDataVisualizations();
        this.startAnalyticsCollection();
    }
    initializeDataVisualizations() {
        const visualizations = [
            {
                id: 'user-growth-chart',
                name: 'User Growth',
                type: 'line',
                data: [],
                config: {
                    title: 'User Growth Over Time',
                    xAxis: 'Date',
                    yAxis: 'Users',
                    colors: ['#3B82F6', '#10B981', '#F59E0B'],
                },
                refreshInterval: 3600000,
                lastUpdated: new Date(),
                isPublic: true,
            },
            {
                id: 'revenue-breakdown',
                name: 'Revenue Breakdown',
                type: 'pie',
                data: [],
                config: {
                    title: 'Revenue by Source',
                    colors: ['#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6'],
                },
                refreshInterval: 86400000,
                lastUpdated: new Date(),
                isPublic: false,
            },
            {
                id: 'performance-metrics',
                name: 'Performance Metrics',
                type: 'bar',
                data: [],
                config: {
                    title: 'API Performance Metrics',
                    xAxis: 'Service',
                    yAxis: 'Response Time (ms)',
                    colors: ['#8B5CF6', '#06B6D4', '#84CC16'],
                },
                refreshInterval: 300000,
                lastUpdated: new Date(),
                isPublic: true,
            },
            {
                id: 'conversion-funnel',
                name: 'Conversion Funnel',
                type: 'funnel',
                data: [],
                config: {
                    title: 'User Conversion Funnel',
                    colors: ['#F59E0B', '#EF4444', '#10B981', '#3B82F6'],
                },
                refreshInterval: 3600000,
                lastUpdated: new Date(),
                isPublic: false,
            },
        ];
        visualizations.forEach(viz => {
            this.dataVisualizations.set(viz.id, viz);
        });
        this.logger.log(`Initialized ${visualizations.length} data visualizations`);
    }
    startAnalyticsCollection() {
        setInterval(() => {
            void this.collectBusinessMetrics();
        }, 300000);
        setInterval(() => {
            void this.collectUserAnalytics();
        }, 60000);
        setInterval(() => {
            void this.collectPerformanceAnalytics();
        }, 30000);
        setInterval(() => {
            void this.updateDataVisualizations();
        }, 600000);
    }
    async collectBusinessMetrics() {
        try {
            const metrics = [
                {
                    id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: 'total_users',
                    category: 'users',
                    value: Math.floor(Math.random() * 10000) + 50000,
                    unit: 'count',
                    timestamp: new Date(),
                    dimensions: { source: 'registration' },
                    metadata: { platform: 'web' },
                },
                {
                    id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: 'active_users',
                    category: 'users',
                    value: Math.floor(Math.random() * 5000) + 10000,
                    unit: 'count',
                    timestamp: new Date(),
                    dimensions: { period: 'daily' },
                    metadata: { platform: 'all' },
                },
                {
                    id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: 'revenue',
                    category: 'revenue',
                    value: Math.floor(Math.random() * 10000) + 50000,
                    unit: 'USD',
                    timestamp: new Date(),
                    dimensions: { source: 'subscriptions' },
                    metadata: { currency: 'USD' },
                },
                {
                    id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: 'conversion_rate',
                    category: 'conversion',
                    value: Math.random() * 10 + 2,
                    unit: '%',
                    timestamp: new Date(),
                    dimensions: { funnel: 'signup_to_paid' },
                    metadata: { period: 'monthly' },
                },
                {
                    id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: 'session_duration',
                    category: 'engagement',
                    value: Math.random() * 600 + 300,
                    unit: 'seconds',
                    timestamp: new Date(),
                    dimensions: { platform: 'web' },
                    metadata: { average: true },
                },
            ];
            for (const metric of metrics) {
                const key = `${metric.category}.${metric.name}`;
                const existingMetrics = this.businessMetrics.get(key) ?? [];
                existingMetrics.push(metric);
                if (existingMetrics.length > 1000) {
                    existingMetrics.splice(0, existingMetrics.length - 1000);
                }
                this.businessMetrics.set(key, existingMetrics);
            }
            this.logger.debug('Business metrics collected');
        }
        catch (error) {
            this.logger.error('Error collecting business metrics:', error);
        }
    }
    async collectUserAnalytics() {
        try {
            const events = [
                'page_view',
                'button_click',
                'form_submit',
                'purchase',
                'signup',
                'login',
            ];
            const analytics = [];
            for (let i = 0; i < Math.floor(Math.random() * 50) + 10; i++) {
                const event = events[Math.floor(Math.random() * events.length)];
                const userId = `user-${Math.floor(Math.random() * 1000)}`;
                const sessionId = `session-${Math.floor(Math.random() * 10000)}`;
                analytics.push({
                    id: `analytics-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    userId,
                    event: event,
                    properties: {
                        page: `/page-${Math.floor(Math.random() * 10)}`,
                        element: event === 'button_click' ? 'cta-button' : undefined,
                        value: event === 'purchase' ? Math.random() * 100 + 10 : undefined,
                    },
                    timestamp: new Date(),
                    sessionId,
                    userAgent: 'Mozilla/5.0 (compatible; AnalyticsBot/1.0)',
                    ipAddress: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                    referrer: Math.random() > 0.5 ? 'https://google.com' : '',
                });
            }
            for (const analytic of analytics) {
                const key = `${analytic.userId}.${analytic.event}`;
                const existingAnalytics = this.userAnalytics.get(key) ?? [];
                existingAnalytics.push(analytic);
                if (existingAnalytics.length > 500) {
                    existingAnalytics.splice(0, existingAnalytics.length - 500);
                }
                this.userAnalytics.set(key, existingAnalytics);
            }
            this.logger.debug(`User analytics collected: ${analytics.length} events`);
        }
        catch (error) {
            this.logger.error('Error collecting user analytics:', error);
        }
    }
    async collectPerformanceAnalytics() {
        try {
            const services = [
                'auth-service',
                'cards-service',
                'monitoring-service',
                'security-service',
            ];
            const endpoints = [
                '/api/auth/login',
                '/api/cards',
                '/api/monitoring/health',
                '/api/security/audit',
            ];
            const methods = ['GET', 'POST', 'PUT', 'DELETE'];
            const analytics = [];
            for (let i = 0; i < Math.floor(Math.random() * 20) + 5; i++) {
                const service = services[Math.floor(Math.random() * services.length)];
                const endpoint = endpoints[Math.floor(Math.random() * endpoints.length)];
                const method = methods[Math.floor(Math.random() * methods.length)];
                analytics.push({
                    id: `perf-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    _service: service ?? '',
                    endpoint: endpoint,
                    method: method,
                    responseTime: Math.random() * 1000 + 50,
                    statusCode: Math.random() > 0.1 ? 200 : Math.random() > 0.5 ? 400 : 500,
                    requestSize: Math.floor(Math.random() * 10000) + 100,
                    responseSize: Math.floor(Math.random() * 50000) + 500,
                    timestamp: new Date(),
                    userId: Math.random() > 0.3
                        ? `user-${Math.floor(Math.random() * 1000)}`
                        : '',
                    sessionId: Math.random() > 0.3
                        ? `session-${Math.floor(Math.random() * 10000)}`
                        : '',
                });
            }
            for (const analytic of analytics) {
                const key = `${analytic._service}.${analytic.endpoint}`;
                const existingAnalytics = this.performanceAnalytics.get(key) ?? [];
                existingAnalytics.push(analytic);
                if (existingAnalytics.length > 1000) {
                    existingAnalytics.splice(0, existingAnalytics.length - 1000);
                }
                this.performanceAnalytics.set(key, existingAnalytics);
            }
            this.logger.debug(`Performance analytics collected: ${analytics.length} requests`);
        }
        catch (error) {
            this.logger.error('Error collecting performance analytics:', error);
        }
    }
    async updateDataVisualizations() {
        try {
            for (const [, visualization] of this.dataVisualizations) {
                await this.updateVisualizationData(visualization);
            }
            this.logger.debug('Data visualizations updated');
        }
        catch (error) {
            this.logger.error('Error updating data visualizations:', error);
        }
    }
    async updateVisualizationData(visualization) {
        switch (visualization.id) {
            case 'user-growth-chart':
                visualization.data = this.generateUserGrowthData();
                break;
            case 'revenue-breakdown':
                visualization.data = this.generateRevenueBreakdownData();
                break;
            case 'performance-metrics':
                visualization.data = this.generatePerformanceMetricsData();
                break;
            case 'conversion-funnel':
                visualization.data = this.generateConversionFunnelData();
                break;
        }
        visualization.lastUpdated = new Date();
    }
    generateUserGrowthData() {
        const data = [];
        const now = new Date();
        for (let i = 29; i >= 0; i--) {
            const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
            data.push({
                date: date.toISOString().split('T')[0],
                users: Math.floor(Math.random() * 1000) + 50000,
                newUsers: Math.floor(Math.random() * 100) + 500,
            });
        }
        return data;
    }
    generateRevenueBreakdownData() {
        return [
            {
                source: 'Subscriptions',
                value: Math.floor(Math.random() * 20000) + 30000,
            },
            {
                source: 'One-time Purchases',
                value: Math.floor(Math.random() * 10000) + 15000,
            },
            {
                source: 'Enterprise',
                value: Math.floor(Math.random() * 15000) + 20000,
            },
            { source: 'API Usage', value: Math.floor(Math.random() * 5000) + 5000 },
            { source: 'Consulting', value: Math.floor(Math.random() * 3000) + 2000 },
        ];
    }
    generatePerformanceMetricsData() {
        const services = [
            'Auth Service',
            'Cards Service',
            'Monitoring Service',
            'Security Service',
        ];
        return services.map(service => ({
            service,
            responseTime: Math.random() * 500 + 100,
            throughput: Math.random() * 1000 + 500,
            errorRate: Math.random() * 5,
        }));
    }
    generateConversionFunnelData() {
        return [
            { stage: 'Visitors', value: Math.floor(Math.random() * 10000) + 50000 },
            { stage: 'Signups', value: Math.floor(Math.random() * 2000) + 5000 },
            { stage: 'Trials', value: Math.floor(Math.random() * 1000) + 2000 },
            { stage: 'Paid Users', value: Math.floor(Math.random() * 500) + 1000 },
        ];
    }
    async generateBusinessReport(type, period, generatedBy) {
        const reportId = `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const metrics = await this.aggregateMetricsForPeriod(period);
        const report = {
            id: reportId,
            name: `${type.charAt(0).toUpperCase() + type.slice(1)} Business Report`,
            type,
            period,
            metrics,
            insights: this.generateInsights(metrics),
            recommendations: this.generateRecommendations(metrics),
            generatedAt: new Date(),
            generatedBy,
        };
        this.businessReports.set(reportId, report);
        this.logger.log(`Generated business report: ${reportId} (${type})`);
        return report;
    }
    async aggregateMetricsForPeriod(_period) {
        const totalUsers = Math.floor(Math.random() * 10000) + 50000;
        const activeUsers = Math.floor(Math.random() * 5000) + 10000;
        const newUsers = Math.floor(Math.random() * 2000) + 1000;
        const revenue = Math.floor(Math.random() * 50000) + 100000;
        const conversionRate = Math.random() * 10 + 5;
        const averageSessionDuration = Math.random() * 600 + 300;
        const bounceRate = Math.random() * 20 + 30;
        return {
            totalUsers,
            activeUsers,
            newUsers,
            revenue,
            conversionRate,
            averageSessionDuration,
            bounceRate,
            topPages: [
                {
                    page: '/dashboard',
                    views: Math.floor(Math.random() * 10000) + 5000,
                    uniqueViews: Math.floor(Math.random() * 5000) + 2000,
                },
                {
                    page: '/cards',
                    views: Math.floor(Math.random() * 8000) + 3000,
                    uniqueViews: Math.floor(Math.random() * 4000) + 1500,
                },
                {
                    page: '/settings',
                    views: Math.floor(Math.random() * 5000) + 2000,
                    uniqueViews: Math.floor(Math.random() * 3000) + 1000,
                },
            ],
            topReferrers: [
                {
                    referrer: 'google.com',
                    visits: Math.floor(Math.random() * 5000) + 2000,
                },
                { referrer: 'direct', visits: Math.floor(Math.random() * 3000) + 1500 },
                {
                    referrer: 'facebook.com',
                    visits: Math.floor(Math.random() * 2000) + 1000,
                },
            ],
            deviceBreakdown: [
                { device: 'Desktop', percentage: Math.random() * 20 + 50 },
                { device: 'Mobile', percentage: Math.random() * 20 + 30 },
                { device: 'Tablet', percentage: Math.random() * 10 + 10 },
            ],
            geographicData: [
                {
                    country: 'United States',
                    users: Math.floor(Math.random() * 20000) + 30000,
                    revenue: Math.floor(Math.random() * 50000) + 80000,
                },
                {
                    country: 'United Kingdom',
                    users: Math.floor(Math.random() * 5000) + 8000,
                    revenue: Math.floor(Math.random() * 15000) + 20000,
                },
                {
                    country: 'Germany',
                    users: Math.floor(Math.random() * 4000) + 6000,
                    revenue: Math.floor(Math.random() * 12000) + 15000,
                },
            ],
        };
    }
    generateInsights(metrics) {
        const insights = [];
        if (metrics.conversionRate > 8) {
            insights.push('Conversion rate is above industry average, indicating strong product-market fit');
        }
        if (metrics.bounceRate < 40) {
            insights.push('Low bounce rate suggests good user engagement and content relevance');
        }
        if (metrics.averageSessionDuration > 600) {
            insights.push('High session duration indicates strong user engagement');
        }
        if (metrics.newUsers > metrics.activeUsers * 0.1) {
            insights.push('Healthy user acquisition rate with good retention');
        }
        insights.push('Mobile traffic represents significant portion of user base');
        insights.push('Direct traffic shows strong brand recognition');
        return insights;
    }
    generateRecommendations(metrics) {
        const recommendations = [];
        if (metrics.conversionRate < 5) {
            recommendations.push('Improve conversion rate by optimizing signup flow and reducing friction');
        }
        if (metrics.bounceRate > 60) {
            recommendations.push('Reduce bounce rate by improving page load times and content quality');
        }
        if (metrics.averageSessionDuration < 300) {
            recommendations.push('Increase session duration by adding engaging features and content');
        }
        recommendations.push('Implement A/B testing for key conversion points');
        recommendations.push('Optimize mobile experience to capture more mobile users');
        recommendations.push('Develop referral program to increase organic growth');
        return recommendations;
    }
    async generatePredictiveAnalytics(model, target, timeframe) {
        const id = `prediction-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const prediction = {
            id,
            model,
            target,
            prediction: Math.random() * 1000 + 100,
            confidence: Math.random() * 30 + 70,
            timeframe,
            factors: [
                { name: 'Historical Growth', impact: 0.4, value: Math.random() * 100 },
                { name: 'Seasonal Trends', impact: 0.3, value: Math.random() * 50 },
                { name: 'Market Conditions', impact: 0.2, value: Math.random() * 30 },
                { name: 'User Engagement', impact: 0.1, value: Math.random() * 20 },
            ],
            timestamp: new Date(),
            accuracy: Math.random() * 20 + 80,
        };
        const key = `${model}.${target}`;
        const existingPredictions = this.predictiveAnalytics.get(key) ?? [];
        existingPredictions.push(prediction);
        if (existingPredictions.length > 100) {
            existingPredictions.splice(0, existingPredictions.length - 100);
        }
        this.predictiveAnalytics.set(key, existingPredictions);
        this.logger.log(`Generated predictive analytics: ${id} for ${target}`);
        return prediction;
    }
    async getBusinessMetrics(category, timeRange) {
        let allMetrics = [];
        if (category != null) {
            for (const [key, metrics] of this.businessMetrics) {
                if (key.startsWith(`${category}.`)) {
                    allMetrics.push(...metrics);
                }
            }
        }
        else {
            for (const metrics of this.businessMetrics.values()) {
                allMetrics.push(...metrics);
            }
        }
        if (timeRange) {
            allMetrics = allMetrics.filter(metric => metric.timestamp >= timeRange.from && metric.timestamp <= timeRange.to);
        }
        return allMetrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getUserAnalytics(userId, event, timeRange) {
        let allAnalytics = [];
        if (userId != null && event != null) {
            const key = `${userId}.${event}`;
            allAnalytics = this.userAnalytics.get(key) ?? [];
        }
        else if (userId != null) {
            for (const [key, analytics] of this.userAnalytics) {
                if (key.startsWith(`${userId}.`)) {
                    allAnalytics.push(...analytics);
                }
            }
        }
        else {
            for (const analytics of this.userAnalytics.values()) {
                allAnalytics.push(...analytics);
            }
        }
        if (timeRange) {
            allAnalytics = allAnalytics.filter(analytic => analytic.timestamp >= timeRange.from &&
                analytic.timestamp <= timeRange.to);
        }
        return allAnalytics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getPerformanceAnalytics(service, endpoint, timeRange) {
        let allAnalytics = [];
        if (service != null && endpoint != null) {
            const key = `${service}.${endpoint}`;
            allAnalytics = this.performanceAnalytics.get(key) ?? [];
        }
        else if (service != null) {
            for (const [key, analytics] of this.performanceAnalytics) {
                if (key.startsWith(`${service}.`)) {
                    allAnalytics.push(...analytics);
                }
            }
        }
        else {
            for (const analytics of this.performanceAnalytics.values()) {
                allAnalytics.push(...analytics);
            }
        }
        if (timeRange) {
            allAnalytics = allAnalytics.filter(analytic => analytic.timestamp >= timeRange.from &&
                analytic.timestamp <= timeRange.to);
        }
        return allAnalytics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getBusinessReport(reportId) {
        return this.businessReports.get(reportId) ?? null;
    }
    async getAllBusinessReports() {
        return Array.from(this.businessReports.values()).sort((a, b) => b.generatedAt.getTime() - a.generatedAt.getTime());
    }
    async getPredictiveAnalytics(model, target) {
        if (model != null && target != null) {
            const key = `${model}.${target}`;
            return this.predictiveAnalytics.get(key) ?? [];
        }
        const allPredictions = [];
        for (const predictions of this.predictiveAnalytics.values()) {
            allPredictions.push(...predictions);
        }
        return allPredictions.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getDataVisualization(id) {
        return this.dataVisualizations.get(id) ?? null;
    }
    async getAllDataVisualizations() {
        return Array.from(this.dataVisualizations.values());
    }
    async createDataVisualization(visualization) {
        const id = `viz-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newVisualization = {
            ...visualization,
            id,
            lastUpdated: new Date(),
        };
        this.dataVisualizations.set(id, newVisualization);
        this.logger.log(`Created data visualization: ${id}`);
        return newVisualization;
    }
    async updateDataVisualization(id, updates) {
        const visualization = this.dataVisualizations.get(id);
        if (!visualization) {
            return null;
        }
        const updatedVisualization = {
            ...visualization,
            ...updates,
            id,
            lastUpdated: new Date(),
        };
        this.dataVisualizations.set(id, updatedVisualization);
        this.logger.log(`Updated data visualization: ${id}`);
        return updatedVisualization;
    }
    async getAnalyticsSummary() {
        const totalBusinessMetrics = Array.from(this.businessMetrics.values()).reduce((sum, metrics) => sum + metrics.length, 0);
        const totalUserEvents = Array.from(this.userAnalytics.values()).reduce((sum, analytics) => sum + analytics.length, 0);
        const totalPerformanceRequests = Array.from(this.performanceAnalytics.values()).reduce((sum, analytics) => sum + analytics.length, 0);
        const eventCounts = new Map();
        for (const analytics of this.userAnalytics.values()) {
            for (const analytic of analytics) {
                eventCounts.set(analytic.event, (eventCounts.get(analytic.event) ?? 0) + 1);
            }
        }
        const topEvents = Array.from(eventCounts.entries())
            .map(([event, count]) => ({ event, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const serviceStats = new Map();
        for (const analytics of this.performanceAnalytics.values()) {
            for (const analytic of analytics) {
                const stats = serviceStats.get(analytic._service) ?? {
                    requests: 0,
                    totalResponseTime: 0,
                };
                stats.requests++;
                stats.totalResponseTime += analytic.responseTime;
                serviceStats.set(analytic._service, stats);
            }
        }
        const topServices = Array.from(serviceStats.entries())
            .map(([service, stats]) => ({
            service,
            requests: stats.requests,
            avgResponseTime: stats.totalResponseTime / stats.requests,
        }))
            .sort((a, b) => b.requests - a.requests)
            .slice(0, 10);
        const pageViews = new Map();
        for (const analytics of this.userAnalytics.values()) {
            for (const analytic of analytics) {
                if (analytic.event === 'page_view' &&
                    analytic.properties.page != null) {
                    pageViews.set(analytic.properties.page || '', (pageViews.get(analytic.properties.page || '') ?? 0) + 1);
                }
            }
        }
        const topPages = Array.from(pageViews.entries())
            .map(([page, views]) => ({ page, views }))
            .sort((a, b) => b.views - a.views)
            .slice(0, 10);
        return {
            totalBusinessMetrics,
            totalUserEvents,
            totalPerformanceRequests,
            totalReports: this.businessReports.size,
            totalPredictions: Array.from(this.predictiveAnalytics.values()).reduce((sum, predictions) => sum + predictions.length, 0),
            totalVisualizations: this.dataVisualizations.size,
            topEvents,
            topServices: topServices.map(s => ({ ...s, _service: s.service })),
            topPages,
        };
    }
};
BusinessIntelligenceService = BusinessIntelligenceService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], BusinessIntelligenceService);



/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UserAnalyticsService: () => (/* binding */ UserAnalyticsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UserAnalyticsService_1;
var _a, _b;



let UserAnalyticsService = UserAnalyticsService_1 = class UserAnalyticsService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UserAnalyticsService_1.name);
        this.userSessions = new Map();
        this.userJourneys = new Map();
        this.userSegments = new Map();
        this.userProfiles = new Map();
        this.engagementMetrics = new Map();
        this._configService.get('USER_ANALYTICS_ENABLED');
        this.eventEmitter.emit('analytics.initialized');
        this.initializeDefaultSegments();
        this.startAnalyticsProcessing();
    }
    initializeDefaultSegments() {
        const defaultSegments = [
            {
                id: 'new-users',
                name: 'New Users',
                description: 'Users who joined in the last 7 days',
                criteria: [
                    {
                        field: 'firstSeen',
                        operator: 'gte',
                        value: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
                    },
                ],
                users: [],
                size: 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'active-users',
                name: 'Active Users',
                description: 'Users with activity in the last 30 days',
                criteria: [
                    {
                        field: 'lastSeen',
                        operator: 'gte',
                        value: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
                    },
                    {
                        field: 'totalSessions',
                        operator: 'gte',
                        value: 3,
                    },
                ],
                users: [],
                size: 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-value-users',
                name: 'High Value Users',
                description: 'Users with high lifetime value',
                criteria: [
                    {
                        field: 'lifetimeValue',
                        operator: 'gte',
                        value: 1000,
                    },
                ],
                users: [],
                size: 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'churn-risk-users',
                name: 'Churn Risk Users',
                description: 'Users at risk of churning',
                criteria: [
                    {
                        field: 'churnRisk',
                        operator: 'eq',
                        value: 'high',
                    },
                ],
                users: [],
                size: 0,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultSegments.forEach(segment => {
            this.userSegments.set(segment.id, segment);
        });
        this.logger.log(`Initialized ${defaultSegments.length} default user segments`);
    }
    startAnalyticsProcessing() {
        setInterval(() => {
            void this.processUserAnalytics();
        }, 300000);
        setInterval(() => {
            void this.updateUserSegments();
        }, 1800000);
    }
    async trackUserEvent(userId, event, properties, sessionId, userAgent, ipAddress) {
        try {
            let session = await this.getActiveSession(userId, sessionId);
            session ??= await this.createSession(userId, sessionId, userAgent, ipAddress);
            session.events++;
            if (event === 'page_view') {
                session.pageViews++;
            }
            await this.updateUserJourney(userId, event, properties, sessionId);
            await this.updateUserProfile(userId, event, properties);
            await this.updateEngagementMetrics(userId);
            this.logger.debug(`Tracked event: ${event} for user ${userId}`);
        }
        catch (error) {
            this.logger.error(`Error tracking user event: ${error}`);
        }
    }
    async getActiveSession(userId, sessionId) {
        const userSessions = this.userSessions.get(userId) ?? [];
        return (userSessions.find(session => session.id === sessionId && session.isActive) ?? null);
    }
    async createSession(userId, sessionId, userAgent, ipAddress) {
        const session = {
            id: sessionId,
            userId,
            startTime: new Date(),
            pageViews: 0,
            events: 0,
            userAgent,
            ipAddress,
            device: this.parseUserAgent(userAgent),
            location: this.getLocationFromIP(ipAddress),
            isActive: true,
        };
        const userSessions = this.userSessions.get(userId) ?? [];
        userSessions.push(session);
        this.userSessions.set(userId, userSessions);
        return session;
    }
    parseUserAgent(userAgent) {
        const isMobile = /Mobile|Android|iPhone|iPad/.test(userAgent);
        const isTablet = /iPad|Tablet/.test(userAgent);
        let type = 'desktop';
        if (isTablet)
            type = 'tablet';
        else if (isMobile)
            type = 'mobile';
        const os = /Windows/.test(userAgent)
            ? 'Windows'
            : /Mac/.test(userAgent)
                ? 'macOS'
                : /Linux/.test(userAgent)
                    ? 'Linux'
                    : /Android/.test(userAgent)
                        ? 'Android'
                        : /iOS/.test(userAgent)
                            ? 'iOS'
                            : 'Unknown';
        const browser = /Chrome/.test(userAgent)
            ? 'Chrome'
            : /Firefox/.test(userAgent)
                ? 'Firefox'
                : /Safari/.test(userAgent)
                    ? 'Safari'
                    : /Edge/.test(userAgent)
                        ? 'Edge'
                        : 'Unknown';
        return { type, os, browser };
    }
    getLocationFromIP(ipAddress) {
        const locations = [
            {
                country: 'United States',
                city: 'New York',
                timezone: 'America/New_York',
            },
            { country: 'United Kingdom', city: 'London', timezone: 'Europe/London' },
            { country: 'Germany', city: 'Berlin', timezone: 'Europe/Berlin' },
            { country: 'France', city: 'Paris', timezone: 'Europe/Paris' },
            { country: 'Japan', city: 'Tokyo', timezone: 'Asia/Tokyo' },
        ];
        const hash = ipAddress
            .split('.')
            .reduce((acc, part) => acc + parseInt(part), 0);
        return (locations[hash % locations.length] ?? {
            country: 'Unknown',
            city: 'Unknown',
            timezone: 'UTC',
        });
    }
    async updateUserJourney(userId, event, properties, _sessionId) {
        const userJourneys = this.userJourneys.get(userId) ?? [];
        let activeJourney = userJourneys.find(journey => !journey.endTime);
        if (activeJourney == null) {
            activeJourney = {
                id: `journey-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                userId,
                startTime: new Date(),
                steps: [],
                conversion: false,
                totalDuration: 0,
            };
            userJourneys.push(activeJourney);
        }
        activeJourney.steps.push({
            timestamp: new Date(),
            event,
            page: properties.page || 'unknown',
            properties,
            duration: activeJourney.steps.length > 0
                ? new Date().getTime() -
                    (activeJourney.steps[activeJourney.steps.length - 1]?.timestamp.getTime() ?? 0)
                : 0,
        });
        if (event === 'purchase' ||
            event === 'signup' ||
            event === 'subscription') {
            activeJourney.conversion = true;
            activeJourney.conversionValue = properties.value || 0;
            activeJourney.endTime = new Date();
            activeJourney.totalDuration =
                activeJourney.endTime.getTime() - activeJourney.startTime.getTime();
        }
        this.userJourneys.set(userId, userJourneys);
    }
    async updateUserProfile(userId, event, properties) {
        let profile = this.userProfiles.get(userId);
        const now = new Date();
        profile ??= {
            userId,
            firstSeen: now,
            lastSeen: now,
            totalSessions: 0,
            totalPageViews: 0,
            totalEvents: 0,
            averageSessionDuration: 0,
            totalDuration: 0,
            deviceBreakdown: {},
            locationBreakdown: {},
            topPages: [],
            topEvents: [],
            conversionFunnel: {
                visitors: 1,
                signups: 0,
                trials: 0,
                paid: 0,
            },
            lifetimeValue: 0,
            churnRisk: 'low',
            engagementScore: 0,
        };
        profile.lastSeen = now;
        profile.totalEvents++;
        if (event === 'page_view') {
            profile.totalPageViews++;
            const page = properties.page ?? 'unknown';
            const existingPage = profile.topPages.find(p => p.page === page);
            if (existingPage != null) {
                existingPage.views++;
            }
            else {
                profile.topPages.push({ page: page, views: 1 });
            }
            profile.topPages.sort((a, b) => b.views - a.views);
        }
        const existingEvent = profile.topEvents.find(e => e.event === event);
        if (existingEvent != null) {
            existingEvent.count++;
        }
        else {
            profile.topEvents.push({ event, count: 1 });
        }
        profile.topEvents.sort((a, b) => b.count - a.count);
        if (event === 'signup')
            profile.conversionFunnel.signups++;
        if (event === 'trial_start')
            profile.conversionFunnel.trials++;
        if (event === 'purchase')
            profile.conversionFunnel.paid++;
        if (event === 'purchase' && properties.value != null) {
            profile.lifetimeValue += properties.value || 0;
        }
        this.userProfiles.set(userId, profile);
    }
    async updateEngagementMetrics(userId) {
        const profile = this.userProfiles.get(userId);
        if (profile == null)
            return;
        const sessions = this.userSessions.get(userId) ?? [];
        const activeSessions = sessions.filter(s => s.isActive);
        if (activeSessions.length > 0) {
            this.logger.debug(`Active sessions: ${activeSessions.length}`);
        }
        const completedSessions = sessions.filter(s => !s.isActive);
        const totalDuration = completedSessions.reduce((sum, s) => sum + (s.duration ?? 0), 0);
        const averageSessionDuration = completedSessions.length > 0
            ? totalDuration / completedSessions.length
            : 0;
        const engagementScore = this.calculateEngagementScore(profile, sessions);
        const metrics = {
            userId,
            sessionCount: sessions.length,
            pageViewCount: profile.totalPageViews,
            eventCount: profile.totalEvents,
            averageSessionDuration,
            bounceRate: this.calculateBounceRate(sessions),
            returnRate: this.calculateReturnRate(sessions),
            engagementScore,
            lastActivity: profile.lastSeen,
            streak: this.calculateStreak(userId),
            totalTimeSpent: totalDuration,
        };
        this.engagementMetrics.set(userId, metrics);
    }
    calculateEngagementScore(profile, _sessions) {
        let score = 0;
        score += Math.min(profile.totalSessions * 10, 100);
        score += Math.min(profile.totalPageViews * 2, 50);
        score += Math.min(profile.totalEvents * 1, 30);
        if (profile.conversionFunnel.signups > 0)
            score += 20;
        if (profile.conversionFunnel.trials > 0)
            score += 30;
        if (profile.conversionFunnel.paid > 0)
            score += 50;
        score += Math.min(profile.lifetimeValue / 100, 50);
        return Math.min(score, 100);
    }
    calculateBounceRate(sessions) {
        if (sessions.length === 0)
            return 0;
        const bouncedSessions = sessions.filter(s => s.pageViews <= 1).length;
        return (bouncedSessions / sessions.length) * 100;
    }
    calculateReturnRate(sessions) {
        if (sessions.length <= 1)
            return 0;
        const uniqueDays = new Set(sessions.map(s => s.startTime.toDateString()))
            .size;
        return (uniqueDays / sessions.length) * 100;
    }
    calculateStreak(userId) {
        const sessions = this.userSessions.get(userId) ?? [];
        if (sessions.length === 0)
            return 0;
        const sortedSessions = sessions.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
        let streak = 0;
        const currentDate = new Date();
        currentDate.setHours(0, 0, 0, 0);
        for (const session of sortedSessions) {
            const sessionDate = new Date(session.startTime);
            sessionDate.setHours(0, 0, 0, 0);
            if (sessionDate.getTime() === currentDate.getTime()) {
                streak++;
                currentDate.setDate(currentDate.getDate() - 1);
            }
            else if (sessionDate.getTime() < currentDate.getTime()) {
                break;
            }
        }
        return streak;
    }
    async processUserAnalytics() {
        try {
            for (const [, sessions] of this.userSessions) {
                for (const session of sessions) {
                    if (session.isActive && this.isSessionExpired(session)) {
                        await this.endSession(session);
                    }
                }
            }
            await this.updateChurnRisk();
            this.logger.debug('User analytics processed');
        }
        catch (error) {
            this.logger.error('Error processing user analytics:', error);
        }
    }
    isSessionExpired(session) {
        const now = new Date();
        const sessionAge = now.getTime() - session.startTime.getTime();
        return sessionAge > 30 * 60 * 1000;
    }
    async endSession(session) {
        session.endTime = new Date();
        session.duration = session.endTime.getTime() - session.startTime.getTime();
        session.isActive = false;
        const profile = this.userProfiles.get(session.userId);
        if (profile) {
            profile.totalSessions++;
            profile.totalDuration += session.duration;
            profile.averageSessionDuration =
                profile.totalDuration / profile.totalSessions;
            const deviceKey = `${session.device.type}-${session.device.os}`;
            profile.deviceBreakdown[deviceKey] =
                (profile.deviceBreakdown[deviceKey] ?? 0) + 1;
            const locationKey = session.location.country;
            profile.locationBreakdown[locationKey] =
                (profile.locationBreakdown[locationKey] ?? 0) + 1;
        }
    }
    async updateChurnRisk() {
        for (const [userId, profile] of this.userProfiles) {
            const daysSinceLastSeen = (Date.now() - profile.lastSeen.getTime()) / (1000 * 60 * 60 * 24);
            const engagementScore = this.engagementMetrics.get(userId)?.engagementScore ?? 0;
            let churnRisk = 'low';
            if (daysSinceLastSeen > 30 || engagementScore < 20) {
                churnRisk = 'high';
            }
            else if (daysSinceLastSeen > 14 || engagementScore < 40) {
                churnRisk = 'medium';
            }
            profile.churnRisk = churnRisk;
        }
    }
    async updateUserSegments() {
        for (const [, segment] of this.userSegments) {
            const matchingUsers = [];
            for (const [userId, profile] of this.userProfiles) {
                if (this.userMatchesSegment(profile, segment)) {
                    matchingUsers.push(userId);
                }
            }
            segment.users = matchingUsers;
            segment.size = matchingUsers.length;
            segment.updatedAt = new Date();
        }
        this.logger.debug('User segments updated');
    }
    userMatchesSegment(profile, segment) {
        return segment.criteria.every(criteria => {
            const value = this.getProfileValue(profile, criteria.field);
            return this.evaluateCriteria(value, criteria.operator, criteria.value);
        });
    }
    getProfileValue(profile, field) {
        switch (field) {
            case 'firstSeen':
                return profile.firstSeen;
            case 'lastSeen':
                return profile.lastSeen;
            case 'totalSessions':
                return profile.totalSessions;
            case 'lifetimeValue':
                return profile.lifetimeValue;
            case 'churnRisk':
                return profile.churnRisk;
            default:
                return undefined;
        }
    }
    evaluateCriteria(value, operator, expectedValue) {
        switch (operator) {
            case 'eq':
                return value === expectedValue;
            case 'gt':
                return value > expectedValue;
            case 'lt':
                return value < expectedValue;
            case 'gte':
                return value >= expectedValue;
            case 'lte':
                return value <= expectedValue;
            case 'contains':
                return String(value).includes(String(expectedValue));
            case 'in':
                return Array.isArray(expectedValue) && expectedValue.includes(value);
            default:
                return false;
        }
    }
    async getUserProfile(userId) {
        return this.userProfiles.get(userId) ?? null;
    }
    async getUserSessions(userId, timeRange) {
        let sessions = this.userSessions.get(userId) ?? [];
        if (timeRange != null) {
            sessions = sessions.filter(session => session.startTime >= timeRange.from &&
                session.startTime <= timeRange.to);
        }
        return sessions.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
    }
    async getUserJourneys(userId, timeRange) {
        let journeys = this.userJourneys.get(userId) ?? [];
        if (timeRange != null) {
            journeys = journeys.filter(journey => journey.startTime >= timeRange.from &&
                journey.startTime <= timeRange.to);
        }
        return journeys.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
    }
    async getEngagementMetrics(userId) {
        return this.engagementMetrics.get(userId) ?? null;
    }
    async getUserSegment(segmentId) {
        return this.userSegments.get(segmentId) ?? null;
    }
    async getAllUserSegments() {
        return Array.from(this.userSegments.values());
    }
    async createUserSegment(segment) {
        const id = `segment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newSegment = {
            ...segment,
            id,
            users: [],
            size: 0,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.userSegments.set(id, newSegment);
        await this.updateUserSegments();
        this.logger.log(`Created user segment: ${id}`);
        return newSegment;
    }
    async getAnalyticsSummary() {
        const totalUsers = this.userProfiles.size;
        const allSessions = Array.from(this.userSessions.values()).flat();
        const totalSessions = allSessions.length;
        const totalPageViews = Array.from(this.userProfiles.values()).reduce((sum, profile) => sum + profile.totalPageViews, 0);
        const totalEvents = Array.from(this.userProfiles.values()).reduce((sum, profile) => sum + profile.totalEvents, 0);
        const completedSessions = allSessions.filter(s => s.duration != null);
        const averageSessionDuration = completedSessions.length > 0
            ? completedSessions.reduce((sum, s) => sum + (s.duration ?? 0), 0) /
                completedSessions.length
            : 0;
        const bounceRate = this.calculateBounceRate(allSessions);
        const totalConversions = Array.from(this.userProfiles.values()).reduce((sum, profile) => sum + profile.conversionFunnel.paid, 0);
        const conversionRate = totalUsers > 0 ? (totalConversions / totalUsers) * 100 : 0;
        const pageViews = new Map();
        for (const profile of this.userProfiles.values()) {
            for (const page of profile.topPages) {
                pageViews.set(page.page, (pageViews.get(page.page) ?? 0) + page.views);
            }
        }
        const topPages = Array.from(pageViews.entries())
            .map(([page, views]) => ({ page, views }))
            .sort((a, b) => b.views - a.views)
            .slice(0, 10);
        const eventCounts = new Map();
        for (const profile of this.userProfiles.values()) {
            for (const event of profile.topEvents) {
                eventCounts.set(event.event, (eventCounts.get(event.event) ?? 0) + event.count);
            }
        }
        const topEvents = Array.from(eventCounts.entries())
            .map(([event, count]) => ({ event, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const deviceCounts = new Map();
        for (const profile of this.userProfiles.values()) {
            for (const [device, count] of Object.entries(profile.deviceBreakdown)) {
                deviceCounts.set(device, (deviceCounts.get(device) ?? 0) + count);
            }
        }
        const totalDeviceSessions = Array.from(deviceCounts.values()).reduce((sum, count) => sum + count, 0);
        const deviceBreakdown = Array.from(deviceCounts.entries())
            .map(([device, count]) => ({
            device,
            percentage: totalDeviceSessions > 0 ? (count / totalDeviceSessions) * 100 : 0,
        }))
            .sort((a, b) => b.percentage - a.percentage);
        const locationCounts = new Map();
        for (const profile of this.userProfiles.values()) {
            for (const [location, count] of Object.entries(profile.locationBreakdown)) {
                locationCounts.set(location, (locationCounts.get(location) ?? 0) + count);
            }
        }
        const totalLocationSessions = Array.from(locationCounts.values()).reduce((sum, count) => sum + count, 0);
        const locationBreakdown = Array.from(locationCounts.entries())
            .map(([location, count]) => ({
            location,
            percentage: totalLocationSessions > 0 ? (count / totalLocationSessions) * 100 : 0,
        }))
            .sort((a, b) => b.percentage - a.percentage);
        const churnRiskCounts = { low: 0, medium: 0, high: 0 };
        for (const profile of this.userProfiles.values()) {
            churnRiskCounts[profile.churnRisk]++;
        }
        const churnRiskBreakdown = Object.entries(churnRiskCounts).map(([risk, count]) => ({
            risk,
            count,
            percentage: totalUsers > 0 ? (count / totalUsers) * 100 : 0,
        }));
        return {
            totalUsers,
            totalSessions,
            totalPageViews,
            totalEvents,
            averageSessionDuration,
            bounceRate,
            conversionRate,
            topPages,
            topEvents,
            deviceBreakdown,
            locationBreakdown,
            churnRiskBreakdown,
        };
    }
};
UserAnalyticsService = UserAnalyticsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], UserAnalyticsService);



/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnalyticsController: () => (/* binding */ AnalyticsController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _business_intelligence_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _user_analytics_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;




let AnalyticsController = class AnalyticsController {
    constructor(businessIntelligenceService, userAnalyticsService) {
        this.businessIntelligenceService = businessIntelligenceService;
        this.userAnalyticsService = userAnalyticsService;
    }
    async getBusinessMetrics(category, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const metrics = await this.businessIntelligenceService.getBusinessMetrics(category, timeRange);
        return {
            success: true,
            data: metrics,
            count: metrics.length,
        };
    }
    async getBusinessReports() {
        const reports = await this.businessIntelligenceService.getAllBusinessReports();
        return {
            success: true,
            data: reports,
            count: reports.length,
        };
    }
    async generateBusinessReport(body) {
        const report = await this.businessIntelligenceService.generateBusinessReport(body.type, {
            from: new Date(body.from),
            to: new Date(body.to),
        }, body.generatedBy);
        return {
            success: true,
            data: report,
            message: 'Business report generated successfully',
        };
    }
    async getPredictiveAnalytics(model, target) {
        const predictions = await this.businessIntelligenceService.getPredictiveAnalytics(model, target);
        return {
            success: true,
            data: predictions,
            count: predictions.length,
        };
    }
    async generatePredictiveAnalytics(body) {
        const prediction = await this.businessIntelligenceService.generatePredictiveAnalytics(body.model, body.target, body.timeframe);
        return {
            success: true,
            data: prediction,
            message: 'Predictive analytics generated successfully',
        };
    }
    async getDataVisualizations() {
        const visualizations = await this.businessIntelligenceService.getAllDataVisualizations();
        return {
            success: true,
            data: visualizations,
            count: visualizations.length,
        };
    }
    async getDataVisualization(id) {
        const visualization = await this.businessIntelligenceService.getDataVisualization(id);
        if (!visualization) {
            return {
                success: false,
                error: 'Data visualization not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: visualization,
        };
    }
    async createDataVisualization(body) {
        const visualization = await this.businessIntelligenceService.createDataVisualization({
            ...body,
            data: [],
        });
        return {
            success: true,
            data: visualization,
            message: 'Data visualization created successfully',
        };
    }
    async getUserProfile(userId) {
        const profile = await this.userAnalyticsService.getUserProfile(userId);
        if (!profile) {
            return {
                success: false,
                error: 'User profile not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: profile,
        };
    }
    async getUserSessions(userId, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const sessions = await this.userAnalyticsService.getUserSessions(userId, timeRange);
        return {
            success: true,
            data: sessions,
            count: sessions.length,
        };
    }
    async getUserJourneys(userId, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const journeys = await this.userAnalyticsService.getUserJourneys(userId, timeRange);
        return {
            success: true,
            data: journeys,
            count: journeys.length,
        };
    }
    async getUserEngagementMetrics(userId) {
        const metrics = await this.userAnalyticsService.getEngagementMetrics(userId);
        if (!metrics) {
            return {
                success: false,
                error: 'User engagement metrics not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: metrics,
        };
    }
    async getUserSegments() {
        const segments = await this.userAnalyticsService.getAllUserSegments();
        return {
            success: true,
            data: segments,
            count: segments.length,
        };
    }
    async getUserSegment(segmentId) {
        const segment = await this.userAnalyticsService.getUserSegment(segmentId);
        if (!segment) {
            return {
                success: false,
                error: 'User segment not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: segment,
        };
    }
    async createUserSegment(body) {
        const segment = await this.userAnalyticsService.createUserSegment(body);
        return {
            success: true,
            data: segment,
            message: 'User segment created successfully',
        };
    }
    async trackUserEvent(body) {
        await this.userAnalyticsService.trackUserEvent(body.userId, body.event, body.properties, body.sessionId, body.userAgent, body.ipAddress);
        return {
            success: true,
            message: 'User event tracked successfully',
        };
    }
    async getPerformanceAnalytics(service, endpoint, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const analytics = await this.businessIntelligenceService.getPerformanceAnalytics(service, endpoint, timeRange);
        return {
            success: true,
            data: analytics,
            count: analytics.length,
        };
    }
    async getAnalyticsSummary() {
        const businessSummary = await this.businessIntelligenceService.getAnalyticsSummary();
        const userSummary = await this.userAnalyticsService.getAnalyticsSummary();
        return {
            success: true,
            data: {
                business: businessSummary,
                users: userSummary,
                timestamp: new Date().toISOString(),
            },
        };
    }
    async getHealth() {
        const businessSummary = await this.businessIntelligenceService.getAnalyticsSummary();
        const userSummary = await this.userAnalyticsService.getAnalyticsSummary();
        return {
            success: true,
            data: {
                status: 'healthy',
                business: {
                    totalMetrics: businessSummary.totalBusinessMetrics,
                    totalReports: businessSummary.totalReports,
                    totalVisualizations: businessSummary.totalVisualizations,
                },
                users: {
                    totalUsers: userSummary.totalUsers,
                    totalSessions: userSummary.totalSessions,
                    totalEvents: userSummary.totalEvents,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('business/metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get business metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'category',
        required: false,
        description: 'Filter by category',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Business metrics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('category')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getBusinessMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('business/reports'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get business reports' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Business reports retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getBusinessReports", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('business/reports'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate business report' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Business report generated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "generateBusinessReport", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('business/predictions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get predictive analytics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'model', required: false, description: 'Filter by model' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'target',
        required: false,
        description: 'Filter by target',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Predictive analytics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('model')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('target')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getPredictiveAnalytics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('business/predictions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate predictive analytics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Predictive analytics generated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "generatePredictiveAnalytics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('business/visualizations'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get data visualizations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data visualizations retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getDataVisualizations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('business/visualizations/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get specific data visualization' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Visualization ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data visualization retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getDataVisualization", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('business/visualizations'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create data visualization' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Data visualization created successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "createDataVisualization", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/profiles/:userId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get user profile' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'userId', description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User profile retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('userId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserProfile", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/sessions/:userId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get user sessions' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'userId', description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User sessions retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('userId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserSessions", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/journeys/:userId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get user journeys' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'userId', description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User journeys retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('userId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserJourneys", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/engagement/:userId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get user engagement metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'userId', description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User engagement metrics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('userId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserEngagementMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/segments'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get user segments' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User segments retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserSegments", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('users/segments/:segmentId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get specific user segment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'segmentId', description: 'Segment ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'User segment retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('segmentId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getUserSegment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('users/segments'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create user segment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'User segment created successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "createUserSegment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('users/track'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Track user event' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'User event tracked successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "trackUserEvent", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/requests'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance analytics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'endpoint',
        required: false,
        description: 'Filter by endpoint',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance analytics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('endpoint')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getPerformanceAnalytics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('summary'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get analytics summary' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Analytics summary retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getAnalyticsSummary", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get analytics service health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getHealth", null);
AnalyticsController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Analytics & Business Intelligence'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('analytics'),
    __metadata("design:paramtypes", [typeof (_a = typeof _business_intelligence_service__WEBPACK_IMPORTED_MODULE_2__.BusinessIntelligenceService !== "undefined" && _business_intelligence_service__WEBPACK_IMPORTED_MODULE_2__.BusinessIntelligenceService) === "function" ? _a : Object, typeof (_b = typeof _user_analytics_service__WEBPACK_IMPORTED_MODULE_3__.UserAnalyticsService !== "undefined" && _user_analytics_service__WEBPACK_IMPORTED_MODULE_3__.UserAnalyticsService) === "function" ? _b : Object])
], AnalyticsController);



/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppController: () => (/* binding */ AppController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _app_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;



let AppController = class AppController {
    constructor(appService) {
        this.appService = appService;
    }
    getHealth() {
        return this.appService.getHealth();
    }
    getDemoCards() {
        return this.appService.getDemoCards();
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья API' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'API работает корректно' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], AppController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cards/demo'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Демо карты лояльности' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список демо карт' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Array !== "undefined" && Array) === "function" ? _b : Object)
], AppController.prototype, "getDemoCards", null);
AppController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('app'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _app_service__WEBPACK_IMPORTED_MODULE_2__.AppService !== "undefined" && _app_service__WEBPACK_IMPORTED_MODULE_2__.AppService) === "function" ? _a : Object])
], AppController);



/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppService: () => (/* binding */ AppService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let AppService = class AppService {
    getHealth() {
        return {
            status: 'ok',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
        };
    }
    getDemoCards() {
        return [
            {
                id: 'demo-1',
                name: 'Скидка 10% на все товары',
                description: 'Демо карта лояльности с базовой скидкой',
                discount: 10,
                network: 'Demo Network',
            },
            {
                id: 'demo-2',
                name: 'Скидка 15% на электронику',
                description: 'Демо карта для категории электроники',
                discount: 15,
                network: 'Demo Network',
            },
            {
                id: 'demo-3',
                name: 'Скидка 20% на одежду',
                description: 'Демо карта для категории одежды',
                discount: 20,
                network: 'Demo Network',
            },
        ];
    }
};
AppService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], AppService);



/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthModule: () => (/* binding */ AuthModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _auth_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _auth_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _auth_repository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
/* harmony import */ var _guards_roles_guard__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(40);
/* harmony import */ var _guards_role_mapping_guard__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41);
/* harmony import */ var _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(42);
/* harmony import */ var _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(43);
/* harmony import */ var _controllers_ai_role_analyzer_controller__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(44);
/* harmony import */ var _supabase_supabase_module__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(46);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













let AuthModule = class AuthModule {
};
AuthModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _supabase_supabase_module__WEBPACK_IMPORTED_MODULE_12__.SupabaseModule,
            _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__.JwtModule.registerAsync({
                imports: [_nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigModule],
                useFactory: (configService) => ({
                    secret: configService.get('JWT_SECRET') ?? 'fallback-secret',
                    signOptions: {
                        expiresIn: configService.get('JWT_EXPIRES_IN', '7d'),
                    },
                }),
                inject: [_nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigService],
            }),
        ],
        controllers: [_auth_controller__WEBPACK_IMPORTED_MODULE_3__.AuthController, _controllers_ai_role_analyzer_controller__WEBPACK_IMPORTED_MODULE_11__.AIRoleAnalyzerController],
        providers: [
            _auth_service__WEBPACK_IMPORTED_MODULE_4__.AuthService,
            _auth_repository__WEBPACK_IMPORTED_MODULE_5__.AuthRepository,
            _guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_6__.JwtAuthGuard,
            _guards_roles_guard__WEBPACK_IMPORTED_MODULE_7__.RolesGuard,
            _guards_role_mapping_guard__WEBPACK_IMPORTED_MODULE_8__.RoleMappingGuard,
            _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_9__.RoleMappingService,
            _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_10__.AIRoleAnalyzerService,
        ],
        exports: [
            _auth_service__WEBPACK_IMPORTED_MODULE_4__.AuthService,
            _guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_6__.JwtAuthGuard,
            _guards_roles_guard__WEBPACK_IMPORTED_MODULE_7__.RolesGuard,
            _guards_role_mapping_guard__WEBPACK_IMPORTED_MODULE_8__.RoleMappingGuard,
            _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_9__.RoleMappingService,
            _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_10__.AIRoleAnalyzerService,
        ],
    })
], AuthModule);



/***/ }),
/* 28 */
/***/ ((module) => {

module.exports = require("@nestjs/jwt");

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthController: () => (/* binding */ AuthController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _dto_login_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);
/* harmony import */ var _dto_register_dto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var _guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;






let AuthController = class AuthController {
    constructor(authService) {
        this.authService = authService;
    }
    async login(loginDto) {
        return this.authService.login(loginDto);
    }
    async register(registerDto) {
        return this.authService.register(registerDto);
    }
    async getCurrentUser(req) {
        if (req.user == null) {
            throw new Error('User not found in request');
        }
        return this.authService.getProfile(req.user.id);
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('login'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Вход в систему' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Успешный вход' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Неверные учетные данные' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof _dto_login_dto__WEBPACK_IMPORTED_MODULE_3__.LoginDto !== "undefined" && _dto_login_dto__WEBPACK_IMPORTED_MODULE_3__.LoginDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "login", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('register'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Регистрация пользователя' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Пользователь создан' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Ошибка валидации' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof _dto_register_dto__WEBPACK_IMPORTED_MODULE_4__.RegisterDto !== "undefined" && _dto_register_dto__WEBPACK_IMPORTED_MODULE_4__.RegisterDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "register", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('me'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_5__.JwtAuthGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить текущего пользователя' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Данные пользователя' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Не авторизован' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "getCurrentUser", null);
AuthController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('auth'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('auth'),
    __metadata("design:paramtypes", [typeof (_a = typeof _auth_service__WEBPACK_IMPORTED_MODULE_2__.AuthService !== "undefined" && _auth_service__WEBPACK_IMPORTED_MODULE_2__.AuthService) === "function" ? _a : Object])
], AuthController);



/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthService: () => (/* binding */ AuthService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _auth_repository__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);
/* harmony import */ var _auth_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AuthService_1;
var _a, _b, _c;






let AuthService = AuthService_1 = class AuthService {
    constructor(supabaseService, jwtService, authRepository) {
        this.supabaseService = supabaseService;
        this.jwtService = jwtService;
        this.authRepository = authRepository;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AuthService_1.name);
    }
    async login(loginDto) {
        const { email, password } = loginDto;
        try {
            const { data: userData, error: userError } = (await this.supabaseService.client
                .from('users')
                .select('*')
                .eq('email', email)
                .eq('is_active', true)
                .single());
            if (userError != null || userData == null) {
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Invalid credentials');
            }
            if (password.length < 6) {
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Invalid credentials');
            }
            const typedUserData = {
                id: userData.id,
                email: userData.email,
                role: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertUserRole)(userData.role),
                firstName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.first_name),
                lastName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.last_name),
                phone: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.phone),
                avatar: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.avatar),
                isActive: Boolean(userData.is_active),
                createdAt: new Date(userData.created_at),
                updatedAt: new Date(userData.updated_at),
            };
            const payload = {
                id: typedUserData.id,
                email: typedUserData.email,
                role: typedUserData.role,
            };
            const accessToken = this.jwtService.sign(payload);
            const refreshToken = this.jwtService.sign(payload, { expiresIn: '30d' });
            return {
                user: typedUserData,
                accessToken,
                refreshToken,
            };
        }
        catch (error) {
            if (error instanceof _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException) {
                throw error;
            }
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Login failed');
        }
    }
    async register(createUserDto) {
        const { email, password, role, firstName, lastName } = createUserDto;
        try {
            const { data: existingUser } = (await this.supabaseService.client
                .from('users')
                .select('id')
                .eq('email', email)
                .single());
            if (existingUser) {
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ConflictException('User already exists');
            }
            const createUserData = {
                user_email: email,
                user_password: password,
                user_first_name: firstName ?? '',
                user_last_name: lastName ?? '',
                user_role: role ?? _types_roles__WEBPACK_IMPORTED_MODULE_3__.UserRole.USER,
            };
            const result = await this.authRepository.createSimpleUser(createUserData);
            if (result == null) {
                this.logger.error('Registration failed: no result from create_simple_user');
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ConflictException('Registration failed');
            }
            const userData = await this.authRepository.findUserById(result.id);
            if (userData == null) {
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ConflictException('Failed to get user profile');
            }
            const typedUserData = {
                id: userData.id,
                email: userData.email,
                role: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertUserRole)(userData.role),
                firstName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.first_name),
                lastName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.last_name),
                phone: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.phone),
                avatar: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(userData.avatar),
                isActive: Boolean(userData.is_active),
                createdAt: new Date(userData.created_at),
                updatedAt: new Date(userData.updated_at),
            };
            const payload = {
                id: typedUserData.id,
                email: typedUserData.email,
                role: typedUserData.role,
            };
            const accessToken = this.jwtService.sign(payload);
            const refreshToken = this.jwtService.sign(payload, { expiresIn: '30d' });
            return {
                user: typedUserData,
                accessToken,
                refreshToken,
            };
        }
        catch (error) {
            this.logger.error('Registration error:', error);
            if (error instanceof _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ConflictException) {
                throw error;
            }
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ConflictException('Registration failed');
        }
    }
    async getProfile(userId) {
        try {
            const user = await this.authRepository.findUserWithProfiles(userId);
            if (user == null) {
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('User not found');
            }
            const typedUserData = {
                id: user.id,
                email: user.email,
                role: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertUserRole)(user.role),
                firstName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(user.first_name),
                lastName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(user.last_name),
                phone: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(user.phone),
                avatar: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(user.avatar),
                isActive: user.is_active,
                createdAt: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertDateString)(user.created_at),
                updatedAt: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertDateString)(user.updated_at),
            };
            const result = {
                id: typedUserData.id,
                email: typedUserData.email,
                role: typedUserData.role,
                firstName: typedUserData.firstName,
                lastName: typedUserData.lastName,
                phone: typedUserData.phone,
                avatar: typedUserData.avatar,
                isActive: typedUserData.isActive,
                createdAt: typedUserData.createdAt,
                updatedAt: typedUserData.updatedAt,
            };
            if (user.user_profiles[0] != null) {
                const profileData = user.user_profiles[0];
                result.profile = {
                    id: profileData.id,
                    userId: profileData.user_id,
                    firstName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(profileData.first_name),
                    lastName: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(profileData.last_name),
                    phone: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(profileData.phone),
                    avatar: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertNullableString)(profileData.avatar),
                    preferences: profileData.preferences ?? undefined,
                    createdAt: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertDateString)(profileData.created_at),
                    updatedAt: (0,_auth_types__WEBPACK_IMPORTED_MODULE_5__.convertDateString)(profileData.updated_at),
                };
            }
            return result;
        }
        catch (error) {
            if (error instanceof _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException) {
                throw error;
            }
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Failed to get profile');
        }
    }
};
AuthService = AuthService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_2__.SupabaseService !== "undefined" && _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_2__.SupabaseService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__.JwtService !== "undefined" && _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__.JwtService) === "function" ? _b : Object, typeof (_c = typeof _auth_repository__WEBPACK_IMPORTED_MODULE_4__.AuthRepository !== "undefined" && _auth_repository__WEBPACK_IMPORTED_MODULE_4__.AuthRepository) === "function" ? _c : Object])
], AuthService);



/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SupabaseService: () => (/* binding */ SupabaseService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;



let SupabaseService = class SupabaseService {
    constructor(configService) {
        this.configService = configService;
    }
    onModuleInit() {
        const supabaseUrl = this.configService.get('SUPABASE_URL');
        const supabaseServiceKey = this.configService.get('SUPABASE_SERVICE_ROLE_KEY');
        if (supabaseUrl == null ||
            supabaseUrl === '' ||
            supabaseUrl.length === 0 ||
            supabaseServiceKey == null ||
            supabaseServiceKey === '' ||
            supabaseServiceKey.length === 0) {
            throw new Error('SUPABASE_URL и SUPABASE_SERVICE_ROLE_KEY должны быть установлены');
        }
        this.supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey);
    }
    get auth() {
        return this.supabase.auth;
    }
    get from() {
        return this.supabase.from;
    }
    get client() {
        return this.supabase;
    }
};
SupabaseService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigService) === "function" ? _a : Object])
], SupabaseService);



/***/ }),
/* 32 */
/***/ ((module) => {

module.exports = require("@supabase/supabase-js");

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ROLE_PERMISSIONS: () => (/* binding */ ROLE_PERMISSIONS),
/* harmony export */   UserRole: () => (/* binding */ UserRole),
/* harmony export */   canAccessRole: () => (/* binding */ canAccessRole),
/* harmony export */   getRoleHierarchy: () => (/* binding */ getRoleHierarchy),
/* harmony export */   hasPermission: () => (/* binding */ hasPermission)
/* harmony export */ });
var UserRole;
(function (UserRole) {
    UserRole["SUPER_ADMIN"] = "super_admin";
    UserRole["ADMIN"] = "admin";
    UserRole["DEVOPS"] = "devops";
    UserRole["NETWORK_MANAGER"] = "network_manager";
    UserRole["STORE_MANAGER"] = "store_manager";
    UserRole["BRAND_MANAGER"] = "brand_manager";
    UserRole["USER"] = "user";
})(UserRole || (UserRole = {}));
const ROLE_PERMISSIONS = {
    [UserRole.SUPER_ADMIN]: {
        canManageRoles: true,
        canManageUsers: true,
        canManageSystemSettings: true,
        canManageTariffs: true,
        canManageCommissions: true,
        canManageSecurity: true,
        canViewAuditLogs: true,
        canManageIntegrations: true,
        canViewSystemMonitoring: true,
        canManageBackups: true,
        canManageDeployments: true,
        canViewFinancialAnalytics: true,
        canManagePartnerBalances: true,
        canIssueInvoices: true,
        canViewFinancialReports: true,
        canViewTopPartners: true,
        canViewRevenueForecasts: true,
        canModerateContent: true,
        canManageCategories: true,
        canSendSystemNotifications: true,
        canManagePromoCodes: true,
        canManageNetworks: true,
        canManageStores: true,
        canAssignStoreManagers: true,
        canManageStorePermissions: true,
        canConfigureGeofencing: true,
        canManageStoreHours: true,
        canManageNetworkBalance: true,
        canViewNetworkAnalytics: true,
        canManageNetworkSubscription: true,
        canViewNetworkReports: true,
        canReplenishNetworkBalance: true,
        canCreateNetworkCampaigns: true,
        canManagePushNotifications: true,
        canBuyPushNotifications: true,
        canRunABTests: true,
        canPersonalizeOffers: true,
        canCompareStores: true,
        canViewGeographicAnalytics: true,
        canViewNetworkForecasts: true,
        canBulkUploadProducts: true,
        canManageStoreInfo: true,
        canConfigureStoreGeofencing: true,
        canManageStorePersonnel: true,
        canIntegratePOS: true,
        canCreateLocalLoyaltyCards: true,
        canManageDiscounts: true,
        canLimitActivationTiers: true,
        canCreateTemporaryPromotions: true,
        canViewStoreAnalytics: true,
        canViewSalesAnalytics: true,
        canViewCustomerBase: true,
        canViewCustomerGeography: true,
        canManageProducts: true,
        canManagePrices: true,
        canManageInventory: true,
        canViewStoreReports: true,
        canReplenishStoreBalance: true,
        canBuyStorePushNotifications: true,
        canUploadStoreCSV: true,
        canManageBrandProfile: true,
        canManageBrandAssortment: true,
        canCategorizeProducts: true,
        canBrandPromotions: true,
        canCreateBrandCampaigns: true,
        canManagePartnerStores: true,
        canConfigurePromotionTerms: true,
        canCreateBrandPromoCodes: true,
        canNegotiateWithStores: true,
        canManageDistribution: true,
        canConfigurePartnershipAgreements: true,
        canAnalyzePartners: true,
        canRunCPCAds: true,
        canRunTargetedAds: true,
        canAnalyzeCompetitors: true,
        canViewMarketingReports: true,
        canReplenishBrandBalance: true,
        canBuyBrandPushNotifications: true,
        canUploadBrandCSV: true,
        canViewBrandMetrics: true,
        canViewBrandEffectiveness: true,
        canViewBrandGeography: true,
        canViewBrandSegmentation: true,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.ADMIN]: {
        canManageRoles: true,
        canManageUsers: true,
        canManageSystemSettings: true,
        canManageTariffs: true,
        canManageCommissions: true,
        canManageSecurity: true,
        canViewAuditLogs: true,
        canManageIntegrations: true,
        canViewSystemMonitoring: true,
        canManageBackups: true,
        canManageDeployments: true,
        canViewFinancialAnalytics: true,
        canManagePartnerBalances: true,
        canIssueInvoices: true,
        canViewFinancialReports: true,
        canViewTopPartners: true,
        canViewRevenueForecasts: true,
        canModerateContent: true,
        canManageCategories: true,
        canSendSystemNotifications: true,
        canManagePromoCodes: true,
        canManageNetworks: true,
        canManageStores: true,
        canAssignStoreManagers: true,
        canManageStorePermissions: true,
        canConfigureGeofencing: true,
        canManageStoreHours: true,
        canManageNetworkBalance: true,
        canViewNetworkAnalytics: true,
        canManageNetworkSubscription: true,
        canViewNetworkReports: true,
        canReplenishNetworkBalance: true,
        canCreateNetworkCampaigns: true,
        canManagePushNotifications: true,
        canBuyPushNotifications: true,
        canRunABTests: true,
        canPersonalizeOffers: true,
        canCompareStores: true,
        canViewGeographicAnalytics: true,
        canViewNetworkForecasts: true,
        canBulkUploadProducts: true,
        canManageStoreInfo: true,
        canConfigureStoreGeofencing: true,
        canManageStorePersonnel: true,
        canIntegratePOS: true,
        canCreateLocalLoyaltyCards: true,
        canManageDiscounts: true,
        canLimitActivationTiers: true,
        canCreateTemporaryPromotions: true,
        canViewStoreAnalytics: true,
        canViewSalesAnalytics: true,
        canViewCustomerBase: true,
        canViewCustomerGeography: true,
        canManageProducts: true,
        canManagePrices: true,
        canManageInventory: true,
        canViewStoreReports: true,
        canReplenishStoreBalance: true,
        canBuyStorePushNotifications: true,
        canUploadStoreCSV: true,
        canManageBrandProfile: true,
        canManageBrandAssortment: true,
        canCategorizeProducts: true,
        canBrandPromotions: true,
        canCreateBrandCampaigns: true,
        canManagePartnerStores: true,
        canConfigurePromotionTerms: true,
        canCreateBrandPromoCodes: true,
        canNegotiateWithStores: true,
        canManageDistribution: true,
        canConfigurePartnershipAgreements: true,
        canAnalyzePartners: true,
        canRunCPCAds: true,
        canRunTargetedAds: true,
        canAnalyzeCompetitors: true,
        canViewMarketingReports: true,
        canReplenishBrandBalance: true,
        canBuyBrandPushNotifications: true,
        canUploadBrandCSV: true,
        canViewBrandMetrics: true,
        canViewBrandEffectiveness: true,
        canViewBrandGeography: true,
        canViewBrandSegmentation: true,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.DEVOPS]: {
        canManageRoles: false,
        canManageUsers: false,
        canManageSystemSettings: true,
        canManageTariffs: false,
        canManageCommissions: false,
        canManageSecurity: true,
        canViewAuditLogs: true,
        canManageIntegrations: true,
        canViewSystemMonitoring: true,
        canManageBackups: true,
        canManageDeployments: true,
        canViewFinancialAnalytics: false,
        canManagePartnerBalances: false,
        canIssueInvoices: false,
        canViewFinancialReports: false,
        canViewTopPartners: false,
        canViewRevenueForecasts: false,
        canModerateContent: false,
        canManageCategories: false,
        canSendSystemNotifications: true,
        canManagePromoCodes: false,
        canManageNetworks: false,
        canManageStores: false,
        canAssignStoreManagers: false,
        canManageStorePermissions: false,
        canConfigureGeofencing: false,
        canManageStoreHours: false,
        canManageNetworkBalance: false,
        canViewNetworkAnalytics: false,
        canManageNetworkSubscription: false,
        canViewNetworkReports: false,
        canReplenishNetworkBalance: false,
        canCreateNetworkCampaigns: false,
        canManagePushNotifications: true,
        canBuyPushNotifications: false,
        canRunABTests: false,
        canPersonalizeOffers: false,
        canCompareStores: false,
        canViewGeographicAnalytics: false,
        canViewNetworkForecasts: false,
        canBulkUploadProducts: false,
        canManageStoreInfo: false,
        canConfigureStoreGeofencing: false,
        canManageStorePersonnel: false,
        canIntegratePOS: false,
        canCreateLocalLoyaltyCards: false,
        canManageDiscounts: false,
        canLimitActivationTiers: false,
        canCreateTemporaryPromotions: false,
        canViewStoreAnalytics: false,
        canViewSalesAnalytics: false,
        canViewCustomerBase: false,
        canViewCustomerGeography: false,
        canManageProducts: false,
        canManagePrices: false,
        canManageInventory: false,
        canViewStoreReports: false,
        canReplenishStoreBalance: false,
        canBuyStorePushNotifications: false,
        canUploadStoreCSV: false,
        canManageBrandProfile: false,
        canManageBrandAssortment: false,
        canCategorizeProducts: false,
        canBrandPromotions: false,
        canCreateBrandCampaigns: false,
        canManagePartnerStores: false,
        canConfigurePromotionTerms: false,
        canCreateBrandPromoCodes: false,
        canNegotiateWithStores: false,
        canManageDistribution: false,
        canConfigurePartnershipAgreements: false,
        canAnalyzePartners: false,
        canRunCPCAds: false,
        canRunTargetedAds: false,
        canAnalyzeCompetitors: false,
        canViewMarketingReports: false,
        canReplenishBrandBalance: false,
        canBuyBrandPushNotifications: false,
        canUploadBrandCSV: false,
        canViewBrandMetrics: false,
        canViewBrandEffectiveness: false,
        canViewBrandGeography: false,
        canViewBrandSegmentation: false,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.NETWORK_MANAGER]: {
        canManageRoles: false,
        canManageUsers: false,
        canManageSystemSettings: false,
        canManageTariffs: false,
        canManageCommissions: false,
        canManageSecurity: false,
        canViewAuditLogs: false,
        canManageIntegrations: false,
        canViewSystemMonitoring: false,
        canManageBackups: false,
        canManageDeployments: false,
        canViewFinancialAnalytics: false,
        canManagePartnerBalances: false,
        canIssueInvoices: false,
        canViewFinancialReports: false,
        canViewTopPartners: false,
        canViewRevenueForecasts: false,
        canModerateContent: false,
        canManageCategories: false,
        canSendSystemNotifications: false,
        canManagePromoCodes: false,
        canManageNetworks: true,
        canManageStores: true,
        canAssignStoreManagers: true,
        canManageStorePermissions: true,
        canConfigureGeofencing: true,
        canManageStoreHours: true,
        canManageNetworkBalance: true,
        canViewNetworkAnalytics: true,
        canManageNetworkSubscription: true,
        canViewNetworkReports: true,
        canReplenishNetworkBalance: true,
        canCreateNetworkCampaigns: true,
        canManagePushNotifications: true,
        canBuyPushNotifications: true,
        canRunABTests: true,
        canPersonalizeOffers: true,
        canCompareStores: true,
        canViewGeographicAnalytics: true,
        canViewNetworkForecasts: true,
        canBulkUploadProducts: true,
        canManageStoreInfo: true,
        canConfigureStoreGeofencing: true,
        canManageStorePersonnel: true,
        canIntegratePOS: true,
        canCreateLocalLoyaltyCards: true,
        canManageDiscounts: true,
        canLimitActivationTiers: true,
        canCreateTemporaryPromotions: true,
        canViewStoreAnalytics: true,
        canViewSalesAnalytics: true,
        canViewCustomerBase: true,
        canViewCustomerGeography: true,
        canManageProducts: true,
        canManagePrices: true,
        canManageInventory: true,
        canViewStoreReports: true,
        canReplenishStoreBalance: true,
        canBuyStorePushNotifications: true,
        canUploadStoreCSV: true,
        canManageBrandProfile: false,
        canManageBrandAssortment: false,
        canCategorizeProducts: false,
        canBrandPromotions: false,
        canCreateBrandCampaigns: false,
        canManagePartnerStores: false,
        canConfigurePromotionTerms: false,
        canCreateBrandPromoCodes: false,
        canNegotiateWithStores: false,
        canManageDistribution: false,
        canConfigurePartnershipAgreements: false,
        canAnalyzePartners: false,
        canRunCPCAds: false,
        canRunTargetedAds: false,
        canAnalyzeCompetitors: false,
        canViewMarketingReports: false,
        canReplenishBrandBalance: false,
        canBuyBrandPushNotifications: false,
        canUploadBrandCSV: false,
        canViewBrandMetrics: false,
        canViewBrandEffectiveness: false,
        canViewBrandGeography: false,
        canViewBrandSegmentation: false,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.STORE_MANAGER]: {
        canManageRoles: false,
        canManageUsers: false,
        canManageSystemSettings: false,
        canManageTariffs: false,
        canManageCommissions: false,
        canManageSecurity: false,
        canViewAuditLogs: false,
        canManageIntegrations: false,
        canViewSystemMonitoring: false,
        canManageBackups: false,
        canManageDeployments: false,
        canViewFinancialAnalytics: false,
        canManagePartnerBalances: false,
        canIssueInvoices: false,
        canViewFinancialReports: false,
        canViewTopPartners: false,
        canViewRevenueForecasts: false,
        canModerateContent: false,
        canManageCategories: false,
        canSendSystemNotifications: false,
        canManagePromoCodes: false,
        canManageNetworks: false,
        canManageStores: false,
        canAssignStoreManagers: false,
        canManageStorePermissions: false,
        canConfigureGeofencing: false,
        canManageStoreHours: false,
        canManageNetworkBalance: false,
        canViewNetworkAnalytics: false,
        canManageNetworkSubscription: false,
        canViewNetworkReports: false,
        canReplenishNetworkBalance: false,
        canCreateNetworkCampaigns: false,
        canManagePushNotifications: false,
        canBuyPushNotifications: false,
        canRunABTests: false,
        canPersonalizeOffers: false,
        canCompareStores: false,
        canViewGeographicAnalytics: false,
        canViewNetworkForecasts: false,
        canBulkUploadProducts: false,
        canManageStoreInfo: true,
        canConfigureStoreGeofencing: true,
        canManageStorePersonnel: true,
        canIntegratePOS: true,
        canCreateLocalLoyaltyCards: true,
        canManageDiscounts: true,
        canLimitActivationTiers: true,
        canCreateTemporaryPromotions: true,
        canViewStoreAnalytics: true,
        canViewSalesAnalytics: true,
        canViewCustomerBase: true,
        canViewCustomerGeography: true,
        canManageProducts: true,
        canManagePrices: true,
        canManageInventory: true,
        canViewStoreReports: true,
        canReplenishStoreBalance: true,
        canBuyStorePushNotifications: true,
        canUploadStoreCSV: true,
        canManageBrandProfile: false,
        canManageBrandAssortment: false,
        canCategorizeProducts: false,
        canBrandPromotions: false,
        canCreateBrandCampaigns: false,
        canManagePartnerStores: false,
        canConfigurePromotionTerms: false,
        canCreateBrandPromoCodes: false,
        canNegotiateWithStores: false,
        canManageDistribution: false,
        canConfigurePartnershipAgreements: false,
        canAnalyzePartners: false,
        canRunCPCAds: false,
        canRunTargetedAds: false,
        canAnalyzeCompetitors: false,
        canViewMarketingReports: false,
        canReplenishBrandBalance: false,
        canBuyBrandPushNotifications: false,
        canUploadBrandCSV: false,
        canViewBrandMetrics: false,
        canViewBrandEffectiveness: false,
        canViewBrandGeography: false,
        canViewBrandSegmentation: false,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.BRAND_MANAGER]: {
        canManageRoles: false,
        canManageUsers: false,
        canManageSystemSettings: false,
        canManageTariffs: false,
        canManageCommissions: false,
        canManageSecurity: false,
        canViewAuditLogs: false,
        canManageIntegrations: false,
        canViewSystemMonitoring: false,
        canManageBackups: false,
        canManageDeployments: false,
        canViewFinancialAnalytics: false,
        canManagePartnerBalances: false,
        canIssueInvoices: false,
        canViewFinancialReports: false,
        canViewTopPartners: false,
        canViewRevenueForecasts: false,
        canModerateContent: false,
        canManageCategories: false,
        canSendSystemNotifications: false,
        canManagePromoCodes: false,
        canManageNetworks: false,
        canManageStores: false,
        canAssignStoreManagers: false,
        canManageStorePermissions: false,
        canConfigureGeofencing: false,
        canManageStoreHours: false,
        canManageNetworkBalance: false,
        canViewNetworkAnalytics: false,
        canManageNetworkSubscription: false,
        canViewNetworkReports: false,
        canReplenishNetworkBalance: false,
        canCreateNetworkCampaigns: false,
        canManagePushNotifications: false,
        canBuyPushNotifications: false,
        canRunABTests: false,
        canPersonalizeOffers: false,
        canCompareStores: false,
        canViewGeographicAnalytics: false,
        canViewNetworkForecasts: false,
        canBulkUploadProducts: false,
        canManageStoreInfo: false,
        canConfigureStoreGeofencing: false,
        canManageStorePersonnel: false,
        canIntegratePOS: false,
        canCreateLocalLoyaltyCards: false,
        canManageDiscounts: false,
        canLimitActivationTiers: false,
        canCreateTemporaryPromotions: false,
        canViewStoreAnalytics: false,
        canViewSalesAnalytics: false,
        canViewCustomerBase: false,
        canViewCustomerGeography: false,
        canManageProducts: false,
        canManagePrices: false,
        canManageInventory: false,
        canViewStoreReports: false,
        canReplenishStoreBalance: false,
        canBuyStorePushNotifications: false,
        canUploadStoreCSV: false,
        canManageBrandProfile: true,
        canManageBrandAssortment: true,
        canCategorizeProducts: true,
        canBrandPromotions: true,
        canCreateBrandCampaigns: true,
        canManagePartnerStores: true,
        canConfigurePromotionTerms: true,
        canCreateBrandPromoCodes: true,
        canNegotiateWithStores: true,
        canManageDistribution: true,
        canConfigurePartnershipAgreements: true,
        canAnalyzePartners: true,
        canRunCPCAds: true,
        canRunTargetedAds: true,
        canAnalyzeCompetitors: true,
        canViewMarketingReports: true,
        canReplenishBrandBalance: true,
        canBuyBrandPushNotifications: true,
        canUploadBrandCSV: true,
        canViewBrandMetrics: true,
        canViewBrandEffectiveness: true,
        canViewBrandGeography: true,
        canViewBrandSegmentation: true,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
    [UserRole.USER]: {
        canManageRoles: false,
        canManageUsers: false,
        canManageSystemSettings: false,
        canManageTariffs: false,
        canManageCommissions: false,
        canManageSecurity: false,
        canViewAuditLogs: false,
        canManageIntegrations: false,
        canViewSystemMonitoring: false,
        canManageBackups: false,
        canManageDeployments: false,
        canViewFinancialAnalytics: false,
        canManagePartnerBalances: false,
        canIssueInvoices: false,
        canViewFinancialReports: false,
        canViewTopPartners: false,
        canViewRevenueForecasts: false,
        canModerateContent: false,
        canManageCategories: false,
        canSendSystemNotifications: false,
        canManagePromoCodes: false,
        canManageNetworks: false,
        canManageStores: false,
        canAssignStoreManagers: false,
        canManageStorePermissions: false,
        canConfigureGeofencing: false,
        canManageStoreHours: false,
        canManageNetworkBalance: false,
        canViewNetworkAnalytics: false,
        canManageNetworkSubscription: false,
        canViewNetworkReports: false,
        canReplenishNetworkBalance: false,
        canCreateNetworkCampaigns: false,
        canManagePushNotifications: false,
        canBuyPushNotifications: false,
        canRunABTests: false,
        canPersonalizeOffers: false,
        canCompareStores: false,
        canViewGeographicAnalytics: false,
        canViewNetworkForecasts: false,
        canBulkUploadProducts: false,
        canManageStoreInfo: false,
        canConfigureStoreGeofencing: false,
        canManageStorePersonnel: false,
        canIntegratePOS: false,
        canCreateLocalLoyaltyCards: false,
        canManageDiscounts: false,
        canLimitActivationTiers: false,
        canCreateTemporaryPromotions: false,
        canViewStoreAnalytics: false,
        canViewSalesAnalytics: false,
        canViewCustomerBase: false,
        canViewCustomerGeography: false,
        canManageProducts: false,
        canManagePrices: false,
        canManageInventory: false,
        canViewStoreReports: false,
        canReplenishStoreBalance: false,
        canBuyStorePushNotifications: false,
        canUploadStoreCSV: false,
        canManageBrandProfile: false,
        canManageBrandAssortment: false,
        canCategorizeProducts: false,
        canBrandPromotions: false,
        canCreateBrandCampaigns: false,
        canManagePartnerStores: false,
        canConfigurePromotionTerms: false,
        canCreateBrandPromoCodes: false,
        canNegotiateWithStores: false,
        canManageDistribution: false,
        canConfigurePartnershipAgreements: false,
        canAnalyzePartners: false,
        canRunCPCAds: false,
        canRunTargetedAds: false,
        canAnalyzeCompetitors: false,
        canViewMarketingReports: false,
        canReplenishBrandBalance: false,
        canBuyBrandPushNotifications: false,
        canUploadBrandCSV: false,
        canViewBrandMetrics: false,
        canViewBrandEffectiveness: false,
        canViewBrandGeography: false,
        canViewBrandSegmentation: false,
        canEditProfile: true,
        canManageNotifications: true,
        canManagePrivacy: true,
        canViewPurchaseHistory: true,
        canViewAvailableCards: true,
        canActivateLoyaltyCards: true,
        canSaveFavoriteCards: true,
        canViewActivationHistory: true,
        canManageFavorites: true,
        canSearchNearbyStores: true,
        canUseGeofencing: true,
        canViewStoreDistance: true,
        canViewStoreHours: true,
        canViewPersonalRecommendations: true,
        canManagePreferences: true,
        canViewPersonalDiscounts: true,
        canViewPromotionsCalendar: true,
    },
};
function hasPermission(userRole, permission) {
    return ROLE_PERMISSIONS[userRole][permission];
}
function getRoleHierarchy(userRole) {
    const hierarchy = {
        [UserRole.SUPER_ADMIN]: [
            UserRole.SUPER_ADMIN,
            UserRole.ADMIN,
            UserRole.DEVOPS,
            UserRole.NETWORK_MANAGER,
            UserRole.STORE_MANAGER,
            UserRole.BRAND_MANAGER,
            UserRole.USER,
        ],
        [UserRole.ADMIN]: [
            UserRole.ADMIN,
            UserRole.DEVOPS,
            UserRole.NETWORK_MANAGER,
            UserRole.STORE_MANAGER,
            UserRole.BRAND_MANAGER,
            UserRole.USER,
        ],
        [UserRole.DEVOPS]: [UserRole.DEVOPS, UserRole.USER],
        [UserRole.NETWORK_MANAGER]: [
            UserRole.NETWORK_MANAGER,
            UserRole.STORE_MANAGER,
            UserRole.USER,
        ],
        [UserRole.STORE_MANAGER]: [UserRole.STORE_MANAGER, UserRole.USER],
        [UserRole.BRAND_MANAGER]: [UserRole.BRAND_MANAGER, UserRole.USER],
        [UserRole.USER]: [UserRole.USER],
    };
    return hierarchy[userRole];
}
function canAccessRole(userRole, targetRole) {
    return getRoleHierarchy(userRole).includes(targetRole);
}


/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthRepository: () => (/* binding */ AuthRepository)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;


let AuthRepository = class AuthRepository {
    constructor(supabaseService) {
        this.supabaseService = supabaseService;
    }
    async createSimpleUser(data) {
        const { data: result, error } = (await this.supabaseService.client.rpc('create_simple_user', data));
        if (error != null) {
            throw new Error(`Failed to create user: ${error}`);
        }
        return result;
    }
    async findUserById(id) {
        const { data: user, error } = (await this.supabaseService.client
            .from('users')
            .select('*')
            .eq('id', id)
            .single());
        if (error != null) {
            throw new Error(`Failed to get user: ${error}`);
        }
        return user;
    }
    async findUserWithProfiles(userId) {
        const { data: user, error } = (await this.supabaseService.client
            .from('users')
            .select(`
        *,
        user_profiles (*)
      `)
            .eq('id', userId)
            .single());
        if (error != null) {
            throw new Error(`Failed to get user with profiles: ${error}`);
        }
        return user;
    }
};
AuthRepository = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_1__.SupabaseService !== "undefined" && _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_1__.SupabaseService) === "function" ? _a : Object])
], AuthRepository);



/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertDateString: () => (/* binding */ convertDateString),
/* harmony export */   convertNullableString: () => (/* binding */ convertNullableString),
/* harmony export */   convertUserRole: () => (/* binding */ convertUserRole),
/* harmony export */   isUserRole: () => (/* binding */ isUserRole),
/* harmony export */   isValidDate: () => (/* binding */ isValidDate)
/* harmony export */ });
function isUserRole(role) {
    return (role === 'admin' ||
        role === 'user' ||
        role === 'super_admin' ||
        role === 'network_manager');
}
function isValidDate(dateString) {
    const date = new Date(dateString);
    return !isNaN(date.getTime());
}
function convertNullableString(value) {
    return value ?? '';
}
function convertDateString(dateString) {
    if (!isValidDate(dateString)) {
        throw new Error(`Invalid date string: ${dateString}`);
    }
    return new Date(dateString);
}
function convertUserRole(role) {
    if (!isUserRole(role)) {
        throw new Error(`Invalid user role: ${role}`);
    }
    return role;
}


/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoginDto: () => (/* binding */ LoginDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


class LoginDto {
}
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiProperty)({
        example: 'user@example.com',
        description: 'Email пользователя',
    }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsEmail)(),
    __metadata("design:type", String)
], LoginDto.prototype, "email", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiProperty)({ example: 'password123', description: 'Пароль пользователя' }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.MinLength)(6),
    __metadata("design:type", String)
], LoginDto.prototype, "password", void 0);


/***/ }),
/* 37 */
/***/ ((module) => {

module.exports = require("class-validator");

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegisterDto: () => (/* binding */ RegisterDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;



class RegisterDto {
}
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({ description: 'Email пользователя' }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsEmail)(),
    __metadata("design:type", String)
], RegisterDto.prototype, "email", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({ description: 'Пароль пользователя', minLength: 6 }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsString)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.MinLength)(6),
    __metadata("design:type", String)
], RegisterDto.prototype, "password", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({
        description: 'Роль пользователя',
        enum: _types_roles__WEBPACK_IMPORTED_MODULE_2__.UserRole,
        default: _types_roles__WEBPACK_IMPORTED_MODULE_2__.UserRole.USER,
    }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsEnum)(_types_roles__WEBPACK_IMPORTED_MODULE_2__.UserRole),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof _types_roles__WEBPACK_IMPORTED_MODULE_2__.UserRole !== "undefined" && _types_roles__WEBPACK_IMPORTED_MODULE_2__.UserRole) === "function" ? _a : Object)
], RegisterDto.prototype, "role", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({ description: 'Имя пользователя', required: false }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsString)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsOptional)(),
    __metadata("design:type", String)
], RegisterDto.prototype, "firstName", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({ description: 'Фамилия пользователя', required: false }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsString)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsOptional)(),
    __metadata("design:type", String)
], RegisterDto.prototype, "lastName", void 0);
__decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.ApiProperty)({ description: 'Телефон пользователя', required: false }),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsString)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_1__.IsOptional)(),
    __metadata("design:type", String)
], RegisterDto.prototype, "phone", void 0);


/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JwtAuthGuard: () => (/* binding */ JwtAuthGuard)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;


let JwtAuthGuard = class JwtAuthGuard {
    constructor(jwtService) {
        this.jwtService = jwtService;
    }
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        const token = this.extractTokenFromHeader(request);
        if (token == null || token === '') {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Token not found');
        }
        try {
            const payload = this.jwtService.verify(token);
            request.user = payload;
            return true;
        }
        catch {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedException('Invalid token');
        }
    }
    extractTokenFromHeader(request) {
        const [type, token] = request.headers.authorization?.split(' ') ?? ['', ''];
        return type === 'Bearer' && token != null && token !== ''
            ? token
            : undefined;
    }
};
JwtAuthGuard = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__.JwtService !== "undefined" && _nestjs_jwt__WEBPACK_IMPORTED_MODULE_1__.JwtService) === "function" ? _a : Object])
], JwtAuthGuard);



/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RolesGuard: () => (/* binding */ RolesGuard)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_core__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;


let RolesGuard = class RolesGuard {
    constructor(reflector) {
        this.reflector = reflector;
    }
    canActivate(context) {
        const requiredRoles = this.reflector.getAllAndOverride('roles', [context.getHandler(), context.getClass()]);
        if (requiredRoles == null || requiredRoles.length === 0) {
            return true;
        }
        const request = context.switchToHttp().getRequest();
        const user = request.user;
        if (!user) {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException('User not found in request');
        }
        const hasRole = requiredRoles.some(role => user.role === role);
        if (!hasRole) {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException(`User role ${user.role} is not authorized. Required roles: ${requiredRoles.join(', ')}`);
        }
        return true;
    }
};
RolesGuard = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_core__WEBPACK_IMPORTED_MODULE_1__.Reflector !== "undefined" && _nestjs_core__WEBPACK_IMPORTED_MODULE_1__.Reflector) === "function" ? _a : Object])
], RolesGuard);



/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoleMappingGuard: () => (/* binding */ RoleMappingGuard)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var RoleMappingGuard_1;
var _a, _b;



let RoleMappingGuard = RoleMappingGuard_1 = class RoleMappingGuard {
    constructor(reflector, roleMappingService) {
        this.reflector = reflector;
        this.roleMappingService = roleMappingService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(RoleMappingGuard_1.name);
    }
    canActivate(context) {
        const roles = this.reflector.get('roles', context.getHandler());
        const resource = this.reflector.get('resource', context.getHandler());
        const operation = this.reflector.get('operation', context.getHandler());
        const crud = this.reflector.get('crud', context.getHandler());
        if (roles === undefined &&
            resource === undefined &&
            operation === undefined &&
            crud === undefined) {
            return true;
        }
        const request = context.switchToHttp().getRequest();
        const user = request.user;
        if (user?.id === undefined || user.id === '') {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException('Пользователь не аутентифицирован');
        }
        const userRole = user.role;
        if (roles !== undefined && roles.length > 0) {
            if (!roles.includes(userRole)) {
                this.logger.warn(`Доступ запрещен: роль ${userRole} не имеет доступа к эндпоинту`);
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException(`Доступ запрещен для роли ${userRole}`);
            }
        }
        if (resource !== undefined && operation !== undefined) {
            const permission = `${resource}_${operation}`;
            if (!this.hasPermission(userRole, { _resource: resource, operation })) {
                this.logger.warn(`Доступ запрещен: роль ${userRole} не имеет разрешения ${permission}`);
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException(`Недостаточно прав для ${operation} на ресурсе ${resource}`);
            }
        }
        if (crud !== undefined && resource !== undefined) {
            const crudPermission = `${resource}_${crud}`;
            if (!this.hasPermission(userRole, { _resource: resource, operation: crud })) {
                this.logger.warn(`Доступ запрещен: роль ${userRole} не имеет CRUD разрешения ${crudPermission}`);
                throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ForbiddenException(`Недостаточно прав для ${crud} на ресурсе ${resource}`);
            }
        }
        this.logger.log(`Доступ разрешен для роли ${userRole} к ресурсу ${resource ?? 'N/A'}`);
        return true;
    }
    hasPermission(userRole, permission) {
        if (permission.roles && permission.roles.length > 0) {
            if (!permission.roles.includes(userRole)) {
                return false;
            }
        }
        const requiredPermission = `${permission._resource}_${permission.operation}`;
        return (this.roleMappingService.hasPermission(userRole, requiredPermission) ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
    canAccessResource(userRole, _resource) {
        return (this.roleMappingService.hasPermission(userRole, `${_resource}_read`) ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
    canPerformOperation(userRole, _resource, operation) {
        const permission = `${_resource}_${operation}`;
        return (this.roleMappingService.hasPermission(userRole, permission) ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
    canCreate(userRole, _resource) {
        return this.canPerformOperation(userRole, _resource, 'create');
    }
    canRead(userRole, _resource) {
        return this.canPerformOperation(userRole, _resource, 'read');
    }
    canUpdate(userRole, _resource) {
        return this.canPerformOperation(userRole, _resource, 'update');
    }
    canDelete(userRole, _resource) {
        return this.canPerformOperation(userRole, _resource, 'delete');
    }
    canManageUsers(userRole) {
        return (this.roleMappingService.hasPermission(userRole, 'user_management') ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
    canViewAnalytics(userRole) {
        return (this.roleMappingService.hasPermission(userRole, 'analytics') ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
    canManageBilling(userRole) {
        return (this.roleMappingService.hasPermission(userRole, 'billing_management') ||
            this.roleMappingService.hasPermission(userRole, '*'));
    }
};
RoleMappingGuard = RoleMappingGuard_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_core__WEBPACK_IMPORTED_MODULE_1__.Reflector !== "undefined" && _nestjs_core__WEBPACK_IMPORTED_MODULE_1__.Reflector) === "function" ? _a : Object, typeof (_b = typeof _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_2__.RoleMappingService !== "undefined" && _services_role_mapping_service__WEBPACK_IMPORTED_MODULE_2__.RoleMappingService) === "function" ? _b : Object])
], RoleMappingGuard);



/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoleMappingService: () => (/* binding */ RoleMappingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let RoleMappingService = class RoleMappingService {
    constructor() {
        this.roleMappings = [
            {
                systemRole: 'admin_role',
                internalRole: _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.SUPER_ADMIN,
                permissions: ['*'],
                description: 'Полный доступ ко всем функциям системы',
            },
            {
                systemRole: 'manager_role',
                internalRole: _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.NETWORK_MANAGER,
                permissions: [
                    'network_management',
                    'store_management',
                    'brand_management',
                    'analytics',
                ],
                description: 'Управление сетями, магазинами и брендами',
            },
            {
                systemRole: 'retailer_role',
                internalRole: _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.STORE_MANAGER,
                permissions: ['store_management', 'loyalty_cards', 'analytics'],
                description: 'Управление магазинами и картами лояльности',
            },
            {
                systemRole: 'brand_role',
                internalRole: _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.BRAND_MANAGER,
                permissions: ['brand_management', 'marketing_campaigns', 'analytics'],
                description: 'Управление брендами и маркетинговыми кампаниями',
            },
            {
                systemRole: 'user_role',
                internalRole: _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER,
                permissions: ['view_cards', 'use_loyalty', 'personal_data'],
                description: 'Базовый пользователь с доступом к картам лояльности',
            },
        ];
    }
    getInternalRole(systemRole) {
        const mapping = this.roleMappings.find(m => m.systemRole === systemRole);
        return mapping ? mapping.internalRole : null;
    }
    getSystemRole(internalRole) {
        const mapping = this.roleMappings.find(m => m.internalRole === internalRole);
        return mapping ? mapping.systemRole : null;
    }
    getPermissions(role) {
        const mapping = this.roleMappings.find(m => m.systemRole === role || m.internalRole === role);
        return mapping ? mapping.permissions : [];
    }
    hasPermission(role, permission) {
        const permissions = this.getPermissions(role);
        return permissions.includes('*') || permissions.includes(permission);
    }
    getAllMappings() {
        return [...this.roleMappings];
    }
    getRoleDescription(role) {
        const mapping = this.roleMappings.find(m => m.systemRole === role || m.internalRole === role);
        return mapping?.description ?? 'Роль не найдена';
    }
    isValidSystemRole(systemRole) {
        return this.roleMappings.some(m => m.systemRole === systemRole);
    }
    isValidInternalRole(internalRole) {
        return this.roleMappings.some(m => m.internalRole === internalRole);
    }
    getRoleHierarchy() {
        return {
            [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.SUPER_ADMIN]: [
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.NETWORK_MANAGER,
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.STORE_MANAGER,
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.BRAND_MANAGER,
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER,
            ],
            [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.NETWORK_MANAGER]: [
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.STORE_MANAGER,
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.BRAND_MANAGER,
                _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER,
            ],
            [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.STORE_MANAGER]: [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER],
            [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.BRAND_MANAGER]: [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER],
            [_types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.USER]: [],
        };
    }
    canManageRole(managerRole, targetRole) {
        if (managerRole === _types_roles__WEBPACK_IMPORTED_MODULE_1__.UserRole.SUPER_ADMIN)
            return true;
        const hierarchy = this.getRoleHierarchy();
        const manageableRoles = hierarchy[managerRole] ?? [];
        return manageableRoles.includes(targetRole);
    }
};
RoleMappingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], RoleMappingService);



/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIRoleAnalyzerService: () => (/* binding */ AIRoleAnalyzerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _role_mapping_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;


let AIRoleAnalyzerService = class AIRoleAnalyzerService {
    constructor(roleMappingService) {
        this.roleMappingService = roleMappingService;
    }
    analyzeRoleConflicts() {
        const conflicts = [];
        const mappings = this.roleMappingService.getAllMappings();
        for (let i = 0; i < mappings.length; i++) {
            for (let j = i + 1; j < mappings.length; j++) {
                const role1 = mappings[i];
                const role2 = mappings[j];
                if (role1 == null || role2 == null) {
                    continue;
                }
                const overlappingPermissions = this.findOverlappingPermissions(role1.permissions, role2.permissions);
                if (overlappingPermissions.length > 0) {
                    const conflict = this.assessConflict(role1, role2, overlappingPermissions);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
        return conflicts;
    }
    findOverlappingPermissions(permissions1, permissions2) {
        if (permissions1.includes('*') || permissions2.includes('*')) {
            return ['*'];
        }
        return permissions1.filter(permission => permissions2.includes(permission));
    }
    assessConflict(role1, role2, overlappingPermissions) {
        const severity = this.calculateConflictSeverity(role1, role2, overlappingPermissions);
        if (severity === 'LOW') {
            return null;
        }
        return {
            role1: role1.systemRole,
            role2: role2.systemRole,
            conflictingPermissions: overlappingPermissions,
            severity,
            description: this.generateConflictDescription(role1, role2, overlappingPermissions),
            recommendation: this.generateConflictRecommendation(role1, role2, overlappingPermissions, severity),
        };
    }
    calculateConflictSeverity(_role1, _role2, overlappingPermissions) {
        const criticalPermissions = [
            '*',
            'admin_access',
            'user_management',
            'billing_management',
        ];
        const highPermissions = [
            'network_management',
            'store_management',
            'brand_management',
        ];
        const mediumPermissions = ['analytics', 'marketing_campaigns'];
        const hasCriticalOverlap = overlappingPermissions.some(p => criticalPermissions.includes(p));
        const hasHighOverlap = overlappingPermissions.some(p => highPermissions.includes(p));
        const hasMediumOverlap = overlappingPermissions.some(p => mediumPermissions.includes(p));
        if (hasCriticalOverlap)
            return 'CRITICAL';
        if (hasHighOverlap)
            return 'HIGH';
        if (hasMediumOverlap)
            return 'MEDIUM';
        return 'LOW';
    }
    generateConflictDescription(role1, role2, overlappingPermissions) {
        return `Роли "${role1.systemRole}" и "${role2.systemRole}" имеют пересекающиеся разрешения: ${overlappingPermissions.join(', ')}. Это может привести к нарушению принципа наименьших привилегий.`;
    }
    generateConflictRecommendation(role1, role2, overlappingPermissions, severity) {
        switch (severity) {
            case 'CRITICAL':
                return `Немедленно пересмотрите роли "${role1.systemRole}" и "${role2.systemRole}". Критические разрешения должны быть уникальными для каждой роли.`;
            case 'HIGH':
                return `Рекомендуется разделить разрешения "${overlappingPermissions.join(', ')}" между ролями "${role1.systemRole}" и "${role2.systemRole}" для повышения безопасности.`;
            case 'MEDIUM':
                return `Рассмотрите возможность уточнения разрешений для ролей "${role1.systemRole}" и "${role2.systemRole}" для лучшего разделения ответственности.`;
            default:
                return `Мониторьте использование пересекающихся разрешений между ролями "${role1.systemRole}" и "${role2.systemRole}".`;
        }
    }
    analyzeRLSPolicies(tableName, currentPolicies) {
        const analysis = {
            tableName,
            currentPolicies,
            suggestedPolicies: [],
            conflicts: [],
            recommendations: [],
            securityScore: 0,
        };
        const securityIssues = this.identifySecurityIssues(currentPolicies);
        analysis.conflicts = securityIssues;
        analysis.suggestedPolicies = this.generateImprovedPolicies(tableName);
        analysis.recommendations = this.generateRecommendations(tableName, securityIssues);
        analysis.securityScore = this.calculateSecurityScore(currentPolicies, securityIssues);
        return analysis;
    }
    identifySecurityIssues(policies) {
        const issues = [];
        if (policies.length === 0) {
            issues.push('Отсутствуют RLS политики - таблица полностью открыта');
        }
        const wideOpenPolicies = policies.filter(p => p.includes('true') || p.includes('1=1') || p.includes('*'));
        if (wideOpenPolicies.length > 0) {
            issues.push('Обнаружены слишком широкие RLS политики');
        }
        const roleBasedPolicies = policies.filter(p => p.includes('auth.role()') || p.includes('current_user_role'));
        if (roleBasedPolicies.length === 0) {
            issues.push('Отсутствуют проверки ролей в RLS политиках');
        }
        return issues;
    }
    generateImprovedPolicies(tableName) {
        const improvedPolicies = [];
        improvedPolicies.push(`-- Базовая политика безопасности для ${tableName}`, `CREATE POLICY "secure_${tableName}_access" ON ${tableName}`, `FOR ALL USING (auth.role() IS NOT NULL);`);
        const rolePolicies = [
            {
                role: 'super_admin',
                policy: `(auth.role() = 'super_admin')`,
            },
            {
                role: 'network_manager',
                policy: `(auth.role() = 'network_manager' AND network_id IN (SELECT network_id FROM user_networks WHERE user_id = auth.uid()))`,
            },
            {
                role: 'store_manager',
                policy: `(auth.role() = 'store_manager' AND store_id IN (SELECT store_id FROM user_stores WHERE user_id = auth.uid()))`,
            },
            {
                role: 'brand_manager',
                policy: `(auth.role() = 'brand_manager' AND brand_id IN (SELECT brand_id FROM user_brands WHERE user_id = auth.uid()))`,
            },
            {
                role: 'user',
                policy: `(auth.role() = 'user' AND user_id = auth.uid())`,
            },
        ];
        rolePolicies.forEach(({ role, policy }) => {
            improvedPolicies.push(`-- Политика для роли ${role}`, `CREATE POLICY "${role}_${tableName}_access" ON ${tableName}`, `FOR ALL USING (${policy});`);
        });
        return improvedPolicies;
    }
    generateRecommendations(tableName, issues) {
        const recommendations = [];
        if (issues.includes('Отсутствуют RLS политики')) {
            recommendations.push(`Создайте базовые RLS политики для таблицы ${tableName}`);
        }
        if (issues.includes('Обнаружены слишком широкие RLS политики')) {
            recommendations.push(`Ограничьте доступ в RLS политиках таблицы ${tableName} согласно принципу наименьших привилегий`);
        }
        if (issues.includes('Отсутствуют проверки ролей')) {
            recommendations.push(`Добавьте проверки ролей в RLS политики таблицы ${tableName}`);
        }
        recommendations.push(`Регулярно аудируйте RLS политики таблицы ${tableName}`);
        recommendations.push(`Тестируйте RLS политики с различными ролями пользователей`);
        return recommendations;
    }
    calculateSecurityScore(policies, issues) {
        let score = 100;
        if (issues.includes('Отсутствуют RLS политики'))
            score -= 50;
        if (issues.includes('Обнаружены слишком широкие RLS политики'))
            score -= 30;
        if (issues.includes('Отсутствуют проверки ролей'))
            score -= 20;
        if (policies.length > 0)
            score += 10;
        if (policies.some(p => p.includes('auth.role()')))
            score += 15;
        if (policies.some(p => p.includes('user_id = auth.uid()')))
            score += 10;
        return Math.max(0, Math.min(100, score));
    }
    analyzePermissionOverlaps() {
        const overlaps = [];
        const mappings = this.roleMappingService.getAllMappings();
        const allPermissions = new Set();
        mappings.forEach(mapping => {
            mapping.permissions.forEach(permission => {
                if (permission !== '*') {
                    allPermissions.add(permission);
                }
            });
        });
        allPermissions.forEach(permission => {
            const rolesWithPermission = mappings
                .filter(mapping => mapping.permissions.includes(permission))
                .map(mapping => mapping.systemRole);
            if (rolesWithPermission.length > 1) {
                const overlapLevel = this.calculateOverlapLevel(rolesWithPermission.length, mappings.length);
                const riskLevel = this.calculateRiskLevel(permission, rolesWithPermission.length);
                overlaps.push({
                    permission,
                    roles: rolesWithPermission,
                    overlapLevel,
                    riskLevel,
                });
            }
        });
        return overlaps;
    }
    calculateOverlapLevel(rolesCount, totalRoles) {
        const percentage = (rolesCount / totalRoles) * 100;
        if (percentage >= 80)
            return 'HIGH';
        if (percentage >= 50)
            return 'MEDIUM';
        if (percentage >= 20)
            return 'LOW';
        return 'NONE';
    }
    calculateRiskLevel(permission, rolesCount) {
        const criticalPermissions = [
            '*',
            'admin_access',
            'user_management',
            'billing_management',
        ];
        const highPermissions = [
            'network_management',
            'store_management',
            'brand_management',
        ];
        if (criticalPermissions.includes(permission))
            return 'HIGH';
        if (highPermissions.includes(permission))
            return 'HIGH';
        if (rolesCount > 3)
            return 'MEDIUM';
        return 'LOW';
    }
    getSecurityReport() {
        const conflicts = this.analyzeRoleConflicts();
        const overlaps = this.analyzePermissionOverlaps();
        const criticalConflicts = conflicts.filter(c => c.severity === 'CRITICAL').length;
        const highConflicts = conflicts.filter(c => c.severity === 'HIGH').length;
        const mediumConflicts = conflicts.filter(c => c.severity === 'MEDIUM').length;
        const highRiskOverlaps = overlaps.filter(o => o.riskLevel === 'HIGH').length;
        const mediumRiskOverlaps = overlaps.filter(o => o.riskLevel === 'MEDIUM').length;
        const overallScore = Math.max(0, 100 -
            criticalConflicts * 20 -
            highConflicts * 10 -
            mediumConflicts * 5 -
            highRiskOverlaps * 5 -
            mediumRiskOverlaps * 2);
        return {
            overallSecurityScore: overallScore,
            conflicts: {
                total: conflicts.length,
                critical: criticalConflicts,
                high: highConflicts,
                medium: mediumConflicts,
                details: conflicts,
            },
            overlaps: {
                total: overlaps.length,
                highRisk: highRiskOverlaps,
                mediumRisk: mediumRiskOverlaps,
                details: overlaps,
            },
            recommendations: this.generateOverallRecommendations(conflicts, overlaps),
            timestamp: new Date().toISOString(),
        };
    }
    generateOverallRecommendations(conflicts, overlaps) {
        const recommendations = [];
        if (conflicts.filter(c => c.severity === 'CRITICAL').length > 0) {
            recommendations.push('НЕМЕДЛЕННО: Устраните критические конфликты ролей для предотвращения нарушений безопасности');
        }
        if (conflicts.filter(c => c.severity === 'HIGH').length > 0) {
            recommendations.push('ВЫСОКИЙ ПРИОРИТЕТ: Пересмотрите роли с высоким уровнем конфликтов');
        }
        if (overlaps.filter(o => o.riskLevel === 'HIGH').length > 0) {
            recommendations.push('ВЫСОКИЙ ПРИОРИТЕТ: Ограничьте доступ к критическим разрешениям');
        }
        recommendations.push('Регулярно проводите аудит ролей и разрешений');
        recommendations.push('Внедрите автоматизированное тестирование RLS политик');
        recommendations.push('Документируйте все изменения в системе ролей');
        return recommendations;
    }
};
AIRoleAnalyzerService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _role_mapping_service__WEBPACK_IMPORTED_MODULE_1__.RoleMappingService !== "undefined" && _role_mapping_service__WEBPACK_IMPORTED_MODULE_1__.RoleMappingService) === "function" ? _a : Object])
], AIRoleAnalyzerService);



/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIRoleAnalyzerController: () => (/* binding */ AIRoleAnalyzerController),
/* harmony export */   AnalyzeRLSPoliciesDto: () => (/* binding */ AnalyzeRLSPoliciesDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
/* harmony import */ var _guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;







class AnalyzeRLSPoliciesDto {
}
let AIRoleAnalyzerController = class AIRoleAnalyzerController {
    constructor(aiRoleAnalyzerService) {
        this.aiRoleAnalyzerService = aiRoleAnalyzerService;
    }
    async analyzeRoleConflicts() {
        const conflicts = this.aiRoleAnalyzerService.analyzeRoleConflicts();
        return {
            success: true,
            data: {
                conflicts,
                totalConflicts: conflicts.length,
                criticalConflicts: conflicts.filter(c => c.severity === 'CRITICAL')
                    .length,
                highConflicts: conflicts.filter(c => c.severity === 'HIGH').length,
                mediumConflicts: conflicts.filter(c => c.severity === 'MEDIUM').length,
                timestamp: new Date().toISOString(),
            },
        };
    }
    async analyzePermissionOverlaps() {
        const overlaps = this.aiRoleAnalyzerService.analyzePermissionOverlaps();
        return {
            success: true,
            data: {
                overlaps,
                totalOverlaps: overlaps.length,
                highRiskOverlaps: overlaps.filter(o => o.riskLevel === 'HIGH').length,
                mediumRiskOverlaps: overlaps.filter(o => o.riskLevel === 'MEDIUM')
                    .length,
                lowRiskOverlaps: overlaps.filter(o => o.riskLevel === 'LOW').length,
                timestamp: new Date().toISOString(),
            },
        };
    }
    async analyzeRLSPolicies(dto) {
        const analysis = this.aiRoleAnalyzerService.analyzeRLSPolicies(dto.tableName, dto.currentPolicies);
        return {
            success: true,
            data: analysis,
        };
    }
    async getSecurityReport() {
        const report = this.aiRoleAnalyzerService.getSecurityReport();
        return {
            success: true,
            data: report,
        };
    }
    async getHealth() {
        const conflicts = this.aiRoleAnalyzerService.analyzeRoleConflicts();
        const overlaps = this.aiRoleAnalyzerService.analyzePermissionOverlaps();
        return {
            success: true,
            data: {
                status: 'HEALTHY',
                service: 'AI Role Analyzer',
                version: '1.0.0',
                checks: {
                    roleConflictsAnalysis: 'OK',
                    permissionOverlapsAnalysis: 'OK',
                    totalConflicts: conflicts.length,
                    totalOverlaps: overlaps.length,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
    async getRecommendations() {
        const report = this.aiRoleAnalyzerService.getSecurityReport();
        return {
            success: true,
            data: {
                recommendations: report.recommendations,
                priority: {
                    critical: report.conflicts.critical > 0,
                    high: report.conflicts.high > 0 || report.overlaps.highRisk > 0,
                    medium: report.conflicts.medium > 0 || report.overlaps.mediumRisk > 0,
                },
                overallScore: report.overallSecurityScore,
                timestamp: new Date().toISOString(),
            },
        };
    }
    async getDashboard() {
        const conflicts = this.aiRoleAnalyzerService.analyzeRoleConflicts();
        const overlaps = this.aiRoleAnalyzerService.analyzePermissionOverlaps();
        const report = this.aiRoleAnalyzerService.getSecurityReport();
        return {
            success: true,
            data: {
                metrics: {
                    overallSecurityScore: report.overallSecurityScore,
                    totalConflicts: conflicts.length,
                    totalOverlaps: overlaps.length,
                    criticalIssues: conflicts.filter(c => c.severity === 'CRITICAL')
                        .length,
                    highIssues: conflicts.filter(c => c.severity === 'HIGH').length +
                        overlaps.filter(o => o.riskLevel === 'HIGH').length,
                },
                charts: {
                    conflictSeverity: {
                        critical: conflicts.filter(c => c.severity === 'CRITICAL').length,
                        high: conflicts.filter(c => c.severity === 'HIGH').length,
                        medium: conflicts.filter(c => c.severity === 'MEDIUM').length,
                        low: conflicts.filter(c => c.severity === 'LOW').length,
                    },
                    overlapRisk: {
                        high: overlaps.filter(o => o.riskLevel === 'HIGH').length,
                        medium: overlaps.filter(o => o.riskLevel === 'MEDIUM').length,
                        low: overlaps.filter(o => o.riskLevel === 'LOW').length,
                    },
                },
                recentIssues: conflicts
                    .filter(c => c.severity === 'CRITICAL' || c.severity === 'HIGH')
                    .slice(0, 5)
                    .map(c => ({
                    type: 'conflict',
                    severity: c.severity,
                    description: c.description,
                    recommendation: c.recommendation,
                })),
                recommendations: report.recommendations.slice(0, 10),
                timestamp: new Date().toISOString(),
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('conflicts'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Анализ конфликтов ролей' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Список конфликтов ролей с рекомендациями',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "analyzeRoleConflicts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overlaps'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Анализ перекрытий разрешений' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Список перекрытий разрешений между ролями',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "analyzePermissionOverlaps", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('rls-analysis'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Анализ RLS политик таблицы' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Анализ RLS политик с рекомендациями по улучшению',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AnalyzeRLSPoliciesDto]),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "analyzeRLSPolicies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('security-report'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Полный отчет по безопасности ролей' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Комплексный отчет по безопасности системы ролей',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "getSecurityReport", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка состояния AI-анализатора' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Статус AI-анализатора ролей',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('recommendations'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить рекомендации по улучшению безопасности' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Список рекомендаций по улучшению безопасности ролей',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "getRecommendations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Дашборд безопасности ролей' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Дашборд с метриками безопасности ролей',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIRoleAnalyzerController.prototype, "getDashboard", null);
AIRoleAnalyzerController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('AI Role Analyzer'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('ai-role-analyzer'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__.JwtAuthGuard, _guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_2__.AIRoleAnalyzerService !== "undefined" && _services_ai_role_analyzer_service__WEBPACK_IMPORTED_MODULE_2__.AIRoleAnalyzerService) === "function" ? _a : Object])
], AIRoleAnalyzerController);



/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ROLES_KEY: () => (/* binding */ ROLES_KEY),
/* harmony export */   Roles: () => (/* binding */ Roles)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);

const ROLES_KEY = 'roles';
const Roles = (...roles) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)(ROLES_KEY, roles);


/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SupabaseModule: () => (/* binding */ SupabaseModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _supabase_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let SupabaseModule = class SupabaseModule {
};
SupabaseModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        providers: [_supabase_service__WEBPACK_IMPORTED_MODULE_1__.SupabaseService],
        exports: [_supabase_service__WEBPACK_IMPORTED_MODULE_1__.SupabaseService],
    })
], SupabaseModule);



/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomationModule: () => (/* binding */ AutomationModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _self_healing_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _automated_scaling_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _resource_optimization_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var _cost_management_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52);
/* harmony import */ var _automated_monitoring_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
/* harmony import */ var _capacity_planning_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54);
/* harmony import */ var _operational_runbooks_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(55);
/* harmony import */ var _devops_integration_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56);
/* harmony import */ var _cost_optimization_ai_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(57);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










let AutomationModule = class AutomationModule {
};
AutomationModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        providers: [
            _self_healing_service__WEBPACK_IMPORTED_MODULE_1__.SelfHealingService,
            _automated_scaling_service__WEBPACK_IMPORTED_MODULE_2__.AutomatedScalingService,
            _resource_optimization_service__WEBPACK_IMPORTED_MODULE_3__.ResourceOptimizationService,
            _cost_management_service__WEBPACK_IMPORTED_MODULE_4__.CostManagementService,
            _automated_monitoring_service__WEBPACK_IMPORTED_MODULE_5__.AutomatedMonitoringService,
            _capacity_planning_service__WEBPACK_IMPORTED_MODULE_6__.CapacityPlanningService,
            _operational_runbooks_service__WEBPACK_IMPORTED_MODULE_7__.OperationalRunbooksService,
            _devops_integration_service__WEBPACK_IMPORTED_MODULE_8__.DevOpsIntegrationService,
            _cost_optimization_ai_service__WEBPACK_IMPORTED_MODULE_9__.CostOptimizationAIService,
        ],
        exports: [
            _self_healing_service__WEBPACK_IMPORTED_MODULE_1__.SelfHealingService,
            _automated_scaling_service__WEBPACK_IMPORTED_MODULE_2__.AutomatedScalingService,
            _resource_optimization_service__WEBPACK_IMPORTED_MODULE_3__.ResourceOptimizationService,
            _cost_management_service__WEBPACK_IMPORTED_MODULE_4__.CostManagementService,
            _automated_monitoring_service__WEBPACK_IMPORTED_MODULE_5__.AutomatedMonitoringService,
            _capacity_planning_service__WEBPACK_IMPORTED_MODULE_6__.CapacityPlanningService,
            _operational_runbooks_service__WEBPACK_IMPORTED_MODULE_7__.OperationalRunbooksService,
            _devops_integration_service__WEBPACK_IMPORTED_MODULE_8__.DevOpsIntegrationService,
            _cost_optimization_ai_service__WEBPACK_IMPORTED_MODULE_9__.CostOptimizationAIService,
        ],
    })
], AutomationModule);



/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SelfHealingService: () => (/* binding */ SelfHealingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SelfHealingService_1;


let SelfHealingService = SelfHealingService_1 = class SelfHealingService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(SelfHealingService_1.name);
        this.healthChecks = new Map();
        this.recoveryActions = new Map();
        this.localIncidents = new Map();
        this.initializeHealthChecks();
    }
    initializeHealthChecks() {
        const localProviders = [
            { id: 'hoster-by', type: 'datacenter', region: 'BY' },
            { id: 'cloud-flex-a1', type: 'datacenter', region: 'BY' },
            { id: 'becloud', type: 'datacenter', region: 'BY' },
            { id: 'vk-cloud', type: 'datacenter', region: 'RU' },
            { id: 'yandex-cloud', type: 'datacenter', region: 'RU' },
            { id: 'sbercloud', type: 'datacenter', region: 'RU' },
        ];
        localProviders.forEach(provider => {
            this.healthChecks.set(provider.id, {
                id: provider.id,
                type: provider.type,
                status: 'healthy',
                region: provider.region,
                lastCheck: new Date(),
                issues: [],
                autoRecoveryAttempts: 0,
                maxRecoveryAttempts: 3,
            });
        });
        this.redactedLogger.log('Self-healing service initialized', 'SelfHealingService');
    }
    async checkInfrastructureHealth() {
        const healthChecks = Array.from(this.healthChecks.values());
        for (const health of healthChecks) {
            await this.performHealthCheckInternal(health);
        }
        return healthChecks;
    }
    async performHealthCheckInternal(health) {
        try {
            const isHealthy = Math.random() > 0.1;
            if (!isHealthy) {
                health.status = 'degraded';
                health.issues.push('High latency detected');
                if (health.autoRecoveryAttempts < health.maxRecoveryAttempts) {
                    await this.triggerAutoRecovery(health);
                }
            }
            else {
                if (typeof health === 'object') {
                    health.status = 'healthy';
                    health.issues = [];
                    health.autoRecoveryAttempts = 0;
                }
            }
            if (typeof health === 'object') {
                health.lastCheck = new Date();
            }
        }
        catch (error) {
            this.redactedLogger.error(`Health check failed for ${health.id}`, error);
            if (typeof health === 'object') {
                health.status = 'critical';
                health.issues.push('Health check failed');
            }
        }
    }
    async triggerAutoRecovery(health) {
        const recoveryAction = {
            id: `recovery-${Date.now()}`,
            targetId: health.id,
            action: this.determineRecoveryAction(health),
            status: 'pending',
            createdAt: new Date(),
        };
        this.recoveryActions.set(recoveryAction.id, recoveryAction);
        health.autoRecoveryAttempts++;
        this.redactedLogger.log(`Auto-recovery triggered for ${health.id}`, 'SelfHealingService', {
            action: recoveryAction.action,
            attempt: health.autoRecoveryAttempts,
        });
        await this.executeRecoveryAction(recoveryAction);
    }
    determineRecoveryAction(health) {
        if (health.type === 'datacenter') {
            return 'failover';
        }
        else if (health.type === 'service') {
            return 'restart';
        }
        else if (health.type === 'database') {
            return 'rollback';
        }
        return 'restart';
    }
    async executeRecoveryAction(action) {
        action.status = 'in-progress';
        try {
            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
            action.status = 'completed';
            action.completedAt = new Date();
            this.redactedLogger.log(`Recovery action completed for ${action.targetId}`, 'SelfHealingService', {
                action: action.action,
                duration: action.completedAt.getTime() - action.createdAt.getTime(),
            });
        }
        catch (error) {
            action.status = 'failed';
            action.error = error instanceof Error ? error.message : 'Unknown error';
            this.redactedLogger.error(`Recovery action failed for ${action.targetId}`, error);
        }
    }
    async reportLocalIncident(incident) {
        const incidentId = `incident-${Date.now()}`;
        const fullIncident = {
            ...incident,
            id: incidentId,
            detectedAt: new Date(),
        };
        this.localIncidents.set(incidentId, fullIncident);
        this.redactedLogger.log(`Local incident reported: ${incident.type}`, 'SelfHealingService', {
            severity: incident.severity,
            region: incident.region,
            affectedServices: incident.affectedServices,
        });
        if (incident.severity === 'critical') {
            await this.handleCriticalIncident(fullIncident);
        }
        return incidentId;
    }
    async handleCriticalIncident(incident) {
        const affectedHealthChecks = Array.from(this.healthChecks.values()).filter(health => incident.affectedServices.includes(health.id));
        for (const health of affectedHealthChecks) {
            if (health.autoRecoveryAttempts < health.maxRecoveryAttempts) {
                await this.triggerAutoRecovery(health);
            }
        }
    }
    async getRecoveryActions() {
        return Array.from(this.recoveryActions.values());
    }
    async getLocalIncidents() {
        return Array.from(this.localIncidents.values());
    }
    async resolveIncident(incidentId) {
        const incident = this.localIncidents.get(incidentId);
        if (!incident) {
            return false;
        }
        incident.resolvedAt = new Date();
        this.redactedLogger.log(`Incident resolved: ${incidentId}`, 'SelfHealingService', {
            type: incident.type,
            duration: incident.resolvedAt.getTime() - incident.detectedAt.getTime(),
        });
        return true;
    }
    async getHealthMetrics() {
        const healthChecks = Array.from(this.healthChecks.values());
        return {
            total: healthChecks.length,
            healthy: healthChecks.filter(h => h.status === 'healthy').length,
            degraded: healthChecks.filter(h => h.status === 'degraded').length,
            critical: healthChecks.filter(h => h.status === 'critical').length,
            down: healthChecks.filter(h => h.status === 'down').length,
        };
    }
    async performHealthCheck(serviceId) {
        const health = this.healthChecks.get(serviceId);
        if (!health) {
            return {
                serviceId,
                status: 'unhealthy',
                lastCheck: new Date(),
                issues: ['Service not found'],
            };
        }
        const isHealthy = Math.random() > 0.2;
        let status;
        if (isHealthy) {
            status = 'healthy';
        }
        else if (Math.random() > 0.5) {
            status = 'degraded';
        }
        else {
            status = 'unhealthy';
        }
        health.status = status === 'healthy' ? 'healthy' : 'degraded';
        health.lastCheck = new Date();
        return {
            serviceId,
            status,
            lastCheck: health.lastCheck,
            issues: health.issues,
        };
    }
    async performAutoRecovery(serviceId) {
        const health = this.healthChecks.get(serviceId);
        if (!health) {
            return {
                serviceId,
                status: 'failed',
                recoveryAction: 'Service not found',
                duration: 0,
            };
        }
        if (health.autoRecoveryAttempts >= health.maxRecoveryAttempts) {
            return {
                serviceId,
                status: 'failed',
                recoveryAction: 'Max recovery attempts exceeded',
                duration: 0,
            };
        }
        const recoveryDuration = Math.floor(Math.random() * 30000) + 5000;
        const success = Math.random() > 0.3;
        health.autoRecoveryAttempts++;
        if (success) {
            health.status = 'healthy';
            health.issues = [];
        }
        return {
            serviceId,
            status: success ? 'success' : 'failed',
            recoveryAction: success
                ? 'Service restarted successfully'
                : 'Recovery failed',
            duration: recoveryDuration,
        };
    }
};
SelfHealingService = SelfHealingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SelfHealingService);



/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RedactedLogger: () => (/* binding */ RedactedLogger),
/* harmony export */   redactedLogger: () => (/* binding */ redactedLogger)
/* harmony export */ });
class RedactedLogger {
    constructor(context) {
        this.context = context;
        this.sensitiveKeys = [
            'JWT_SECRET',
            'ENCRYPTION_KEY',
            'API_KEY_SECRET',
            'SUPABASE_KEY',
            'SUPABASE_SERVICE_ROLE_KEY',
            'OPENAI_API_KEY',
            'TELEGRAM_BOT_TOKEN',
            'SLACK_WEBHOOK_URL',
            'password',
            'secret',
            'token',
            'key',
        ];
        this.sensitivePatterns = [
            /password/i,
            /secret/i,
            /token/i,
            /key/i,
            /auth/i,
            /credential/i,
        ];
    }
    isSensitiveKey(key) {
        const lowerKey = key.toLowerCase();
        return (this.sensitiveKeys.some(sensitive => lowerKey.includes(sensitive.toLowerCase())) || this.sensitivePatterns.some(pattern => pattern.test(key)));
    }
    redactObject(obj, depth = 0) {
        if (depth > 3)
            return '[MAX_DEPTH]';
        if (obj == null)
            return obj;
        if (typeof obj !== 'object')
            return obj;
        if (Array.isArray(obj)) {
            return obj.map(item => this.redactObject(item, depth + 1));
        }
        const redacted = {};
        for (const [key, value] of Object.entries(obj)) {
            if (this.isSensitiveKey(key)) {
                redacted[key] = '***REDACTED***';
            }
            else if (typeof value === 'object' && value != null) {
                redacted[key] = this.redactObject(value, depth + 1);
            }
            else {
                redacted[key] = value;
            }
        }
        return redacted;
    }
    log(message, context, data) {
        const logContext = context ?? this.context ?? 'RedactedLogger';
        if (data != null) {
            const redactedData = this.redactObject(data);
            console.log(`[${logContext}] ${message} ${JSON.stringify(redactedData, null, 2)}`);
        }
        else {
            console.log(`[${logContext}] ${message}`);
        }
    }
    error(message, trace, context, data) {
        const logContext = context ?? this.context ?? 'RedactedLogger';
        if (data != null) {
            const redactedData = this.redactObject(data);
            console.error(`[${logContext}] ERROR: ${message} ${JSON.stringify(redactedData, null, 2)}`);
            if (trace != null) {
                console.error(`[${logContext}] TRACE: ${trace}`);
            }
        }
        else {
            console.error(`[${logContext}] ERROR: ${message}`);
            if (trace != null) {
                console.error(`[${logContext}] TRACE: ${trace}`);
            }
        }
    }
    errorWithData(message, data, context) {
        const logContext = context ?? this.context ?? 'RedactedLogger';
        const redactedData = this.redactObject(data);
        console.error(`[${logContext}] ERROR: ${message} ${JSON.stringify(redactedData, null, 2)}`);
    }
    warn(message, context, data) {
        const logContext = context ?? this.context ?? 'RedactedLogger';
        if (data != null) {
            const redactedData = this.redactObject(data);
            console.warn(`[${logContext}] WARN: ${message} ${JSON.stringify(redactedData, null, 2)}`);
        }
        else {
            console.warn(`[${logContext}] WARN: ${message}`);
        }
    }
    debug(message, context, data) {
        const logContext = context ?? this.context ?? 'RedactedLogger';
        if (data != null) {
            const redactedData = this.redactObject(data);
            console.debug(`[${logContext}] DEBUG: ${message} ${JSON.stringify(redactedData, null, 2)}`);
        }
        else {
            console.debug(`[${logContext}] DEBUG: ${message}`);
        }
    }
    logConfig(config, context = 'Config') {
        this.log('Configuration loaded:', context, config);
    }
    logEnvironment(env, context = 'Environment') {
        const redactedEnv = {};
        for (const [key, value] of Object.entries(env)) {
            if (this.isSensitiveKey(key)) {
                redactedEnv[key] = '***REDACTED***';
            }
            else {
                redactedEnv[key] = value;
            }
        }
        this.log('Environment variables:', context, redactedEnv);
    }
}
const redactedLogger = new RedactedLogger('RedactedLogger');


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomatedScalingService: () => (/* binding */ AutomatedScalingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutomatedScalingService_1;


let AutomatedScalingService = AutomatedScalingService_1 = class AutomatedScalingService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(AutomatedScalingService_1.name);
        this.scalingPolicies = new Map();
        this.trafficPatterns = new Map();
        this.scalingActions = new Map();
        this.holidayCalendar = new Map();
        this.initializeScalingPolicies();
        this.initializeTrafficPatterns();
        this.initializeHolidayCalendar();
    }
    initializeScalingPolicies() {
        const defaultPolicies = [
            {
                id: 'cpu-scaling',
                name: 'CPU-based scaling',
                type: 'cpu',
                threshold: 80,
                action: 'scale-up',
                minInstances: 2,
                maxInstances: 20,
                currentInstances: 3,
                cooldownPeriod: 5,
                enabled: true,
            },
            {
                id: 'memory-scaling',
                name: 'Memory-based scaling',
                type: 'memory',
                threshold: 85,
                action: 'scale-up',
                minInstances: 2,
                maxInstances: 20,
                currentInstances: 3,
                cooldownPeriod: 5,
                enabled: true,
            },
            {
                id: 'network-scaling',
                name: 'Network-based scaling',
                type: 'network',
                threshold: 75,
                action: 'scale-up',
                minInstances: 2,
                maxInstances: 20,
                currentInstances: 3,
                cooldownPeriod: 3,
                enabled: true,
            },
        ];
        defaultPolicies.forEach(policy => {
            this.scalingPolicies.set(policy.id, policy);
        });
    }
    initializeTrafficPatterns() {
        const patterns = [
            {
                id: 'morning-rush',
                name: 'Morning rush hour',
                type: 'daily',
                startTime: '08:00',
                endTime: '10:00',
                expectedTrafficMultiplier: 1.5,
                scalingAdjustment: 2,
            },
            {
                id: 'lunch-break',
                name: 'Lunch break traffic',
                type: 'daily',
                startTime: '12:00',
                endTime: '14:00',
                expectedTrafficMultiplier: 1.3,
                scalingAdjustment: 1,
            },
            {
                id: 'evening-peak',
                name: 'Evening peak',
                type: 'daily',
                startTime: '18:00',
                endTime: '21:00',
                expectedTrafficMultiplier: 1.8,
                scalingAdjustment: 3,
            },
            {
                id: 'weekend-traffic',
                name: 'Weekend traffic increase',
                type: 'weekly',
                startTime: '00:00',
                endTime: '23:59',
                daysOfWeek: [0, 6],
                expectedTrafficMultiplier: 1.2,
                scalingAdjustment: 1,
            },
        ];
        patterns.forEach(pattern => {
            this.trafficPatterns.set(pattern.id, pattern);
        });
    }
    initializeHolidayCalendar() {
        const holidays = [
            {
                id: 'by-new-year',
                name: 'Новый год',
                region: 'BY',
                date: '01-01',
                type: 'national',
                trafficImpact: 'high',
                scalingMultiplier: 2.0,
            },
            {
                id: 'by-independence-day',
                name: 'День независимости',
                region: 'BY',
                date: '07-03',
                type: 'national',
                trafficImpact: 'medium',
                scalingMultiplier: 1.5,
            },
            {
                id: 'ru-new-year',
                name: 'Новый год',
                region: 'RU',
                date: '01-01',
                type: 'national',
                trafficImpact: 'high',
                scalingMultiplier: 2.0,
            },
            {
                id: 'ru-victory-day',
                name: 'День Победы',
                region: 'RU',
                date: '05-09',
                type: 'national',
                trafficImpact: 'medium',
                scalingMultiplier: 1.3,
            },
            {
                id: 'ru-black-friday',
                name: 'Черная пятница',
                region: 'RU',
                date: '11-29',
                type: 'commercial',
                trafficImpact: 'high',
                scalingMultiplier: 2.5,
            },
        ];
        holidays.forEach(holiday => {
            this.holidayCalendar.set(holiday.id, holiday);
        });
        this.redactedLogger.log('Automated scaling service initialized', 'AutomatedScalingService');
    }
    async evaluateScalingNeeds(currentMetrics) {
        const actions = [];
        for (const policy of this.scalingPolicies.values()) {
            if (!policy.enabled)
                continue;
            const shouldScale = await this.shouldTriggerScaling(policy, currentMetrics);
            if (shouldScale) {
                const action = await this.createScalingAction(policy, currentMetrics);
                if (action) {
                    actions.push(action);
                }
            }
        }
        return actions;
    }
    async shouldTriggerScaling(policy, metrics) {
        if (policy.lastScalingAction) {
            const cooldownMs = policy.cooldownPeriod * 60 * 1000;
            const timeSinceLastAction = Date.now() - policy.lastScalingAction.getTime();
            if (timeSinceLastAction < cooldownMs) {
                return false;
            }
        }
        let currentValue;
        switch (policy.type) {
            case 'cpu':
                currentValue = metrics.cpu;
                break;
            case 'memory':
                currentValue = metrics.memory;
                break;
            case 'network':
                currentValue = metrics.network;
                break;
            default:
                return false;
        }
        if (currentValue > policy.threshold) {
            return (policy.action === 'scale-up' &&
                policy.currentInstances < policy.maxInstances);
        }
        else if (currentValue < policy.threshold * 0.6) {
            return (policy.action === 'scale-down' &&
                policy.currentInstances > policy.minInstances);
        }
        return false;
    }
    async createScalingAction(policy, metrics) {
        const currentValue = this.getMetricValue(policy.type, metrics);
        const isScaleUp = currentValue > policy.threshold;
        if (isScaleUp && policy.currentInstances >= policy.maxInstances) {
            return null;
        }
        if (!isScaleUp && policy.currentInstances <= policy.minInstances) {
            return null;
        }
        const action = {
            id: `scaling-${Date.now()}`,
            policyId: policy.id,
            action: isScaleUp ? 'scale-up' : 'scale-down',
            reason: `${policy.type.toUpperCase()} threshold exceeded: ${currentValue}% > ${policy.threshold}%`,
            fromInstances: policy.currentInstances,
            toInstances: isScaleUp
                ? policy.currentInstances + 1
                : policy.currentInstances - 1,
            timestamp: new Date(),
            success: false,
        };
        this.scalingActions.set(action.id, action);
        return action;
    }
    getMetricValue(type, metrics) {
        switch (type) {
            case 'cpu':
                return metrics.cpu;
            case 'memory':
                return metrics.memory;
            case 'network':
                return metrics.network;
            default:
                return 0;
        }
    }
    async applyTrafficPatternScaling() {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const currentTime = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
        const currentDay = now.getDay();
        for (const pattern of this.trafficPatterns.values()) {
            if (this.isPatternActive(pattern, currentTime, currentDay)) {
                await this.applyPatternScaling(pattern);
            }
        }
    }
    isPatternActive(pattern, currentTime, currentDay) {
        if (pattern.type === 'daily') {
            return currentTime >= pattern.startTime && currentTime <= pattern.endTime;
        }
        else if (pattern.type === 'weekly' && pattern.daysOfWeek) {
            return (pattern.daysOfWeek.includes(currentDay) &&
                currentTime >= pattern.startTime &&
                currentTime <= pattern.endTime);
        }
        return false;
    }
    async applyPatternScaling(pattern) {
        for (const policy of this.scalingPolicies.values()) {
            if (policy.enabled && policy.currentInstances < policy.maxInstances) {
                const newInstances = Math.min(policy.maxInstances, policy.currentInstances + pattern.scalingAdjustment);
                if (newInstances !== policy.currentInstances) {
                    policy.currentInstances = newInstances;
                    policy.lastScalingAction = new Date();
                    this.redactedLogger.log(`Traffic pattern scaling applied`, 'AutomatedScalingService', {
                        pattern: pattern.name,
                        policy: policy.name,
                        instances: newInstances,
                    });
                }
            }
        }
    }
    async applyHolidayScaling() {
        const now = new Date();
        const currentDate = `${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
        for (const holiday of this.holidayCalendar.values()) {
            if (holiday.date === currentDate) {
                await this.applyHolidayScalingInternal(holiday);
            }
        }
    }
    async applyHolidayScalingInternal(holiday) {
        for (const policy of this.scalingPolicies.values()) {
            if (policy.enabled) {
                const newInstances = Math.min(policy.maxInstances, Math.ceil(policy.currentInstances * holiday.scalingMultiplier));
                if (newInstances !== policy.currentInstances) {
                    policy.currentInstances = newInstances;
                    policy.lastScalingAction = new Date();
                    this.redactedLogger.log(`Holiday scaling applied`, 'AutomatedScalingService', {
                        holiday: holiday.name,
                        region: holiday.region,
                        policy: policy.name,
                        instances: newInstances,
                        multiplier: holiday.scalingMultiplier,
                    });
                }
            }
        }
    }
    async executeScalingAction(actionId) {
        const action = this.scalingActions.get(actionId);
        if (!action) {
            return false;
        }
        try {
            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
            action.success = true;
            const policy = this.scalingPolicies.get(action.policyId);
            if (policy) {
                policy.currentInstances = action.toInstances;
                policy.lastScalingAction = new Date();
            }
            this.redactedLogger.log(`Scaling action executed successfully`, 'AutomatedScalingService', {
                action: action.action,
                from: action.fromInstances,
                to: action.toInstances,
                policy: action.policyId,
            });
            return true;
        }
        catch (error) {
            action.success = false;
            action.error = error instanceof Error ? error.message : 'Unknown error';
            this.redactedLogger.errorWithData(`Scaling action failed`, {
                actionId,
                error: action.error,
            }, 'AutomatedScalingService');
            return false;
        }
    }
    async getScalingPolicies() {
        return Array.from(this.scalingPolicies.values());
    }
    async getTrafficPatterns() {
        return Array.from(this.trafficPatterns.values());
    }
    async getHolidayCalendar() {
        return Array.from(this.holidayCalendar.values());
    }
    async getScalingActions() {
        return Array.from(this.scalingActions.values());
    }
    async updateScalingPolicy(policyId, updates) {
        const policy = this.scalingPolicies.get(policyId);
        if (!policy) {
            return false;
        }
        Object.assign(policy, updates);
        return true;
    }
    async addTrafficPattern(pattern) {
        const patternId = `pattern-${Date.now()}`;
        const newPattern = {
            ...pattern,
            id: patternId,
        };
        this.trafficPatterns.set(patternId, newPattern);
        return patternId;
    }
    async addHoliday(holiday) {
        const holidayId = `holiday-${Date.now()}`;
        const newHoliday = {
            ...holiday,
            id: holidayId,
        };
        this.holidayCalendar.set(holidayId, newHoliday);
        return holidayId;
    }
    scaleBasedOnCPU(serviceId, cpuUsage) {
        const policy = this.scalingPolicies.get('cpu-scaling');
        if (!policy) {
            return {
                serviceId,
                action: 'no_action',
                reason: 'CPU scaling policy not found',
                currentInstances: 0,
                targetInstances: 0,
            };
        }
        let action = 'no_action';
        let reason = 'CPU usage within normal range';
        let targetInstances = policy.currentInstances;
        if (cpuUsage > policy.threshold &&
            policy.currentInstances < policy.maxInstances) {
            action = 'scale_up';
            reason = `CPU usage ${cpuUsage}% exceeds threshold ${policy.threshold}%`;
            targetInstances = Math.min(policy.currentInstances + 1, policy.maxInstances);
        }
        else if (cpuUsage < policy.threshold * 0.5 &&
            policy.currentInstances > policy.minInstances) {
            action = 'scale_down';
            reason = `CPU usage ${cpuUsage}% below 50% of threshold ${policy.threshold}%`;
            targetInstances = Math.max(policy.currentInstances - 1, policy.minInstances);
        }
        return {
            serviceId,
            action,
            reason,
            currentInstances: policy.currentInstances,
            targetInstances,
        };
    }
    scaleBasedOnMemory(serviceId, memoryUsage) {
        const policy = this.scalingPolicies.get('memory-scaling');
        if (!policy) {
            return {
                serviceId,
                action: 'no_action',
                reason: 'Memory scaling policy not found',
                currentInstances: 0,
                targetInstances: 0,
            };
        }
        let action = 'no_action';
        let reason = 'Memory usage within normal range';
        let targetInstances = policy.currentInstances;
        if (memoryUsage > policy.threshold &&
            policy.currentInstances < policy.maxInstances) {
            action = 'scale_up';
            reason = `Memory usage ${memoryUsage}% exceeds threshold ${policy.threshold}%`;
            targetInstances = Math.min(policy.currentInstances + 1, policy.maxInstances);
        }
        else if (memoryUsage < policy.threshold * 0.5 &&
            policy.currentInstances > policy.minInstances) {
            action = 'scale_down';
            reason = `Memory usage ${memoryUsage}% below 50% of threshold ${policy.threshold}%`;
            targetInstances = Math.max(policy.currentInstances - 1, policy.minInstances);
        }
        return {
            serviceId,
            action,
            reason,
            currentInstances: policy.currentInstances,
            targetInstances,
        };
    }
    scaleBasedOnNetwork(serviceId, networkUsage) {
        const policy = this.scalingPolicies.get('network-scaling');
        if (!policy) {
            return {
                serviceId,
                action: 'no_action',
                reason: 'Network scaling policy not found',
                currentInstances: 0,
                targetInstances: 0,
            };
        }
        let action = 'no_action';
        let reason = 'Network usage within normal range';
        let targetInstances = policy.currentInstances;
        if (networkUsage > policy.threshold &&
            policy.currentInstances < policy.maxInstances) {
            action = 'scale_up';
            reason = `Network usage ${networkUsage}% exceeds threshold ${policy.threshold}%`;
            targetInstances = Math.min(policy.currentInstances + 1, policy.maxInstances);
        }
        else if (networkUsage < policy.threshold * 0.5 &&
            policy.currentInstances > policy.minInstances) {
            action = 'scale_down';
            reason = `Network usage ${networkUsage}% below 50% of threshold ${policy.threshold}%`;
            targetInstances = Math.max(policy.currentInstances - 1, policy.minInstances);
        }
        return {
            serviceId,
            action,
            reason,
            currentInstances: policy.currentInstances,
            targetInstances,
        };
    }
    applyHolidayCalendarScaling(country, date) {
        const holiday = Array.from(this.holidayCalendar.values()).find(h => h.region === country && h.date === date);
        if (holiday) {
            return {
                country,
                date,
                dayType: 'holiday',
                scalingMultiplier: holiday.scalingMultiplier,
                reason: `Holiday: ${holiday.name}`,
            };
        }
        const dayOfWeek = new Date(date).getDay();
        if (dayOfWeek === 0 || dayOfWeek === 6) {
            return {
                country,
                date,
                dayType: 'weekend',
                scalingMultiplier: 0.7,
                reason: 'Weekend - reduced traffic expected',
            };
        }
        return {
            country,
            date,
            dayType: 'workday',
            scalingMultiplier: 1.0,
            reason: 'Regular workday',
        };
    }
};
AutomatedScalingService = AutomatedScalingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AutomatedScalingService);



/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResourceOptimizationService: () => (/* binding */ ResourceOptimizationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ResourceOptimizationService = class ResourceOptimizationService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger();
        this.resourceMetrics = new Map();
        this.optimizationRules = new Map();
        this.optimizationActions = new Map();
        this.localCloudProviders = new Map();
        this.initializeOptimizationRules();
        this.initializeLocalCloudProviders();
    }
    initializeOptimizationRules() {
        const defaultRules = [
            {
                id: 'cpu-high-usage',
                name: 'High CPU usage alert',
                resourceType: 'cpu',
                condition: 'above',
                threshold: 85,
                action: 'alert',
                priority: 'high',
                enabled: true,
                cooldownPeriod: 5,
            },
            {
                id: 'cpu-critical-usage',
                name: 'Critical CPU usage scale-up',
                resourceType: 'cpu',
                condition: 'above',
                threshold: 95,
                action: 'scale-up',
                priority: 'critical',
                enabled: true,
                cooldownPeriod: 2,
            },
            {
                id: 'memory-high-usage',
                name: 'High memory usage alert',
                resourceType: 'memory',
                condition: 'above',
                threshold: 80,
                action: 'alert',
                priority: 'high',
                enabled: true,
                cooldownPeriod: 5,
            },
            {
                id: 'memory-critical-usage',
                name: 'Critical memory usage scale-up',
                resourceType: 'memory',
                condition: 'above',
                threshold: 90,
                action: 'scale-up',
                priority: 'critical',
                enabled: true,
                cooldownPeriod: 2,
            },
            {
                id: 'network-high-latency',
                name: 'High network latency alert',
                resourceType: 'network',
                condition: 'above',
                threshold: 100,
                action: 'alert',
                priority: 'medium',
                enabled: true,
                cooldownPeriod: 10,
            },
            {
                id: 'storage-high-usage',
                name: 'High storage usage alert',
                resourceType: 'storage',
                condition: 'above',
                threshold: 85,
                action: 'alert',
                priority: 'high',
                enabled: true,
                cooldownPeriod: 15,
            },
            {
                id: 'cpu-low-usage-optimize',
                name: 'Low CPU usage optimization',
                resourceType: 'cpu',
                condition: 'below',
                threshold: 20,
                action: 'optimize',
                priority: 'low',
                enabled: true,
                cooldownPeriod: 30,
            },
            {
                id: 'memory-low-usage-optimize',
                name: 'Low memory usage optimization',
                resourceType: 'memory',
                condition: 'below',
                threshold: 30,
                action: 'optimize',
                priority: 'low',
                enabled: true,
                cooldownPeriod: 30,
            },
        ];
        defaultRules.forEach(rule => {
            this.optimizationRules.set(rule.id, rule);
        });
    }
    initializeLocalCloudProviders() {
        const providers = [
            {
                id: 'hoster-by',
                name: 'Hoster.by',
                region: 'BY',
                type: 'hoster-by',
                resources: {
                    maxCpu: 32,
                    maxMemory: 128,
                    maxStorage: 2000,
                    maxBandwidth: 1000,
                },
                pricing: {
                    cpuPerCore: 0.05,
                    memoryPerGb: 0.02,
                    storagePerGb: 0.01,
                    bandwidthPerMbps: 0.001,
                    currency: 'BYN',
                },
            },
            {
                id: 'cloud-flex-a1',
                name: 'Cloud Flex А1',
                region: 'BY',
                type: 'cloud-flex-a1',
                resources: {
                    maxCpu: 64,
                    maxMemory: 256,
                    maxStorage: 4000,
                    maxBandwidth: 2000,
                },
                pricing: {
                    cpuPerCore: 0.06,
                    memoryPerGb: 0.025,
                    storagePerGb: 0.012,
                    bandwidthPerMbps: 0.0012,
                    currency: 'BYN',
                },
            },
            {
                id: 'becloud',
                name: 'BeCloud',
                region: 'BY',
                type: 'becloud',
                resources: {
                    maxCpu: 48,
                    maxMemory: 192,
                    maxStorage: 3000,
                    maxBandwidth: 1500,
                },
                pricing: {
                    cpuPerCore: 0.055,
                    memoryPerGb: 0.022,
                    storagePerGb: 0.011,
                    bandwidthPerMbps: 0.0011,
                    currency: 'BYN',
                },
            },
            {
                id: 'vk-cloud',
                name: 'VK Cloud',
                region: 'RU',
                type: 'vk-cloud',
                resources: {
                    maxCpu: 96,
                    maxMemory: 384,
                    maxStorage: 8000,
                    maxBandwidth: 5000,
                },
                pricing: {
                    cpuPerCore: 0.08,
                    memoryPerGb: 0.03,
                    storagePerGb: 0.015,
                    bandwidthPerMbps: 0.002,
                    currency: 'RUB',
                },
            },
        ];
        providers.forEach(provider => {
            this.localCloudProviders.set(provider.id, provider);
        });
    }
    async collectResourceMetrics(_providerId, metrics) {
        const metricsId = `metrics-${Date.now()}`;
        const fullMetrics = {
            ...metrics,
            id: metricsId,
            timestamp: new Date(),
        };
        this.resourceMetrics.set(metricsId, fullMetrics);
        await this.checkOptimizationRules(fullMetrics);
        return metricsId;
    }
    async checkOptimizationRules(metrics) {
        for (const rule of this.optimizationRules.values()) {
            if (!rule.enabled)
                continue;
            if (rule.lastTriggered) {
                const cooldownMs = rule.cooldownPeriod * 60 * 1000;
                const timeSinceLastTrigger = Date.now() - rule.lastTriggered.getTime();
                if (timeSinceLastTrigger < cooldownMs) {
                    continue;
                }
            }
            const shouldTrigger = this.evaluateRule(rule, metrics);
            if (shouldTrigger) {
                await this.triggerOptimizationAction(rule, metrics);
                rule.lastTriggered = new Date();
            }
        }
    }
    evaluateRule(rule, metrics) {
        const currentValue = this.getResourceValue(rule.resourceType, metrics);
        switch (rule.condition) {
            case 'above':
                return currentValue > rule.threshold;
            case 'below':
                return currentValue < rule.threshold;
            case 'between':
                if (rule.thresholdMax == null)
                    return false;
                return (currentValue >= rule.threshold && currentValue <= rule.thresholdMax);
            default:
                return false;
        }
    }
    getResourceValue(resourceType, metrics) {
        switch (resourceType) {
            case 'cpu':
                return metrics.cpu.usage;
            case 'memory':
                return metrics.memory.usage;
            case 'network':
                return metrics.network.latency;
            case 'storage':
                return metrics.storage.usage;
            default:
                return 0;
        }
    }
    async triggerOptimizationAction(rule, metrics) {
        const action = {
            id: `optimization-${Date.now()}`,
            ruleId: rule.id,
            resourceId: metrics.id,
            action: rule.action,
            reason: `${rule.resourceType.toUpperCase()} ${rule.condition} threshold: ${this.getResourceValue(rule.resourceType, metrics)}%`,
            currentValue: this.getResourceValue(rule.resourceType, metrics),
            timestamp: new Date(),
            status: 'pending',
        };
        this.optimizationActions.set(action.id, action);
        this.redactedLogger.log(`Optimization action triggered`, 'ResourceOptimizationService', {
            rule: rule.name,
            resource: rule.resourceType,
            action: rule.action,
            priority: rule.priority,
            value: action.currentValue,
        });
        await this.executeOptimizationAction(action);
    }
    async executeOptimizationAction(action) {
        action.status = 'in-progress';
        try {
            switch (action.action) {
                case 'scale-up':
                    await this.performScaleUp(action);
                    break;
                case 'scale-down':
                    await this.performScaleDown(action);
                    break;
                case 'optimize':
                    await this.performOptimization(action);
                    break;
                case 'alert':
                    await this.sendAlert(action);
                    break;
            }
            action.status = 'completed';
            action.result = 'Action executed successfully';
        }
        catch {
            action.status = 'failed';
            action.error = 'Unknown error';
            this.redactedLogger.errorWithData(`Optimization action failed`, {
                actionId: action.id,
                error: action.error,
            }, 'ResourceOptimizationService');
        }
    }
    async performScaleUp(action) {
        await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
        this.redactedLogger.log(`Scale-up completed for resource ${action.resourceId}`, 'ResourceOptimizationService');
    }
    async performScaleDown(action) {
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
        this.redactedLogger.log(`Scale-down completed for resource ${action.resourceId}`, 'ResourceOptimizationService');
    }
    async performOptimization(action) {
        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2500));
        this.redactedLogger.log(`Resource optimization completed for ${action.resourceId}`, 'ResourceOptimizationService');
    }
    async sendAlert(action) {
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
        this.redactedLogger.log(`Alert sent for resource ${action.resourceId}`, 'ResourceOptimizationService', {
            reason: action.reason,
            value: action.currentValue,
        });
    }
    async getResourceMetrics(providerId, limit = 100) {
        let metrics = Array.from(this.resourceMetrics.values());
        if (providerId !== undefined) {
            metrics = metrics.filter(m => m.providerId === providerId);
        }
        metrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        return metrics.slice(0, limit);
    }
    async getOptimizationRules() {
        return Array.from(this.optimizationRules.values());
    }
    async getOptimizationActions() {
        return Array.from(this.optimizationActions.values());
    }
    async getLocalCloudProviders() {
        return Array.from(this.localCloudProviders.values());
    }
    async addOptimizationRule(rule) {
        const ruleId = `rule-${Date.now()}`;
        const newRule = {
            ...rule,
            id: ruleId,
        };
        this.optimizationRules.set(ruleId, newRule);
        return ruleId;
    }
    async updateOptimizationRule(ruleId, updates) {
        const rule = this.optimizationRules.get(ruleId);
        if (!rule) {
            return false;
        }
        Object.assign(rule, updates);
        return true;
    }
    async getResourceUtilization(_providerId, _resourceType, _period) {
        const providerMetrics = Array.from(this.resourceMetrics.values()).slice(-24);
        if (providerMetrics.length === 0) {
            return {
                cpu: { current: 0, average: 0, peak: 0 },
                memory: { current: 0, average: 0, peak: 0 },
                network: { current: 0, average: 0, peak: 0 },
                storage: { current: 0, average: 0, peak: 0 },
            };
        }
        const latest = providerMetrics[0];
        if (latest === undefined) {
            return {
                cpu: { current: 0, average: 0, peak: 0 },
                memory: { current: 0, average: 0, peak: 0 },
                network: { current: 0, average: 0, peak: 0 },
                storage: { current: 0, average: 0, peak: 0 },
            };
        }
        return {
            cpu: {
                current: latest.cpu.usage,
                average: providerMetrics.reduce((sum, m) => sum + m.cpu.usage, 0) /
                    providerMetrics.length,
                peak: Math.max(...providerMetrics.map(m => m.cpu.usage)),
            },
            memory: {
                current: latest.memory.usage,
                average: providerMetrics.reduce((sum, m) => sum + m.memory.usage, 0) /
                    providerMetrics.length,
                peak: Math.max(...providerMetrics.map(m => m.memory.usage)),
            },
            network: {
                current: latest.network.latency,
                average: providerMetrics.reduce((sum, m) => sum + m.network.latency, 0) /
                    providerMetrics.length,
                peak: Math.max(...providerMetrics.map(m => m.network.latency)),
            },
            storage: {
                current: latest.storage.usage,
                average: providerMetrics.reduce((sum, m) => sum + m.storage.usage, 0) /
                    providerMetrics.length,
                peak: Math.max(...providerMetrics.map(m => m.storage.usage)),
            },
        };
    }
    async getCostOptimizationSuggestions(providerId) {
        const provider = this.localCloudProviders.get(providerId);
        if (!provider) {
            return { suggestions: [], estimatedSavings: 0, currency: 'BYN' };
        }
        const utilization = await this.getResourceUtilization('', '', '1d');
        const suggestions = [];
        let estimatedSavings = 0;
        if (utilization.cpu.average < 30) {
            suggestions.push('Consider reducing CPU cores - current average usage is low');
            estimatedSavings += provider.pricing.cpuPerCore * 24 * 30 * 0.5;
        }
        if (utilization.memory.average < 40) {
            suggestions.push('Consider reducing memory allocation - current average usage is low');
            estimatedSavings += provider.pricing.memoryPerGb * 24 * 30 * 0.4;
        }
        if (utilization.storage.average < 60) {
            suggestions.push('Consider cleaning up unused storage - current usage is below optimal');
            estimatedSavings += provider.pricing.storagePerGb * 24 * 30 * 0.3;
        }
        return {
            suggestions,
            estimatedSavings: Math.round(estimatedSavings * 100) / 100,
            currency: provider.pricing.currency,
        };
    }
    optimizeCPU(serviceId) {
        try {
            const recommendations = [];
            let estimatedSavings = 0;
            const cpuUtilization = Math.random() * 100;
            if (cpuUtilization > 80) {
                recommendations.push('Scale up CPU resources - high utilization detected');
                recommendations.push('Consider load balancing across instances');
            }
            else if (cpuUtilization < 20) {
                recommendations.push('Scale down CPU resources - low utilization detected');
                estimatedSavings = Math.random() * 50 + 10;
            }
            else {
                recommendations.push('CPU utilization is within optimal range');
            }
            const status = recommendations.length > 0 && estimatedSavings > 0
                ? 'optimized'
                : recommendations.length > 0
                    ? 'no_action_needed'
                    : 'failed';
            return {
                serviceId,
                status,
                recommendations,
                estimatedSavings: Math.round(estimatedSavings * 100) / 100,
            };
        }
        catch {
            return {
                serviceId,
                status: 'failed',
                recommendations: ['Error during CPU optimization'],
                estimatedSavings: 0,
            };
        }
    }
    optimizeMemory(serviceId) {
        try {
            const recommendations = [];
            let estimatedSavings = 0;
            const memoryUtilization = Math.random() * 100;
            if (memoryUtilization > 85) {
                recommendations.push('Scale up memory resources - high memory usage detected');
                recommendations.push('Consider memory leak investigation');
            }
            else if (memoryUtilization < 25) {
                recommendations.push('Scale down memory allocation - low memory usage detected');
                estimatedSavings = Math.random() * 40 + 15;
            }
            else {
                recommendations.push('Memory utilization is within optimal range');
            }
            const status = recommendations.length > 0 && estimatedSavings > 0
                ? 'optimized'
                : recommendations.length > 0
                    ? 'no_action_needed'
                    : 'failed';
            return {
                serviceId,
                status,
                recommendations,
                estimatedSavings: Math.round(estimatedSavings * 100) / 100,
            };
        }
        catch {
            return {
                serviceId,
                status: 'failed',
                recommendations: ['Error during memory optimization'],
                estimatedSavings: 0,
            };
        }
    }
    optimizeNetwork(serviceId) {
        try {
            const recommendations = [];
            let estimatedSavings = 0;
            const networkUtilization = Math.random() * 100;
            const latency = Math.random() * 100 + 10;
            if (networkUtilization > 90) {
                recommendations.push('Scale up network bandwidth - high network usage detected');
                recommendations.push('Consider CDN implementation');
            }
            else if (latency > 80) {
                recommendations.push('Optimize network routing - high latency detected');
                recommendations.push('Consider edge locations');
            }
            else if (networkUtilization < 30) {
                recommendations.push('Scale down network resources - low utilization detected');
                estimatedSavings = Math.random() * 30 + 10;
            }
            else {
                recommendations.push('Network utilization is within optimal range');
            }
            const status = recommendations.length > 0 && estimatedSavings > 0
                ? 'optimized'
                : recommendations.length > 0
                    ? 'no_action_needed'
                    : 'failed';
            return {
                serviceId,
                status,
                recommendations,
                estimatedSavings: Math.round(estimatedSavings * 100) / 100,
            };
        }
        catch {
            return {
                serviceId,
                status: 'failed',
                recommendations: ['Error during network optimization'],
                estimatedSavings: 0,
            };
        }
    }
    optimizeStorage(serviceId) {
        try {
            const recommendations = [];
            let estimatedSavings = 0;
            const storageUtilization = Math.random() * 100;
            const iops = Math.random() * 1000 + 100;
            if (storageUtilization > 90) {
                recommendations.push('Scale up storage capacity - high storage usage detected');
                recommendations.push('Consider data archiving strategy');
            }
            else if (iops > 800) {
                recommendations.push('Optimize storage performance - high IOPS detected');
                recommendations.push('Consider SSD upgrade');
            }
            else if (storageUtilization < 40) {
                recommendations.push('Scale down storage allocation - low utilization detected');
                estimatedSavings = Math.random() * 35 + 15;
            }
            else {
                recommendations.push('Storage utilization is within optimal range');
            }
            const status = recommendations.length > 0 && estimatedSavings > 0
                ? 'optimized'
                : recommendations.length > 0
                    ? 'no_action_needed'
                    : 'failed';
            return {
                serviceId,
                status,
                recommendations,
                estimatedSavings: Math.round(estimatedSavings * 100) / 100,
            };
        }
        catch {
            return {
                serviceId,
                status: 'failed',
                recommendations: ['Error during storage optimization'],
                estimatedSavings: 0,
            };
        }
    }
};
ResourceOptimizationService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ResourceOptimizationService);



/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CostManagementService: () => (/* binding */ CostManagementService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CostManagementService_1;


let CostManagementService = CostManagementService_1 = class CostManagementService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(CostManagementService_1.name);
        this.billingPeriods = new Map();
        this.resourceCosts = new Map();
        this.costAlerts = new Map();
        this.budgets = new Map();
        this.currencyRates = new Map();
        this.initializeBudgets();
        this.initializeCurrencyRates();
    }
    initializeBudgets() {
        const defaultBudgets = [
            {
                id: 'monthly-main',
                name: 'Основной месячный бюджет',
                amount: 1000,
                currency: 'BYN',
                period: 'monthly',
                startDate: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
                endDate: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0),
                spent: 0,
                remaining: 1000,
                alerts: {
                    warning: 80,
                    critical: 95,
                },
                enabled: true,
            },
            {
                id: 'quarterly-infrastructure',
                name: 'Квартальный бюджет инфраструктуры',
                amount: 5000,
                currency: 'RUB',
                period: 'quarterly',
                startDate: new Date(new Date().getFullYear(), Math.floor(new Date().getMonth() / 3) * 3, 1),
                endDate: new Date(new Date().getFullYear(), Math.floor(new Date().getMonth() / 3) * 3 + 3, 0),
                spent: 0,
                remaining: 5000,
                alerts: {
                    warning: 75,
                    critical: 90,
                },
                enabled: true,
            },
        ];
        defaultBudgets.forEach(budget => {
            this.budgets.set(budget.id, budget);
        });
    }
    initializeCurrencyRates() {
        const now = new Date();
        const defaultRates = [
            {
                from: 'BYN',
                to: 'USD',
                rate: 0.31,
                timestamp: now,
                source: 'central-bank',
            },
            {
                from: 'USD',
                to: 'BYN',
                rate: 3.23,
                timestamp: now,
                source: 'central-bank',
            },
            {
                from: 'RUB',
                to: 'USD',
                rate: 0.011,
                timestamp: now,
                source: 'central-bank',
            },
            {
                from: 'USD',
                to: 'RUB',
                rate: 91.5,
                timestamp: now,
                source: 'central-bank',
            },
            {
                from: 'BYN',
                to: 'RUB',
                rate: 28.3,
                timestamp: now,
                source: 'central-bank',
            },
            {
                from: 'RUB',
                to: 'BYN',
                rate: 0.035,
                timestamp: now,
                source: 'central-bank',
            },
        ];
        defaultRates.forEach(rate => {
            const key = `${rate.from}-${rate.to}`;
            this.currencyRates.set(key, rate);
        });
    }
    async createBillingPeriod(startDate, endDate, currency) {
        const periodId = `period-${Date.now()}`;
        const period = {
            id: periodId,
            startDate,
            endDate,
            status: 'active',
            totalCost: 0,
            currency,
        };
        this.billingPeriods.set(periodId, period);
        this.redactedLogger.log(`Billing period created`, 'CostManagementService', {
            periodId,
            startDate: startDate.toISOString(),
            endDate: endDate.toISOString(),
            currency,
        });
        return periodId;
    }
    async recordResourceCost(cost) {
        const costId = `cost-${Date.now()}`;
        const totalCost = cost.usage * cost.unitPrice;
        const fullCost = {
            ...cost,
            id: costId,
            totalCost,
            timestamp: new Date(),
        };
        this.resourceCosts.set(costId, fullCost);
        await this.updateBillingPeriodCost(cost.billingPeriodId, totalCost, cost.currency);
        await this.checkBudgetLimits(cost.providerId, totalCost, cost.currency);
        return costId;
    }
    async updateBillingPeriodCost(periodId, cost, currency) {
        const period = this.billingPeriods.get(periodId);
        if (!period)
            return;
        if (period.currency !== currency) {
            const convertedCost = await this.convertCurrencyInternal(cost, currency, period.currency);
            period.totalCost += convertedCost;
        }
        else {
            period.totalCost += cost;
        }
    }
    async convertCurrencyInternal(amount, from, to) {
        if (from === to)
            return amount;
        const rateKey = `${from}-${to}`;
        const rate = this.currencyRates.get(rateKey);
        if (rate) {
            return amount * rate.rate;
        }
        if (from !== 'USD' && to !== 'USD') {
            const toUsd = await this.convertCurrencyInternal(amount, from, 'USD');
            return await this.convertCurrencyInternal(toUsd, 'USD', to);
        }
        return amount;
    }
    async checkBudgetLimits(_providerId, cost, currency) {
        for (const budget of this.budgets.values()) {
            if (!budget.enabled)
                continue;
            const convertedCost = await this.convertCurrencyInternal(cost, currency, budget.currency);
            budget.spent += convertedCost;
            budget.remaining = budget.amount - budget.spent;
            const spentPercentage = (budget.spent / budget.amount) * 100;
            if (spentPercentage >= budget.alerts.critical) {
                await this.createCostAlert('budget-exceeded', 'critical', budget, spentPercentage);
            }
            else if (spentPercentage >= budget.alerts.warning) {
                await this.createCostAlert('budget-exceeded', 'high', budget, spentPercentage);
            }
        }
    }
    async createCostAlert(type, severity, budget, spentPercentage) {
        const alert = {
            id: `alert-${Date.now()}`,
            type,
            severity,
            message: `Бюджет "${budget.name}" превышен на ${spentPercentage.toFixed(1)}%`,
            currentCost: budget.spent,
            threshold: budget.amount,
            currency: budget.currency,
            timestamp: new Date(),
            acknowledged: false,
        };
        this.costAlerts.set(alert.id, alert);
        this.redactedLogger.log(`Cost alert created`, 'CostManagementService', {
            alertId: alert.id,
            budget: budget.name,
            spentPercentage: spentPercentage.toFixed(1),
            severity,
        });
    }
    async updateCurrencyRate(from, to, rate, source = 'manual') {
        const rateKey = `${from}-${to}`;
        const currencyRate = {
            from,
            to,
            rate,
            timestamp: new Date(),
            source,
        };
        this.currencyRates.set(rateKey, currencyRate);
        const reverseKey = `${to}-${from}`;
        const reverseRate = {
            from: to,
            to: from,
            rate: 1 / rate,
            timestamp: new Date(),
            source,
        };
        this.currencyRates.set(reverseKey, reverseRate);
        this.redactedLogger.log(`Currency rate updated`, 'CostManagementService', {
            from,
            to,
            rate,
            source,
        });
    }
    async getCostAnalysis(periodId, groupBy = 'resource') {
        const period = this.billingPeriods.get(periodId);
        if (!period) {
            throw new Error('Billing period not found');
        }
        const costs = Array.from(this.resourceCosts.values()).filter(cost => cost.billingPeriodId === periodId);
        const totalCost = period.totalCost;
        const breakdown = new Map();
        costs.forEach(cost => {
            let key;
            switch (groupBy) {
                case 'resource':
                    key = cost.resourceId;
                    break;
                case 'provider':
                    key = cost.providerId;
                    break;
                case 'type':
                    key = cost.resourceType;
                    break;
                default:
                    key = cost.resourceId;
            }
            const currentCost = breakdown.get(key) ?? 0;
            breakdown.set(key, currentCost + cost.totalCost);
        });
        const breakdownArray = Array.from(breakdown.entries())
            .map(([key, cost]) => ({
            key,
            cost,
            percentage: (cost / totalCost) * 100,
        }))
            .sort((a, b) => b.cost - a.cost);
        return {
            totalCost,
            currency: period.currency,
            breakdown: breakdownArray,
        };
    }
    async getCostOptimizationSuggestions() {
        const suggestions = [];
        const resourceUsage = await this.analyzeResourceUsage();
        if (resourceUsage.cpu.average < 30) {
            suggestions.push({
                id: `suggestion-${Date.now()}`,
                type: 'resource-downsize',
                priority: 'medium',
                estimatedSavings: resourceUsage.cpu.potentialSavings,
                currency: 'BYN',
                implementationEffort: 'low',
                description: 'CPU usage is consistently low, consider reducing cores',
                resources: resourceUsage.cpu.resources,
                createdAt: new Date(),
            });
        }
        if (resourceUsage.memory.average < 40) {
            suggestions.push({
                id: `suggestion-${Date.now() + 1}`,
                type: 'resource-downsize',
                priority: 'medium',
                estimatedSavings: resourceUsage.memory.potentialSavings,
                currency: 'BYN',
                implementationEffort: 'low',
                description: 'Memory usage is consistently low, consider reducing allocation',
                resources: resourceUsage.memory.resources,
                createdAt: new Date(),
            });
        }
        const providerComparison = await this.compareProviderCosts();
        if (providerComparison.hasBetterOption) {
            suggestions.push({
                id: `suggestion-${Date.now() + 2}`,
                type: 'provider-migration',
                priority: 'high',
                estimatedSavings: providerComparison.potentialSavings,
                currency: providerComparison.currency,
                implementationEffort: 'medium',
                description: `Migration to ${providerComparison.betterProvider} could save costs`,
                resources: providerComparison.resources,
                createdAt: new Date(),
            });
        }
        return suggestions;
    }
    async analyzeResourceUsage() {
        return {
            cpu: {
                average: 25,
                potentialSavings: 150,
                resources: ['server-1', 'server-2'],
            },
            memory: {
                average: 35,
                potentialSavings: 200,
                resources: ['server-1', 'server-3'],
            },
        };
    }
    async compareProviderCosts() {
        return {
            hasBetterOption: true,
            betterProvider: 'BeCloud',
            potentialSavings: 300,
            currency: 'BYN',
            resources: ['server-1', 'server-2', 'server-3'],
        };
    }
    async acknowledgeAlert(alertId) {
        const alert = this.costAlerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.acknowledged = true;
        alert.acknowledgedAt = new Date();
        return true;
    }
    async getBillingPeriods() {
        return Array.from(this.billingPeriods.values());
    }
    async getResourceCosts(periodId, limit = 100) {
        let costs = Array.from(this.resourceCosts.values());
        if (periodId !== undefined) {
            costs = costs.filter(c => c.billingPeriodId === periodId);
        }
        costs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        return costs.slice(0, limit);
    }
    async getCostAlerts() {
        return Array.from(this.costAlerts.values());
    }
    async getBudgets() {
        return Array.from(this.budgets.values());
    }
    async getCurrencyRates() {
        return Array.from(this.currencyRates.values());
    }
    async addBudget(budget) {
        const budgetId = `budget-${Date.now()}`;
        const newBudget = {
            ...budget,
            id: budgetId,
            spent: 0,
            remaining: budget.amount,
        };
        this.budgets.set(budgetId, newBudget);
        return budgetId;
    }
    async updateBudget(budgetId, updates) {
        const budget = this.budgets.get(budgetId);
        if (!budget) {
            return false;
        }
        Object.assign(budget, updates);
        budget.remaining = budget.amount - budget.spent;
        return true;
    }
    trackCostsByProvider(providerId) {
        const providerCosts = Array.from(this.resourceCosts.values()).filter(cost => cost.providerId === providerId);
        const costs = providerCosts.map(cost => ({
            resourceType: cost.resourceType,
            usage: cost.usage,
            unit: cost.unit,
            cost: cost.totalCost,
            currency: cost.currency,
        }));
        const totalCost = costs.reduce((sum, cost) => sum + cost.cost, 0);
        return {
            provider: providerId,
            costs,
            totalCost: Math.round(totalCost * 100) / 100,
            period: 'current-month',
        };
    }
    convertCurrency(amount, fromCurrency, toCurrency) {
        const rates = {
            BYN: 1,
            RUB: 0.03,
            USD: 0.4,
        };
        const fromRate = rates[fromCurrency] ?? 1;
        const toRate = rates[toCurrency] ?? 1;
        const exchangeRate = toRate / fromRate;
        const convertedAmount = amount * exchangeRate;
        return {
            originalAmount: amount,
            originalCurrency: fromCurrency,
            targetCurrency: toCurrency,
            convertedAmount: Math.round(convertedAmount * 100) / 100,
            exchangeRate: Math.round(exchangeRate * 10000) / 10000,
            timestamp: new Date(),
        };
    }
    setBudgetAlert(budgetId, amount, currency) {
        const alertId = `alert-${Date.now()}`;
        const alert = {
            id: alertId,
            type: 'budget-exceeded',
            severity: 'high',
            message: `Budget ${budgetId} exceeded threshold ${amount} ${currency}`,
            currentCost: amount * 1.1,
            threshold: amount,
            currency: currency,
            timestamp: new Date(),
            acknowledged: false,
        };
        this.costAlerts.set(alertId, alert);
        return {
            budgetId,
            amount,
            currency,
            alertId,
            status: 'active',
            createdAt: alert.timestamp,
        };
    }
    getCostTrends(providerId, period) {
        const data = Array.from({ length: 7 }, (_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - i);
            return {
                date: date.toISOString().split('T')[0],
                cost: Math.random() * 100 + 50,
                currency: 'BYN',
            };
        }).reverse();
        const firstCost = data[0]?.cost ?? 0;
        const lastCost = data[data.length - 1]?.cost ?? 0;
        const changePercentage = firstCost > 0 ? ((lastCost - firstCost) / firstCost) * 100 : 0;
        let trend;
        if (changePercentage > 5) {
            trend = 'increasing';
        }
        else if (changePercentage < -5) {
            trend = 'decreasing';
        }
        else {
            trend = 'stable';
        }
        return {
            provider: providerId,
            period,
            data: data.map(d => ({ ...d, date: d.date ?? '' })),
            trend,
            changePercentage: Math.round(changePercentage * 100) / 100,
        };
    }
};
CostManagementService = CostManagementService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CostManagementService);



/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomatedMonitoringService: () => (/* binding */ AutomatedMonitoringService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutomatedMonitoringService_1;


let AutomatedMonitoringService = AutomatedMonitoringService_1 = class AutomatedMonitoringService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(AutomatedMonitoringService_1.name);
        this.metrics = new Map();
        this.alertRules = new Map();
        this.alerts = new Map();
        this.notificationChannels = new Map();
        this.notificationTemplates = new Map();
        this.dashboards = new Map();
        this.initializeNotificationChannels();
        this.initializeAlertRules();
        this.initializeNotificationTemplates();
        this.initializeDashboards();
    }
    initializeNotificationChannels() {
        const defaultChannels = [
            {
                id: 'telegram-main',
                type: 'telegram',
                name: 'Основной Telegram канал',
                config: {
                    telegram: {
                        botToken: process.env.TELEGRAM_BOT_TOKEN ?? 'demo-token',
                        chatId: process.env.TELEGRAM_CHAT_ID ?? 'demo-chat-id',
                    },
                },
                enabled: true,
                priority: 'critical',
            },
            {
                id: 'viber-team',
                type: 'viber',
                name: 'Командный Viber канал',
                config: {
                    viber: {
                        botToken: process.env.VIBER_BOT_TOKEN ?? 'demo-token',
                        userId: process.env.VIBER_USER_ID ?? 'demo-user-id',
                    },
                },
                enabled: true,
                priority: 'high',
            },
            {
                id: 'email-admin',
                type: 'email',
                name: 'Email администраторов',
                config: {
                    email: {
                        smtpHost: process.env.SMTP_HOST ?? 'smtp.gmail.com',
                        smtpPort: parseInt(process.env.SMTP_PORT ?? '587'),
                        username: process.env.SMTP_USERNAME ?? 'admin@example.com',
                        password: process.env.SMTP_PASSWORD ?? 'demo-password',
                        from: process.env.SMTP_FROM ?? 'monitoring@example.com',
                        to: (process.env.SMTP_TO ?? 'admin@example.com').split(','),
                    },
                },
                enabled: true,
                priority: 'medium',
            },
        ];
        defaultChannels.forEach(channel => {
            this.notificationChannels.set(channel.id, channel);
        });
    }
    initializeAlertRules() {
        const defaultRules = [
            {
                id: 'cpu-high-usage',
                name: 'High CPU Usage',
                metricName: 'cpu_usage',
                condition: 'above',
                threshold: 85,
                severity: 'high',
                enabled: true,
                cooldownPeriod: 5,
                notificationChannels: this.getNotificationChannelsByIds([
                    'telegram-main',
                    'email-admin',
                ]),
            },
            {
                id: 'memory-critical-usage',
                name: 'Critical Memory Usage',
                metricName: 'memory_usage',
                condition: 'above',
                threshold: 95,
                severity: 'critical',
                enabled: true,
                cooldownPeriod: 2,
                notificationChannels: this.getNotificationChannelsByIds([
                    'telegram-main',
                    'viber-team',
                    'email-admin',
                ]),
            },
            {
                id: 'disk-space-low',
                name: 'Low Disk Space',
                metricName: 'disk_usage',
                condition: 'above',
                threshold: 90,
                severity: 'high',
                enabled: true,
                cooldownPeriod: 10,
                notificationChannels: this.getNotificationChannelsByIds([
                    'telegram-main',
                    'email-admin',
                ]),
            },
            {
                id: 'network-latency-high',
                name: 'High Network Latency',
                metricName: 'network_latency',
                condition: 'above',
                threshold: 100,
                severity: 'medium',
                enabled: true,
                cooldownPeriod: 15,
                notificationChannels: this.getNotificationChannelsByIds([
                    'email-admin',
                ]),
            },
        ];
        defaultRules.forEach(rule => {
            this.alertRules.set(rule.id, rule);
        });
    }
    getNotificationChannelsByIds(channelIds) {
        const channels = [];
        for (const id of channelIds) {
            const channel = this.notificationChannels.get(id);
            if (channel) {
                channels.push(channel);
            }
        }
        if (channels.length === 0) {
            channels.push(this.createDefaultNotificationChannel());
        }
        return channels;
    }
    createDefaultNotificationChannel() {
        return {
            id: 'default-email',
            type: 'email',
            name: 'Default Email Channel',
            config: {
                email: {
                    smtpHost: 'localhost',
                    smtpPort: 587,
                    username: 'admin@example.com',
                    password: 'password',
                    from: 'admin@example.com',
                    to: ['admin@example.com'],
                },
            },
            enabled: true,
            priority: 'medium',
        };
    }
    initializeNotificationTemplates() {
        const templates = [
            {
                id: 'alert-critical',
                name: 'Critical Alert Template',
                type: 'alert',
                subject: '🚨 КРИТИЧЕСКИЙ АЛЕРТ: {metric_name}',
                body: `Метрика {metric_name} превысила пороговое значение!

Текущее значение: {current_value}
Пороговое значение: {threshold}
Время: {timestamp}
Источник: {source}

Требуется немедленное вмешательство!`,
                variables: [
                    'metric_name',
                    'current_value',
                    'threshold',
                    'timestamp',
                    'source',
                ],
            },
            {
                id: 'alert-high',
                name: 'High Alert Template',
                type: 'alert',
                subject: '⚠️ ВЫСОКИЙ АЛЕРТ: {metric_name}',
                body: `Метрика {metric_name} превысила пороговое значение.

Текущее значение: {current_value}
Пороговое значение: {threshold}
Время: {timestamp}
Источник: {source}

Рекомендуется проверить систему.`,
                variables: [
                    'metric_name',
                    'current_value',
                    'threshold',
                    'timestamp',
                    'source',
                ],
            },
            {
                id: 'daily-summary',
                name: 'Daily Summary Template',
                type: 'summary',
                subject: '📊 Ежедневный отчет мониторинга',
                body: `Отчет за {date}

Всего алертов: {total_alerts}
Критических: {critical_alerts}
Высоких: {high_alerts}
Средних: {medium_alerts}
Низких: {low_alerts}

Статус системы: {system_status}`,
                variables: [
                    'date',
                    'total_alerts',
                    'critical_alerts',
                    'high_alerts',
                    'medium_alerts',
                    'low_alerts',
                    'system_status',
                ],
            },
        ];
        templates.forEach(template => {
            this.notificationTemplates.set(template.id, template);
        });
    }
    initializeDashboards() {
        const defaultDashboards = [
            {
                id: 'main-overview',
                name: 'Основной обзор',
                description: 'Общий обзор состояния системы',
                metrics: ['cpu_usage', 'memory_usage', 'disk_usage', 'network_latency'],
                refreshInterval: 30,
                layout: {
                    rows: 2,
                    columns: 2,
                    widgets: [
                        {
                            id: 'cpu-gauge',
                            type: 'gauge',
                            position: { row: 0, col: 0, width: 1, height: 1 },
                            config: { title: 'CPU Usage', min: 0, max: 100, unit: '%' },
                        },
                        {
                            id: 'memory-gauge',
                            type: 'gauge',
                            position: { row: 0, col: 1, width: 1, height: 1 },
                            config: { title: 'Memory Usage', min: 0, max: 100, unit: '%' },
                        },
                        {
                            id: 'disk-chart',
                            type: 'chart',
                            position: { row: 1, col: 0, width: 1, height: 1 },
                            config: { title: 'Disk Usage', type: 'line' },
                        },
                        {
                            id: 'network-status',
                            type: 'status',
                            position: { row: 1, col: 1, width: 1, height: 1 },
                            config: { title: 'Network Status' },
                        },
                    ],
                },
            },
        ];
        defaultDashboards.forEach(dashboard => {
            this.dashboards.set(dashboard.id, dashboard);
        });
    }
    async collectMetric(metric) {
        const metricId = `metric-${Date.now()}`;
        const fullMetric = {
            ...metric,
            id: metricId,
            timestamp: new Date(),
        };
        this.metrics.set(metricId, fullMetric);
        await this.checkAlertRules(fullMetric);
        return metricId;
    }
    async checkAlertRules(metric) {
        for (const rule of this.alertRules.values()) {
            if (!rule.enabled || rule.metricName !== metric.name)
                continue;
            if (rule.lastTriggered) {
                const cooldownMs = rule.cooldownPeriod * 60 * 1000;
                const timeSinceLastTrigger = Date.now() - rule.lastTriggered.getTime();
                if (timeSinceLastTrigger < cooldownMs) {
                    continue;
                }
            }
            const shouldTrigger = this.evaluateAlertRule(rule, metric);
            if (shouldTrigger) {
                await this.createAlert(rule, metric);
                rule.lastTriggered = new Date();
            }
        }
    }
    evaluateAlertRule(rule, metric) {
        switch (rule.condition) {
            case 'above':
                return metric.value > rule.threshold;
            case 'below':
                return metric.value < rule.threshold;
            case 'equals':
                return metric.value === rule.threshold;
            case 'not-equals':
                return metric.value !== rule.threshold;
            default:
                return false;
        }
    }
    async createAlert(rule, metric) {
        const alert = {
            id: `alert-${Date.now()}`,
            ruleId: rule.id,
            metricName: metric.name,
            severity: rule.severity,
            message: `${rule.name}: ${metric.value} ${metric.unit}`,
            currentValue: metric.value,
            threshold: rule.threshold,
            timestamp: new Date(),
            acknowledged: false,
            resolved: false,
            notificationSent: false,
        };
        this.alerts.set(alert.id, alert);
        this.redactedLogger.log(`Alert created`, 'AutomatedMonitoringService', {
            alertId: alert.id,
            rule: rule.name,
            severity: rule.severity,
            value: metric.value,
            threshold: rule.threshold,
        });
        await this.sendNotifications(alert, rule);
    }
    async sendNotifications(alert, rule) {
        for (const channel of rule.notificationChannels) {
            if (!channel.enabled)
                continue;
            try {
                await this.sendNotification(channel, alert);
                alert.notificationSent = true;
            }
            catch (error) {
                this.redactedLogger.errorWithData(`Failed to send notification via ${channel.type}`, {
                    channelId: channel.id,
                    alertId: alert.id,
                    error: error instanceof Error ? error.message : 'Unknown error',
                }, 'AutomatedMonitoringService');
            }
        }
    }
    async sendNotification(channel, alert) {
        const template = this.getNotificationTemplate(alert.severity);
        const message = this.formatMessage(template, alert);
        switch (channel.type) {
            case 'telegram':
                await this.sendTelegramNotification(channel, message);
                break;
            case 'viber':
                await this.sendViberNotification(channel, message);
                break;
            case 'email':
                await this.sendEmailNotification(channel, message, template.subject);
                break;
            case 'sms':
                await this.sendSmsNotification(channel, message);
                break;
            case 'webhook':
                await this.sendWebhookNotification(channel, message);
                break;
        }
    }
    getNotificationTemplate(severity) {
        if (severity === 'critical') {
            const template = this.notificationTemplates.get('alert-critical');
            if (template)
                return template;
        }
        else if (severity === 'high') {
            const template = this.notificationTemplates.get('alert-high');
            if (template)
                return template;
        }
        const fallbackTemplate = this.notificationTemplates.get('alert-high');
        if (fallbackTemplate)
            return fallbackTemplate;
        return {
            id: 'default',
            name: 'Default Template',
            type: 'alert',
            subject: 'Alert: {metric_name}',
            body: 'Metric {metric_name} exceeded threshold {threshold}',
            variables: ['metric_name', 'threshold'],
        };
    }
    formatMessage(template, alert) {
        let message = template.body;
        message = message.replace('{metric_name}', alert.metricName);
        message = message.replace('{current_value}', alert.currentValue.toString());
        message = message.replace('{threshold}', alert.threshold.toString());
        message = message.replace('{timestamp}', alert.timestamp.toLocaleString('ru-RU'));
        message = message.replace('{source}', 'Automated Monitoring');
        return message;
    }
    async sendTelegramNotification(channel, message) {
        const config = channel.config.telegram;
        if (!config)
            return;
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
        this.redactedLogger.log(`Telegram notification sent`, 'AutomatedMonitoringService', {
            chatId: config.chatId,
            messageLength: message.length,
        });
    }
    async sendViberNotification(channel, message) {
        const config = channel.config.viber;
        if (!config)
            return;
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
        this.redactedLogger.log(`Viber notification sent`, 'AutomatedMonitoringService', {
            userId: config.userId,
            messageLength: message.length,
        });
    }
    async sendEmailNotification(channel, message, subject) {
        const config = channel.config.email;
        if (!config)
            return;
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
        this.redactedLogger.log(`Email notification sent`, 'AutomatedMonitoringService', {
            to: config.to.join(', '),
            subject,
            messageLength: message.length,
        });
    }
    async sendSmsNotification(channel, message) {
        const config = channel.config.sms;
        if (!config)
            return;
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
        this.redactedLogger.log(`SMS notification sent`, 'AutomatedMonitoringService', {
            phoneNumbers: config.phoneNumbers.join(', '),
            messageLength: message.length,
        });
    }
    async sendWebhookNotification(channel, message) {
        const config = channel.config.webhook;
        if (!config)
            return;
        await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 700));
        this.redactedLogger.log(`Webhook notification sent`, 'AutomatedMonitoringService', {
            url: config.url,
            method: config.method,
            messageLength: message.length,
        });
    }
    async acknowledgeAlert(alertId) {
        const alert = this.alerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.acknowledged = true;
        alert.acknowledgedAt = new Date();
        this.redactedLogger.log(`Alert acknowledged`, 'AutomatedMonitoringService', {
            alertId,
            acknowledgedAt: alert.acknowledgedAt.toISOString(),
        });
        return true;
    }
    async resolveAlert(alertId) {
        const alert = this.alerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.resolved = true;
        alert.resolvedAt = new Date();
        this.redactedLogger.log(`Alert resolved`, 'AutomatedMonitoringService', {
            alertId,
            resolvedAt: alert.resolvedAt.toISOString(),
        });
        return true;
    }
    async getMetrics(metricName, limit = 100) {
        let metrics = Array.from(this.metrics.values());
        if (metricName !== undefined && metricName !== '') {
            metrics = metrics.filter(m => m.name === metricName);
        }
        metrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        return metrics.slice(0, limit);
    }
    async getAlertRules() {
        return Array.from(this.alertRules.values());
    }
    async getAlerts(severity, acknowledged, resolved) {
        let alerts = Array.from(this.alerts.values());
        if (severity) {
            alerts = alerts.filter(a => a.severity === severity);
        }
        if (acknowledged !== undefined) {
            alerts = alerts.filter(a => a.acknowledged === acknowledged);
        }
        if (resolved !== undefined) {
            alerts = alerts.filter(a => a.resolved === resolved);
        }
        alerts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        return alerts;
    }
    async getNotificationChannels() {
        return Array.from(this.notificationChannels.values());
    }
    async getDashboards() {
        return Array.from(this.dashboards.values());
    }
    async addAlertRule(rule) {
        const ruleId = `rule-${Date.now()}`;
        const newRule = {
            ...rule,
            id: ruleId,
        };
        this.alertRules.set(ruleId, newRule);
        return ruleId;
    }
    async updateAlertRule(ruleId, updates) {
        const rule = this.alertRules.get(ruleId);
        if (!rule) {
            return false;
        }
        Object.assign(rule, updates);
        return true;
    }
    async addNotificationChannel(channel) {
        const channelId = `channel-${Date.now()}`;
        const newChannel = {
            ...channel,
            id: channelId,
        };
        this.notificationChannels.set(channelId, newChannel);
        return channelId;
    }
    async getSystemStatus() {
        const totalMetrics = this.metrics.size;
        const activeAlerts = Array.from(this.alerts.values()).filter(a => !a.resolved).length;
        const criticalAlerts = Array.from(this.alerts.values()).filter(a => a.severity === 'critical' && !a.resolved).length;
        let systemHealth = 'healthy';
        if (criticalAlerts > 0) {
            systemHealth = 'critical';
        }
        else if (activeAlerts > 0) {
            systemHealth = 'degraded';
        }
        return {
            totalMetrics,
            activeAlerts,
            criticalAlerts,
            systemHealth,
        };
    }
    async generateDailyReport() {
        const alerts = Array.from(this.alerts.values());
        const today = new Date();
        const todayAlerts = alerts.filter(a => a.timestamp.toDateString() === today.toDateString());
        const criticalAlerts = todayAlerts.filter(a => a.severity === 'critical').length;
        const highAlerts = todayAlerts.filter(a => a.severity === 'high').length;
        const mediumAlerts = todayAlerts.filter(a => a.severity === 'medium').length;
        const lowAlerts = todayAlerts.filter(a => a.severity === 'low').length;
        const systemStatus = await this.getSystemStatus();
        return {
            date: today.toLocaleDateString('ru-RU'),
            totalAlerts: todayAlerts.length,
            criticalAlerts,
            highAlerts,
            mediumAlerts,
            lowAlerts,
            systemStatus: systemStatus.systemHealth,
        };
    }
    monitorCPU(serviceId) {
        const cpuUsage = Math.random() * 100;
        let status = 'normal';
        if (cpuUsage > 90) {
            status = 'critical';
        }
        else if (cpuUsage > 80) {
            status = 'warning';
        }
        return {
            serviceId,
            metric: 'cpu',
            value: Math.round(cpuUsage * 100) / 100,
            timestamp: new Date(),
            status,
        };
    }
    monitorMemory(serviceId) {
        const memoryUsage = Math.random() * 100;
        let status = 'normal';
        if (memoryUsage > 95) {
            status = 'critical';
        }
        else if (memoryUsage > 85) {
            status = 'warning';
        }
        return {
            serviceId,
            metric: 'memory',
            value: Math.round(memoryUsage * 100) / 100,
            timestamp: new Date(),
            status,
        };
    }
    monitorDisk(serviceId) {
        const diskUsage = Math.random() * 100;
        let status = 'normal';
        if (diskUsage > 95) {
            status = 'critical';
        }
        else if (diskUsage > 85) {
            status = 'warning';
        }
        return {
            serviceId,
            metric: 'disk',
            value: Math.round(diskUsage * 100) / 100,
            timestamp: new Date(),
            status,
        };
    }
    monitorNetwork(serviceId) {
        const networkUsage = Math.random() * 100;
        let status = 'normal';
        if (networkUsage > 90) {
            status = 'critical';
        }
        else if (networkUsage > 80) {
            status = 'warning';
        }
        return {
            serviceId,
            metric: 'network',
            value: Math.round(networkUsage * 100) / 100,
            timestamp: new Date(),
            status,
        };
    }
    sendAlert(alertConfig) {
        const alertId = `alert-${Date.now()}`;
        const status = Math.random() > 0.1 ? 'sent' : Math.random() > 0.5 ? 'queued' : 'failed';
        const alert = {
            id: alertId,
            ruleId: `rule-${Date.now()}`,
            metricName: alertConfig.metric,
            severity: alertConfig.severity,
            message: `${alertConfig.metric.toUpperCase()} usage ${alertConfig.value}% exceeds threshold ${alertConfig.threshold}%`,
            currentValue: alertConfig.value,
            threshold: alertConfig.threshold,
            timestamp: new Date(),
            acknowledged: false,
            resolved: false,
            notificationSent: status === 'sent',
        };
        this.alerts.set(alertId, alert);
        return {
            serviceId: alertConfig.serviceId,
            metric: alertConfig.metric,
            severity: alertConfig.severity,
            status,
            alertId,
            timestamp: alert.timestamp,
        };
    }
};
AutomatedMonitoringService = AutomatedMonitoringService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AutomatedMonitoringService);



/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CapacityPlanningService: () => (/* binding */ CapacityPlanningService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let CapacityPlanningService = class CapacityPlanningService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger();
        this.performanceBaselines = new Map();
        this.capacityForecasts = new Map();
        this.resourceCapacities = new Map();
        this.localClients = new Map();
        this.capacityRecommendations = new Map();
        this.performanceAnalyses = new Map();
        this.initializeLocalClients();
        this.initializePerformanceBaselines();
        this.initializeResourceCapacities();
    }
    initializeLocalClients() {
        const clients = [
            {
                id: 'client-by-ecommerce-1',
                name: 'BY-Ecommerce-1',
                region: 'BY',
                industry: 'ecommerce',
                size: 'medium',
                criticality: 'high',
                sla: {
                    uptime: 99.9,
                    responseTime: 200,
                    recoveryTime: 15,
                },
                peakHours: {
                    start: '18:00',
                    end: '22:00',
                    days: [1, 2, 3, 4, 5, 6],
                },
                seasonalPatterns: [
                    {
                        name: 'Новогодний сезон',
                        startMonth: 12,
                        endMonth: 1,
                        multiplier: 2.5,
                    },
                    {
                        name: 'Черная пятница',
                        startMonth: 11,
                        endMonth: 11,
                        multiplier: 3.0,
                    },
                ],
            },
            {
                id: 'client-ru-finance-1',
                name: 'RU-Finance-1',
                region: 'RU',
                industry: 'finance',
                size: 'large',
                criticality: 'critical',
                sla: {
                    uptime: 99.99,
                    responseTime: 100,
                    recoveryTime: 5,
                },
                peakHours: {
                    start: '09:00',
                    end: '18:00',
                    days: [1, 2, 3, 4, 5],
                },
                seasonalPatterns: [
                    {
                        name: 'Квартальный отчет',
                        startMonth: 3,
                        endMonth: 3,
                        multiplier: 1.8,
                    },
                    {
                        name: 'Годовой отчет',
                        startMonth: 12,
                        endMonth: 12,
                        multiplier: 2.2,
                    },
                ],
            },
            {
                id: 'client-by-government-1',
                name: 'BY-Government-1',
                region: 'BY',
                industry: 'government',
                size: 'enterprise',
                criticality: 'critical',
                sla: {
                    uptime: 99.95,
                    responseTime: 150,
                    recoveryTime: 10,
                },
                peakHours: {
                    start: '08:00',
                    end: '17:00',
                    days: [1, 2, 3, 4, 5],
                },
                seasonalPatterns: [
                    {
                        name: 'Бюджетный период',
                        startMonth: 10,
                        endMonth: 12,
                        multiplier: 1.5,
                    },
                ],
            },
        ];
        clients.forEach(client => {
            this.localClients.set(client.id, client);
        });
    }
    initializePerformanceBaselines() {
        const baselines = [
            {
                id: 'baseline-cpu-general',
                name: 'General CPU Performance Baseline',
                description: 'Базовый показатель производительности CPU для общих нагрузок',
                resourceType: 'cpu',
                metric: 'cpu_usage_percent',
                baselineValue: 45,
                unit: '%',
                confidence: 0.85,
                period: 'hourly',
                createdAt: new Date(),
                updatedAt: new Date(),
                dataPoints: 720,
            },
            {
                id: 'baseline-memory-general',
                name: 'General Memory Performance Baseline',
                description: 'Базовый показатель производительности памяти для общих нагрузок',
                resourceType: 'memory',
                metric: 'memory_usage_percent',
                baselineValue: 60,
                unit: '%',
                confidence: 0.82,
                period: 'hourly',
                createdAt: new Date(),
                updatedAt: new Date(),
                dataPoints: 720,
            },
            {
                id: 'baseline-database-response',
                name: 'Database Response Time Baseline',
                description: 'Базовый показатель времени ответа базы данных',
                resourceType: 'database',
                metric: 'query_response_time_ms',
                baselineValue: 25,
                unit: 'ms',
                confidence: 0.78,
                period: 'hourly',
                createdAt: new Date(),
                updatedAt: new Date(),
                dataPoints: 720,
            },
            {
                id: 'baseline-network-latency',
                name: 'Network Latency Baseline',
                description: 'Базовый показатель сетевой латентности',
                resourceType: 'network',
                metric: 'network_latency_ms',
                baselineValue: 15,
                unit: 'ms',
                confidence: 0.8,
                period: 'hourly',
                createdAt: new Date(),
                updatedAt: new Date(),
                dataPoints: 720,
            },
        ];
        baselines.forEach(baseline => {
            this.performanceBaselines.set(baseline.id, baseline);
        });
    }
    initializeResourceCapacities() {
        const capacities = [
            {
                id: 'capacity-cpu-cluster-1',
                name: 'CPU Cluster 1',
                type: 'cpu',
                currentCapacity: 32,
                unit: 'cores',
                maxCapacity: 64,
                utilization: 50,
                growthTrend: 'increasing',
                lastUpdated: new Date(),
                recommendations: [
                    'Мониторить рост нагрузки',
                    'Рассмотреть масштабирование через 3 месяца',
                ],
            },
            {
                id: 'capacity-memory-cluster-1',
                name: 'Memory Cluster 1',
                type: 'memory',
                currentCapacity: 128,
                unit: 'GB',
                maxCapacity: 256,
                utilization: 65,
                growthTrend: 'stable',
                lastUpdated: new Date(),
                recommendations: [
                    'Текущее использование в норме',
                    'Планировать обновление через 6 месяцев',
                ],
            },
            {
                id: 'capacity-storage-cluster-1',
                name: 'Storage Cluster 1',
                type: 'storage',
                currentCapacity: 2000,
                unit: 'GB',
                maxCapacity: 4000,
                utilization: 75,
                growthTrend: 'increasing',
                lastUpdated: new Date(),
                recommendations: [
                    'Высокое использование хранилища',
                    'Рассмотреть очистку неиспользуемых данных',
                    'Планировать расширение через 2 месяца',
                ],
            },
        ];
        capacities.forEach(capacity => {
            this.resourceCapacities.set(capacity.id, capacity);
        });
    }
    async createPerformanceBaseline(baseline) {
        const baselineId = `baseline-${Date.now()}`;
        const now = new Date();
        const fullBaseline = {
            ...baseline,
            id: baselineId,
            createdAt: now,
            updatedAt: now,
        };
        this.performanceBaselines.set(baselineId, fullBaseline);
        this.redactedLogger.log(`Performance baseline created`, 'CapacityPlanningService', {
            baselineId,
            name: baseline.name,
            resourceType: baseline.resourceType,
            metric: baseline.metric,
        });
        return baselineId;
    }
    async updatePerformanceBaseline(baselineId, updates) {
        const baseline = this.performanceBaselines.get(baselineId);
        if (!baseline) {
            return false;
        }
        Object.assign(baseline, updates);
        baseline.updatedAt = new Date();
        return true;
    }
    async generateCapacityForecast(baselineId, forecastPeriod, forecastDate) {
        const baseline = this.performanceBaselines.get(baselineId);
        if (!baseline) {
            throw new Error('Performance baseline not found');
        }
        const growthRate = this.calculateGrowthRate(baseline);
        const monthsToForecast = this.getMonthsFromPeriod(forecastPeriod);
        const predictedValue = baseline.baselineValue * (1 + (growthRate * monthsToForecast) / 100);
        const confidence = Math.max(0.5, baseline.confidence - monthsToForecast * 0.05);
        const forecast = {
            resourceType: baseline.resourceType,
            baselineId,
            forecastPeriod,
            forecastDate,
            predictedValue: Math.round(predictedValue * 100) / 100,
            confidence: Math.round(confidence * 100) / 100,
            upperBound: predictedValue * 1.2,
            lowerBound: predictedValue * 0.8,
            growthRate,
            factors: this.identifyGrowthFactors(baseline),
        };
        const fullForecast = {
            ...forecast,
            id: `forecast-${Date.now()}`,
        };
        this.capacityForecasts.set(fullForecast.id, fullForecast);
        this.redactedLogger.log(`Capacity forecast generated`, 'CapacityPlanningService', {
            forecastId: fullForecast.id,
            baselineId,
            period: forecastPeriod,
            predictedValue: forecast.predictedValue,
            confidence: forecast.confidence,
        });
        return fullForecast.id;
    }
    calculateGrowthRate(baseline) {
        const baseGrowthRate = 5;
        switch (baseline.resourceType) {
            case 'cpu':
                return baseGrowthRate * 1.2;
            case 'memory':
                return baseGrowthRate * 1.1;
            case 'storage':
                return baseGrowthRate * 1.5;
            case 'network':
                return baseGrowthRate * 0.8;
            default:
                return baseGrowthRate;
        }
    }
    getMonthsFromPeriod(period) {
        switch (period) {
            case '1h':
            case '6h':
            case '12h':
            case '1d':
                return 0.1;
            case '1w':
                return 0.25;
            case '1m':
                return 1;
            case '3m':
                return 3;
            case '6m':
                return 6;
            case '1y':
                return 12;
            default:
                return 1;
        }
    }
    identifyGrowthFactors(baseline) {
        const factors = [];
        switch (baseline.resourceType) {
            case 'cpu':
                factors.push('Увеличение пользовательской нагрузки');
                factors.push('Новые функции приложения');
                factors.push('Сезонные пики трафика');
                break;
            case 'memory':
                factors.push('Кэширование данных');
                factors.push('Увеличение размера сессий');
                factors.push('Новые модули системы');
                break;
            case 'storage':
                factors.push('Рост пользовательского контента');
                factors.push('Логи и аналитика');
                factors.push('Резервные копии');
                break;
            case 'network':
                factors.push('Увеличение трафика');
                factors.push('Новые региональные офисы');
                factors.push('Интеграции с внешними сервисами');
                break;
        }
        return factors;
    }
    async analyzeClientPerformance(clientId, baselineId, currentValue) {
        const client = this.localClients.get(clientId);
        const baseline = this.performanceBaselines.get(baselineId);
        if (!client || !baseline) {
            throw new Error('Client or baseline not found');
        }
        const deviation = ((currentValue - baseline.baselineValue) / baseline.baselineValue) * 100;
        const status = this.determinePerformanceStatus(deviation, client.criticality);
        const analysis = {
            id: `analysis-${Date.now()}`,
            clientId,
            baselineId,
            analysisDate: new Date(),
            currentValue,
            baselineValue: baseline.baselineValue,
            deviation: Math.round(deviation * 100) / 100,
            status,
            factors: this.analyzePerformanceFactors(deviation, baseline, client),
            recommendations: this.generatePerformanceRecommendations(deviation, status, baseline, client),
        };
        this.performanceAnalyses.set(analysis.id, analysis);
        if (status === 'critical' || status === 'warning') {
            await this.generateCapacityRecommendations(clientId, baseline, deviation);
        }
        return analysis.id;
    }
    determinePerformanceStatus(deviation, criticality) {
        const criticalityMultiplier = {
            low: 1.5,
            medium: 1.2,
            high: 1.0,
            critical: 0.8,
        };
        const threshold = 20 * criticalityMultiplier[criticality];
        if (Math.abs(deviation) > threshold) {
            return 'critical';
        }
        else if (Math.abs(deviation) > threshold * 0.6) {
            return 'warning';
        }
        else if (deviation < -10) {
            return 'improved';
        }
        else {
            return 'normal';
        }
    }
    analyzePerformanceFactors(deviation, _baseline, client) {
        const factors = [];
        if (deviation > 0) {
            factors.push('Увеличение нагрузки выше базового уровня');
            const currentMonth = new Date().getMonth() + 1;
            const seasonalPattern = client.seasonalPatterns.find(pattern => currentMonth >= pattern.startMonth && currentMonth <= pattern.endMonth);
            if (seasonalPattern) {
                factors.push(`Сезонный рост: ${seasonalPattern.name}`);
            }
            const currentHour = new Date().getHours();
            const currentDay = new Date().getDay();
            const startHour = client.peakHours.start.split(':')[0];
            const endHour = client.peakHours.end.split(':')[0];
            if (startHour != null &&
                endHour != null &&
                startHour !== '' &&
                endHour !== '') {
                const isPeakHour = client.peakHours.days.includes(currentDay) &&
                    currentHour >= parseInt(startHour) &&
                    currentHour <= parseInt(endHour);
                if (isPeakHour) {
                    factors.push('Пиковые часы работы');
                }
            }
        }
        else if (deviation < 0) {
            factors.push('Снижение нагрузки ниже базового уровня');
            factors.push('Возможная оптимизация ресурсов');
        }
        return factors;
    }
    generatePerformanceRecommendations(deviation, status, _baseline, client) {
        const recommendations = [];
        if (status === 'critical' || status === 'warning') {
            if (deviation > 0) {
                recommendations.push('Немедленно увеличить ресурсы');
                recommendations.push('Активировать автоматическое масштабирование');
                recommendations.push('Проверить настройки оптимизации');
            }
        }
        else if (status === 'improved') {
            recommendations.push('Рассмотреть возможность снижения ресурсов');
            recommendations.push('Оптимизировать стоимость инфраструктуры');
        }
        if (client.criticality === 'critical') {
            recommendations.push('Добавить резервные мощности');
            recommendations.push('Улучшить мониторинг производительности');
        }
        return recommendations;
    }
    async generateCapacityRecommendations(clientId, baseline, deviation) {
        const recommendation = {
            id: `recommendation-${Date.now()}`,
            clientId,
            resourceType: baseline.resourceType,
            type: deviation > 0 ? 'scale-up' : 'optimize',
            priority: Math.abs(deviation) > 50 ? 'critical' : 'high',
            description: `Требуется ${deviation > 0 ? 'увеличение' : 'оптимизация'} ресурсов ${baseline.resourceType}`,
            estimatedCost: this.estimateRecommendationCost(baseline, deviation),
            currency: 'BYN',
            implementationEffort: Math.abs(deviation) > 30 ? 'high' : 'medium',
            expectedImpact: Math.abs(deviation) > 50 ? 'significant' : 'moderate',
            timeline: Math.abs(deviation) > 50 ? 'immediate' : '1week',
            createdAt: new Date(),
            status: 'pending',
        };
        this.capacityRecommendations.set(recommendation.id, recommendation);
    }
    estimateRecommendationCost(baseline, deviation) {
        const baseCosts = {
            cpu: 100,
            memory: 80,
            storage: 50,
            network: 120,
            database: 200,
            application: 150,
        };
        const baseCost = baseCosts[baseline.resourceType] || 100;
        const deviationMultiplier = Math.abs(deviation) / 100;
        return Math.round(baseCost * deviationMultiplier * 100) / 100;
    }
    async getClientCapacityReport(clientId) {
        const client = this.localClients.get(clientId);
        if (!client) {
            throw new Error('Client not found');
        }
        const currentPerformance = Array.from(this.performanceAnalyses.values())
            .filter(analysis => analysis.clientId === clientId)
            .sort((a, b) => b.analysisDate.getTime() - a.analysisDate.getTime());
        const forecasts = Array.from(this.capacityForecasts.values()).filter(forecast => this.performanceBaselines.has(forecast.baselineId));
        const recommendations = Array.from(this.capacityRecommendations.values())
            .filter(rec => rec.clientId === clientId)
            .sort((a, b) => {
            const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
            return priorityOrder[b.priority] - priorityOrder[a.priority];
        });
        const resourceUtilization = Array.from(this.resourceCapacities.values());
        return {
            client,
            currentPerformance,
            forecasts,
            recommendations,
            resourceUtilization,
        };
    }
    async getPerformanceBaselines() {
        return Array.from(this.performanceBaselines.values());
    }
    async getCapacityForecasts() {
        return Array.from(this.capacityForecasts.values());
    }
    async getResourceCapacities() {
        return Array.from(this.resourceCapacities.values());
    }
    async getLocalClients() {
        return Array.from(this.localClients.values());
    }
    async getCapacityRecommendations() {
        return Array.from(this.capacityRecommendations.values());
    }
    async getPerformanceAnalyses() {
        return Array.from(this.performanceAnalyses.values());
    }
    async addLocalClient(client) {
        const clientId = `client-${Date.now()}`;
        const newClient = {
            ...client,
            id: clientId,
        };
        this.localClients.set(clientId, newClient);
        return clientId;
    }
    async updateCapacityRecommendation(recommendationId, updates) {
        const recommendation = this.capacityRecommendations.get(recommendationId);
        if (!recommendation) {
            return false;
        }
        Object.assign(recommendation, updates);
        return true;
    }
    analyzeCurrentCapacity(serviceId) {
        const cpuCurrent = Math.random() * 8 + 2;
        const cpuMax = 16;
        const memoryCurrent = Math.random() * 32 + 8;
        const memoryMax = 64;
        const storageCurrent = Math.random() * 500 + 100;
        const storageMax = 1000;
        const recommendations = [];
        if (cpuCurrent / cpuMax > 0.8) {
            recommendations.push('Consider scaling up CPU resources');
        }
        if (memoryCurrent / memoryMax > 0.8) {
            recommendations.push('Consider scaling up memory resources');
        }
        if (storageCurrent / storageMax > 0.8) {
            recommendations.push('Consider scaling up storage capacity');
        }
        return {
            serviceId,
            cpu: {
                current: Math.round(cpuCurrent * 100) / 100,
                max: cpuMax,
                utilization: Math.round((cpuCurrent / cpuMax) * 100 * 100) / 100,
            },
            memory: {
                current: Math.round(memoryCurrent * 100) / 100,
                max: memoryMax,
                utilization: Math.round((memoryCurrent / memoryMax) * 100 * 100) / 100,
            },
            storage: {
                current: Math.round(storageCurrent * 100) / 100,
                max: storageMax,
                utilization: Math.round((storageCurrent / storageMax) * 100 * 100) / 100,
            },
            recommendations,
        };
    }
    forecastCapacityNeeds(serviceId, period) {
        const predictions = [
            {
                resourceType: 'cpu',
                currentValue: Math.random() * 8 + 2,
                predictedValue: Math.random() * 12 + 4,
                growthRate: Math.random() * 20 + 5,
                confidence: Math.random() * 30 + 70,
            },
            {
                resourceType: 'memory',
                currentValue: Math.random() * 32 + 8,
                predictedValue: Math.random() * 48 + 16,
                growthRate: Math.random() * 25 + 10,
                confidence: Math.random() * 25 + 75,
            },
            {
                resourceType: 'storage',
                currentValue: Math.random() * 500 + 100,
                predictedValue: Math.random() * 750 + 200,
                growthRate: Math.random() * 30 + 15,
                confidence: Math.random() * 20 + 80,
            },
        ];
        const recommendations = predictions
            .filter(p => p.growthRate > 20)
            .map(p => `Plan for ${p.resourceType.toUpperCase()} scaling - expected growth: ${Math.round(p.growthRate)}%`);
        return {
            serviceId,
            period,
            predictions: predictions.map(p => ({
                ...p,
                currentValue: Math.round(p.currentValue * 100) / 100,
                predictedValue: Math.round(p.predictedValue * 100) / 100,
                growthRate: Math.round(p.growthRate * 100) / 100,
                confidence: Math.round(p.confidence * 100) / 100,
            })),
            recommendations,
        };
    }
    createScalingPlan(serviceId) {
        const recommendations = [
            {
                resourceType: 'CPU',
                action: 'Scale up from 4 to 8 cores',
                priority: 'short_term',
                estimatedCost: 150,
                timeline: '2 weeks',
            },
            {
                resourceType: 'Memory',
                action: 'Increase from 16GB to 32GB',
                priority: 'short_term',
                estimatedCost: 200,
                timeline: '2 weeks',
            },
            {
                resourceType: 'Storage',
                action: 'Expand from 500GB to 1TB',
                priority: 'long_term',
                estimatedCost: 100,
                timeline: '3 months',
            },
        ];
        const totalEstimatedCost = recommendations.reduce((sum, rec) => sum + rec.estimatedCost, 0);
        const priority = recommendations.some((r) => r.priority === 'immediate')
            ? 'immediate'
            : recommendations.some((r) => r.priority === 'short_term')
                ? 'short_term'
                : 'long_term';
        return {
            serviceId,
            recommendations,
            priority,
            totalEstimatedCost,
        };
    }
    async performStressTest(serviceId, testScenario) {
        const duration = testScenario.duration;
        await new Promise(resolve => setTimeout(resolve, Math.min(duration * 1000, 100)));
        const maxCpuUsage = Math.min(testScenario.cpuLoad + Math.random() * 20, 100);
        const maxMemoryUsage = Math.min(testScenario.memoryLoad + Math.random() * 15, 100);
        const maxStorageUsage = Math.min(testScenario.storageLoad + Math.random() * 10, 100);
        const maxNetworkUsage = Math.min(testScenario.networkLoad + Math.random() * 25, 100);
        const recommendations = [];
        let success = true;
        if (maxCpuUsage > 90) {
            recommendations.push('CPU usage exceeded 90% - consider scaling up');
            success = false;
        }
        if (maxMemoryUsage > 90) {
            recommendations.push('Memory usage exceeded 90% - consider scaling up');
            success = false;
        }
        if (maxStorageUsage > 90) {
            recommendations.push('Storage usage exceeded 90% - consider expansion');
            success = false;
        }
        if (maxNetworkUsage > 90) {
            recommendations.push('Network usage exceeded 90% - consider bandwidth upgrade');
            success = false;
        }
        if (recommendations.length === 0) {
            recommendations.push('System handled stress test successfully');
        }
        return {
            serviceId,
            success,
            recommendations,
            metrics: {
                maxCpuUsage: Math.round(maxCpuUsage * 100) / 100,
                maxMemoryUsage: Math.round(maxMemoryUsage * 100) / 100,
                maxStorageUsage: Math.round(maxStorageUsage * 100) / 100,
                maxNetworkUsage: Math.round(maxNetworkUsage * 100) / 100,
            },
        };
    }
};
CapacityPlanningService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CapacityPlanningService);



/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OperationalRunbooksService: () => (/* binding */ OperationalRunbooksService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let OperationalRunbooksService = class OperationalRunbooksService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger();
        this.runbooks = new Map();
        this.incidentTypes = new Map();
        this.incidentResponses = new Map();
        this.maintenanceProcedures = new Map();
        this.troubleshootingGuides = new Map();
        this.initializeRunbooks();
        this.initializeIncidentTypes();
        this.initializeMaintenanceProcedures();
        this.initializeTroubleshootingGuides();
    }
    initializeRunbooks() {
        const runbooks = [
            {
                id: 'runbook-server-outage-response',
                name: 'Server Outage Response',
                description: 'Standard procedure for responding to server outages and service disruptions',
                category: 'incident-response',
                priority: 'high',
                tags: ['server', 'outage', 'incident', 'response'],
                version: '1.0.0',
                lastUpdated: new Date(),
                author: 'System Administrator',
                status: 'active',
                estimatedTime: 30,
                prerequisites: [
                    'Access to monitoring systems',
                    'Server access credentials',
                    'Emergency contact list',
                ],
                tools: [
                    'SSH',
                    'Monitoring Dashboard',
                    'Alert System',
                    'Communication Tools',
                ],
                contacts: [
                    {
                        role: 'Primary On-Call',
                        name: 'Primary Engineer',
                        email: 'primary@company.com',
                        phone: '+375291234567',
                        telegram: '@primary_engineer',
                    },
                    {
                        role: 'Secondary On-Call',
                        name: 'Secondary Engineer',
                        email: 'secondary@company.com',
                        phone: '+375291234568',
                        telegram: '@secondary_engineer',
                    },
                ],
                steps: [
                    {
                        id: 'step-1',
                        order: 1,
                        title: 'Assess Situation',
                        description: 'Quickly assess the scope and impact of the outage',
                        type: 'manual',
                        estimatedTime: 5,
                        instructions: 'Check monitoring dashboards and alert systems to understand the current state',
                        expectedResult: 'Clear understanding of affected services and users',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Engineer',
                        notes: 'Focus on business impact assessment',
                    },
                    {
                        id: 'step-2',
                        order: 2,
                        title: 'Communicate Status',
                        description: 'Notify stakeholders about the outage',
                        type: 'automated',
                        estimatedTime: 2,
                        instructions: 'Send initial status update to all stakeholders',
                        expectedResult: 'Stakeholders informed of outage status',
                        failureAction: 'retry',
                        maxRetries: 3,
                        retryDelay: 30,
                        automationScript: 'send-outage-notification.sh',
                        requiredRole: 'Engineer',
                    },
                    {
                        id: 'step-3',
                        order: 3,
                        title: 'Investigate Root Cause',
                        description: 'Determine the underlying cause of the outage',
                        type: 'manual',
                        estimatedTime: 15,
                        instructions: 'Check logs, system metrics, and recent changes',
                        expectedResult: 'Identified root cause of the outage',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Senior Engineer',
                        notes: 'Document findings for post-incident review',
                    },
                    {
                        id: 'step-4',
                        order: 4,
                        title: 'Implement Fix',
                        description: 'Apply the necessary fix to resolve the outage',
                        type: 'manual',
                        estimatedTime: 8,
                        instructions: 'Execute the fix based on root cause analysis',
                        expectedResult: 'Service restored and functioning normally',
                        failureAction: 'retry',
                        maxRetries: 2,
                        retryDelay: 60,
                        requiredRole: 'Senior Engineer',
                        notes: 'Monitor closely after fix implementation',
                    },
                ],
                rollbackSteps: [
                    {
                        id: 'rollback-1',
                        order: 1,
                        title: 'Stop Fix Implementation',
                        description: 'Immediately stop the current fix if it causes issues',
                        type: 'manual',
                        estimatedTime: 2,
                        instructions: 'Stop any ongoing fix implementation',
                        expectedResult: 'Fix implementation stopped',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Engineer',
                    },
                    {
                        id: 'rollback-2',
                        order: 2,
                        title: 'Restore Previous State',
                        description: 'Restore the system to its previous working state',
                        type: 'manual',
                        estimatedTime: 10,
                        instructions: 'Use backup or restore procedures to return to previous state',
                        expectedResult: 'System restored to previous working state',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Senior Engineer',
                    },
                ],
                successCriteria: [
                    'All affected services restored',
                    'System performance back to normal',
                    'No data loss occurred',
                    'Stakeholders informed of resolution',
                ],
                failureCriteria: [
                    'Service still unavailable after fix',
                    'Performance degradation persists',
                    'Data integrity compromised',
                    'Escalation required',
                ],
                relatedRunbooks: [
                    'runbook-database-recovery',
                    'runbook-network-troubleshooting',
                ],
                attachments: [
                    {
                        name: 'Server Outage Checklist',
                        type: 'document',
                        url: '/docs/runbooks/server-outage-checklist.pdf',
                        description: 'Quick reference checklist for server outages',
                    },
                    {
                        name: 'Emergency Contact List',
                        type: 'template',
                        url: '/templates/emergency-contacts.json',
                        description: 'Template for emergency contact information',
                    },
                ],
            },
            {
                id: 'runbook-database-backup-restore',
                name: 'Database Backup and Restore',
                description: 'Procedure for creating database backups and restoring from them',
                category: 'maintenance',
                priority: 'medium',
                tags: ['database', 'backup', 'restore', 'maintenance'],
                version: '1.0.0',
                lastUpdated: new Date(),
                author: 'Database Administrator',
                status: 'active',
                estimatedTime: 45,
                prerequisites: [
                    'Database access credentials',
                    'Backup storage location',
                    'Maintenance window approval',
                ],
                tools: ['Database Client', 'Backup Tools', 'Monitoring System'],
                contacts: [
                    {
                        role: 'Database Administrator',
                        name: 'DB Admin',
                        email: 'dbadmin@company.com',
                        phone: '+375291234569',
                    },
                ],
                steps: [
                    {
                        id: 'step-1',
                        order: 1,
                        title: 'Verify Backup Requirements',
                        description: 'Ensure backup requirements are met before proceeding',
                        type: 'verification',
                        estimatedTime: 5,
                        instructions: 'Check available disk space and backup retention policies',
                        expectedResult: 'Backup requirements verified and met',
                        failureAction: 'abort',
                        maxRetries: 0,
                        retryDelay: 0,
                        verificationMethod: 'Check disk space and backup policies',
                        requiredRole: 'Database Administrator',
                    },
                    {
                        id: 'step-2',
                        order: 2,
                        title: 'Create Backup',
                        description: 'Create a full database backup',
                        type: 'automated',
                        estimatedTime: 20,
                        instructions: 'Execute backup command with appropriate parameters',
                        expectedResult: 'Backup created successfully',
                        failureAction: 'retry',
                        maxRetries: 3,
                        retryDelay: 300,
                        automationScript: 'create-db-backup.sh',
                        requiredRole: 'Database Administrator',
                    },
                    {
                        id: 'step-3',
                        order: 3,
                        title: 'Verify Backup Integrity',
                        description: 'Verify the backup file is valid and complete',
                        type: 'verification',
                        estimatedTime: 10,
                        instructions: 'Check backup file size and run integrity checks',
                        expectedResult: 'Backup integrity verified',
                        failureAction: 'retry',
                        maxRetries: 2,
                        retryDelay: 60,
                        verificationMethod: 'Backup integrity check',
                        requiredRole: 'Database Administrator',
                    },
                    {
                        id: 'step-4',
                        order: 4,
                        title: 'Test Restore Process',
                        description: 'Test the restore process in a safe environment',
                        type: 'manual',
                        estimatedTime: 10,
                        instructions: 'Perform a test restore to verify backup usability',
                        expectedResult: 'Restore process tested successfully',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Database Administrator',
                        notes: 'Use test environment only',
                    },
                ],
                rollbackSteps: [
                    {
                        id: 'rollback-1',
                        order: 1,
                        title: 'Stop Backup Process',
                        description: 'Stop any ongoing backup process',
                        type: 'manual',
                        estimatedTime: 2,
                        instructions: 'Terminate backup process if issues occur',
                        expectedResult: 'Backup process stopped',
                        failureAction: 'escalate',
                        maxRetries: 0,
                        retryDelay: 0,
                        requiredRole: 'Database Administrator',
                    },
                ],
                successCriteria: [
                    'Backup created successfully',
                    'Backup integrity verified',
                    'Restore process tested',
                    'Documentation updated',
                ],
                failureCriteria: [
                    'Backup creation failed',
                    'Backup integrity check failed',
                    'Restore test failed',
                    'Performance impact on production',
                ],
                relatedRunbooks: [
                    'runbook-database-recovery',
                    'runbook-maintenance-procedures',
                ],
                attachments: [
                    {
                        name: 'Backup Script Template',
                        type: 'script',
                        url: '/scripts/backup-template.sh',
                        description: 'Template script for database backups',
                    },
                ],
            },
        ];
        runbooks.forEach(runbook => {
            this.runbooks.set(runbook.id, runbook);
        });
    }
    initializeIncidentTypes() {
        const incidentTypes = [
            {
                id: 'incident-server-outage',
                name: 'Server Outage',
                description: 'Complete or partial server unavailability',
                severity: 'high',
                category: 'infrastructure',
                priority: 'p1',
                sla: {
                    responseTime: 5,
                    resolutionTime: 30,
                    escalationTime: 15,
                },
                runbooks: ['runbook-server-outage-response'],
                escalationPath: [
                    {
                        level: 1,
                        role: 'Primary On-Call Engineer',
                        contact: 'primary@company.com',
                        timeout: 5,
                    },
                    {
                        level: 2,
                        role: 'Senior Engineer',
                        contact: 'senior@company.com',
                        timeout: 15,
                    },
                    {
                        level: 3,
                        role: 'Engineering Manager',
                        contact: 'manager@company.com',
                        timeout: 30,
                    },
                ],
                notificationChannels: ['email', 'telegram', 'slack'],
                autoAssignment: true,
                defaultAssignee: 'primary-oncall',
            },
            {
                id: 'incident-database-performance',
                name: 'Database Performance Degradation',
                description: 'Significant decrease in database performance',
                severity: 'medium',
                category: 'infrastructure',
                priority: 'p2',
                sla: {
                    responseTime: 15,
                    resolutionTime: 60,
                    escalationTime: 30,
                },
                runbooks: ['runbook-database-troubleshooting'],
                escalationPath: [
                    {
                        level: 1,
                        role: 'Database Administrator',
                        contact: 'dbadmin@company.com',
                        timeout: 15,
                    },
                    {
                        level: 2,
                        role: 'Senior DBA',
                        contact: 'senior-dba@company.com',
                        timeout: 30,
                    },
                ],
                notificationChannels: ['email', 'telegram'],
                autoAssignment: true,
                defaultAssignee: 'dbadmin',
            },
        ];
        incidentTypes.forEach(incidentType => {
            this.incidentTypes.set(incidentType.id, incidentType);
        });
    }
    initializeMaintenanceProcedures() {
        const maintenanceProcedures = [
            {
                id: 'maintenance-database-backup',
                name: 'Database Backup Maintenance',
                description: 'Regular database backup and maintenance procedures',
                type: 'scheduled',
                category: 'infrastructure',
                priority: 'medium',
                estimatedDuration: 60,
                maintenanceWindow: {
                    startTime: '02:00',
                    endTime: '04:00',
                    timezone: 'Europe/Minsk',
                    recurrence: 'daily',
                },
                affectedServices: ['Database Service'],
                affectedUsers: 0,
                riskLevel: 'low',
                rollbackPlan: 'Restore from previous backup if issues occur',
                notificationChannels: ['email'],
                approvalRequired: false,
                approvers: [],
                runbooks: ['runbook-database-backup-restore'],
                checklist: [
                    {
                        item: 'Verify backup storage space',
                        completed: false,
                    },
                    {
                        item: 'Create full database backup',
                        completed: false,
                    },
                    {
                        item: 'Verify backup integrity',
                        completed: false,
                    },
                    {
                        item: 'Clean up old backup files',
                        completed: false,
                    },
                    {
                        item: 'Update backup documentation',
                        completed: false,
                    },
                ],
                status: 'planned',
                scheduledDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
            },
        ];
        maintenanceProcedures.forEach(procedure => {
            this.maintenanceProcedures.set(procedure.id, procedure);
        });
    }
    initializeTroubleshootingGuides() {
        const troubleshootingGuides = [
            {
                id: 'guide-slow-database-queries',
                name: 'Slow Database Queries Troubleshooting',
                description: 'Guide for identifying and resolving slow database query performance issues',
                symptom: 'Database queries taking longer than expected to execute',
                category: 'performance',
                severity: 'medium',
                affectedComponents: ['Database', 'Application', 'API'],
                commonCauses: [
                    'Missing database indexes',
                    'Inefficient query structure',
                    'Large result sets',
                    'Database resource constraints',
                    'Network latency',
                ],
                diagnosticSteps: [
                    {
                        step: 1,
                        action: 'Identify slow queries',
                        expectedResult: 'List of queries with execution times',
                        failureResult: 'Unable to identify slow queries',
                        nextStep: 'Analyze query execution plans',
                        tools: ['Database Monitoring', 'Query Analyzer'],
                        commands: ['SHOW PROCESSLIST', 'EXPLAIN ANALYZE'],
                    },
                    {
                        step: 2,
                        action: 'Analyze query execution plans',
                        expectedResult: 'Understanding of query execution path',
                        failureResult: 'Unable to analyze execution plans',
                        nextStep: 'Check database indexes',
                        tools: ['Query Analyzer'],
                        commands: ['EXPLAIN', 'ANALYZE TABLE'],
                    },
                    {
                        step: 3,
                        action: 'Check database indexes',
                        expectedResult: 'Index usage analysis',
                        failureResult: 'Index analysis failed',
                        nextStep: 'Review query structure',
                        tools: ['Database Client'],
                        commands: ['SHOW INDEX', 'ANALYZE TABLE'],
                    },
                ],
                quickFixes: [
                    {
                        name: 'Add Missing Indexes',
                        description: 'Create indexes for frequently queried columns',
                        successRate: 0.8,
                        risk: 'low',
                        estimatedTime: 15,
                        steps: [
                            'Identify missing indexes',
                            'Create appropriate indexes',
                            'Monitor performance improvement',
                        ],
                    },
                    {
                        name: 'Optimize Query Structure',
                        description: 'Rewrite queries for better performance',
                        successRate: 0.7,
                        risk: 'medium',
                        estimatedTime: 30,
                        steps: [
                            'Analyze query logic',
                            'Rewrite for efficiency',
                            'Test performance impact',
                        ],
                    },
                ],
                escalationCriteria: [
                    'Performance degradation persists after fixes',
                    'Multiple services affected',
                    'Business impact significant',
                ],
                relatedIssues: ['Database Connection Issues', 'Memory Usage Problems'],
                preventionTips: [
                    'Regular query performance monitoring',
                    'Proactive index maintenance',
                    'Query optimization reviews',
                    'Resource capacity planning',
                ],
                documentation: [
                    'Database Performance Tuning Guide',
                    'Query Optimization Best Practices',
                    'Index Management Procedures',
                ],
                lastUpdated: new Date(),
                author: 'Database Administrator',
                status: 'active',
            },
        ];
        troubleshootingGuides.forEach(guide => {
            this.troubleshootingGuides.set(guide.id, guide);
        });
    }
    async createRunbook(runbook) {
        const runbookId = `runbook-${Date.now()}`;
        const newRunbook = {
            ...runbook,
            id: runbookId,
            lastUpdated: new Date(),
        };
        this.runbooks.set(runbookId, newRunbook);
        this.redactedLogger.log(`Runbook created`, 'OperationalRunbooksService', {
            runbookId,
            name: newRunbook.name,
            category: newRunbook.category,
        });
        return runbookId;
    }
    async updateRunbook(runbookId, updates) {
        const runbook = this.runbooks.get(runbookId);
        if (!runbook) {
            return false;
        }
        Object.assign(runbook, updates);
        runbook.lastUpdated = new Date();
        this.redactedLogger.log(`Runbook updated`, 'OperationalRunbooksService', {
            runbookId,
            name: runbook.name,
        });
        return true;
    }
    async createIncidentResponse(incident) {
        const incidentId = `incident-${Date.now()}`;
        const newIncident = {
            ...incident,
            id: incidentId,
            detectedAt: new Date(),
            status: 'new',
            slaBreach: false,
            timeline: [
                {
                    timestamp: new Date(),
                    action: 'Incident created',
                    user: incident.reporter,
                    details: 'Initial incident report',
                },
            ],
        };
        this.incidentResponses.set(incidentId, newIncident);
        this.redactedLogger.log(`Incident response created`, 'OperationalRunbooksService', {
            incidentId,
            title: newIncident.title,
            severity: newIncident.severity,
        });
        return incidentId;
    }
    async updateIncidentStatus(incidentId, status, userId, details) {
        const incident = this.incidentResponses.get(incidentId);
        if (!incident) {
            return false;
        }
        incident.status = status;
        incident.timeline.push({
            timestamp: new Date(),
            action: `Status changed to ${status}`,
            user: userId,
            details,
        });
        switch (status) {
            case 'assigned':
                incident.assignedAt = new Date();
                break;
            case 'in-progress':
                incident.startedAt = new Date();
                break;
            case 'resolved':
                if (incident.resolvedAt !== undefined) {
                    incident.resolvedAt = new Date();
                }
                break;
            case 'closed':
                incident.closedAt = new Date();
                break;
        }
        if (status === 'resolved' || status === 'closed') {
            const incidentType = this.incidentTypes.get(incident.incidentTypeId);
            if (incidentType) {
                const resolutionTime = incident.resolvedAt !== undefined
                    ? (incident.resolvedAt.getTime() - incident.detectedAt.getTime()) /
                        (1000 * 60)
                    : 0;
                incident.slaBreach = resolutionTime > incidentType.sla.resolutionTime;
                if (incident.slaBreach) {
                    incident.slaBreachReason = `Resolution time ${resolutionTime} minutes exceeded SLA of ${incidentType.sla.resolutionTime} minutes`;
                }
            }
        }
        this.redactedLogger.log(`Incident status updated`, 'OperationalRunbooksService', {
            incidentId,
            status,
            userId,
        });
        return true;
    }
    async createMaintenanceProcedure(procedure) {
        const procedureId = `maintenance-${Date.now()}`;
        const newProcedure = {
            ...procedure,
            id: procedureId,
            status: 'planned',
        };
        this.maintenanceProcedures.set(procedureId, newProcedure);
        this.redactedLogger.log(`Maintenance procedure created`, 'OperationalRunbooksService', {
            procedureId,
            name: newProcedure.name,
            type: newProcedure.type,
        });
        return procedureId;
    }
    async updateMaintenanceStatus(procedureId, status, userId, notes) {
        const procedure = this.maintenanceProcedures.get(procedureId);
        if (!procedure) {
            return false;
        }
        procedure.status = status;
        if (notes != null) {
            procedure.notes = notes;
        }
        if (status === 'in-progress') {
            procedure.startedAt = new Date();
            procedure.executor = userId;
        }
        else if (status === 'completed') {
            procedure.completedAt = new Date();
        }
        this.redactedLogger.log(`Maintenance procedure status updated`, 'OperationalRunbooksService', {
            procedureId,
            status,
            userId,
        });
        return true;
    }
    async getRunbooks(category, status) {
        let runbooks = Array.from(this.runbooks.values());
        if (category) {
            runbooks = runbooks.filter(r => r.category === category);
        }
        if (status) {
            runbooks = runbooks.filter(r => r.status === status);
        }
        return runbooks.sort((a, b) => b.lastUpdated.getTime() - a.lastUpdated.getTime());
    }
    async getIncidentTypes() {
        return Array.from(this.incidentTypes.values());
    }
    async getIncidentResponses(status, severity) {
        let incidents = Array.from(this.incidentResponses.values());
        if (status) {
            incidents = incidents.filter(i => i.status === status);
        }
        if (severity) {
            incidents = incidents.filter(i => i.severity === severity);
        }
        return incidents.sort((a, b) => b.detectedAt.getTime() - a.detectedAt.getTime());
    }
    async getMaintenanceProcedures(type, status) {
        let procedures = Array.from(this.maintenanceProcedures.values());
        if (type) {
            procedures = procedures.filter(p => p.type === type);
        }
        if (status) {
            procedures = procedures.filter(p => p.status === status);
        }
        return procedures.sort((a, b) => {
            if (a.scheduledDate && b.scheduledDate) {
                return a.scheduledDate.getTime() - b.scheduledDate.getTime();
            }
            return 0;
        });
    }
    async getTroubleshootingGuides(category) {
        let guides = Array.from(this.troubleshootingGuides.values());
        if (category) {
            guides = guides.filter(g => g.category === category);
        }
        return guides.sort((a, b) => b.lastUpdated.getTime() - a.lastUpdated.getTime());
    }
    async searchRunbooks(query) {
        const searchTerm = query.toLowerCase();
        return Array.from(this.runbooks.values()).filter(runbook => runbook.name.toLowerCase().includes(searchTerm) ||
            runbook.description.toLowerCase().includes(searchTerm) ||
            runbook.tags.some(tag => tag.toLowerCase().includes(searchTerm)));
    }
    async getRunbookById(runbookId) {
        return this.runbooks.get(runbookId) ?? null;
    }
    async getIncidentResponseById(incidentId) {
        return this.incidentResponses.get(incidentId) ?? null;
    }
    async getMaintenanceProcedureById(procedureId) {
        return this.maintenanceProcedures.get(procedureId) ?? null;
    }
    async getTroubleshootingGuideById(guideId) {
        return this.troubleshootingGuides.get(guideId) ?? null;
    }
    async deleteRunbook(runbookId) {
        const runbook = this.runbooks.get(runbookId);
        if (!runbook) {
            return false;
        }
        this.runbooks.delete(runbookId);
        this.redactedLogger.log(`Runbook deleted`, 'OperationalRunbooksService', {
            runbookId,
            name: runbook.name,
        });
        return true;
    }
    async getRunbookStatistics() {
        const runbooks = Array.from(this.runbooks.values());
        const activeRunbooks = runbooks.filter(r => r.status === 'active');
        const categories = {};
        runbooks.forEach(r => {
            categories[r.category] = (categories[r.category] ?? 0) + 1;
        });
        const totalSteps = runbooks.reduce((sum, r) => sum + r.steps.length, 0);
        const averageSteps = runbooks.length > 0 ? totalSteps / runbooks.length : 0;
        const mostUsedRunbooks = [
            {
                id: 'runbook-server-outage-response',
                name: 'Server Outage Response',
                usageCount: 15,
            },
            {
                id: 'runbook-database-backup-restore',
                name: 'Database Backup and Restore',
                usageCount: 8,
            },
        ];
        return {
            totalRunbooks: runbooks.length,
            activeRunbooks: activeRunbooks.length,
            categories,
            averageSteps: Math.round(averageSteps * 100) / 100,
            mostUsedRunbooks,
        };
    }
    createIncidentResponseRunbook(_incidentType) {
        const runbookId = `runbook-${Date.now()}`;
        const steps = [
            {
                order: 1,
                title: 'Assess Impact',
                description: 'Evaluate the scope and severity of the incident',
                action: 'Document affected services and users',
            },
            {
                order: 2,
                title: 'Contain Issue',
                description: 'Implement immediate measures to prevent escalation',
                action: 'Apply emergency fixes or workarounds',
            },
            {
                order: 3,
                title: 'Communicate Status',
                description: 'Notify stakeholders and update status page',
                action: 'Send incident notifications',
            },
        ];
        return {
            id: runbookId,
            type: 'incident_response',
            steps,
            status: 'active',
            priority: 'high',
        };
    }
    createMaintenanceRunbook(_maintenanceType) {
        const runbookId = `runbook-${Date.now()}`;
        const steps = [
            {
                order: 1,
                title: 'Pre-maintenance Check',
                description: 'Verify system health before maintenance',
                action: 'Run health checks and backups',
            },
            {
                order: 2,
                title: 'Execute Maintenance',
                description: 'Perform scheduled maintenance tasks',
                action: 'Apply updates and configurations',
            },
            {
                order: 3,
                title: 'Post-maintenance Verification',
                description: 'Confirm system functionality after maintenance',
                action: 'Run tests and verify services',
            },
        ];
        return {
            id: runbookId,
            type: 'maintenance',
            steps,
            status: 'active',
            priority: 'medium',
        };
    }
    createDeploymentRunbook(_deploymentType) {
        const runbookId = `runbook-${Date.now()}`;
        const steps = [
            {
                order: 1,
                title: 'Pre-deployment Validation',
                description: 'Validate deployment artifacts and environment',
                action: 'Run automated tests and checks',
            },
            {
                order: 2,
                title: 'Deploy Application',
                description: 'Execute deployment process',
                action: 'Deploy to target environment',
            },
            {
                order: 3,
                title: 'Post-deployment Verification',
                description: 'Verify successful deployment',
                action: 'Run smoke tests and health checks',
            },
        ];
        return {
            id: runbookId,
            type: 'deployment',
            steps,
            status: 'active',
            priority: 'high',
        };
    }
    executeRunbook(runbookId) {
        const runbook = this.runbooks.get(runbookId);
        if (!runbook) {
            return {
                runbookId,
                status: 'failed',
                startTime: new Date(),
                currentStep: 0,
                totalSteps: 0,
                progress: 0,
            };
        }
        const currentStep = Math.floor(Math.random() * runbook.steps.length) + 1;
        const totalSteps = runbook.steps.length;
        const progress = (currentStep / totalSteps) * 100;
        let status;
        if (progress >= 100) {
            status = 'completed';
        }
        else if (Math.random() > 0.1) {
            status = 'running';
        }
        else {
            status = 'failed';
        }
        return {
            runbookId,
            status,
            startTime: new Date(),
            currentStep,
            totalSteps,
            progress: Math.round(progress * 100) / 100,
        };
    }
};
OperationalRunbooksService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], OperationalRunbooksService);



/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DevOpsIntegrationService: () => (/* binding */ DevOpsIntegrationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let DevOpsIntegrationService = class DevOpsIntegrationService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger();
        this.terraformConfigs = new Map();
        this.ansiblePlaybooks = new Map();
        this.cicdPipelines = new Map();
        this.deploymentStrategies = new Map();
        this.localProviderIntegrations = new Map();
        this.initializeLocalProviderIntegrations();
        this.initializeTerraformConfigurations();
        this.initializeAnsiblePlaybooks();
        this.initializeCICDPipelines();
        this.initializeDeploymentStrategies();
    }
    initializeLocalProviderIntegrations() {
        const integrations = [
            {
                id: 'integration-hoster-by',
                name: 'Hoster.by Integration',
                provider: 'hoster-by',
                region: 'BY',
                credentials: {
                    accessKey: 'hoster-by-access-key',
                    secretKey: 'hoster-by-secret-key',
                    endpoint: 'https://api.hoster.by',
                },
                services: ['compute', 'storage', 'network', 'database'],
                quotas: {
                    'compute.instances': 100,
                    'storage.volumes': 200,
                    'network.floating_ips': 50,
                    'database.instances': 20,
                },
                pricing: {
                    currency: 'BYN',
                    rates: {
                        'compute.small': 2.5,
                        'compute.medium': 5.0,
                        'compute.large': 10.0,
                        'storage.gb': 0.1,
                        'network.gb': 0.05,
                    },
                    discounts: {
                        'reserved-instance': 0.3,
                        'volume-discount': 0.2,
                    },
                },
                compliance: {
                    dataResidency: 'true',
                    localRegulations: 'true',
                    auditLogging: 'true',
                },
                status: 'active',
                lastSync: new Date(),
                syncEnabled: true,
                syncInterval: 15,
            },
            {
                id: 'integration-becloud',
                name: 'BeCloud Integration',
                provider: 'becloud',
                region: 'BY',
                credentials: {
                    accessKey: 'becloud-access-key',
                    secretKey: 'becloud-secret-key',
                    endpoint: 'https://api.becloud.by',
                },
                services: ['compute', 'storage', 'network', 'kubernetes'],
                quotas: {
                    'compute.instances': 80,
                    'storage.volumes': 150,
                    'network.floating_ips': 40,
                    'kubernetes.clusters': 10,
                },
                pricing: {
                    currency: 'BYN',
                    rates: {
                        'compute.small': 2.8,
                        'compute.medium': 5.5,
                        'compute.large': 11.0,
                        'storage.gb': 0.12,
                        'network.gb': 0.06,
                    },
                    discounts: {
                        'reserved-instance': 0.25,
                        'volume-discount': 0.15,
                    },
                },
                compliance: {
                    dataResidency: 'true',
                    localRegulations: 'true',
                    auditLogging: 'true',
                },
                status: 'active',
                lastSync: new Date(),
                syncEnabled: true,
                syncInterval: 15,
            },
            {
                id: 'integration-vk-cloud',
                name: 'VK Cloud Integration',
                provider: 'vk-cloud',
                region: 'RU',
                credentials: {
                    accessKey: 'vk-cloud-access-key',
                    secretKey: 'vk-cloud-secret-key',
                    endpoint: 'https://api.vk.cloud',
                    projectId: 'vk-cloud-project-id',
                },
                services: ['compute', 'storage', 'network', 'ai', 'iot'],
                quotas: {
                    'compute.instances': 200,
                    'storage.volumes': 500,
                    'network.floating_ips': 100,
                    'ai.gpu_instances': 20,
                },
                pricing: {
                    currency: 'RUB',
                    rates: {
                        'compute.small': 150,
                        'compute.medium': 300,
                        'compute.large': 600,
                        'storage.gb': 8,
                        'network.gb': 4,
                    },
                    discounts: {
                        'reserved-instance': 0.35,
                        'volume-discount': 0.25,
                    },
                },
                compliance: {
                    dataResidency: 'true',
                    localRegulations: 'true',
                    auditLogging: 'true',
                },
                status: 'active',
                lastSync: new Date(),
                syncEnabled: true,
                syncInterval: 15,
            },
        ];
        integrations.forEach(integration => {
            this.localProviderIntegrations.set(integration.id, integration);
        });
    }
    initializeTerraformConfigurations() {
        const configs = [
            {
                id: 'terraform-hoster-by-production',
                name: 'Hoster.by Production Infrastructure',
                description: 'Production infrastructure configuration for Hoster.by provider',
                version: '1.0.0',
                environment: 'production',
                region: 'BY',
                provider: 'hoster-by',
                modules: [
                    {
                        id: 'module-compute',
                        name: 'Compute Resources',
                        source: './modules/compute',
                        version: '1.0.0',
                        variables: {
                            instance_count: 5,
                            instance_type: 'medium',
                            region: 'BY',
                        },
                        outputs: ['instance_ids', 'public_ips'],
                        dependencies: [],
                        estimatedResources: 5,
                        estimatedCost: 25.0,
                    },
                    {
                        id: 'module-storage',
                        name: 'Storage Resources',
                        source: './modules/storage',
                        version: '1.0.0',
                        variables: {
                            volume_size: 100,
                            volume_count: 10,
                            backup_enabled: true,
                        },
                        outputs: ['volume_ids', 'backup_policy_id'],
                        dependencies: ['module-compute'],
                        estimatedResources: 10,
                        estimatedCost: 10.0,
                    },
                ],
                variables: [
                    {
                        name: 'environment',
                        type: 'string',
                        description: 'Environment name',
                        defaultValue: 'production',
                        required: true,
                        sensitive: false,
                    },
                    {
                        name: 'region',
                        type: 'string',
                        description: 'Target region',
                        defaultValue: 'BY',
                        required: true,
                        sensitive: false,
                    },
                    {
                        name: 'instance_count',
                        type: 'number',
                        description: 'Number of compute instances',
                        defaultValue: 5,
                        required: false,
                        sensitive: false,
                        validation: {
                            condition: 'instance_count > 0 && instance_count <= 100',
                            errorMessage: 'Instance count must be between 1 and 100',
                        },
                    },
                ],
                outputs: [
                    {
                        name: 'public_ips',
                        description: 'Public IP addresses of compute instances',
                        value: 'module.compute.public_ips',
                        sensitive: false,
                    },
                    {
                        name: 'total_cost',
                        description: 'Estimated monthly cost',
                        value: 'local.total_cost',
                        sensitive: false,
                    },
                ],
                stateBackend: {
                    type: 'remote',
                    config: {
                        hostname: 'terraform.hoster.by',
                        organization: 'company',
                        workspaces: 'production',
                    },
                },
                status: 'applied',
                lastApplied: new Date(Date.now() - 24 * 60 * 60 * 1000),
                tags: {
                    Environment: 'production',
                    Provider: 'hoster-by',
                    Region: 'BY',
                    Team: 'devops',
                },
                estimatedCost: 35.0,
                currency: 'BYN',
                compliance: {
                    fz152: 'true',
                    rbRequirements: 'true',
                    pciDss: 'false',
                    cbrfRequirements: 'true',
                },
            },
        ];
        configs.forEach(config => {
            this.terraformConfigs.set(config.id, config);
        });
    }
    initializeAnsiblePlaybooks() {
        const playbooks = [
            {
                id: 'playbook-server-provisioning',
                name: 'Server Provisioning',
                description: 'Automated server provisioning and configuration',
                version: '1.0.0',
                targetEnvironment: 'production',
                targetHosts: ['web-servers', 'db-servers', 'app-servers'],
                tags: ['provisioning', 'configuration', 'security'],
                tasks: [
                    {
                        id: 'task-1',
                        name: 'Update package cache',
                        module: 'apt',
                        description: 'Update package cache for Ubuntu systems',
                        parameters: {
                            update_cache: true,
                        },
                        tags: ['system', 'maintenance'],
                        when: "ansible_os_family == 'Debian'",
                        failedWhen: false,
                        changedWhen: false,
                        retries: 3,
                        delay: 5,
                        timeout: 300,
                        become: true,
                        becomeUser: 'root',
                        becomeMethod: 'sudo',
                    },
                    {
                        id: 'task-2',
                        name: 'Install required packages',
                        module: 'package',
                        description: 'Install essential packages for server operation',
                        parameters: {
                            name: ['nginx', 'mysql-server', 'python3', 'curl', 'wget'],
                            state: 'present',
                        },
                        tags: ['packages', 'installation'],
                        when: '',
                        failedWhen: false,
                        changedWhen: false,
                        retries: 2,
                        delay: 10,
                        timeout: 600,
                        become: true,
                        becomeUser: 'root',
                        becomeMethod: 'sudo',
                    },
                    {
                        id: 'task-3',
                        name: 'Configure firewall',
                        module: 'ufw',
                        description: 'Configure firewall rules for security',
                        parameters: {
                            rule: 'allow',
                            port: ['22', '80', '443', '3306'],
                            proto: 'tcp',
                        },
                        tags: ['security', 'firewall'],
                        when: '',
                        failedWhen: false,
                        changedWhen: false,
                        retries: 1,
                        delay: 0,
                        timeout: 120,
                        become: true,
                        becomeUser: 'root',
                        becomeMethod: 'sudo',
                    },
                ],
                handlers: [
                    {
                        id: 'handler-1',
                        name: 'Restart nginx',
                        description: 'Restart nginx service when configuration changes',
                        tasks: ['restart_nginx'],
                        listen: ['nginx_config_changed'],
                        flushHandlers: false,
                    },
                ],
                variables: {
                    nginx_user: 'www-data',
                    mysql_root_password: '{{ vault_mysql_root_password }}',
                    server_timezone: 'Europe/Minsk',
                },
                executionCount: 15,
                averageExecutionTime: 420,
                successRate: 0.93,
                status: 'active',
                compliance: {
                    securityStandards: 'true',
                    auditTrail: 'true',
                    changeControl: 'true',
                },
            },
        ];
        playbooks.forEach(playbook => {
            this.ansiblePlaybooks.set(playbook.id, playbook);
        });
    }
    initializeCICDPipelines() {
        const pipelines = [
            {
                id: 'pipeline-web-app-deployment',
                name: 'Web Application Deployment',
                description: 'CI/CD pipeline for web application deployment',
                type: 'jenkins',
                repository: 'https://github.com/company/web-app.git',
                branch: 'main',
                stages: [
                    {
                        id: 'stage-build',
                        name: 'Build',
                        order: 1,
                        type: 'build',
                        parallel: false,
                        timeout: 15,
                        conditions: ['code_changed'],
                        steps: [
                            {
                                id: 'step-npm-install',
                                name: 'Install Dependencies',
                                type: 'script',
                                command: 'npm ci',
                                parameters: {},
                                timeout: 300,
                                retries: 2,
                                onFailure: 'fail',
                                environment: {
                                    NODE_ENV: 'production',
                                },
                                secrets: [],
                            },
                            {
                                id: 'step-build',
                                name: 'Build Application',
                                type: 'script',
                                command: 'npm run build',
                                parameters: {},
                                timeout: 600,
                                retries: 1,
                                onFailure: 'fail',
                                environment: {
                                    NODE_ENV: 'production',
                                },
                                secrets: [],
                            },
                        ],
                        requiredApproval: false,
                        approvers: [],
                        rollbackOnFailure: false,
                    },
                    {
                        id: 'stage-test',
                        name: 'Test',
                        order: 2,
                        type: 'test',
                        parallel: true,
                        timeout: 20,
                        conditions: ['build_successful'],
                        steps: [
                            {
                                id: 'step-unit-tests',
                                name: 'Unit Tests',
                                type: 'script',
                                command: 'npm run test:unit',
                                parameters: {},
                                timeout: 300,
                                retries: 1,
                                onFailure: 'fail',
                                environment: {
                                    NODE_ENV: 'test',
                                },
                                secrets: [],
                            },
                            {
                                id: 'step-integration-tests',
                                name: 'Integration Tests',
                                type: 'script',
                                command: 'npm run test:integration',
                                parameters: {},
                                timeout: 600,
                                retries: 1,
                                onFailure: 'fail',
                                environment: {
                                    NODE_ENV: 'test',
                                },
                                secrets: [],
                            },
                        ],
                        requiredApproval: false,
                        approvers: [],
                        rollbackOnFailure: false,
                    },
                    {
                        id: 'stage-deploy',
                        name: 'Deploy',
                        order: 3,
                        type: 'deploy',
                        parallel: false,
                        timeout: 30,
                        conditions: ['tests_passed'],
                        steps: [
                            {
                                id: 'step-terraform-plan',
                                name: 'Terraform Plan',
                                type: 'terraform',
                                command: 'terraform plan',
                                parameters: {
                                    var_file: 'production.tfvars',
                                },
                                timeout: 300,
                                retries: 1,
                                onFailure: 'fail',
                                environment: {},
                                secrets: ['TF_VAR_access_key', 'TF_VAR_secret_key'],
                            },
                            {
                                id: 'step-terraform-apply',
                                name: 'Terraform Apply',
                                type: 'terraform',
                                command: 'terraform apply -auto-approve',
                                parameters: {
                                    var_file: 'production.tfvars',
                                },
                                timeout: 900,
                                retries: 1,
                                onFailure: 'fail',
                                environment: {},
                                secrets: ['TF_VAR_access_key', 'TF_VAR_secret_key'],
                            },
                        ],
                        requiredApproval: true,
                        approvers: ['devops-lead', 'team-lead'],
                        rollbackOnFailure: true,
                    },
                ],
                triggers: [
                    {
                        type: 'push',
                        condition: 'branch == main',
                        enabled: true,
                    },
                    {
                        type: 'pull-request',
                        condition: 'target_branch == main',
                        enabled: true,
                    },
                ],
                artifacts: [
                    {
                        name: 'build-artifacts',
                        type: 'binary',
                        path: 'dist/',
                        retention: 30,
                        compression: true,
                        encryption: false,
                    },
                    {
                        name: 'test-results',
                        type: 'test-results',
                        path: 'test-results/',
                        retention: 90,
                        compression: true,
                        encryption: false,
                    },
                ],
                environment: 'production',
                buildCount: 45,
                successRate: 0.89,
                averageBuildTime: 25,
                status: 'active',
                security: {
                    codeScanning: 'true',
                    dependencyScanning: 'true',
                    secretScanning: 'true',
                    containerScanning: 'false',
                },
                compliance: {
                    auditLogging: 'true',
                    approvalRequired: 'true',
                    changeTracking: 'true',
                },
            },
        ];
        pipelines.forEach(pipeline => {
            this.cicdPipelines.set(pipeline.id, pipeline);
        });
    }
    initializeDeploymentStrategies() {
        const strategies = [
            {
                id: 'strategy-blue-green-production',
                name: 'Blue-Green Deployment for Production',
                description: 'Blue-green deployment strategy for production environment',
                type: 'blue-green',
                environment: 'production',
                targetServices: ['web-app', 'api-service', 'database'],
                configuration: {
                    maxUnavailable: 0,
                    maxSurge: 100,
                    minReadySeconds: 300,
                    progressDeadlineSeconds: 1800,
                    rollbackOnFailure: true,
                    healthCheckPath: '/health',
                    healthCheckTimeout: 30,
                },
                rollback: {
                    automatic: true,
                    triggerConditions: [
                        'health_check_failed',
                        'error_rate_high',
                        'response_time_slow',
                    ],
                    rollbackSteps: [
                        'Stop new deployment',
                        'Route traffic back to old version',
                        'Verify system stability',
                        'Investigate failure cause',
                    ],
                },
                monitoring: {
                    metrics: [
                        'response_time',
                        'error_rate',
                        'throughput',
                        'cpu_usage',
                        'memory_usage',
                    ],
                    alerts: [
                        'high_error_rate',
                        'slow_response_time',
                        'service_unavailable',
                    ],
                    dashboards: [
                        'production-overview',
                        'deployment-metrics',
                        'service-health',
                    ],
                },
                deploymentCount: 12,
                successRate: 0.92,
                averageDeploymentTime: 18,
                status: 'active',
            },
        ];
        strategies.forEach(strategy => {
            this.deploymentStrategies.set(strategy.id, strategy);
        });
    }
    async createTerraformConfiguration(config) {
        const configId = `terraform-${Date.now()}`;
        const newConfig = {
            ...config,
            id: configId,
            status: 'draft',
        };
        this.terraformConfigs.set(configId, newConfig);
        this.redactedLogger.log(`Terraform configuration created`, 'DevOpsIntegrationService', {
            configId,
            name: newConfig.name,
            environment: newConfig.environment,
        });
        return configId;
    }
    async planTerraformConfiguration(configId) {
        const config = this.terraformConfigs.get(configId);
        if (!config) {
            throw new Error('Terraform configuration not found');
        }
        await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
        const planId = `plan-${Date.now()}`;
        const changes = [
            {
                _resource: 'hoster-by_instance.web_server',
                action: 'create',
                details: 'Create new web server instance',
            },
            {
                _resource: 'hoster-by_volume.data_volume',
                action: 'create',
                details: 'Create new data volume',
            },
        ];
        const estimatedCost = config.estimatedCost ?? 0;
        const estimatedTime = 15 + Math.random() * 30;
        config.status = 'planned';
        config.lastPlanned = new Date();
        this.redactedLogger.log(`Terraform plan completed`, 'DevOpsIntegrationService', {
            configId,
            planId,
            changesCount: changes.length,
            estimatedCost,
        });
        return {
            planId,
            changes,
            estimatedCost,
            estimatedTime: Math.round(estimatedTime * 100) / 100,
        };
    }
    async applyTerraformConfiguration(configId) {
        const config = this.terraformConfigs.get(configId);
        if (!config) {
            return false;
        }
        if (config.status !== 'planned') {
            throw new Error('Configuration must be planned before applying');
        }
        config.status = 'applied';
        config.lastApplied = new Date();
        this.redactedLogger.log(`Terraform configuration applied`, 'DevOpsIntegrationService', {
            configId,
            name: config.name,
        });
        return true;
    }
    async createAnsiblePlaybook(playbook) {
        const playbookId = `playbook-${Date.now()}`;
        const newPlaybook = {
            ...playbook,
            id: playbookId,
            executionCount: 0,
            averageExecutionTime: 0,
            successRate: 0,
            status: 'draft',
        };
        this.ansiblePlaybooks.set(playbookId, newPlaybook);
        this.redactedLogger.log(`Ansible playbook created`, 'DevOpsIntegrationService', {
            playbookId,
            name: newPlaybook.name,
            targetEnvironment: newPlaybook.targetEnvironment,
        });
        return playbookId;
    }
    async executeAnsiblePlaybook(playbookId, targetHosts) {
        const playbook = this.ansiblePlaybooks.get(playbookId);
        if (!playbook) {
            throw new Error('Ansible playbook not found');
        }
        const executionId = `execution-${Date.now()}`;
        const execution = {
            executionId,
            status: 'running',
            progress: 0,
            logs: [`Starting execution of playbook: ${playbook.name}`],
        };
        setTimeout(() => {
            execution.progress = 25;
            execution.logs.push('Gathering facts from target hosts...');
        }, 1000);
        setTimeout(() => {
            execution.progress = 50;
            execution.logs.push('Executing tasks...');
        }, 3000);
        setTimeout(() => {
            execution.progress = 75;
            execution.logs.push('Running handlers...');
        }, 5000);
        setTimeout(() => {
            execution.progress = 100;
            execution.status = 'completed';
            execution.logs.push('Playbook execution completed successfully');
            playbook.executionCount += 1;
            playbook.lastExecuted = new Date();
            this.redactedLogger.log(`Ansible playbook executed successfully`, 'DevOpsIntegrationService', {
                playbookId,
                executionId,
                targetHosts,
            });
        }, 8000);
        return execution;
    }
    async createCICDPipeline(pipeline) {
        const pipelineId = `pipeline-${Date.now()}`;
        const newPipeline = {
            ...pipeline,
            id: pipelineId,
            buildCount: 0,
            successRate: 0,
            averageBuildTime: 0,
            status: 'active',
        };
        this.cicdPipelines.set(pipelineId, newPipeline);
        this.redactedLogger.log(`CI/CD pipeline created`, 'DevOpsIntegrationService', {
            pipelineId,
            name: newPipeline.name,
            type: newPipeline.type,
        });
        return pipelineId;
    }
    async triggerPipelineBuild(pipelineId, parameters) {
        const pipeline = this.cicdPipelines.get(pipelineId);
        if (!pipeline) {
            throw new Error('CI/CD pipeline not found');
        }
        const buildId = `build-${Date.now()}`;
        const estimatedTime = pipeline.averageBuildTime || 30;
        this.redactedLogger.log(`Pipeline build triggered`, 'DevOpsIntegrationService', {
            pipelineId,
            buildId,
            parameters,
        });
        return {
            buildId,
            status: 'queued',
            estimatedTime,
        };
    }
    async createDeploymentStrategy(strategy) {
        const strategyId = `strategy-${Date.now()}`;
        const newStrategy = {
            ...strategy,
            id: strategyId,
            deploymentCount: 0,
            successRate: 0,
            averageDeploymentTime: 0,
            status: 'active',
        };
        this.deploymentStrategies.set(strategyId, newStrategy);
        this.redactedLogger.log(`Deployment strategy created`, 'DevOpsIntegrationService', {
            strategyId,
            name: newStrategy.name,
            type: newStrategy.type,
        });
        return strategyId;
    }
    async executeDeployment(strategyId, version) {
        const strategy = this.deploymentStrategies.get(strategyId);
        if (!strategy) {
            throw new Error('Deployment strategy not found');
        }
        const deploymentId = `deployment-${Date.now()}`;
        const deployment = {
            deploymentId,
            status: 'in-progress',
            progress: 0,
            logs: [`Starting ${strategy.type} deployment for version ${version}`],
        };
        setTimeout(() => {
            deployment.progress = 25;
            deployment.logs.push('Preparing new environment...');
        }, 2000);
        setTimeout(() => {
            deployment.progress = 50;
            deployment.logs.push('Deploying new version...');
        }, 5000);
        setTimeout(() => {
            deployment.progress = 75;
            deployment.logs.push('Running health checks...');
        }, 8000);
        setTimeout(() => {
            deployment.progress = 100;
            deployment.status = 'completed';
            deployment.logs.push('Deployment completed successfully');
            strategy.deploymentCount += 1;
            this.redactedLogger.log(`Deployment executed successfully`, 'DevOpsIntegrationService', {
                strategyId,
                deploymentId,
                version,
            });
        }, 12000);
        return deployment;
    }
    async getTerraformConfigurations(environment, provider) {
        let configs = Array.from(this.terraformConfigs.values());
        if (environment) {
            configs = configs.filter(c => c.environment === environment);
        }
        if (provider) {
            configs = configs.filter(c => c.provider === provider);
        }
        return configs.sort((a, b) => {
            if (a.lastApplied && b.lastApplied) {
                return b.lastApplied.getTime() - a.lastApplied.getTime();
            }
            return 0;
        });
    }
    async getAnsiblePlaybooks(targetEnvironment) {
        let playbooks = Array.from(this.ansiblePlaybooks.values());
        if (targetEnvironment) {
            playbooks = playbooks.filter(p => p.targetEnvironment === targetEnvironment);
        }
        return playbooks.sort((a, b) => b.executionCount - a.executionCount);
    }
    async getCICDPipelines(type, environment) {
        let pipelines = Array.from(this.cicdPipelines.values());
        if (type) {
            pipelines = pipelines.filter(p => p.type === type);
        }
        if (environment) {
            pipelines = pipelines.filter(p => p.environment === environment);
        }
        return pipelines.sort((a, b) => b.buildCount - a.buildCount);
    }
    async getDeploymentStrategies(type, environment) {
        let strategies = Array.from(this.deploymentStrategies.values());
        if (type) {
            strategies = strategies.filter(s => s.type === type);
        }
        if (environment) {
            strategies = strategies.filter(s => s.environment === environment);
        }
        return strategies.sort((a, b) => b.deploymentCount - a.deploymentCount);
    }
    async getLocalProviderIntegrations(provider, region) {
        let integrations = Array.from(this.localProviderIntegrations.values());
        if (provider) {
            integrations = integrations.filter(i => i.provider === provider);
        }
        if (region) {
            integrations = integrations.filter(i => i.region === region);
        }
        return integrations.filter(i => i.status === 'active');
    }
    async syncLocalProviderIntegration(integrationId) {
        const integration = this.localProviderIntegrations.get(integrationId);
        if (!integration) {
            return false;
        }
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
        integration.lastSync = new Date();
        this.redactedLogger.log(`Local provider integration synced`, 'DevOpsIntegrationService', {
            integrationId,
            provider: integration.provider,
            region: integration.region,
        });
        return true;
    }
    async getDevOpsMetrics() {
        const terraformConfigs = this.terraformConfigs.size;
        const ansiblePlaybooks = this.ansiblePlaybooks.size;
        const cicdPipelines = this.cicdPipelines.size;
        const deploymentStrategies = this.deploymentStrategies.size;
        const localIntegrations = this.localProviderIntegrations.size;
        const totalEstimatedCost = Array.from(this.terraformConfigs.values()).reduce((sum, config) => sum + (config.estimatedCost ?? 0), 0);
        const successRates = [
            ...Array.from(this.ansiblePlaybooks.values()).map(p => p.successRate),
            ...Array.from(this.cicdPipelines.values()).map(p => p.successRate),
            ...Array.from(this.deploymentStrategies.values()).map(s => s.successRate),
        ];
        const averageSuccessRate = successRates.length > 0
            ? successRates.reduce((sum, rate) => sum + rate, 0) /
                successRates.length
            : 0;
        const providerStats = new Map();
        Array.from(this.terraformConfigs.values()).forEach(config => {
            const current = providerStats.get(config.provider) ?? {
                configs: 0,
                estimatedCost: 0,
            };
            current.configs += 1;
            current.estimatedCost += config.estimatedCost ?? 0;
            providerStats.set(config.provider, current);
        });
        const topProviders = Array.from(providerStats.entries())
            .map(([provider, stats]) => ({
            provider,
            configs: stats.configs,
            estimatedCost: stats.estimatedCost,
        }))
            .sort((a, b) => b.estimatedCost - a.estimatedCost)
            .slice(0, 5);
        return {
            terraformConfigs,
            ansiblePlaybooks,
            cicdPipelines,
            deploymentStrategies,
            localIntegrations,
            totalEstimatedCost: Math.round(totalEstimatedCost * 100) / 100,
            averageSuccessRate: Math.round(averageSuccessRate * 100) / 100,
            topProviders,
        };
    }
    executeTerraformCommand(command, workspace) {
        const executionTime = Math.floor(Math.random() * 5000) + 1000;
        const success = Math.random() > 0.2;
        let output = '';
        let status;
        if (command === 'plan') {
            output = `Terraform plan for workspace: ${workspace}\n+ 3 resources to create\n+ 1 resource to modify\n+ 0 resources to destroy`;
            status = success ? 'success' : 'failed';
        }
        else if (command === 'apply') {
            output = `Terraform apply for workspace: ${workspace}\n✓ 3 resources created\n✓ 1 resource modified`;
            status = success ? 'success' : 'failed';
        }
        else if (command === 'destroy') {
            output = `Terraform destroy for workspace: ${workspace}\n✓ 4 resources destroyed`;
            status = success ? 'success' : 'failed';
        }
        else {
            output = `Terraform ${command} for workspace: ${workspace}`;
            status = success ? 'success' : 'failed';
        }
        return {
            command,
            workspace,
            status,
            output,
            executionTime,
        };
    }
    runCICDPipeline(pipelineId, branch) {
        const buildNumber = `#${Math.floor(Math.random() * 1000) + 1}`;
        const estimatedDuration = Math.floor(Math.random() * 300) + 60;
        const success = Math.random() > 0.15;
        let status;
        if (Math.random() > 0.7) {
            status = 'running';
        }
        else {
            status = success ? 'success' : 'failed';
        }
        return {
            pipelineId,
            branch,
            status,
            buildNumber,
            startTime: new Date(),
            estimatedDuration,
        };
    }
    deployToEnvironment(application, environment) {
        const deploymentId = `deploy-${Date.now()}`;
        const version = `v${Math.floor(Math.random() * 10) + 1}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}`;
        const success = Math.random() > 0.1;
        let status;
        if (Math.random() > 0.8) {
            status = 'deploying';
        }
        else {
            status = success ? 'success' : 'failed';
        }
        return {
            application,
            environment,
            status,
            deploymentId,
            startTime: new Date(),
            version,
        };
    }
};
DevOpsIntegrationService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DevOpsIntegrationService);



/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CostOptimizationAIService: () => (/* binding */ CostOptimizationAIService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CostOptimizationAIService_1;


let CostOptimizationAIService = CostOptimizationAIService_1 = class CostOptimizationAIService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(CostOptimizationAIService_1.name);
        this.optimizationRecommendations = new Map();
        this.resourceUsagePatterns = new Map();
        this.costPredictions = new Map();
        this.aiModels = new Map();
        this.optimizationExecutions = new Map();
        this.initializeAIModels();
        this.initializeResourceUsagePatterns();
    }
    initializeAIModels() {
        const models = [
            {
                id: 'model-cost-optimization-v1',
                name: 'Cost Optimization Model v1',
                version: '1.0.0',
                type: 'cost-optimization',
                algorithm: 'ensemble',
                trainingData: {
                    startDate: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000),
                    endDate: new Date(),
                    records: 50000,
                    accuracy: 0.89,
                },
                performance: {
                    precision: 0.87,
                    recall: 0.91,
                    f1Score: 0.89,
                    mse: 0.023,
                },
                lastTrained: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
                status: 'active',
                configuration: {
                    learning_rate: 0.001,
                    batch_size: 64,
                    epochs: 100,
                    validation_split: 0.2,
                },
            },
            {
                id: 'model-resource-prediction-v1',
                name: 'Resource Prediction Model v1',
                version: '1.0.0',
                type: 'resource-prediction',
                algorithm: 'time-series',
                trainingData: {
                    startDate: new Date(Date.now() - 180 * 24 * 60 * 60 * 1000),
                    endDate: new Date(),
                    records: 25000,
                    accuracy: 0.92,
                },
                performance: {
                    precision: 0.9,
                    recall: 0.94,
                    f1Score: 0.92,
                    mse: 0.018,
                },
                lastTrained: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
                status: 'active',
                configuration: {
                    window_size: 24,
                    forecast_horizon: 168,
                    seasonality: 24,
                },
            },
            {
                id: 'model-anomaly-detection-v1',
                name: 'Anomaly Detection Model v1',
                version: '1.0.0',
                type: 'anomaly-detection',
                algorithm: 'neural-network',
                trainingData: {
                    startDate: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000),
                    endDate: new Date(),
                    records: 15000,
                    accuracy: 0.95,
                },
                performance: {
                    precision: 0.93,
                    recall: 0.97,
                    f1Score: 0.95,
                    mse: 0.012,
                },
                lastTrained: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
                status: 'active',
                configuration: {
                    threshold: 0.85,
                    sensitivity: 0.8,
                    auto_learning: true,
                },
            },
        ];
        models.forEach(model => {
            this.aiModels.set(model.id, model);
        });
    }
    initializeResourceUsagePatterns() {
        const patterns = [
            {
                id: 'pattern-cpu-server-1',
                resourceId: 'server-1',
                resourceType: 'cpu',
                providerId: 'hoster-by',
                region: 'BY',
                timeSeries: this.generateTimeSeriesData('cpu'),
                patterns: {
                    daily: [
                        20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 75, 70, 65, 60,
                        55, 50, 45, 40, 35, 30, 25,
                    ],
                    weekly: [45, 50, 55, 60, 65, 70, 75],
                    monthly: [55, 58, 62, 65, 68, 72, 75, 78, 82, 85, 88, 92],
                    seasonal: [60, 65, 70, 75, 80, 85, 90, 85, 80, 75, 70, 65],
                },
                anomalies: [
                    {
                        timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
                        type: 'spike',
                        severity: 'high',
                        description: 'Unusual CPU spike during maintenance window',
                    },
                ],
                lastAnalyzed: new Date(),
            },
            {
                id: 'pattern-memory-server-1',
                resourceId: 'server-1',
                resourceType: 'memory',
                providerId: 'hoster-by',
                region: 'BY',
                timeSeries: this.generateTimeSeriesData('memory'),
                patterns: {
                    daily: [
                        45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 85, 80, 75, 70, 65, 60, 55,
                        50, 45, 40, 35, 30, 25, 20,
                    ],
                    weekly: [60, 65, 70, 75, 80, 85, 90],
                    monthly: [65, 68, 72, 75, 78, 82, 85, 88, 92, 95, 98, 100],
                    seasonal: [70, 75, 80, 85, 90, 95, 100, 95, 90, 85, 80, 75],
                },
                anomalies: [],
                lastAnalyzed: new Date(),
            },
        ];
        patterns.forEach(pattern => {
            this.resourceUsagePatterns.set(pattern.id, pattern);
        });
    }
    generateTimeSeriesData(resourceType) {
        const data = [];
        const now = new Date();
        for (let i = 23; i >= 0; i--) {
            const timestamp = new Date(now.getTime() - i * 60 * 60 * 1000);
            const baseUsage = resourceType === 'cpu' ? 60 : 70;
            const variation = (Math.random() - 0.5) * 20;
            const usage = Math.max(0, Math.min(100, baseUsage + variation));
            data.push({
                timestamp,
                usage: Math.round(usage * 100) / 100,
                cost: Math.round((usage / 100) * 50 * 100) / 100,
                currency: 'BYN',
            });
        }
        return data;
    }
    async analyzeResourceUsage(resourceId) {
        const pattern = this.resourceUsagePatterns.get(resourceId);
        if (!pattern) {
            throw new Error('Resource usage pattern not found');
        }
        const analysis = await this.performAIAnalysis(pattern);
        const recommendations = await this.generateOptimizationRecommendations(pattern, analysis);
        const predictions = await this.generateCostPredictions(pattern, analysis);
        return { patterns: pattern, recommendations, predictions };
    }
    async performAIAnalysis(pattern) {
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
        const dailyPattern = pattern.patterns.daily;
        const averageUtilization = dailyPattern.reduce((sum, val) => sum + val, 0) / dailyPattern.length;
        const peakUtilization = Math.max(...dailyPattern);
        const lowUtilizationPeriods = dailyPattern.filter(val => val < 30).length;
        let utilizationTrend;
        if (averageUtilization > 80) {
            utilizationTrend = 'increasing';
        }
        else if (averageUtilization < 40) {
            utilizationTrend = 'decreasing';
        }
        else if (lowUtilizationPeriods > 8) {
            utilizationTrend = 'volatile';
        }
        else {
            utilizationTrend = 'stable';
        }
        const costEfficiency = averageUtilization > 70 ? 0.8 : averageUtilization > 50 ? 0.6 : 0.4;
        const optimizationPotential = Math.max(0, 1 - costEfficiency);
        return {
            utilizationTrend,
            averageUtilization: Math.round(averageUtilization * 100) / 100,
            peakUtilization,
            lowUtilizationPeriods,
            costEfficiency: Math.round(costEfficiency * 100) / 100,
            optimizationPotential: Math.round(optimizationPotential * 100) / 100,
        };
    }
    async generateOptimizationRecommendations(pattern, analysis) {
        const recommendations = [];
        if (analysis.utilizationTrend === 'decreasing' &&
            analysis.averageUtilization < 40) {
            const lastTimeSeriesEntry = pattern.timeSeries[pattern.timeSeries.length - 1];
            if (lastTimeSeriesEntry?.cost !== undefined) {
                const currentCost = lastTimeSeriesEntry.cost;
                const estimatedSavings = currentCost * 0.3;
                recommendations.push({
                    id: `rec-${Date.now()}`,
                    type: 'resource-downsize',
                    priority: analysis.averageUtilization < 20 ? 'high' : 'medium',
                    category: 'short-term',
                    title: 'Reduce Resource Allocation',
                    description: `Resource ${pattern.resourceType} on ${pattern.resourceId} is underutilized. Consider reducing allocation to save costs.`,
                    currentState: {
                        cost: currentCost,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        utilization: {
                            [pattern.resourceType]: analysis.averageUtilization,
                        },
                    },
                    proposedState: {
                        cost: currentCost - estimatedSavings,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        estimatedSavings,
                        savingsPercentage: 30,
                    },
                    implementation: {
                        effort: 'low',
                        estimatedTime: 2,
                        risk: 'low',
                        steps: [
                            'Analyze current resource allocation',
                            'Identify unused resources',
                            'Reduce allocation gradually',
                            'Monitor performance impact',
                        ],
                        rollbackPlan: 'Immediately restore previous allocation if performance degrades',
                    },
                    aiConfidence: 0.85,
                    factors: [
                        'Low average utilization',
                        'Consistent underutilization pattern',
                        'Historical cost analysis',
                    ],
                    createdAt: new Date(),
                    status: 'pending',
                });
            }
        }
        if (analysis.costEfficiency < 0.6 && pattern.region === 'BY') {
            const lastTimeSeriesEntry = pattern.timeSeries[pattern.timeSeries.length - 1];
            if (lastTimeSeriesEntry?.cost !== undefined) {
                const currentCost = lastTimeSeriesEntry.cost;
                const estimatedSavings = currentCost * 0.25;
                recommendations.push({
                    id: `rec-${Date.now() + 1}`,
                    type: 'provider-migration',
                    priority: 'medium',
                    category: 'long-term',
                    title: 'Consider Provider Migration',
                    description: `Current provider may not be cost-effective for this workload. Evaluate alternatives for better pricing.`,
                    currentState: {
                        cost: currentCost,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        utilization: {
                            [pattern.resourceType]: analysis.averageUtilization,
                        },
                    },
                    proposedState: {
                        cost: currentCost - estimatedSavings,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        estimatedSavings,
                        savingsPercentage: 25,
                    },
                    implementation: {
                        effort: 'high',
                        estimatedTime: 24,
                        risk: 'medium',
                        steps: [
                            'Research alternative providers',
                            'Compare pricing and features',
                            'Plan migration strategy',
                            'Execute migration during low-traffic period',
                        ],
                        rollbackPlan: 'Maintain backup of current configuration for quick rollback',
                    },
                    aiConfidence: 0.72,
                    factors: [
                        'Low cost efficiency',
                        'Regional provider options',
                        'Workload characteristics',
                    ],
                    createdAt: new Date(),
                    status: 'pending',
                });
            }
        }
        if (analysis.lowUtilizationPeriods > 8) {
            const lastTimeSeriesEntry = pattern.timeSeries[pattern.timeSeries.length - 1];
            if (lastTimeSeriesEntry?.cost !== undefined) {
                const currentCost = lastTimeSeriesEntry.cost;
                const estimatedSavings = currentCost * 0.15;
                recommendations.push({
                    id: `rec-${Date.now() + 2}`,
                    type: 'scheduling-optimization',
                    priority: 'low',
                    category: 'short-term',
                    title: 'Optimize Resource Scheduling',
                    description: 'High variability in resource usage suggests scheduling optimization opportunities.',
                    currentState: {
                        cost: currentCost,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        utilization: {
                            [pattern.resourceType]: analysis.averageUtilization,
                        },
                    },
                    proposedState: {
                        cost: currentCost - estimatedSavings,
                        currency: pattern.timeSeries[0]?.currency ?? 'BYN',
                        resources: [pattern.resourceId],
                        estimatedSavings,
                        savingsPercentage: 15,
                    },
                    implementation: {
                        effort: 'medium',
                        estimatedTime: 8,
                        risk: 'low',
                        steps: [
                            'Analyze usage patterns',
                            'Identify peak and off-peak periods',
                            'Implement dynamic scaling',
                            'Optimize workload distribution',
                        ],
                        rollbackPlan: 'Revert to static allocation if dynamic scaling causes issues',
                    },
                    aiConfidence: 0.78,
                    factors: [
                        'High usage variability',
                        'Predictable patterns',
                        'Automation opportunities',
                    ],
                    createdAt: new Date(),
                    status: 'pending',
                });
            }
        }
        recommendations.forEach(rec => {
            this.optimizationRecommendations.set(rec.id, rec);
        });
        return recommendations;
    }
    async generateCostPredictions(pattern, analysis) {
        const predictions = [];
        const lastTimeSeriesEntry = pattern.timeSeries[pattern.timeSeries.length - 1];
        if (lastTimeSeriesEntry?.cost === undefined) {
            throw new Error('Cost data not available for predictions');
        }
        const currentCost = lastTimeSeriesEntry.cost;
        const monthlyPrediction = await this.predictCost(pattern, '1m', analysis.utilizationTrend, currentCost);
        predictions.push(monthlyPrediction);
        const quarterlyPrediction = await this.predictCost(pattern, '3m', analysis.utilizationTrend, currentCost);
        predictions.push(quarterlyPrediction);
        const semiAnnualPrediction = await this.predictCost(pattern, '6m', analysis.utilizationTrend, currentCost);
        predictions.push(semiAnnualPrediction);
        predictions.forEach(pred => {
            this.costPredictions.set(pred.id, pred);
        });
        return predictions;
    }
    async predictCost(pattern, period, trend, currentCost) {
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
        let growthFactor = 1.0;
        let confidence = 0.8;
        switch (trend) {
            case 'increasing':
                growthFactor = 1.1 + Math.random() * 0.2;
                confidence = 0.75;
                break;
            case 'decreasing':
                growthFactor = 0.9 - Math.random() * 0.2;
                confidence = 0.85;
                break;
            case 'stable':
                growthFactor = 0.95 + Math.random() * 0.1;
                confidence = 0.9;
                break;
            case 'volatile':
                growthFactor = 0.8 + Math.random() * 0.4;
                confidence = 0.6;
                break;
        }
        const periodMultipliers = {
            '1d': 1,
            '1w': 7,
            '1m': 1,
            '3m': 3,
            '6m': 6,
            '1y': 12,
        };
        const periodMultiplier = periodMultipliers[period] ?? 1;
        const predictedCost = currentCost * growthFactor * periodMultiplier;
        const upperBound = predictedCost * (1 + 0.2);
        const lowerBound = predictedCost * (1 - 0.2);
        let trendDirection;
        if (growthFactor > 1.05)
            trendDirection = 'increasing';
        else if (growthFactor < 0.95)
            trendDirection = 'decreasing';
        else if (Math.abs(growthFactor - 1) < 0.05)
            trendDirection = 'stable';
        else
            trendDirection = 'volatile';
        const recommendations = [];
        if (trendDirection === 'increasing') {
            recommendations.push('Consider resource optimization to control cost growth');
            recommendations.push('Implement cost monitoring and alerting');
        }
        else if (trendDirection === 'decreasing') {
            recommendations.push('Monitor for potential underutilization');
            recommendations.push('Consider cost-effective resource allocation');
        }
        return {
            id: `prediction-${Date.now()}`,
            resourceId: pattern.resourceId,
            predictionPeriod: period,
            predictionDate: new Date(),
            predictedCost: Math.round(predictedCost * 100) / 100,
            currency: pattern.timeSeries[0]?.currency ?? 'BYN',
            confidence: Math.round(confidence * 100) / 100,
            factors: [
                `Historical ${trend} trend`,
                `Seasonal patterns`,
                `Resource utilization patterns`,
                `Provider pricing changes`,
            ],
            upperBound: Math.round(upperBound * 100) / 100,
            lowerBound: Math.round(lowerBound * 100) / 100,
            trend: trendDirection,
            recommendations,
        };
    }
    async approveRecommendation(recommendationId, executor) {
        const recommendation = this.optimizationRecommendations.get(recommendationId);
        if (!recommendation) {
            throw new Error('Optimization recommendation not found');
        }
        recommendation.status = 'approved';
        recommendation.approvedAt = new Date();
        const execution = {
            id: `execution-${Date.now()}`,
            recommendationId,
            status: 'scheduled',
            scheduledAt: new Date(),
            executor,
            progress: 0,
            logs: [`Recommendation approved by ${executor}`],
            errors: [],
        };
        this.optimizationExecutions.set(execution.id, execution);
        this.redactedLogger.log(`Optimization recommendation approved`, 'CostOptimizationAIService', {
            recommendationId,
            executor,
            executionId: execution.id,
        });
        return execution.id;
    }
    async executeOptimization(executionId) {
        const execution = this.optimizationExecutions.get(executionId);
        if (!execution) {
            return false;
        }
        const recommendation = this.optimizationRecommendations.get(execution.recommendationId);
        if (!recommendation) {
            return false;
        }
        execution.status = 'running';
        execution.startedAt = new Date();
        try {
            for (let i = 0; i <= 100; i += 20) {
                execution.progress = i;
                execution.logs.push(`Step ${i / 20 + 1}/5: ${this.getStepDescription(i / 20 + 1)}`);
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
            }
            execution.status = 'completed';
            execution.completedAt = new Date();
            execution.progress = 100;
            execution.logs.push('Optimization completed successfully');
            recommendation.status = 'implemented';
            recommendation.implementedAt = new Date();
            recommendation.actualSavings =
                recommendation.proposedState.estimatedSavings * 0.9;
            this.redactedLogger.log(`Optimization executed successfully`, 'CostOptimizationAIService', {
                executionId,
                recommendationId: recommendation.id,
                actualSavings: recommendation.actualSavings,
            });
            return true;
        }
        catch (error) {
            execution.status = 'failed';
            execution.errors.push(error instanceof Error ? error.message : 'Unknown error');
            execution.logs.push('Optimization failed');
            this.redactedLogger.errorWithData(`Optimization execution failed`, {
                executionId,
                error: execution.errors[0],
            }, 'CostOptimizationAIService');
            return false;
        }
    }
    getStepDescription(step) {
        const descriptions = [
            'Analyzing current state',
            'Preparing optimization plan',
            'Implementing changes',
            'Verifying results',
            'Finalizing optimization',
        ];
        return descriptions[step - 1] ?? 'Unknown step';
    }
    async getOptimizationMetrics() {
        const recommendations = Array.from(this.optimizationRecommendations.values());
        const implemented = recommendations.filter(r => r.status === 'implemented');
        const totalSavings = implemented.reduce((sum, r) => sum + (r.actualSavings ?? 0), 0);
        const averageSavings = implemented.length > 0 ? totalSavings / implemented.length : 0;
        const successRate = recommendations.length > 0
            ? (implemented.length / recommendations.length) * 100
            : 0;
        const typeBreakdown = new Map();
        implemented.forEach(rec => {
            const current = typeBreakdown.get(rec.type) ?? { savings: 0, count: 0 };
            current.savings += rec.actualSavings ?? 0;
            current.count += 1;
            typeBreakdown.set(rec.type, current);
        });
        const topOptimizations = Array.from(typeBreakdown.entries())
            .map(([type, data]) => ({
            type,
            savings: data.savings,
            count: data.count,
        }))
            .sort((a, b) => b.savings - a.savings)
            .slice(0, 5);
        const regionalBreakdown = [
            {
                region: 'RU',
                savings: totalSavings * 0.4,
                recommendations: implemented.length * 0.4,
            },
            {
                region: 'BY',
                savings: totalSavings * 0.6,
                recommendations: implemented.length * 0.6,
            },
        ];
        const providerBreakdown = [
            {
                provider: 'hoster-by',
                savings: totalSavings * 0.3,
                recommendations: implemented.length * 0.3,
            },
            {
                provider: 'becloud',
                savings: totalSavings * 0.25,
                recommendations: implemented.length * 0.25,
            },
            {
                provider: 'vk-cloud',
                savings: totalSavings * 0.25,
                recommendations: implemented.length * 0.25,
            },
            {
                provider: 'other',
                savings: totalSavings * 0.2,
                recommendations: implemented.length * 0.2,
            },
        ];
        return {
            totalRecommendations: recommendations.length,
            implementedRecommendations: implemented.length,
            totalSavings: Math.round(totalSavings * 100) / 100,
            averageSavings: Math.round(averageSavings * 100) / 100,
            successRate: Math.round(successRate * 100) / 100,
            topOptimizations,
            regionalBreakdown,
            providerBreakdown,
        };
    }
    async getOptimizationRecommendations() {
        return Array.from(this.optimizationRecommendations.values());
    }
    async getResourceUsagePatterns() {
        return Array.from(this.resourceUsagePatterns.values());
    }
    async getCostPredictions() {
        return Array.from(this.costPredictions.values());
    }
    async getAIModels() {
        return Array.from(this.aiModels.values());
    }
    async getOptimizationExecutions() {
        return Array.from(this.optimizationExecutions.values());
    }
    async addOptimizationRecommendation(recommendation) {
        const recommendationId = `rec-${Date.now()}`;
        const newRecommendation = {
            ...recommendation,
            id: recommendationId,
            createdAt: new Date(),
        };
        this.optimizationRecommendations.set(recommendationId, newRecommendation);
        return recommendationId;
    }
    async updateRecommendationStatus(recommendationId, status) {
        const recommendation = this.optimizationRecommendations.get(recommendationId);
        if (!recommendation) {
            return false;
        }
        recommendation.status = status;
        if (status === 'implemented') {
            recommendation.implementedAt = new Date();
        }
        return true;
    }
    optimizeCosts(serviceId) {
        const recommendations = [
            {
                type: 'resource-downsize',
                description: 'Scale down underutilized resources',
                estimatedSavings: Math.random() * 200 + 100,
                implementationEffort: 'low',
            },
            {
                type: 'provider-migration',
                description: 'Migrate to more cost-effective provider',
                estimatedSavings: Math.random() * 500 + 300,
                implementationEffort: 'medium',
            },
            {
                type: 'reserved-instance',
                description: 'Purchase reserved instances for predictable workloads',
                estimatedSavings: Math.random() * 300 + 200,
                implementationEffort: 'low',
            },
        ];
        const totalEstimatedSavings = recommendations.reduce((sum, rec) => sum + rec.estimatedSavings, 0);
        const confidenceScore = Math.random() * 0.3 + 0.7;
        return {
            serviceId,
            recommendations: recommendations.map(rec => ({
                ...rec,
                estimatedSavings: Math.round(rec.estimatedSavings * 100) / 100,
            })),
            confidenceScore: Math.round(confidenceScore * 100) / 100,
            totalEstimatedSavings: Math.round(totalEstimatedSavings * 100) / 100,
        };
    }
    predictResourceUsage(serviceId, period) {
        const predictions = [
            {
                resourceType: 'CPU',
                currentUsage: Math.random() * 40 + 30,
                predictedUsage: Math.random() * 60 + 40,
                confidence: Math.random() * 0.3 + 0.7,
                trend: 'increasing',
            },
            {
                resourceType: 'Memory',
                currentUsage: Math.random() * 50 + 25,
                predictedUsage: Math.random() * 70 + 35,
                confidence: Math.random() * 0.25 + 0.75,
                trend: 'increasing',
            },
            {
                resourceType: 'Storage',
                currentUsage: Math.random() * 60 + 20,
                predictedUsage: Math.random() * 80 + 30,
                confidence: Math.random() * 0.2 + 0.8,
                trend: 'stable',
            },
        ];
        const overallTrend = predictions.filter(p => p.trend === 'increasing').length > 1
            ? 'increasing'
            : 'stable';
        const recommendations = predictions
            .filter(p => p.trend === 'increasing')
            .map(p => `Plan for ${p.resourceType} scaling - expected growth: ${Math.round(((p.predictedUsage - p.currentUsage) / p.currentUsage) * 100)}%`);
        return {
            serviceId,
            period,
            predictions: predictions.map(p => ({
                ...p,
                currentUsage: Math.round(p.currentUsage * 100) / 100,
                predictedUsage: Math.round(p.predictedUsage * 100) / 100,
                confidence: Math.round(p.confidence * 100) / 100,
            })),
            overallTrend,
            recommendations,
        };
    }
    detectAnomalies(serviceId) {
        const anomalies = [
            {
                type: 'cost-spike',
                severity: 'high',
                description: 'Unusual cost increase detected',
                detectedAt: new Date(),
                impact: 'Budget exceeded by 25%',
            },
            {
                type: 'resource-utilization',
                severity: 'medium',
                description: 'Low resource utilization pattern',
                detectedAt: new Date(),
                impact: 'Potential cost optimization opportunity',
            },
            {
                type: 'provider-performance',
                severity: 'low',
                description: 'Provider performance degradation',
                detectedAt: new Date(),
                impact: 'Consider alternative providers',
            },
        ];
        const criticalAnomalies = anomalies.filter(a => a.severity === 'critical').length;
        return {
            serviceId,
            anomalies,
            totalAnomalies: anomalies.length,
            criticalAnomalies,
        };
    }
    analyzeUsagePatterns(serviceId) {
        const patterns = [
            {
                type: 'daily-usage',
                description: 'Peak usage during business hours',
                frequency: 'Daily',
                impact: 'High',
                recommendation: 'Implement auto-scaling',
            },
            {
                type: 'weekly-usage',
                description: 'Lower usage on weekends',
                frequency: 'Weekly',
                impact: 'Medium',
                recommendation: 'Schedule maintenance on weekends',
            },
            {
                type: 'monthly-usage',
                description: 'Consistent growth trend',
                frequency: 'Monthly',
                impact: 'High',
                recommendation: 'Plan capacity expansion',
            },
        ];
        const seasonalTrends = [
            'Higher usage during Q4 (holiday season)',
            'Lower usage during summer months',
            'Spikes during major events',
        ];
        const optimizationOpportunities = Math.floor(Math.random() * 5) + 3;
        return {
            serviceId,
            patterns,
            seasonalTrends,
            optimizationOpportunities,
        };
    }
};
CostOptimizationAIService = CostOptimizationAIService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CostOptimizationAIService);



/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppCacheModule: () => (/* binding */ AppCacheModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _redis_redis_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony import */ var _cache_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
/* harmony import */ var _cache_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





let AppCacheModule = class AppCacheModule {
};
AppCacheModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_1__.CacheModule.register({
                isGlobal: true,
                ttl: 60 * 60 * 24,
                max: 1000,
            }),
            _redis_redis_module__WEBPACK_IMPORTED_MODULE_2__.RedisModule,
        ],
        providers: [_cache_service__WEBPACK_IMPORTED_MODULE_3__.CacheService],
        controllers: [_cache_controller__WEBPACK_IMPORTED_MODULE_4__.CacheController],
        exports: [_cache_service__WEBPACK_IMPORTED_MODULE_3__.CacheService],
    })
], AppCacheModule);



/***/ }),
/* 59 */
/***/ ((module) => {

module.exports = require("@nestjs/cache-manager");

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RedisModule: () => (/* binding */ RedisModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _redis_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



let RedisModule = class RedisModule {
};
RedisModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule],
        providers: [
            {
                provide: 'REDIS_CLIENT',
                useFactory: async () => {
                    const mockRedis = {
                        get: async () => null,
                        set: async () => 'OK',
                        del: async () => 1,
                        exists: async () => 0,
                        expire: async () => 1,
                        ttl: async () => -1,
                        keys: async () => [],
                        flushall: async () => 'OK',
                        ping: async () => 'PONG',
                        on: () => { },
                        connect: async () => { },
                        disconnect: async () => { },
                    };
                    console.log('Using mock Redis client for development');
                    return mockRedis;
                },
                inject: [],
            },
            _redis_service__WEBPACK_IMPORTED_MODULE_2__.RedisService,
        ],
        exports: ['REDIS_CLIENT', _redis_service__WEBPACK_IMPORTED_MODULE_2__.RedisService],
    })
], RedisModule);



/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RedisService: () => (/* binding */ RedisService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RedisService_1;

let RedisService = RedisService_1 = class RedisService {
    constructor(redisClient) {
        this.redisClient = redisClient;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(RedisService_1.name);
    }
    getClient() {
        return this.redisClient;
    }
    async get(key) {
        try {
            return await this.redisClient.get(key);
        }
        catch {
            this.logger.error(`Error getting key ${key}`);
            return null;
        }
    }
    async set(key, value, ttl) {
        try {
            const result = await this.redisClient.set(key, value);
            if (ttl != null && ttl > 0) {
                await this.redisClient.expire(key, ttl);
            }
            return result;
        }
        catch {
            this.logger.error(`Error setting key ${key}`);
            throw new Error('Redis set operation failed');
        }
    }
    async del(key) {
        try {
            return await this.redisClient.del(key);
        }
        catch {
            this.logger.error(`Error deleting key ${key}`);
            return 0;
        }
    }
    async exists(key) {
        try {
            return await this.redisClient.exists(key);
        }
        catch {
            this.logger.error(`Error checking existence of key ${key}`);
            return 0;
        }
    }
    async expire(key, ttl) {
        try {
            return await this.redisClient.expire(key, ttl);
        }
        catch {
            this.logger.error(`Error setting TTL for key ${key}`);
            return 0;
        }
    }
    async ttl(key) {
        try {
            return await this.redisClient.ttl(key);
        }
        catch {
            this.logger.error(`Error getting TTL for key ${key}`);
            return -1;
        }
    }
    async keys(pattern) {
        try {
            return await this.redisClient.keys(pattern);
        }
        catch {
            this.logger.error(`Error getting keys for pattern ${pattern}`);
            return [];
        }
    }
    async flushall() {
        try {
            return await this.redisClient.flushall();
        }
        catch {
            this.logger.error('Error flushing all keys');
            throw new Error('Redis flush operation failed');
        }
    }
    async ping() {
        try {
            return await this.redisClient.ping();
        }
        catch {
            this.logger.error('Error pinging Redis');
            throw new Error('Redis ping operation failed');
        }
    }
    async connect() {
        try {
            await this.redisClient.connect();
            this.logger.log('Connected to Redis');
        }
        catch {
            this.logger.error('Error connecting to Redis');
            throw new Error('Redis connection failed');
        }
    }
    async disconnect() {
        try {
            await this.redisClient.disconnect();
            this.logger.log('Disconnected from Redis');
        }
        catch {
            this.logger.error('Error disconnecting from Redis');
            throw new Error('Redis disconnection failed');
        }
    }
    async healthCheck() {
        try {
            const startTime = Date.now();
            await this.redisClient.ping();
            const latency = Date.now() - startTime;
            return {
                status: 'healthy',
                latency,
            };
        }
        catch {
            this.logger.error('Redis health check failed');
            return {
                status: 'unhealthy',
            };
        }
    }
    async getInfo() {
        try {
            await this.redisClient.ping();
            return {
                connected: true,
                clientType: 'mock',
                version: '1.0.0',
            };
        }
        catch {
            return {
                connected: false,
                clientType: 'unknown',
            };
        }
    }
};
RedisService = RedisService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Inject)('REDIS_CLIENT')),
    __metadata("design:paramtypes", [Object])
], RedisService);



/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CacheService: () => (/* binding */ CacheService)
/* harmony export */ });
/* harmony import */ var _nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CacheService_1;


let CacheService = CacheService_1 = class CacheService {
    constructor(cacheManager, redis) {
        this.cacheManager = cacheManager;
        this.redis = redis;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Logger(CacheService_1.name);
        this.stats = {
            hits: 0,
            misses: 0,
        };
    }
    async get(key) {
        try {
            const value = await this.cacheManager.get(key);
            if (value !== undefined && value !== null) {
                this.stats.hits++;
                this.logger.debug(`Cache HIT: ${key}`);
                return value;
            }
            else {
                this.stats.misses++;
                this.logger.debug(`Cache MISS: ${key}`);
                return null;
            }
        }
        catch (error) {
            this.logger.error(`Cache get error for key ${key}:`, error);
            return null;
        }
    }
    async set(key, value, ttl) {
        try {
            await this.cacheManager.set(key, value, ttl);
            this.logger.debug(`Cache SET: ${key} (TTL: ${ttl ?? 'default'}s)`);
        }
        catch (error) {
            this.logger.error(`Cache set error for key ${key}:`, error);
        }
    }
    async delete(key) {
        try {
            await this.cacheManager.del(key);
            this.logger.debug(`Cache DELETE: ${key}`);
        }
        catch (error) {
            this.logger.error(`Cache delete error for key ${key}:`, error);
        }
    }
    async deleteByPattern(pattern) {
        try {
            const keys = await this.redis.keys(pattern);
            if (keys.length > 0) {
                const deleted = await this.redis.del(...keys);
                this.logger.debug(`Cache DELETE PATTERN: ${pattern} (${deleted} keys)`);
                return deleted;
            }
            return 0;
        }
        catch (error) {
            this.logger.error(`Cache delete pattern error for ${pattern}:`, error);
            return 0;
        }
    }
    async clear() {
        try {
            await this.redis.flushdb();
            this.logger.debug('Cache CLEAR: all keys');
        }
        catch (error) {
            this.logger.error('Cache clear error:', error);
        }
    }
    async getTTL(key) {
        try {
            const ttl = await this.redis.ttl(key);
            return ttl;
        }
        catch (error) {
            this.logger.error(`Cache TTL error for key ${key}:`, error);
            return -1;
        }
    }
    async setTTL(key, ttl) {
        try {
            const result = await this.redis.expire(key, ttl);
            this.logger.debug(`Cache SET TTL: ${key} -> ${ttl}s`);
            return result === 1;
        }
        catch (error) {
            this.logger.error(`Cache set TTL error for key ${key}:`, error);
            return false;
        }
    }
    async getStats() {
        try {
            const info = await this.redis.info('stats');
            const keys = await this.redis.dbsize();
            const memory = await this.redis.info('memory');
            const stats = this.parseRedisInfo(info);
            const memoryInfo = this.parseRedisMemory(memory);
            return {
                hits: this.stats.hits,
                misses: this.stats.misses,
                keys,
                memory: memoryInfo.used_memory_human ?? '0B',
                uptime: stats.uptime_in_seconds ?? 0,
            };
        }
        catch (error) {
            this.logger.error('Cache stats error:', error);
            return {
                hits: this.stats.hits,
                misses: this.stats.misses,
                keys: 0,
                memory: '0B',
                uptime: 0,
            };
        }
    }
    async healthCheck() {
        try {
            await this.redis.ping();
            return { status: 'healthy', message: 'Redis connection is healthy' };
        }
        catch (error) {
            this.logger.error('Redis health check failed:', error);
            return { status: 'unhealthy', message: 'Redis connection failed' };
        }
    }
    parseRedisInfo(info) {
        const stats = {};
        const lines = info.split('\r\n');
        for (const line of lines) {
            const [key, value] = line.split(':');
            if (key != null &&
                key !== '' &&
                value != null &&
                value !== '' &&
                !Number.isNaN(Number(value))) {
                stats[key] = Number(value);
            }
        }
        return stats;
    }
    parseRedisMemory(memory) {
        const memoryInfo = {};
        const lines = memory.split('\r\n');
        for (const line of lines) {
            const [key, value] = line.split(':');
            if (key != null && key !== '' && value != null && value !== '') {
                memoryInfo[key] = value;
            }
        }
        return memoryInfo;
    }
    async getPerformanceMetrics() {
        try {
            const start = Date.now();
            await this.redis.ping();
            const responseTime = Date.now() - start;
            const total = this.stats.hits + this.stats.misses;
            const hitRate = total > 0 ? this.stats.hits / total : 0;
            const errorRate = 1 - hitRate;
            return {
                responseTime,
                throughput: total,
                errorRate,
            };
        }
        catch (error) {
            this.logger.error('Performance metrics error:', error);
            return {
                responseTime: -1,
                throughput: 0,
                errorRate: 1,
            };
        }
    }
};
CacheService = CacheService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Injectable)(),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Inject)(_nestjs_cache_manager__WEBPACK_IMPORTED_MODULE_0__.CACHE_MANAGER)),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Inject)('REDIS_CLIENT')),
    __metadata("design:paramtypes", [Object, Object])
], CacheService);



/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CacheController: () => (/* binding */ CacheController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cache_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;



let CacheController = class CacheController {
    constructor(cacheService) {
        this.cacheService = cacheService;
    }
    async healthCheck() {
        return this.cacheService.healthCheck();
    }
    async getStats() {
        return this.cacheService.getStats();
    }
    async getPerformanceMetrics() {
        return this.cacheService.getPerformanceMetrics();
    }
    async get(key) {
        const value = await this.cacheService.get(key);
        if (value === null) {
            return { message: 'Key not found', key };
        }
        return { key, value };
    }
    async getTTL(key) {
        const ttl = await this.cacheService.getTTL(key);
        return { key, ttl };
    }
    async set(dto) {
        await this.cacheService.set(dto.key, dto.value, dto.ttl);
        return { message: 'Value set successfully', key: dto.key };
    }
    async setTTL(key, ttl) {
        const success = await this.cacheService.setTTL(key, ttl);
        return { key, ttl, success };
    }
    async delete(key) {
        await this.cacheService.delete(key);
        return { message: 'Key deleted successfully', key };
    }
    async deleteByPattern(dto) {
        const deleted = await this.cacheService.deleteByPattern(dto.pattern);
        return {
            message: 'Keys deleted successfully',
            pattern: dto.pattern,
            deleted,
        };
    }
    async clear() {
        await this.cacheService.clear();
        return { message: 'Cache cleared successfully' };
    }
    async setDemoData() {
        const demoData = {
            users: [
                { id: 1, name: 'John Doe', email: 'john@example.com' },
                { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
            ],
            cards: [
                { id: 'card-1', name: 'Скидка 10%', discount: 10 },
                { id: 'card-2', name: 'Скидка 15%', discount: 15 },
            ],
            timestamp: new Date().toISOString(),
        };
        await this.cacheService.set('demo:data', demoData, 3600);
        await this.cacheService.set('demo:users', demoData.users, 1800);
        await this.cacheService.set('demo:cards', demoData.cards, 7200);
        return {
            message: 'Demo data set successfully',
            keys: ['demo:data', 'demo:users', 'demo:cards'],
        };
    }
    async getDemoData() {
        const data = await this.cacheService.get('demo:data');
        const users = await this.cacheService.get('demo:users');
        const cards = await this.cacheService.get('demo:cards');
        return {
            data,
            users,
            cards,
            cacheStats: await this.cacheService.getStats(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Redis' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Redis здоров' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 503, description: 'Redis недоступен' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "healthCheck", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика кеша' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], CacheController.prototype, "getStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить метрики производительности' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Метрики производительности' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "getPerformanceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить значение из кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Ключ кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Значение найдено' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Значение не найдено' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "get", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':key/ttl'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить TTL ключа' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Ключ кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'TTL ключа' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "getTTL", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('set'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Установить значение в кеш' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Значение установлено' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "set", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)(':key/ttl'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Установить TTL для ключа' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Ключ кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'ttl', description: 'TTL в секундах', type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'TTL установлен' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('ttl')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "setTTL", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)(':key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Удалить ключ из кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Ключ кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Ключ удален' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "delete", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('pattern'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Удалить ключи по паттерну' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Ключи удалены' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "deleteByPattern", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('clear/all'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Очистить весь кеш' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Кеш очищен' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "clear", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/set-demo'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Установить демо данные в кеш' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Демо данные установлены' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "setDemoData", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('test/get-demo'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить демо данные из кеша' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Демо данные' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CacheController.prototype, "getDemoData", null);
CacheController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('cache'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('cache'),
    __metadata("design:paramtypes", [typeof (_a = typeof _cache_service__WEBPACK_IMPORTED_MODULE_2__.CacheService !== "undefined" && _cache_service__WEBPACK_IMPORTED_MODULE_2__.CacheService) === "function" ? _a : Object])
], CacheController);



/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardsModule: () => (/* binding */ CardsModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _cards_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/* harmony import */ var _cards_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _supabase_supabase_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




let CardsModule = class CardsModule {
};
CardsModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_supabase_supabase_module__WEBPACK_IMPORTED_MODULE_3__.SupabaseModule],
        controllers: [_cards_controller__WEBPACK_IMPORTED_MODULE_1__.CardsController],
        providers: [_cards_service__WEBPACK_IMPORTED_MODULE_2__.CardsService],
        exports: [_cards_service__WEBPACK_IMPORTED_MODULE_2__.CardsService],
    })
], CardsModule);



/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardsController: () => (/* binding */ CardsController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cards_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_role_mapping_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(41);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _auth_decorators_resource_decorator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
/* harmony import */ var _auth_decorators_operation_decorator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68);
/* harmony import */ var _auth_decorators_crud_decorator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;










let CardsController = class CardsController {
    constructor(cardsService) {
        this.cardsService = cardsService;
    }
    async getCards(limit, offset) {
        return this.cardsService.getCards(limit != null && limit !== '' ? Number.parseInt(limit, 10) : 10, offset != null && offset !== '' ? Number.parseInt(offset, 10) : 0);
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить список карт лояльности' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список карт' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, description: 'Количество карт' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'offset', required: false, description: 'Смещение' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_5__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_9__.UserRole.USER, _types_roles__WEBPACK_IMPORTED_MODULE_9__.UserRole.STORE_MANAGER, _types_roles__WEBPACK_IMPORTED_MODULE_9__.UserRole.BRAND_MANAGER, _types_roles__WEBPACK_IMPORTED_MODULE_9__.UserRole.NETWORK_MANAGER, _types_roles__WEBPACK_IMPORTED_MODULE_9__.UserRole.SUPER_ADMIN),
    (0,_auth_decorators_resource_decorator__WEBPACK_IMPORTED_MODULE_6__.Resource)('cards'),
    (0,_auth_decorators_operation_decorator__WEBPACK_IMPORTED_MODULE_7__.Operation)('read'),
    (0,_auth_decorators_crud_decorator__WEBPACK_IMPORTED_MODULE_8__.CRUD)('list'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('offset')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], CardsController.prototype, "getCards", null);
CardsController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('cards'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('cards'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__.JwtAuthGuard, _auth_guards_role_mapping_guard__WEBPACK_IMPORTED_MODULE_4__.RoleMappingGuard),
    __metadata("design:paramtypes", [typeof (_a = typeof _cards_service__WEBPACK_IMPORTED_MODULE_2__.CardsService !== "undefined" && _cards_service__WEBPACK_IMPORTED_MODULE_2__.CardsService) === "function" ? _a : Object])
], CardsController);



/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CardsService: () => (/* binding */ CardsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CardsService_1;

let CardsService = CardsService_1 = class CardsService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CardsService_1.name);
    }
    async getCards(limit = 10, offset = 0) {
        try {
            return [
                {
                    id: 'card-1',
                    name: 'Скидка 10% на все товары',
                    description: 'Базовая карта лояльности с универсальной скидкой',
                    discount: 10,
                    network: 'Demo Network',
                },
                {
                    id: 'card-2',
                    name: 'Скидка 15% на электронику',
                    description: 'Специальная карта для категории электроники',
                    discount: 15,
                    network: 'Demo Network',
                },
                {
                    id: 'card-3',
                    name: 'Скидка 20% на одежду',
                    description: 'Карта лояльности для модной одежды',
                    discount: 20,
                    network: 'Demo Network',
                },
            ].slice(offset, offset + limit);
        }
        catch (error) {
            this.logger.error('Ошибка получения карт:', error);
            return [];
        }
    }
};
CardsService = CardsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CardsService);



/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRUD: () => (/* binding */ CRUD),
/* harmony export */   Create: () => (/* binding */ Create),
/* harmony export */   Delete: () => (/* binding */ Delete),
/* harmony export */   FullAccess: () => (/* binding */ FullAccess),
/* harmony export */   ModuleResource: () => (/* binding */ ModuleResource),
/* harmony export */   Operation: () => (/* binding */ Operation),
/* harmony export */   Permission: () => (/* binding */ Permission),
/* harmony export */   Permissions: () => (/* binding */ Permissions),
/* harmony export */   RESOURCE_KEY: () => (/* binding */ RESOURCE_KEY),
/* harmony export */   Read: () => (/* binding */ Read),
/* harmony export */   Resource: () => (/* binding */ Resource),
/* harmony export */   Update: () => (/* binding */ Update)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);

const RESOURCE_KEY = 'resource';
const Resource = (__resource) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)(RESOURCE_KEY, __resource);
const Operation = (operation) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)('operation', operation);
const CRUD = (__resource, operations = ['read']) => {
    const permissions = operations.map(operation => ({
        _resource: __resource,
        operation,
    }));
    return (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)('requiredPermissions', permissions);
};
const Create = (__resource) => CRUD(__resource, ['create']);
const Read = (__resource) => CRUD(__resource, ['read']);
const Update = (__resource) => CRUD(__resource, ['update']);
const Delete = (__resource) => CRUD(__resource, ['delete']);
const FullAccess = (__resource) => CRUD(__resource, ['create', 'read', 'update', 'delete']);
const ModuleResource = (module) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)('module', module);
const Permission = (permission, roles) => {
    const [_resource, operation] = permission.split('_');
    const requiredPermission = {
        _resource: _resource ?? '',
        operation: operation ?? '',
        ...(roles && { roles }),
    };
    return (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)('requiredPermissions', [requiredPermission]);
};
const Permissions = (permissions) => {
    return (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)('requiredPermissions', permissions);
};


/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OPERATION_KEY: () => (/* binding */ OPERATION_KEY),
/* harmony export */   Operation: () => (/* binding */ Operation)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);

const OPERATION_KEY = 'operation';
const Operation = (operation) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)(OPERATION_KEY, operation);


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CRUD: () => (/* binding */ CRUD),
/* harmony export */   CRUD_KEY: () => (/* binding */ CRUD_KEY)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);

const CRUD_KEY = 'crud';
const CRUD = (operation) => (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.SetMetadata)(CRUD_KEY, operation);


/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigurationModule: () => (/* binding */ ConfigurationModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _environment_config_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73);
/* harmony import */ var _configuration_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(74);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






let ConfigurationModule = class ConfigurationModule {
};
ConfigurationModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Global)(),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitterModule],
        providers: [
            _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService,
            _environment_config_service__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfigService,
            _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__.SecretsManagerService,
        ],
        controllers: [_configuration_controller__WEBPACK_IMPORTED_MODULE_5__.ConfigurationController],
        exports: [
            _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService,
            _environment_config_service__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfigService,
            _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__.SecretsManagerService,
        ],
    })
], ConfigurationModule);



/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CentralizedConfigService: () => (/* binding */ CentralizedConfigService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CentralizedConfigService_1;
var _a, _b;



let CentralizedConfigService = CentralizedConfigService_1 = class CentralizedConfigService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CentralizedConfigService_1.name);
        this.configs = new Map();
        this.schemas = new Map();
        this.backups = new Map();
        this.changeHistory = [];
        this._configService.get('CENTRALIZED_CONFIG_ENABLED');
    }
    async onModuleInit() {
        await this.initializeDefaultConfigs();
        await this.loadConfigsFromEnvironment();
        this.startConfigWatcher();
    }
    async initializeDefaultConfigs() {
        const defaultConfigs = [
            {
                key: 'auth.jwt.secret',
                value: this._configService.get('JWT_SECRET', 'default-secret'),
                type: 'string',
                environment: 'all',
                service: 'auth-service',
            },
            {
                key: 'auth.jwt.expiresIn',
                value: this._configService.get('JWT_EXPIRES_IN', '1h'),
                type: 'string',
                environment: 'all',
                service: 'auth-service',
            },
            {
                key: 'database.url',
                value: this._configService.get('DATABASE_URL', 'postgresql://localhost:5432/salespot'),
                type: 'string',
                environment: 'all',
                service: 'database',
            },
            {
                key: 'database.pool.min',
                value: parseInt(this._configService.get('DB_POOL_MIN', '2')),
                type: 'number',
                environment: 'all',
                service: 'database',
            },
            {
                key: 'database.pool.max',
                value: parseInt(this._configService.get('DB_POOL_MAX', '10')),
                type: 'number',
                environment: 'all',
                service: 'database',
            },
            {
                key: 'redis.url',
                value: this._configService.get('REDIS_URL', 'redis://localhost:6379'),
                type: 'string',
                environment: 'all',
                service: 'redis',
            },
            {
                key: 'redis.ttl',
                value: parseInt(this._configService.get('REDIS_TTL', '3600')),
                type: 'number',
                environment: 'all',
                service: 'redis',
            },
            {
                key: 'monitoring.enabled',
                value: this._configService.get('MONITORING_ENABLED', 'true') === 'true',
                type: 'boolean',
                environment: 'all',
                service: 'monitoring',
            },
            {
                key: 'monitoring.interval',
                value: parseInt(this._configService.get('MONITORING_INTERVAL', '30000')),
                type: 'number',
                environment: 'all',
                service: 'monitoring',
            },
            {
                key: 'security.rateLimit.enabled',
                value: this._configService.get('RATE_LIMIT_ENABLED', 'true') === 'true',
                type: 'boolean',
                environment: 'all',
                service: 'security',
            },
            {
                key: 'security.rateLimit.max',
                value: parseInt(this._configService.get('RATE_LIMIT_MAX', '100')),
                type: 'number',
                environment: 'all',
                service: 'security',
            },
            {
                key: 'features.newDashboard',
                value: this._configService.get('FEATURE_NEW_DASHBOARD', 'false') === 'true',
                type: 'boolean',
                environment: 'all',
                service: 'feature-flags',
            },
            {
                key: 'features.aiAssistant',
                value: this._configService.get('FEATURE_AI_ASSISTANT', 'true') === 'true',
                type: 'boolean',
                environment: 'all',
                service: 'feature-flags',
            },
        ];
        for (const config of defaultConfigs) {
            await this.setConfig(config.key, config.value, config.environment, config.service, 'system');
        }
        this.logger.log(`Initialized ${defaultConfigs.length} default configurations`);
    }
    async loadConfigsFromEnvironment() {
        const envConfigs = this._configService.get('CONFIG_OVERRIDES', '{}');
        try {
            const overrides = JSON.parse(envConfigs);
            for (const [key, value] of Object.entries(overrides)) {
                await this.setConfig(key, value, 'all', 'system', 'environment');
            }
        }
        catch (error) {
            this.logger.warn('Failed to parse CONFIG_OVERRIDES:', error);
        }
    }
    startConfigWatcher() {
        setInterval(() => {
            void this.checkForEnvironmentChanges();
        }, 30000);
    }
    async checkForEnvironmentChanges() {
        const currentEnv = process.env;
        const changedKeys = [];
        for (const [key, value] of Object.entries(currentEnv)) {
            if (key.startsWith('CONFIG_')) {
                const configKey = key
                    .replace('CONFIG_', '')
                    .toLowerCase()
                    .replace(/_/g, '.');
                const currentConfig = this.configs.get(configKey);
                if (!currentConfig || currentConfig.value !== value) {
                    changedKeys.push(configKey);
                }
            }
        }
        if (changedKeys.length > 0) {
            this.logger.log(`Detected ${changedKeys.length} environment configuration changes`);
            this.eventEmitter.emit('config.changed', { keys: changedKeys });
        }
    }
    async setConfig(key, value, environment, _service, changedBy) {
        const oldConfig = this.configs.get(key);
        const newConfig = {
            key,
            value,
            type: typeof value,
            environment,
            _service: _service,
            lastUpdated: new Date(),
            version: oldConfig ? oldConfig.version + 1 : 1,
        };
        const schema = this.schemas.get(_service);
        if (schema?.[key]) {
            try {
                schema[key].parse(value);
            }
            catch (error) {
                throw new Error(`Configuration validation failed for ${key}: ${error}`);
            }
        }
        if (oldConfig != null) {
            await this.createBackup(key, oldConfig.value, environment, _service);
        }
        this.configs.set(key, newConfig);
        if (oldConfig != null) {
            this.changeHistory.push({
                key,
                oldValue: oldConfig.value,
                newValue: value,
                environment,
                _service,
                timestamp: new Date(),
                changedBy,
            });
        }
        this.eventEmitter.emit('config.updated', {
            key,
            oldValue: oldConfig?.value,
            newValue: value,
            environment,
            _service,
        });
        this.logger.log(`Configuration updated: ${key} = ${value} (${_service})`);
    }
    async getConfig(key, environment) {
        const config = this.configs.get(key);
        if (config == null) {
            return undefined;
        }
        if (environment != null &&
            config.environment !== 'all' &&
            config.environment !== environment) {
            return undefined;
        }
        return config.value;
    }
    async getAllConfigs(service, environment) {
        const configs = Array.from(this.configs.values());
        let filtered = configs;
        if (service != null) {
            filtered = filtered.filter(config => config._service === service);
        }
        if (environment != null) {
            filtered = filtered.filter(config => config.environment === 'all' || config.environment === environment);
        }
        return filtered;
    }
    async registerSchema(_service, schema) {
        this.schemas.set(_service, schema);
        this.logger.log(`Registered configuration schema for service: ${_service}`);
    }
    async validateConfig(_service, config) {
        const schema = this.schemas.get(_service);
        if (!schema) {
            return true;
        }
        try {
            for (const [key, value] of Object.entries(config)) {
                if (schema[key]) {
                    schema[key].parse(value);
                }
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Configuration validation failed for ${_service}:`, error);
            return false;
        }
    }
    async createBackup(key, value, environment, _service) {
        const backupId = `${_service}-${environment}-${Date.now()}`;
        const backup = {
            id: backupId,
            environment,
            _service,
            config: { [key]: value },
            timestamp: new Date(),
            version: 1,
        };
        this.backups.set(backupId, backup);
        if (this.backups.size > 100) {
            const oldestBackup = Array.from(this.backups.values()).sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())[0];
            if (oldestBackup != null) {
                this.backups.delete(oldestBackup.id);
            }
        }
    }
    async getBackups(service, environment) {
        const backups = Array.from(this.backups.values());
        let filtered = backups;
        if (service != null) {
            filtered = filtered.filter(backup => backup._service === service);
        }
        if (environment != null) {
            filtered = filtered.filter(backup => backup.environment === 'all' || backup.environment === environment);
        }
        return filtered.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getChangeHistory(service, key) {
        let history = this.changeHistory;
        if (service != null) {
            history = history.filter(change => change._service === service);
        }
        if (key != null) {
            history = history.filter(change => change.key === key);
        }
        return history.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async exportConfig(_service, environment, format) {
        const configs = await this.getAllConfigs(_service, environment);
        switch (format) {
            case 'json':
                return JSON.stringify(configs.reduce((acc, config) => {
                    acc[config.key] = config.value;
                    return acc;
                }, {}), null, 2);
            case 'env':
                return configs
                    .map(config => `${config.key.toUpperCase().replace(/\./g, '_')}=${config.value}`)
                    .join('\n');
            case 'yaml':
                return configs
                    .map(config => `${config.key}: ${config.value}`)
                    .join('\n');
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }
};
CentralizedConfigService = CentralizedConfigService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], CentralizedConfigService);



/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentConfigService: () => (/* binding */ EnvironmentConfigService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EnvironmentConfigService_1;
var _a, _b;



let EnvironmentConfigService = EnvironmentConfigService_1 = class EnvironmentConfigService {
    constructor(_configService, centralizedConfigService) {
        this._configService = _configService;
        this.centralizedConfigService = centralizedConfigService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(EnvironmentConfigService_1.name);
        this.environments = new Map();
        this.overrides = new Map();
        this._configService.get('ENVIRONMENT_CONFIG_ENABLED');
        this.initializeEnvironments();
    }
    initializeEnvironments() {
        const environments = [
            {
                name: 'development',
                displayName: 'Development',
                description: 'Local development environment',
                configs: {
                    'database.pool.min': 1,
                    'database.pool.max': 5,
                    'monitoring.enabled': false,
                    'security.rateLimit.max': 1000,
                    'features.newDashboard': true,
                    'features.aiAssistant': true,
                },
                isActive: process.env.NODE_ENV === 'development',
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                name: 'staging',
                displayName: 'Staging',
                description: 'Staging environment for testing',
                configs: {
                    'database.pool.min': 2,
                    'database.pool.max': 8,
                    'monitoring.enabled': true,
                    'security.rateLimit.max': 500,
                    'features.newDashboard': true,
                    'features.aiAssistant': false,
                },
                isActive: process.env.NODE_ENV === 'test',
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                name: 'production',
                displayName: 'Production',
                description: 'Production environment',
                configs: {
                    'database.pool.min': 5,
                    'database.pool.max': 20,
                    'monitoring.enabled': true,
                    'security.rateLimit.max': 100,
                    'features.newDashboard': false,
                    'features.aiAssistant': true,
                },
                isActive: process.env.NODE_ENV === 'production',
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                name: 'testing',
                displayName: 'Testing',
                description: 'Testing environment',
                configs: {
                    'database.pool.min': 1,
                    'database.pool.max': 3,
                    'monitoring.enabled': false,
                    'security.rateLimit.max': 2000,
                    'features.newDashboard': true,
                    'features.aiAssistant': true,
                },
                isActive: process.env.NODE_ENV === 'test',
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        environments.forEach(env => {
            this.environments.set(env.name, env);
        });
        this.logger.log(`Initialized ${environments.length} environments`);
    }
    async getEnvironment(name) {
        return this.environments.get(name) ?? null;
    }
    async getAllEnvironments() {
        return Array.from(this.environments.values());
    }
    async getActiveEnvironment() {
        const activeEnv = Array.from(this.environments.values()).find(env => env.isActive);
        return activeEnv ?? null;
    }
    async setEnvironmentConfig(environment, key, value, reason, appliedBy) {
        const env = this.environments.get(environment);
        if (!env) {
            throw new Error(`Environment ${environment} not found`);
        }
        env.configs[key] = value;
        env.updatedAt = new Date();
        const override = {
            key,
            value,
            environment,
            reason,
            appliedAt: new Date(),
            appliedBy,
        };
        const overrides = this.overrides.get(environment) ?? [];
        overrides.push(override);
        this.overrides.set(environment, overrides);
        await this.centralizedConfigService.setConfig(key, value, environment, 'environment-config', appliedBy);
        this.logger.log(`Environment config updated: ${environment}.${key} = ${value}`);
    }
    async getEnvironmentOverrides(environment) {
        return this.overrides.get(environment) ?? [];
    }
    async applyEnvironmentConfig(environment) {
        const env = this.environments.get(environment);
        if (!env) {
            throw new Error(`Environment ${environment} not found`);
        }
        for (const [key, value] of Object.entries(env.configs)) {
            await this.centralizedConfigService.setConfig(key, value, environment, 'environment-config', 'system');
        }
        this.logger.log(`Applied ${Object.keys(env.configs).length} configurations for environment: ${environment}`);
    }
    async switchEnvironment(environment) {
        const env = this.environments.get(environment);
        if (!env) {
            throw new Error(`Environment ${environment} not found`);
        }
        for (const [, envConfig] of this.environments) {
            envConfig.isActive = false;
        }
        env.isActive = true;
        env.updatedAt = new Date();
        await this.applyEnvironmentConfig(environment);
        this.logger.log(`Switched to environment: ${environment}`);
    }
    async createEnvironment(name, displayName, description, baseEnvironment) {
        if (this.environments.has(name)) {
            throw new Error(`Environment ${name} already exists`);
        }
        let configs = {};
        if (baseEnvironment != null && baseEnvironment !== '') {
            const baseEnv = this.environments.get(baseEnvironment);
            if (baseEnv) {
                configs = { ...baseEnv.configs };
            }
        }
        const newEnvironment = {
            name,
            displayName,
            description,
            configs,
            isActive: false,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.environments.set(name, newEnvironment);
        this.logger.log(`Created new environment: ${name}`);
        return newEnvironment;
    }
    async deleteEnvironment(name) {
        if (name === 'production') {
            throw new Error('Cannot delete production environment');
        }
        const env = this.environments.get(name);
        if (!env) {
            throw new Error(`Environment ${name} not found`);
        }
        if (env.isActive) {
            throw new Error('Cannot delete active environment');
        }
        this.environments.delete(name);
        this.overrides.delete(name);
        this.logger.log(`Deleted environment: ${name}`);
    }
    async getEnvironmentDiff(env1, env2) {
        const environment1 = this.environments.get(env1);
        const environment2 = this.environments.get(env2);
        if (!environment1 || !environment2) {
            throw new Error('One or both environments not found');
        }
        const keys1 = Object.keys(environment1.configs);
        const keys2 = Object.keys(environment2.configs);
        const onlyInEnv1 = keys1.filter(key => !keys2.includes(key));
        const onlyInEnv2 = keys2.filter(key => !keys1.includes(key));
        const commonKeys = keys1.filter(key => keys2.includes(key));
        const different = commonKeys
            .filter(key => environment1.configs[key] !== environment2.configs[key])
            .map(key => ({
            key,
            value1: environment1.configs[key],
            value2: environment2.configs[key],
        }));
        return {
            onlyInEnv1,
            onlyInEnv2,
            different,
        };
    }
    async exportEnvironmentConfig(environment, format) {
        const env = this.environments.get(environment);
        if (!env) {
            throw new Error(`Environment ${environment} not found`);
        }
        switch (format) {
            case 'json':
                return JSON.stringify(env.configs, null, 2);
            case 'env':
                return Object.entries(env.configs)
                    .map(([key, value]) => `${key.toUpperCase().replace(/\./g, '_')}=${value}`)
                    .join('\n');
            case 'yaml':
                return Object.entries(env.configs)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join('\n');
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }
};
EnvironmentConfigService = EnvironmentConfigService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService !== "undefined" && _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService) === "function" ? _b : Object])
], EnvironmentConfigService);



/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretsManagerService: () => (/* binding */ SecretsManagerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SecretsManagerService_1;
var _a, _b;



let SecretsManagerService = SecretsManagerService_1 = class SecretsManagerService {
    constructor(_configService, centralizedConfigService) {
        this._configService = _configService;
        this.centralizedConfigService = centralizedConfigService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(SecretsManagerService_1.name);
        this.secrets = new Map();
        this.rotationHistory = [];
        this._configService.get('SECRETS_MANAGER_ENABLED');
        this.initializeKMSConfig();
        this.loadSecretsFromEnvironment();
    }
    initializeKMSConfig() {
        this.kmsConfig = {
            provider: this._configService.get('KMS_PROVIDER', 'local'),
            region: this._configService.get('KMS_REGION', 'us-east-1'),
            keyId: this._configService.get('KMS_KEY_ID', 'default-key'),
            endpoint: this._configService.get('KMS_ENDPOINT') ?? '',
        };
        this.logger.log(`Initialized KMS config: ${this.kmsConfig.provider} in ${this.kmsConfig.region}`);
    }
    loadSecretsFromEnvironment() {
        const secretKeys = [
            'JWT_SECRET',
            'DATABASE_URL',
            'REDIS_URL',
            'SUPABASE_URL',
            'SUPABASE_ANON_KEY',
            'SUPABASE_SERVICE_ROLE_KEY',
            'SENTRY_DSN',
            'BETTERSTACK_TOKEN',
        ];
        for (const key of secretKeys) {
            const value = this._configService.get(key);
            if (value != null && value !== '') {
                void this.setSecret(key.toLowerCase().replace(/_/g, '.'), value, 'system', 'all', { source: 'environment' });
            }
        }
        this.logger.log(`Loaded ${secretKeys.length} secrets from environment`);
    }
    async setSecret(key, value, _service, environment, tags = {}, expiresAt) {
        const encrypted = this.kmsConfig.provider !== 'local';
        const secretValue = encrypted ? await this.encryptSecret(value) : value;
        const secret = {
            key,
            value: secretValue,
            encrypted,
            _service: _service,
            environment,
            lastRotated: new Date(),
            expiresAt: expiresAt ?? new Date(),
            tags,
        };
        this.secrets.set(key, secret);
        await this.centralizedConfigService.setConfig(key, secretValue, environment, _service, 'secrets-manager');
        this.logger.log(`Secret set: ${key} (${_service})`);
    }
    async getSecret(key, environment) {
        const secret = this.secrets.get(key);
        if (!secret) {
            return null;
        }
        if (environment != null &&
            environment !== '' &&
            secret.environment !== 'all' &&
            secret.environment !== environment) {
            return null;
        }
        if (secret.expiresAt != null && secret.expiresAt < new Date()) {
            this.logger.warn(`Secret ${key} has expired`);
            return null;
        }
        if (secret.encrypted) {
            return await this.decryptSecret(secret.value);
        }
        return secret.value;
    }
    async getAllSecrets(service, environment) {
        const secrets = Array.from(this.secrets.values());
        let filtered = secrets;
        if (service != null && service !== '') {
            filtered = filtered.filter(secret => secret._service === service);
        }
        if (environment != null && environment !== '') {
            filtered = filtered.filter(secret => secret.environment === 'all' || secret.environment === environment);
        }
        return filtered;
    }
    async rotateSecret(key, newValue, _service, environment, reason, rotatedBy) {
        const oldSecret = this.secrets.get(key);
        if (!oldSecret) {
            throw new Error(`Secret ${key} not found`);
        }
        const oldValue = oldSecret.encrypted
            ? await this.decryptSecret(oldSecret.value)
            : oldSecret.value;
        await this.setSecret(key, newValue, _service, environment, oldSecret.tags, oldSecret.expiresAt);
        const rotation = {
            key,
            oldValue,
            newValue,
            _service: _service,
            environment,
            rotatedAt: new Date(),
            rotatedBy,
            reason,
        };
        this.rotationHistory.push(rotation);
        this.logger.log(`Secret rotated: ${key} (${_service})`);
    }
    async getRotationHistory(key, service) {
        let history = this.rotationHistory;
        if (key != null && key !== '') {
            history = history.filter(rotation => rotation.key === key);
        }
        if (service != null && service !== '') {
            history = history.filter(rotation => rotation._service === service);
        }
        return history.sort((a, b) => b.rotatedAt.getTime() - a.rotatedAt.getTime());
    }
    async deleteSecret(key) {
        const secret = this.secrets.get(key);
        if (!secret) {
            throw new Error(`Secret ${key} not found`);
        }
        this.secrets.delete(key);
        this.logger.log(`Secret deleted: ${key}`);
    }
    async getExpiringSecrets(days = 30) {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() + days);
        return Array.from(this.secrets.values()).filter(secret => secret.expiresAt != null && secret.expiresAt <= cutoffDate);
    }
    async validateSecret(key, value) {
        if (!value || value.length < 8) {
            return false;
        }
        if (key.includes('jwt') || key.includes('secret')) {
            return value.length >= 32;
        }
        if (key.includes('url')) {
            try {
                new globalThis.URL(value);
                return true;
            }
            catch {
                return false;
            }
        }
        if (key.includes('key') || key.includes('token')) {
            return value.length >= 16;
        }
        return true;
    }
    async encryptSecret(value) {
        return globalThis.Buffer.from(value).toString('base64');
    }
    async decryptSecret(encryptedValue) {
        return globalThis.Buffer.from(encryptedValue, 'base64').toString('utf-8');
    }
    async exportSecrets(service, environment, format = 'json') {
        const secrets = await this.getAllSecrets(service, environment);
        const decryptedSecrets = {};
        for (const secret of secrets) {
            const value = secret.encrypted
                ? await this.decryptSecret(secret.value)
                : secret.value;
            decryptedSecrets[secret.key] = value;
        }
        switch (format) {
            case 'json':
                return JSON.stringify(decryptedSecrets, null, 2);
            case 'env':
                return Object.entries(decryptedSecrets)
                    .map(([key, value]) => `${key.toUpperCase().replace(/\./g, '_')}=${value}`)
                    .join('\n');
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }
    async getKMSConfig() {
        return { ...this.kmsConfig };
    }
    async updateKMSConfig(config) {
        this.kmsConfig = { ...this.kmsConfig, ...config };
        this.logger.log(`KMS config updated: ${JSON.stringify(this.kmsConfig)}`);
    }
};
SecretsManagerService = SecretsManagerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService !== "undefined" && _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService) === "function" ? _b : Object])
], SecretsManagerService);



/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigurationController: () => (/* binding */ ConfigurationController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _environment_config_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;





let ConfigurationController = class ConfigurationController {
    constructor(centralizedConfigService, environmentConfigService, secretsManagerService) {
        this.centralizedConfigService = centralizedConfigService;
        this.environmentConfigService = environmentConfigService;
        this.secretsManagerService = secretsManagerService;
    }
    async getAllConfigs(service, environment) {
        const configs = await this.centralizedConfigService.getAllConfigs(service, environment);
        return {
            success: true,
            data: configs,
            count: configs.length,
        };
    }
    async getConfig(key, environment) {
        const value = await this.centralizedConfigService.getConfig(key, environment);
        if (value === undefined) {
            return {
                success: false,
                error: 'Configuration not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: { key, value },
        };
    }
    async setConfig(key, body) {
        await this.centralizedConfigService.setConfig(key, body.value, body.environment, body._service, body.changedBy);
        return {
            success: true,
            message: 'Configuration set successfully',
        };
    }
    async getEnvironments() {
        const environments = await this.environmentConfigService.getAllEnvironments();
        return {
            success: true,
            data: environments,
        };
    }
    async getEnvironment(name) {
        const environment = await this.environmentConfigService.getEnvironment(name);
        if (environment == null) {
            return {
                success: false,
                error: 'Environment not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: environment,
        };
    }
    async switchEnvironment(name) {
        await this.environmentConfigService.switchEnvironment(name);
        return {
            success: true,
            message: `Switched to environment: ${name}`,
        };
    }
    async getSecrets(service, environment) {
        const secrets = await this.secretsManagerService.getAllSecrets(service, environment);
        const safeSecrets = secrets.map(secret => ({
            key: secret.key,
            _service: secret._service,
            environment: secret.environment,
            encrypted: secret.encrypted,
            lastRotated: secret.lastRotated,
            expiresAt: secret.expiresAt,
            tags: secret.tags,
        }));
        return {
            success: true,
            data: safeSecrets,
            count: safeSecrets.length,
        };
    }
    async getSecret(key, environment) {
        const value = await this.secretsManagerService.getSecret(key, environment);
        if (value == null) {
            return {
                success: false,
                error: 'Secret not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: { key, value: '***' },
        };
    }
    async setSecret(key, body) {
        const expiresAt = body.expiresAt != null && body.expiresAt !== ''
            ? new Date(body.expiresAt)
            : undefined;
        await this.secretsManagerService.setSecret(key, body.value, body._service, body.environment, body.tags ?? {}, expiresAt);
        return {
            success: true,
            message: 'Secret set successfully',
        };
    }
    async rotateSecret(key, body) {
        await this.secretsManagerService.rotateSecret(key, body.newValue, body._service, body.environment, body.reason, body.rotatedBy);
        return {
            success: true,
            message: 'Secret rotated successfully',
        };
    }
    async getChangeHistory(service, key) {
        const history = await this.centralizedConfigService.getChangeHistory(service, key);
        return {
            success: true,
            data: history,
            count: history.length,
        };
    }
    async getBackups(service, environment) {
        const backups = await this.centralizedConfigService.getBackups(service, environment);
        return {
            success: true,
            data: backups,
            count: backups.length,
        };
    }
    async exportConfigs(service, environment, format = 'json') {
        const exported = await this.centralizedConfigService.exportConfig(service ?? 'all', environment ?? 'all', format);
        return {
            success: true,
            data: exported,
            format,
            service: service ?? 'all',
            environment: environment ?? 'all',
        };
    }
    async getHealth() {
        const activeEnvironment = await this.environmentConfigService.getActiveEnvironment();
        const expiringSecrets = await this.secretsManagerService.getExpiringSecrets(30);
        return {
            success: true,
            data: {
                status: 'healthy',
                activeEnvironment: activeEnvironment?.name ?? 'unknown',
                totalConfigs: (await this.centralizedConfigService.getAllConfigs())
                    .length,
                totalSecrets: (await this.secretsManagerService.getAllSecrets()).length,
                expiringSecrets: expiringSecrets.length,
                timestamp: new Date().toISOString(),
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('all'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all configurations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Filter by environment',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Configurations retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getAllConfigs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('key/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get configuration by key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Configuration key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Environment filter',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Configuration retrieved successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Configuration not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('key/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Set configuration value' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Configuration key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Configuration set successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "setConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('environments'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all environments' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Environments retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getEnvironments", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('environments/:name'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get environment configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'name', description: 'Environment name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Environment retrieved successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Environment not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getEnvironment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('environments/:name/switch'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Switch to environment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'name', description: 'Environment name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Environment switched successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "switchEnvironment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all secrets' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Filter by environment',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secrets retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getSecrets", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get secret value' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Secret key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Environment filter',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret retrieved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Secret not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('secrets/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Set secret value' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Secret key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret set successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "setSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('secrets/:key/rotate'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Rotate secret' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Secret key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret rotated successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "rotateSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get configuration change history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'key', required: false, description: 'Filter by key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'History retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getChangeHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('backups'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get configuration backups' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Filter by environment',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Backups retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getBackups", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('export'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Export configurations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'environment',
        required: false,
        description: 'Filter by environment',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'format',
        required: false,
        description: 'Export format (json, env, yaml)',
        enum: ['json', 'env', 'yaml'],
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Configurations exported successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('format')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "exportConfigs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get configuration service health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "getHealth", null);
ConfigurationController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Configuration Management'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('config'),
    __metadata("design:paramtypes", [typeof (_a = typeof _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService !== "undefined" && _centralized_config_service__WEBPACK_IMPORTED_MODULE_2__.CentralizedConfigService) === "function" ? _a : Object, typeof (_b = typeof _environment_config_service__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfigService !== "undefined" && _environment_config_service__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfigService) === "function" ? _b : Object, typeof (_c = typeof _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__.SecretsManagerService !== "undefined" && _secrets_manager_service__WEBPACK_IMPORTED_MODULE_4__.SecretsManagerService) === "function" ? _c : Object])
], ConfigurationController);



/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DevOpsModule: () => (/* binding */ DevOpsModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _controllers_automated_failover_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76);
/* harmony import */ var _controllers_devops_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
/* harmony import */ var _services_artifact_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(80);
/* harmony import */ var _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77);
/* harmony import */ var _services_devops_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(83);
/* harmony import */ var _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(81);
/* harmony import */ var _services_pipeline_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(82);
/* harmony import */ var _unified_cicd_pipeline_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(84);
/* harmony import */ var _infrastructure_orchestration_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(85);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













let DevOpsModule = class DevOpsModule {
};
DevOpsModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule,
            _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__.JwtModule.register({
                secret: process.env.JWT_SECRET ?? 'test-secret',
                signOptions: { expiresIn: '1h' },
            }),
            _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitterModule,
        ],
        controllers: [_controllers_automated_failover_controller__WEBPACK_IMPORTED_MODULE_4__.AutomatedFailoverController, _controllers_devops_controller__WEBPACK_IMPORTED_MODULE_5__.DevOpsController],
        providers: [
            _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_7__.AutomatedFailoverService,
            _services_devops_service__WEBPACK_IMPORTED_MODULE_8__.DevOpsService,
            _services_pipeline_service__WEBPACK_IMPORTED_MODULE_10__.PipelineService,
            _services_artifact_service__WEBPACK_IMPORTED_MODULE_6__.ArtifactService,
            _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_9__.PipelineMonitoringService,
            _unified_cicd_pipeline_service__WEBPACK_IMPORTED_MODULE_11__.UnifiedCICDPipelineService,
            _infrastructure_orchestration_service__WEBPACK_IMPORTED_MODULE_12__.InfrastructureOrchestrationService,
        ],
        exports: [
            _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_7__.AutomatedFailoverService,
            _services_devops_service__WEBPACK_IMPORTED_MODULE_8__.DevOpsService,
            _services_pipeline_service__WEBPACK_IMPORTED_MODULE_10__.PipelineService,
            _services_artifact_service__WEBPACK_IMPORTED_MODULE_6__.ArtifactService,
            _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_9__.PipelineMonitoringService,
            _unified_cicd_pipeline_service__WEBPACK_IMPORTED_MODULE_11__.UnifiedCICDPipelineService,
            _infrastructure_orchestration_service__WEBPACK_IMPORTED_MODULE_12__.InfrastructureOrchestrationService,
        ],
    })
], DevOpsModule);



/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomatedFailoverController: () => (/* binding */ AutomatedFailoverController),
/* harmony export */   ManualSwitchDto: () => (/* binding */ ManualSwitchDto),
/* harmony export */   UpdateFailoverConfigDto: () => (/* binding */ UpdateFailoverConfigDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;



class UpdateFailoverConfigDto {
}
class ManualSwitchDto {
}
let AutomatedFailoverController = class AutomatedFailoverController {
    constructor(automatedFailoverService) {
        this.automatedFailoverService = automatedFailoverService;
    }
    async startAutomatedFailover() {
        await this.automatedFailoverService.startAutomatedFailover();
        return {
            success: true,
            message: 'Automated failover monitoring started',
        };
    }
    async stopAutomatedFailover() {
        await this.automatedFailoverService.stopAutomatedFailover();
        return {
            success: true,
            message: 'Automated failover monitoring stopped',
        };
    }
    async performHealthChecks() {
        return this.automatedFailoverService.performHealthChecks();
    }
    async performFailover(dataCenterId) {
        return this.automatedFailoverService.performFailover(dataCenterId);
    }
    async manualSwitch(request) {
        return this.automatedFailoverService.manualSwitch(request.dataCenterId, request.reason);
    }
    async getConfig() {
        return this.automatedFailoverService.getConfig();
    }
    async updateConfig(config) {
        this.automatedFailoverService.updateConfig(config);
        return {
            success: true,
            message: 'Failover configuration updated',
        };
    }
    async getDataCenters() {
        return this.automatedFailoverService.getDataCenters();
    }
    async getActiveDataCenter() {
        return this.automatedFailoverService.getActiveDataCenter();
    }
    async getFailoverEvents(limit) {
        return this.automatedFailoverService.getFailoverEvents(limit);
    }
    async getHealthCheckResults(limit) {
        return this.automatedFailoverService.getHealthCheckResults(limit);
    }
    async getStatus() {
        const config = this.automatedFailoverService.getConfig();
        const dataCenters = this.automatedFailoverService.getDataCenters();
        const activeDataCenter = this.automatedFailoverService.getActiveDataCenter();
        const events = this.automatedFailoverService.getFailoverEvents(10);
        const healthResults = this.automatedFailoverService.getHealthCheckResults(1);
        const healthyDataCenters = dataCenters.filter(dc => dc.status === 'HEALTHY').length;
        const recentFailoverEvents = events.filter(e => e.type === 'FAILOVER' &&
            Date.now() - new Date(e.timestamp).getTime() < 3600000).length;
        const result = {
            isMonitoring: config.enabled,
            totalDataCenters: dataCenters.length,
            healthyDataCenters,
            lastHealthCheck: healthResults.length > 0 && healthResults[0] != null
                ? healthResults[0].timestamp
                : 'Never',
            recentFailoverEvents,
        };
        if (activeDataCenter != null) {
            result.activeDataCenter = activeDataCenter;
        }
        return result;
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('start'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Start automated failover monitoring' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Automated failover started successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], AutomatedFailoverController.prototype, "startAutomatedFailover", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('stop'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Stop automated failover monitoring' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Automated failover stopped successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], AutomatedFailoverController.prototype, "stopAutomatedFailover", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('health-check'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform manual health checks' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Health checks performed successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], AutomatedFailoverController.prototype, "performHealthChecks", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('failover/:dataCenterId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Perform manual failover from specific data center',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Failover initiated successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid data center or no suitable target',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'dataCenterId', description: 'Source data center ID' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('dataCenterId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], AutomatedFailoverController.prototype, "performFailover", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('manual-switch'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Manually switch to a specific data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Manual switch completed successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid data center or switch failed',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: ManualSwitchDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ManualSwitchDto]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], AutomatedFailoverController.prototype, "manualSwitch", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Configuration retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], AutomatedFailoverController.prototype, "getConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update failover configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Configuration updated successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: UpdateFailoverConfigDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UpdateFailoverConfigDto]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], AutomatedFailoverController.prototype, "updateConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data centers retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], AutomatedFailoverController.prototype, "getDataCenters", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/active'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get active data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Active data center retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], AutomatedFailoverController.prototype, "getActiveDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('events'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover events history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Events retrieved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of events to return',
        type: Number,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], AutomatedFailoverController.prototype, "getFailoverEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health-results'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get health check results' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health check results retrieved successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of results to return',
        type: Number,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], AutomatedFailoverController.prototype, "getHealthCheckResults", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover system status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Status retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], AutomatedFailoverController.prototype, "getStatus", null);
AutomatedFailoverController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Automated Failover'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('devops/failover'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_2__.AutomatedFailoverService !== "undefined" && _services_automated_failover_service__WEBPACK_IMPORTED_MODULE_2__.AutomatedFailoverService) === "function" ? _a : Object])
], AutomatedFailoverController);



/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomatedFailoverService: () => (/* binding */ AutomatedFailoverService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutomatedFailoverService_1;

let AutomatedFailoverService = AutomatedFailoverService_1 = class AutomatedFailoverService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AutomatedFailoverService_1.name);
        this.dataCenters = new Map();
        this.failoverEvents = [];
        this.healthCheckResults = [];
        this.initializeDefaultConfig();
        this.initializeDefaultDataCenters();
    }
    initializeDefaultConfig() {
        this.config = {
            enabled: true,
            autoFailover: true,
            healthCheckInterval: 30000,
            failoverThreshold: 3,
            recoveryThreshold: 5,
            maxFailoverAttempts: 3,
            failoverTimeout: 300000,
            notificationChannels: ['email', 'telegram', 'slack'],
            dataCenters: [],
        };
    }
    initializeDefaultDataCenters() {
        const defaultDataCenters = [
            {
                id: 'dc-minsk-primary',
                name: 'Minsk Primary DC',
                type: 'PRIMARY',
                region: 'Minsk',
                country: 'BY',
                endpoint: 'https://api-minsk.salespot.by',
                healthCheckUrl: 'https://api-minsk.salespot.by/health',
                isActive: true,
                priority: 1,
                capacity: {
                    cpu: 80,
                    memory: 64,
                    storage: 1000,
                    network: 1000,
                },
                services: [
                    {
                        id: 'api-minsk',
                        name: 'API Service',
                        type: 'API',
                        endpoint: 'https://api-minsk.salespot.by',
                        healthCheckUrl: 'https://api-minsk.salespot.by/health',
                        isActive: true,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 50,
                        errorRate: 0.01,
                        uptime: 99.9,
                    },
                    {
                        id: 'db-minsk',
                        name: 'Database Service',
                        type: 'DATABASE',
                        endpoint: 'postgresql://db-minsk.salespot.by:5432',
                        healthCheckUrl: 'https://db-minsk.salespot.by/health',
                        isActive: true,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 20,
                        errorRate: 0.001,
                        uptime: 99.99,
                    },
                ],
                lastHealthCheck: new Date().toISOString(),
                status: 'HEALTHY',
            },
            {
                id: 'dc-minsk-secondary',
                name: 'Minsk Secondary DC',
                type: 'SECONDARY',
                region: 'Minsk',
                country: 'BY',
                endpoint: 'https://api-minsk-2.salespot.by',
                healthCheckUrl: 'https://api-minsk-2.salespot.by/health',
                isActive: false,
                priority: 2,
                capacity: {
                    cpu: 60,
                    memory: 48,
                    storage: 800,
                    network: 800,
                },
                services: [
                    {
                        id: 'api-minsk-2',
                        name: 'API Service',
                        type: 'API',
                        endpoint: 'https://api-minsk-2.salespot.by',
                        healthCheckUrl: 'https://api-minsk-2.salespot.by/health',
                        isActive: false,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 60,
                        errorRate: 0.02,
                        uptime: 99.8,
                    },
                    {
                        id: 'db-minsk-2',
                        name: 'Database Service',
                        type: 'DATABASE',
                        endpoint: 'postgresql://db-minsk-2.salespot.by:5432',
                        healthCheckUrl: 'https://db-minsk-2.salespot.by/health',
                        isActive: false,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 25,
                        errorRate: 0.002,
                        uptime: 99.98,
                    },
                ],
                lastHealthCheck: new Date().toISOString(),
                status: 'HEALTHY',
            },
            {
                id: 'dc-moscow-backup',
                name: 'Moscow Backup DC',
                type: 'BACKUP',
                region: 'Moscow',
                country: 'RU',
                endpoint: 'https://api-moscow.salespot.ru',
                healthCheckUrl: 'https://api-moscow.salespot.ru/health',
                isActive: false,
                priority: 3,
                capacity: {
                    cpu: 40,
                    memory: 32,
                    storage: 500,
                    network: 500,
                },
                services: [
                    {
                        id: 'api-moscow',
                        name: 'API Service',
                        type: 'API',
                        endpoint: 'https://api-moscow.salespot.ru',
                        healthCheckUrl: 'https://api-moscow.salespot.ru/health',
                        isActive: false,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 80,
                        errorRate: 0.05,
                        uptime: 99.5,
                    },
                    {
                        id: 'db-moscow',
                        name: 'Database Service',
                        type: 'DATABASE',
                        endpoint: 'postgresql://db-moscow.salespot.ru:5432',
                        healthCheckUrl: 'https://db-moscow.salespot.ru/health',
                        isActive: false,
                        status: 'HEALTHY',
                        lastHealthCheck: new Date().toISOString(),
                        responseTime: 35,
                        errorRate: 0.005,
                        uptime: 99.95,
                    },
                ],
                lastHealthCheck: new Date().toISOString(),
                status: 'HEALTHY',
            },
        ];
        for (const dc of defaultDataCenters) {
            this.dataCenters.set(dc.id, dc);
        }
        this.config.dataCenters = defaultDataCenters;
    }
    async startAutomatedFailover() {
        if (!this.config.enabled) {
            this.logger.warn('Automated failover is disabled');
            return;
        }
        this.logger.log('Starting automated failover monitoring');
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(() => {
            void this.performHealthChecks();
        }, this.config.healthCheckInterval);
        await this.performHealthChecks();
    }
    async stopAutomatedFailover() {
        if (this.healthCheckInterval != null) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = undefined;
        }
        this.logger.log('Automated failover monitoring stopped');
    }
    async performHealthChecks() {
        const results = [];
        for (const [dcId, dataCenter] of this.dataCenters) {
            const result = await this.checkDataCenterHealth(dataCenter);
            results.push(result);
            dataCenter.status = result.status;
            dataCenter.lastHealthCheck = result.timestamp;
            for (const serviceResult of result.services) {
                const service = dataCenter.services.find(s => s.id === serviceResult.serviceId);
                if (service) {
                    service.status = serviceResult.status;
                    service.lastHealthCheck = result.timestamp;
                    service.responseTime = serviceResult.responseTime;
                    service.errorRate = serviceResult.errorRate;
                }
            }
            this.dataCenters.set(dcId, dataCenter);
        }
        this.healthCheckResults.push(...results);
        if (this.config.autoFailover) {
            await this.checkFailoverNeeded();
        }
        return results;
    }
    async checkDataCenterHealth(dataCenter) {
        const timestamp = new Date().toISOString();
        const errors = [];
        let overallStatus = 'HEALTHY';
        let totalResponseTime = 0;
        let serviceCount = 0;
        const serviceResults = [];
        for (const service of dataCenter.services) {
            try {
                const serviceResult = await this.checkServiceHealth(service);
                serviceResults.push(serviceResult);
                totalResponseTime += serviceResult.responseTime;
                serviceCount++;
                if (serviceResult.status === 'FAILED') {
                    overallStatus = 'FAILED';
                    errors.push(`Service ${service.name} is down`);
                }
                else if (serviceResult.status === 'DEGRADED' &&
                    overallStatus === 'HEALTHY') {
                    overallStatus = 'DEGRADED';
                }
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                errors.push(`Service ${service.name} check failed: ${errorMessage}`);
                serviceResults.push({
                    serviceId: service.id,
                    status: 'FAILED',
                    responseTime: 0,
                    errorRate: 1.0,
                });
                overallStatus = 'FAILED';
            }
        }
        return {
            dataCenterId: dataCenter.id,
            timestamp,
            status: overallStatus,
            responseTime: serviceCount > 0 ? totalResponseTime / serviceCount : 0,
            services: serviceResults,
            errors,
        };
    }
    async checkServiceHealth(service) {
        const startTime = Date.now();
        let status = 'HEALTHY';
        let errorRate = 0;
        try {
            const responseTime = Math.random() * 100 + 20;
            await this.delay(responseTime);
            if (Math.random() < 0.05) {
                status = 'DEGRADED';
                errorRate = 0.05;
            }
            if (Math.random() < 0.01) {
                status = 'FAILED';
                errorRate = 1.0;
            }
            return {
                serviceId: service.id,
                status,
                responseTime,
                errorRate,
            };
        }
        catch {
            return {
                serviceId: service.id,
                status: 'FAILED',
                responseTime: Date.now() - startTime,
                errorRate: 1.0,
            };
        }
    }
    async checkFailoverNeeded() {
        const activeDataCenter = Array.from(this.dataCenters.values()).find(dc => dc.isActive);
        if (!activeDataCenter) {
            this.logger.error('No active data center found');
            return;
        }
        if (activeDataCenter.status === 'FAILED' ||
            activeDataCenter.status === 'DEGRADED') {
            const failoverCount = this.getFailoverCount(activeDataCenter.id);
            if (failoverCount >= this.config.failoverThreshold) {
                await this.performFailover(activeDataCenter.id);
            }
        }
    }
    async performFailover(fromDataCenterId) {
        this.logger.log(`Initiating failover from ${fromDataCenterId}`);
        const event = {
            id: `failover-${Date.now()}`,
            timestamp: new Date().toISOString(),
            type: 'FAILOVER',
            sourceDataCenter: fromDataCenterId,
            targetDataCenter: '',
            reason: 'Health check failure',
            services: [],
            status: 'IN_PROGRESS',
            metadata: {},
        };
        try {
            const targetDataCenter = this.findBestTargetDataCenter(fromDataCenterId);
            if (!targetDataCenter) {
                throw new Error('No suitable target data center found');
            }
            event.targetDataCenter = targetDataCenter.id;
            event.services = targetDataCenter.services.map(s => s.id);
            await this.switchToDataCenter(targetDataCenter.id);
            event.status = 'SUCCESS';
            event.duration = Date.now() - new Date(event.timestamp).getTime();
            this.logger.log(`Failover completed successfully to ${targetDataCenter.id}`);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            event.status = 'FAILED';
            event.metadata.error = errorMessage;
            this.logger.error(`Failover failed: ${errorMessage}`);
        }
        this.failoverEvents.push(event);
        return event;
    }
    findBestTargetDataCenter(excludeDataCenterId) {
        const availableDataCenters = Array.from(this.dataCenters.values())
            .filter(dc => dc.id !== excludeDataCenterId && dc.status === 'HEALTHY')
            .sort((a, b) => a.priority - b.priority);
        return availableDataCenters[0];
    }
    async switchToDataCenter(dataCenterId) {
        for (const [dcId, dataCenter] of this.dataCenters) {
            if (dataCenter.isActive) {
                dataCenter.isActive = false;
                for (const service of dataCenter.services) {
                    service.isActive = false;
                }
                this.dataCenters.set(dcId, dataCenter);
            }
        }
        const targetDataCenter = this.dataCenters.get(dataCenterId);
        if (targetDataCenter) {
            targetDataCenter.isActive = true;
            for (const service of targetDataCenter.services) {
                service.isActive = true;
            }
            this.dataCenters.set(dataCenterId, targetDataCenter);
        }
        await this.delay(5000);
    }
    getFailoverCount(dataCenterId) {
        const recentEvents = this.failoverEvents.filter(event => event.sourceDataCenter === dataCenterId &&
            event.type === 'FAILOVER' &&
            Date.now() - new Date(event.timestamp).getTime() < 300000);
        return recentEvents.length;
    }
    getConfig() {
        return { ...this.config };
    }
    updateConfig(config) {
        this.config = { ...this.config, ...config };
        this.logger.log('Failover configuration updated');
    }
    getDataCenters() {
        return Array.from(this.dataCenters.values());
    }
    getActiveDataCenter() {
        return Array.from(this.dataCenters.values()).find(dc => dc.isActive);
    }
    getFailoverEvents(limit = 100) {
        return this.failoverEvents.slice(-limit);
    }
    getHealthCheckResults(limit = 100) {
        return this.healthCheckResults.slice(-limit);
    }
    async manualSwitch(dataCenterId, reason) {
        const activeDataCenter = this.getActiveDataCenter();
        if (!activeDataCenter) {
            throw new Error('No active data center found');
        }
        const targetDataCenter = this.dataCenters.get(dataCenterId);
        if (!targetDataCenter) {
            throw new Error('Data center not found');
        }
        const event = {
            id: `manual-switch-${Date.now()}`,
            timestamp: new Date().toISOString(),
            type: 'MANUAL_SWITCH',
            sourceDataCenter: activeDataCenter.id,
            targetDataCenter: dataCenterId,
            reason,
            services: [],
            status: 'IN_PROGRESS',
            metadata: {},
        };
        try {
            await this.switchToDataCenter(dataCenterId);
            event.status = 'SUCCESS';
            event.duration = Date.now() - new Date(event.timestamp).getTime();
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            event.status = 'FAILED';
            event.metadata.error = errorMessage;
        }
        this.failoverEvents.push(event);
        return event;
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
};
AutomatedFailoverService = AutomatedFailoverService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], AutomatedFailoverService);



/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DevOpsController: () => (/* binding */ DevOpsController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33);
/* harmony import */ var _services_artifact_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(80);
/* harmony import */ var _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(81);
/* harmony import */ var _services_pipeline_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;










let DevOpsController = class DevOpsController {
    constructor(pipelineService, artifactService, monitoringService) {
        this.pipelineService = pipelineService;
        this.artifactService = artifactService;
        this.monitoringService = monitoringService;
    }
    async executePipeline(config) {
        return this.pipelineService.executePipeline(config);
    }
    async rollbackDeployment(body) {
        return this.pipelineService.rollbackDeployment(body.environment, body.targetVersion);
    }
    async getPipelineMetrics() {
        return this.pipelineService.getPipelineMetrics();
    }
    async getBuildArtifacts() {
        return this.pipelineService.getBuildArtifacts();
    }
    async pushArtifact(body) {
        const artifactBuffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.artifact, 'base64');
        return this.artifactService.pushArtifact(artifactBuffer, {
            ...body.metadata,
            createdAt: new Date(),
        }, body.registryName);
    }
    async pullArtifact(body) {
        return this.artifactService.pullArtifact(body.name, body.version, body.registryName);
    }
    async listArtifacts(registryName, name, version, tags) {
        const filter = {};
        if (name != null && name !== '')
            filter.name = name;
        if (version != null && version !== '')
            filter.version = version;
        if (tags != null && tags !== '')
            filter.tags = tags.split(',');
        return this.artifactService.listArtifacts(registryName);
    }
    async deleteArtifact(body) {
        return this.artifactService.deleteArtifact(body.name, body.version, body.registryName);
    }
    async tagArtifact(body) {
        return this.artifactService.tagArtifact(body.name, body.version, body.tags);
    }
    async cleanupOldArtifacts(body) {
        return this.artifactService.cleanupOldArtifacts(body.retentionDays, body.registryName);
    }
    async getRegistryHealth() {
        return this.artifactService.getRegistryHealth();
    }
    async getMonitoringMetrics(from, to, _environment) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        return this.monitoringService.getPipelineMetrics(timeRange);
    }
    async getPipelineAlerts(resolved, severity, type) {
        return this.monitoringService.getPipelineAlerts(resolved, severity, type);
    }
    async resolveAlert(alertId) {
        return this.monitoringService.resolveAlert(alertId);
    }
    async getPipelineEvents(buildId, type, from, to) {
        const timeRange = from != null && to != null
            ? { from: new Date(from), to: new Date(to) }
            : undefined;
        return this.monitoringService.getPipelineEvents(buildId, type, timeRange);
    }
    async getBuildTimeline(buildId) {
        return this.monitoringService.getBuildTimeline(buildId);
    }
    async getPerformanceInsights(from, to) {
        const timeRange = from != null && to != null
            ? { from: new Date(from), to: new Date(to) }
            : undefined;
        return this.monitoringService.getPerformanceInsights(timeRange);
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('pipeline/execute'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Execute CI/CD pipeline' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Pipeline executed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Invalid pipeline configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "executePipeline", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('pipeline/rollback'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Rollback deployment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Rollback completed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Invalid rollback parameters' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "rollbackDeployment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('pipeline/metrics'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get pipeline metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Pipeline metrics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getPipelineMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('pipeline/artifacts'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get build artifacts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Build artifacts retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getBuildArtifacts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('artifacts/push'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Push artifact to registry' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Artifact pushed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Invalid artifact data' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "pushArtifact", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('artifacts/pull'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Pull artifact from registry' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Artifact pulled successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Artifact not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "pullArtifact", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('artifacts/list'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'List artifacts in registry' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Artifacts listed successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('registryName')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('name')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('version')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('tags')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "listArtifacts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('artifacts/delete'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete artifact from registry' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Artifact deleted successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Artifact not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "deleteArtifact", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('artifacts/tag'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Tag artifact' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Artifact tagged successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Artifact not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "tagArtifact", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('artifacts/cleanup'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clean up old artifacts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Cleanup completed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "cleanupOldArtifacts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('artifacts/registry/health'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get registry health status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Registry health retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getRegistryHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/metrics'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get pipeline monitoring metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Monitoring metrics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('environment')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getMonitoringMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/alerts'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get pipeline alerts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Pipeline alerts retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('resolved')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('severity')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean, String, String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getPipelineAlerts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('monitoring/alerts/:alertId/resolve'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.OK),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Resolve pipeline alert' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Alert resolved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Alert not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Insufficient permissions' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('alertId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "resolveAlert", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/events'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get pipeline events' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Pipeline events retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('buildId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getPipelineEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/timeline/:buildId'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get build timeline' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Build timeline retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('buildId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getBuildTimeline", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/insights'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.DEVOPS, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.USER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance insights' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance insights retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], DevOpsController.prototype, "getPerformanceInsights", null);
DevOpsController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('DevOps'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('devops'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_4__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_5__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_pipeline_service__WEBPACK_IMPORTED_MODULE_9__.PipelineService !== "undefined" && _services_pipeline_service__WEBPACK_IMPORTED_MODULE_9__.PipelineService) === "function" ? _a : Object, typeof (_b = typeof _services_artifact_service__WEBPACK_IMPORTED_MODULE_7__.ArtifactService !== "undefined" && _services_artifact_service__WEBPACK_IMPORTED_MODULE_7__.ArtifactService) === "function" ? _b : Object, typeof (_c = typeof _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_8__.PipelineMonitoringService !== "undefined" && _services_pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_8__.PipelineMonitoringService) === "function" ? _c : Object])
], DevOpsController);



/***/ }),
/* 79 */
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArtifactService: () => (/* binding */ ArtifactService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ArtifactService_1;
var _a;



let ArtifactService = ArtifactService_1 = class ArtifactService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ArtifactService_1.name);
        this.registries = [];
        this.initializeRegistries();
    }
    initializeRegistries() {
        this.registries.push({
            name: 'local-registry',
            url: this.configService.get('ARTIFACT_REGISTRY_URL', 'https://registry.local'),
            credentials: {
                username: this.configService.get('ARTIFACT_REGISTRY_USERNAME', ''),
                password: this.configService.get('ARTIFACT_REGISTRY_PASSWORD', ''),
            },
        });
        this.registries.push({
            name: 'docker-hub',
            url: 'https://index.docker.io/v1/',
            credentials: {
                username: this.configService.get('DOCKER_HUB_USERNAME', ''),
                password: this.configService.get('DOCKER_HUB_PASSWORD', ''),
            },
        });
    }
    async pushArtifact(artifact, metadata, registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Pushing artifact ${metadata.name}:${metadata.version} to ${registry.name}`);
            const artifactUrl = await this.simulateArtifactPush(artifact, metadata, registry);
            this.logger.log(`Artifact pushed successfully: ${artifactUrl}`);
            return { success: true, url: artifactUrl };
        }
        catch (error) {
            this.logger.error(`Failed to push artifact: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async pullArtifact(name, version, registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Pulling artifact ${name}:${version} from ${registry.name}`);
            const { artifact, metadata } = await this.simulateArtifactPull(name, version, registry);
            this.logger.log(`Artifact pulled successfully: ${name}:${version}`);
            return { success: true, artifact, metadata };
        }
        catch (error) {
            this.logger.error(`Failed to pull artifact: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async listArtifacts(registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Listing artifacts in ${registry.name}`);
            const artifacts = await this.simulateArtifactListing(registry);
            return artifacts;
        }
        catch (error) {
            this.logger.error(`Failed to list artifacts: ${error instanceof Error ? error.message : String(error)}`);
            return [];
        }
    }
    async deleteArtifact(name, version, registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Deleting artifact ${name}:${version} from ${registry.name}`);
            await this.simulateArtifactDeletion();
            this.logger.log(`Artifact deleted successfully: ${name}:${version}`);
            return { success: true };
        }
        catch (error) {
            this.logger.error(`Failed to delete artifact: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async getArtifactMetadata(name, version, registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Getting metadata for ${name}:${version} from ${registry.name}`);
            const metadata = await this.simulateMetadataRetrieval(name, version, registry);
            return { success: true, metadata };
        }
        catch (error) {
            this.logger.error(`Failed to get artifact metadata: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async tagArtifact(name, version, tags) {
        try {
            this.logger.log(`Tagging artifact ${name}:${version} with tags: ${tags.join(', ')}`);
            await this.simulateArtifactTagging();
            this.logger.log(`Artifact tagged successfully: ${name}:${version}`);
            return { success: true };
        }
        catch (error) {
            this.logger.error(`Failed to tag artifact: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async cleanupOldArtifacts(retentionDays = 30, registryName) {
        try {
            const registry = this.selectRegistry(registryName);
            this.logger.log(`Cleaning up artifacts older than ${retentionDays} days in ${registry.name}`);
            const deletedCount = await this.simulateArtifactCleanup();
            this.logger.log(`Cleanup completed: ${deletedCount} artifacts deleted`);
            return { success: true, deletedCount };
        }
        catch (error) {
            this.logger.error(`Failed to cleanup artifacts: ${error instanceof Error ? error.message : String(error)}`);
            return {
                success: false,
                deletedCount: 0,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async getRegistryHealth() {
        try {
            const startTime = Date.now();
            await this.simulateHealthCheck();
            const responseTime = Date.now() - startTime;
            return {
                success: true,
                status: responseTime < 1000 ? 'healthy' : 'degraded',
                responseTime,
            };
        }
        catch (error) {
            return {
                success: false,
                status: 'unhealthy',
                responseTime: 0,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    selectRegistry(registryName) {
        if (registryName != null && registryName !== '') {
            const registry = this.registries.find(r => r.name === registryName);
            if (!registry) {
                throw new Error(`Registry ${registryName} not found`);
            }
            return registry;
        }
        const fallbackRegistry = {
            name: 'fallback',
            url: 'http://localhost:5000',
            credentials: { username: 'fallback', password: 'fallback' },
        };
        return (this.registries[0] ??
            this.registries[1] ??
            this.registries[2] ??
            fallbackRegistry);
    }
    async simulateArtifactPush(_artifact, metadata, registry) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return `${registry.url}/${metadata.name}:${metadata.version}`;
    }
    async simulateArtifactPull(name, version, registry) {
        await new Promise(resolve => setTimeout(resolve, 800));
        const artifact = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(`simulated-artifact-${name}-${version}`);
        const metadata = {
            name,
            version,
            size: artifact.length,
            checksum: `sha256:${Math.random().toString(36).substr(2, 64)}`,
            createdAt: new Date(),
            tags: ['latest'],
            metadata: { registry: registry.name },
        };
        return { artifact, metadata };
    }
    async simulateArtifactListing(registry) {
        await new Promise(resolve => setTimeout(resolve, 500));
        return [
            {
                name: 'salespot-api',
                version: '1.0.0',
                size: 1024 * 1024 * 50,
                checksum: 'sha256:abc123...',
                createdAt: new Date(),
                tags: ['latest', 'production'],
                metadata: { registry: registry.name },
            },
        ];
    }
    async simulateArtifactDeletion() {
        await new Promise(resolve => setTimeout(resolve, 300));
    }
    async simulateMetadataRetrieval(name, version, registry) {
        await new Promise(resolve => setTimeout(resolve, 200));
        return {
            name,
            version,
            size: 1024 * 1024 * 50,
            checksum: 'sha256:abc123...',
            createdAt: new Date(),
            tags: ['latest'],
            metadata: { registry: registry.name },
        };
    }
    async simulateArtifactTagging() {
        await new Promise(resolve => setTimeout(resolve, 400));
    }
    async simulateArtifactCleanup() {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return Math.floor(Math.random() * 10);
    }
    async simulateHealthCheck() {
        await new Promise(resolve => setTimeout(resolve, 100));
    }
};
ArtifactService = ArtifactService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], ArtifactService);



/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PipelineMonitoringService: () => (/* binding */ PipelineMonitoringService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PipelineMonitoringService_1;
var _a;


let PipelineMonitoringService = PipelineMonitoringService_1 = class PipelineMonitoringService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(PipelineMonitoringService_1.name);
        this.events = [];
        this.alerts = [];
    }
    onModuleInit() {
        this.configService.get('PIPELINE_MONITORING_ENABLED');
    }
    async recordEvent(event) {
        const pipelineEvent = {
            ...event,
            id: this.generateEventId(),
            timestamp: new Date(),
        };
        this.events.push(pipelineEvent);
        this.logger.log(`Recorded pipeline event: ${event.type} for build ${event.buildId}`);
        this.checkForAlerts(pipelineEvent);
    }
    async getPipelineMetrics(timeRange) {
        const filteredEvents = this.filterEventsByTimeRange(this.events, timeRange);
        const buildEvents = filteredEvents.filter(e => e.type.includes('build'));
        const testEvents = filteredEvents.filter(e => e.type.includes('test'));
        const deployEvents = filteredEvents.filter(e => e.type.includes('deploy'));
        const totalBuilds = buildEvents.filter(e => e.type === 'build_started').length;
        const successfulBuilds = buildEvents.filter(e => e.type === 'build_completed' && e.success === true).length;
        const failedBuilds = buildEvents.filter(e => e.type === 'build_completed' && e.success === false).length;
        const averageBuildTime = this.calculateAverageDuration(buildEvents);
        const averageTestTime = this.calculateAverageDuration(testEvents);
        const averageDeployTime = this.calculateAverageDuration(deployEvents);
        const successRate = totalBuilds > 0 ? (successfulBuilds / totalBuilds) * 100 : 0;
        const failureRate = totalBuilds > 0 ? (failedBuilds / totalBuilds) * 100 : 0;
        const lastBuildEvent = buildEvents
            .filter(e => e.type === 'build_completed')
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
        return {
            totalBuilds,
            successfulBuilds,
            failedBuilds,
            averageBuildTime,
            averageTestTime,
            averageDeployTime,
            successRate,
            failureRate,
            lastBuildTime: lastBuildEvent?.timestamp ?? new Date(),
            trends: {
                buildsPerDay: this.calculateBuildsPerDay(filteredEvents),
                successRateTrend: this.calculateSuccessRateTrend(filteredEvents),
                buildTimeTrend: this.calculateBuildTimeTrend(filteredEvents),
            },
        };
    }
    async getPipelineAlerts(resolved, severity, type) {
        let filteredAlerts = [...this.alerts];
        if (typeof resolved === 'boolean') {
            filteredAlerts = filteredAlerts.filter(alert => alert.resolved === resolved);
        }
        if (severity != null && severity !== '') {
            filteredAlerts = filteredAlerts.filter(alert => alert.severity === severity);
        }
        if (type != null && type !== '') {
            filteredAlerts = filteredAlerts.filter(alert => alert.type === type);
        }
        return filteredAlerts.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async resolveAlert(alertId) {
        try {
            const alert = this.alerts.find(a => a.id === alertId);
            if (!alert) {
                return { success: false, error: 'Alert not found' };
            }
            alert.resolved = true;
            this.logger.log(`Alert resolved: ${alertId}`);
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async getPipelineEvents(buildId, type, timeRange) {
        let filteredEvents = [...this.events];
        if (buildId != null && buildId !== '') {
            filteredEvents = filteredEvents.filter(event => event.buildId === buildId);
        }
        if (type != null && type !== '') {
            filteredEvents = filteredEvents.filter(event => event.type === type);
        }
        if (timeRange) {
            filteredEvents = this.filterEventsByTimeRange(filteredEvents, timeRange);
        }
        return filteredEvents.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getBuildTimeline(buildId) {
        return this.events
            .filter(event => event.buildId === buildId)
            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    }
    async getPerformanceInsights(timeRange) {
        const filteredEvents = this.filterEventsByTimeRange(this.events, timeRange);
        const stageTimes = new Map();
        for (const event of filteredEvents) {
            if (event.duration != null) {
                if (!stageTimes.has(event.stage)) {
                    stageTimes.set(event.stage, []);
                }
                const times = stageTimes.get(event.stage);
                if (times != null) {
                    times.push(event.duration);
                }
            }
        }
        const slowestStages = Array.from(stageTimes.entries())
            .map(([stage, times]) => ({
            stage,
            averageTime: times.reduce((sum, time) => sum + time, 0) / times.length,
        }))
            .sort((a, b) => b.averageTime - a.averageTime)
            .slice(0, 5);
        const bottlenecks = [];
        for (const [stage, times] of stageTimes.entries()) {
            const average = times.reduce((sum, time) => sum + time, 0) / times.length;
            const variance = times.reduce((sum, time) => sum + Math.pow(time - average, 2), 0) /
                times.length;
            const standardDeviation = Math.sqrt(variance);
            if (standardDeviation > average * 0.5 || average > 300000) {
                bottlenecks.push(stage);
            }
        }
        const recommendations = [];
        if (bottlenecks.includes('build')) {
            recommendations.push('Consider optimizing build process with better caching');
        }
        if (bottlenecks.includes('test')) {
            recommendations.push('Parallelize test execution or optimize test suite');
        }
        if (bottlenecks.includes('deploy')) {
            recommendations.push('Review deployment strategy and infrastructure');
        }
        return {
            slowestStages,
            bottlenecks,
            recommendations,
        };
    }
    checkForAlerts(event) {
        if (event.type === 'pipeline_failed' || event.success === false) {
            this.createAlert({
                type: 'failure',
                severity: 'high',
                title: `Pipeline failed in stage: ${event.stage}`,
                description: `Build ${event.buildId} failed in ${event.stage} stage`,
                buildId: event.buildId,
                stage: event.stage,
                metadata: { eventId: event.id, error: event.error },
            });
        }
        if (event.duration != null && event.duration > 600000) {
            this.createAlert({
                type: 'performance',
                severity: 'medium',
                title: `Slow pipeline stage: ${event.stage}`,
                description: `Stage ${event.stage} took ${Math.round(event.duration / 1000 / 60)} minutes`,
                buildId: event.buildId,
                stage: event.stage,
                metadata: { eventId: event.id, duration: event.duration },
            });
        }
    }
    createAlert(alert) {
        const pipelineAlert = {
            ...alert,
            id: this.generateAlertId(),
            timestamp: new Date(),
            resolved: false,
        };
        this.alerts.push(pipelineAlert);
        this.logger.warn(`Created pipeline alert: ${alert.title}`);
    }
    filterEventsByTimeRange(events, timeRange) {
        if (!timeRange)
            return events;
        return events.filter(event => event.timestamp >= timeRange.from && event.timestamp <= timeRange.to);
    }
    calculateAverageDuration(events) {
        const eventsWithDuration = events.filter(e => e.duration != null && e.duration > 0);
        if (eventsWithDuration.length === 0)
            return 0;
        const totalDuration = eventsWithDuration.reduce((sum, e) => sum + (e.duration ?? 0), 0);
        return totalDuration / eventsWithDuration.length;
    }
    calculateBuildsPerDay(events) {
        const buildEvents = events.filter(e => e.type === 'build_started');
        if (buildEvents.length === 0)
            return 0;
        const days = this.getDaysBetween(Math.min(...buildEvents.map(e => e.timestamp.getTime())), Math.max(...buildEvents.map(e => e.timestamp.getTime())));
        return days > 0 ? buildEvents.length / days : buildEvents.length;
    }
    calculateSuccessRateTrend(events) {
        const recentEvents = events.slice(-10);
        const olderEvents = events.slice(-20, -10);
        const recentSuccessRate = this.calculateSuccessRate(recentEvents);
        const olderSuccessRate = this.calculateSuccessRate(olderEvents);
        return recentSuccessRate - olderSuccessRate;
    }
    calculateBuildTimeTrend(events) {
        const recentEvents = events.slice(-10);
        const olderEvents = events.slice(-20, -10);
        const recentAvgTime = this.calculateAverageDuration(recentEvents);
        const olderAvgTime = this.calculateAverageDuration(olderEvents);
        return recentAvgTime - olderAvgTime;
    }
    calculateSuccessRate(events) {
        const completedEvents = events.filter(e => e.type.includes('completed'));
        if (completedEvents.length === 0)
            return 0;
        const successfulEvents = completedEvents.filter(e => e.success === true);
        return (successfulEvents.length / completedEvents.length) * 100;
    }
    getDaysBetween(startTime, endTime) {
        return Math.ceil((endTime - startTime) / (1000 * 60 * 60 * 24));
    }
    generateEventId() {
        return `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    generateAlertId() {
        return `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
};
PipelineMonitoringService = PipelineMonitoringService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], PipelineMonitoringService);



/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PipelineService: () => (/* binding */ PipelineService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PipelineService_1;
var _a;


let PipelineService = PipelineService_1 = class PipelineService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(PipelineService_1.name);
    }
    onModuleInit() {
        this.configService.get('PIPELINE_ENABLED');
    }
    async executePipeline(config) {
        const buildId = this.generateBuildId();
        this.logger.log(`Starting pipeline execution for build ${buildId}`);
        try {
            const buildStartTime = Date.now();
            const buildResult = await this.executeBuildStage(config, buildId);
            const buildTime = Date.now() - buildStartTime;
            if (!buildResult.success) {
                throw new Error(`Build stage failed: ${buildResult.error}`);
            }
            const testStartTime = Date.now();
            const testResult = await this.executeTestStage(config, buildId);
            const testTime = Date.now() - testStartTime;
            if (!testResult.success) {
                throw new Error(`Test stage failed: ${testResult.error}`);
            }
            const securityResult = await this.executeSecurityScan(config, buildId);
            if (!securityResult.success) {
                throw new Error(`Security scan failed: ${securityResult.error}`);
            }
            const deployStartTime = Date.now();
            const deployResult = await this.executeDeployStage(config, buildId);
            const deployTime = Date.now() - deployStartTime;
            if (!deployResult.success) {
                throw new Error(`Deploy stage failed: ${deployResult.error}`);
            }
            const metrics = {
                buildTime,
                testTime,
                deployTime,
                successRate: 100,
                failureRate: 0,
                averageBuildTime: buildTime,
            };
            this.logger.log(`Pipeline execution completed successfully for build ${buildId}`);
            return {
                success: true,
                buildId,
                artifacts: buildResult.artifacts,
                metrics,
            };
        }
        catch (error) {
            this.logger.error(`Pipeline execution failed for build ${buildId}:`, error);
            throw error;
        }
    }
    async executeBuildStage(config, buildId) {
        try {
            this.logger.log(`Executing build stage for build ${buildId}`);
            await this.simulateBuildProcess();
            const artifacts = [
                {
                    id: `${buildId}-api`,
                    name: 'salespot-api',
                    version: config.buildNumber,
                    size: 1024 * 1024 * 50,
                    checksum: this.generateChecksum(),
                    createdAt: new Date(),
                    metadata: {
                        environment: config.environment,
                        branch: config.branch,
                        commitHash: config.commitHash,
                    },
                },
                {
                    id: `${buildId}-web`,
                    name: 'salespot-web',
                    version: config.buildNumber,
                    size: 1024 * 1024 * 30,
                    checksum: this.generateChecksum(),
                    createdAt: new Date(),
                    metadata: {
                        environment: config.environment,
                        branch: config.branch,
                        commitHash: config.commitHash,
                    },
                },
            ];
            return { success: true, artifacts };
        }
        catch (error) {
            return {
                success: false,
                artifacts: [],
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async executeTestStage(_config, buildId) {
        try {
            this.logger.log(`Executing test stage for build ${buildId}`);
            await this.simulateTestProcess();
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async executeSecurityScan(_config, buildId) {
        try {
            this.logger.log(`Executing security scan for build ${buildId}`);
            await this.simulateSecurityScan();
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async executeDeployStage(_config, buildId) {
        try {
            this.logger.log(`Executing deploy stage for build ${buildId}`);
            await this.simulateDeployment();
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async rollbackDeployment(environment, targetVersion) {
        try {
            this.logger.log(`Rolling back deployment in ${environment} to version ${targetVersion}`);
            await this.simulateRollback();
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async getPipelineMetrics() {
        return {
            buildTime: 120000,
            testTime: 180000,
            deployTime: 60000,
            successRate: 95.5,
            failureRate: 4.5,
            averageBuildTime: 125000,
        };
    }
    async getBuildArtifacts() {
        return [
            {
                id: 'build-123-api',
                name: 'salespot-api',
                version: '1.0.0',
                size: 1024 * 1024 * 50,
                checksum: 'sha256:abc123...',
                createdAt: new Date(),
                metadata: { environment: 'production' },
            },
        ];
    }
    generateBuildId() {
        return `build-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    generateChecksum() {
        return `sha256:${Math.random().toString(36).substr(2, 64)}`;
    }
    async simulateBuildProcess() {
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    async simulateTestProcess() {
        await new Promise(resolve => setTimeout(resolve, 3000));
    }
    async simulateSecurityScan() {
        await new Promise(resolve => setTimeout(resolve, 1500));
    }
    async simulateDeployment() {
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    async simulateRollback() {
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
};
PipelineService = PipelineService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], PipelineService);



/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DevOpsService: () => (/* binding */ DevOpsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _artifact_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/* harmony import */ var _pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/* harmony import */ var _pipeline_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DevOpsService_1;
var _a, _b, _c, _d;





let DevOpsService = DevOpsService_1 = class DevOpsService {
    constructor(configService, pipelineService, artifactService, monitoringService) {
        this.configService = configService;
        this.pipelineService = pipelineService;
        this.artifactService = artifactService;
        this.monitoringService = monitoringService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DevOpsService_1.name);
    }
    async getDevOpsHealth() {
        try {
            this.logger.log('Checking DevOps health status');
            const pipelineMetrics = await this.pipelineService.getPipelineMetrics();
            const pipelineStatus = pipelineMetrics.successRate > 90
                ? 'healthy'
                : pipelineMetrics.successRate > 70
                    ? 'degraded'
                    : 'unhealthy';
            const artifactHealth = await this.artifactService.getRegistryHealth();
            const artifactStatus = artifactHealth.status;
            const monitoringMetrics = await this.monitoringService.getPipelineMetrics();
            const monitoringStatus = monitoringMetrics.totalBuilds > 0 ? 'healthy' : 'degraded';
            const statuses = [pipelineStatus, artifactStatus, monitoringStatus];
            const overallStatus = statuses.includes('unhealthy')
                ? 'unhealthy'
                : statuses.includes('degraded')
                    ? 'degraded'
                    : 'healthy';
            return {
                status: overallStatus,
                components: {
                    pipeline: pipelineStatus,
                    artifacts: artifactStatus,
                    monitoring: monitoringStatus,
                },
                timestamp: new Date(),
            };
        }
        catch (error) {
            this.logger.error('Failed to get DevOps health status:', error);
            return {
                status: 'unhealthy',
                components: {
                    pipeline: 'unhealthy',
                    artifacts: 'unhealthy',
                    monitoring: 'unhealthy',
                },
                timestamp: new Date(),
            };
        }
    }
    async getDashboardData() {
        try {
            this.logger.log('Getting DevOps dashboard data');
            const [pipelineMetrics, artifactStats, monitoringAlerts] = await Promise.all([
                this.pipelineService.getPipelineMetrics(),
                this.artifactService.listArtifacts(),
                this.monitoringService.getPipelineAlerts(false),
            ]);
            const recentActivity = await this.monitoringService.getPipelineEvents(undefined, undefined, {
                from: new Date(Date.now() - 24 * 60 * 60 * 1000),
                to: new Date(),
            });
            return {
                pipelineMetrics,
                artifactStats: {
                    total: artifactStats.length,
                    latest: artifactStats.slice(0, 5),
                },
                monitoringAlerts: {
                    total: monitoringAlerts.length,
                    critical: monitoringAlerts.filter(a => a.severity === 'critical')
                        .length,
                    high: monitoringAlerts.filter(a => a.severity === 'high').length,
                },
                recentActivity: recentActivity.slice(0, 10),
            };
        }
        catch (error) {
            this.logger.error('Failed to get dashboard data:', error);
            throw error;
        }
    }
    async executeFullWorkflow(config) {
        const workflowId = `workflow-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const stages = [
            { name: 'build', status: 'pending' },
            { name: 'test', status: 'pending' },
            { name: 'security-scan', status: 'pending' },
            { name: 'deploy', status: 'pending' },
        ];
        try {
            this.logger.log(`Starting full DevOps workflow ${workflowId}`);
            if (stages[0])
                stages[0].status = 'running';
            const buildStartTime = Date.now();
            const pipelineResult = await this.pipelineService.executePipeline({
                stages: ['build', 'test', 'deploy'],
                environment: config.environment,
                branch: config.branch,
                commitHash: config.commitHash,
                buildNumber: config.buildNumber,
            });
            if (stages[0])
                stages[0].duration = Date.now() - buildStartTime;
            if (!pipelineResult.success) {
                if (stages[0]) {
                    stages[0].status = 'failed';
                    stages[0].error = 'Pipeline execution failed';
                }
                throw new Error('Pipeline execution failed');
            }
            if (stages[0])
                stages[0].status = 'completed';
            if (stages[1]) {
                stages[1].status = 'completed';
                stages[1].duration = pipelineResult.metrics.testTime;
            }
            if (stages[2]) {
                stages[2].status = 'completed';
                stages[2].duration = 30000;
            }
            if (stages[3]) {
                stages[3].status = 'completed';
                stages[3].duration = pipelineResult.metrics.deployTime;
            }
            await this.monitoringService.recordEvent({
                type: 'deploy_completed',
                buildId: pipelineResult.buildId,
                stage: 'full-workflow',
                metadata: { workflowId, environment: config.environment },
                duration: Date.now() - buildStartTime,
                success: true,
            });
            this.logger.log(`DevOps workflow ${workflowId} completed successfully`);
            return {
                success: true,
                workflowId,
                stages,
            };
        }
        catch (error) {
            this.logger.error(`DevOps workflow ${workflowId} failed:`, error);
            stages.some(stage => {
                if (stage.status === 'running') {
                    stage.status = 'failed';
                    stage.error = error instanceof Error ? error.message : String(error);
                    return true;
                }
                return false;
            });
            await this.monitoringService.recordEvent({
                type: 'pipeline_failed',
                buildId: workflowId,
                stage: 'full-workflow',
                metadata: { workflowId, environment: config.environment },
                error: error instanceof Error ? error.message : String(error),
            });
            return {
                success: false,
                workflowId,
                stages,
            };
        }
    }
    getDevOpsConfig() {
        return {
            environments: ['development', 'staging', 'production'],
            deploymentStrategies: ['rolling', 'blue-green', 'canary'],
            artifactRegistries: ['local-registry', 'docker-hub'],
            monitoringEnabled: this.configService.get('PIPELINE_MONITORING_ENABLED') ?? true,
        };
    }
};
DevOpsService = DevOpsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _pipeline_service__WEBPACK_IMPORTED_MODULE_4__.PipelineService !== "undefined" && _pipeline_service__WEBPACK_IMPORTED_MODULE_4__.PipelineService) === "function" ? _b : Object, typeof (_c = typeof _artifact_service__WEBPACK_IMPORTED_MODULE_2__.ArtifactService !== "undefined" && _artifact_service__WEBPACK_IMPORTED_MODULE_2__.ArtifactService) === "function" ? _c : Object, typeof (_d = typeof _pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_3__.PipelineMonitoringService !== "undefined" && _pipeline_monitoring_service__WEBPACK_IMPORTED_MODULE_3__.PipelineMonitoringService) === "function" ? _d : Object])
], DevOpsService);



/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedCICDPipelineService: () => (/* binding */ UnifiedCICDPipelineService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UnifiedCICDPipelineService_1;
var _a, _b;



let UnifiedCICDPipelineService = UnifiedCICDPipelineService_1 = class UnifiedCICDPipelineService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UnifiedCICDPipelineService_1.name);
        this.pipelines = new Map();
        this.deployments = new Map();
        this.environments = new Map();
        this.pipelineTemplates = new Map();
        this._configService.get('CICD_ENABLED');
        this.initializeEnvironments();
        this.initializePipelineTemplates();
    }
    initializeEnvironments() {
        const defaultEnvironments = [
            {
                name: 'development',
                displayName: 'Development',
                type: 'development',
                status: 'active',
                url: 'https://dev.example.com',
                replicas: 1,
                resources: {
                    cpu: '500m',
                    memory: '1Gi',
                    storage: '10Gi',
                },
                config: {
                    database: 'dev-db',
                    redis: 'dev-redis',
                    monitoring: false,
                },
                healthStatus: 'healthy',
            },
            {
                name: 'staging',
                displayName: 'Staging',
                type: 'staging',
                status: 'active',
                url: 'https://staging.example.com',
                replicas: 2,
                resources: {
                    cpu: '1000m',
                    memory: '2Gi',
                    storage: '20Gi',
                },
                config: {
                    database: 'staging-db',
                    redis: 'staging-redis',
                    monitoring: true,
                },
                healthStatus: 'healthy',
            },
            {
                name: 'production',
                displayName: 'Production',
                type: 'production',
                status: 'active',
                url: 'https://example.com',
                replicas: 5,
                resources: {
                    cpu: '2000m',
                    memory: '4Gi',
                    storage: '50Gi',
                },
                config: {
                    database: 'prod-db',
                    redis: 'prod-redis',
                    monitoring: true,
                },
                healthStatus: 'healthy',
            },
        ];
        defaultEnvironments.forEach(env => {
            this.environments.set(env.name, env);
        });
        this.logger.log(`Initialized ${defaultEnvironments.length} environments`);
    }
    initializePipelineTemplates() {
        const templates = [
            {
                id: 'standard-pipeline',
                name: 'Standard Pipeline',
                description: 'Standard CI/CD pipeline with build, test, and deploy stages',
                stages: [
                    {
                        name: 'Checkout',
                        type: 'build',
                        script: 'git checkout $CI_COMMIT_SHA',
                    },
                    {
                        name: 'Install Dependencies',
                        type: 'build',
                        script: 'pnpm install --frozen-lockfile',
                    },
                    {
                        name: 'Type Check',
                        type: 'test',
                        script: 'pnpm type-check',
                    },
                    {
                        name: 'Lint',
                        type: 'quality',
                        script: 'pnpm lint',
                    },
                    {
                        name: 'Unit Tests',
                        type: 'test',
                        script: 'pnpm test',
                    },
                    {
                        name: 'Build',
                        type: 'build',
                        script: 'pnpm build',
                    },
                    {
                        name: 'Security Scan',
                        type: 'security',
                        script: 'pnpm audit',
                    },
                    {
                        name: 'Deploy',
                        type: 'deploy',
                        script: 'kubectl apply -f k8s/',
                    },
                ],
            },
            {
                id: 'fast-pipeline',
                name: 'Fast Pipeline',
                description: 'Fast pipeline for development with minimal checks',
                stages: [
                    {
                        name: 'Checkout',
                        type: 'build',
                        script: 'git checkout $CI_COMMIT_SHA',
                    },
                    {
                        name: 'Install Dependencies',
                        type: 'build',
                        script: 'pnpm install --frozen-lockfile',
                    },
                    {
                        name: 'Quick Tests',
                        type: 'test',
                        script: 'pnpm test --passWithNoTests',
                    },
                    {
                        name: 'Build',
                        type: 'build',
                        script: 'pnpm build',
                    },
                    {
                        name: 'Deploy to Dev',
                        type: 'deploy',
                        script: 'kubectl apply -f k8s/dev/',
                    },
                ],
            },
        ];
        templates.forEach(template => {
            this.pipelineTemplates.set(template.id, template);
        });
        this.logger.log(`Initialized ${templates.length} pipeline templates`);
    }
    async createPipeline(templateId, branch, commit, environment, createdBy, metadata = {}) {
        const template = this.pipelineTemplates.get(templateId);
        if (template == null) {
            throw new Error(`Pipeline template ${templateId} not found`);
        }
        const pipelineId = `pipeline-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const stages = template.stages.map((stageTemplate, index) => ({
            id: `stage-${index}`,
            name: stageTemplate.name,
            type: stageTemplate.type,
            status: 'pending',
            logs: [],
            artifacts: [],
            metrics: {},
            dependencies: index > 0 ? [`stage-${index - 1}`] : [],
        }));
        const pipeline = {
            id: pipelineId,
            name: template.name,
            version: '1.0.0',
            branch,
            commit,
            trigger: 'manual',
            status: 'pending',
            stages,
            startTime: new Date(),
            environment,
            metadata: {
                templateId,
                ...metadata,
            },
            createdBy,
            createdAt: new Date(),
        };
        this.pipelines.set(pipelineId, pipeline);
        this.eventEmitter.emit('pipeline.created', pipeline);
        this.logger.log(`Created pipeline: ${pipelineId} for branch ${branch}`);
        return pipeline;
    }
    async startPipeline(pipelineId) {
        const pipeline = this.pipelines.get(pipelineId);
        if (!pipeline) {
            throw new Error(`Pipeline ${pipelineId} not found`);
        }
        if (pipeline.status !== 'pending') {
            throw new Error(`Pipeline ${pipelineId} is not in pending status`);
        }
        pipeline.status = 'running';
        pipeline.startTime = new Date();
        if (pipeline.stages[0]) {
            await this.startStage(pipelineId, pipeline.stages[0].id);
        }
        this.logger.log(`Started pipeline: ${pipelineId}`);
        return pipeline;
    }
    async startStage(pipelineId, stageId) {
        const pipeline = this.pipelines.get(pipelineId);
        if (!pipeline) {
            throw new Error(`Pipeline ${pipelineId} not found`);
        }
        const stage = pipeline.stages.find(s => s.id === stageId);
        if (!stage) {
            throw new Error(`Stage ${stageId} not found in pipeline ${pipelineId}`);
        }
        for (const depId of stage.dependencies) {
            const depStage = pipeline.stages.find(s => s.id === depId);
            if (!depStage || depStage.status !== 'success') {
                throw new Error(`Dependency ${depId} not completed for stage ${stageId}`);
            }
        }
        stage.status = 'running';
        stage.startTime = new Date();
        setTimeout(() => {
            void this.completeStage(pipelineId, stageId, 'success');
        }, Math.random() * 10000 + 5000);
        this.logger.log(`Started stage: ${stageId} in pipeline ${pipelineId}`);
        return stage;
    }
    async completeStage(pipelineId, stageId, status, logs = [], artifacts = [], metrics = {}) {
        const pipeline = this.pipelines.get(pipelineId);
        if (!pipeline) {
            throw new Error(`Pipeline ${pipelineId} not found`);
        }
        const stage = pipeline.stages.find(s => s.id === stageId);
        if (!stage) {
            throw new Error(`Stage ${stageId} not found in pipeline ${pipelineId}`);
        }
        stage.status = status;
        stage.endTime = new Date();
        stage.duration = stage.startTime
            ? stage.endTime.getTime() - stage.startTime.getTime()
            : 0;
        stage.logs = logs;
        stage.artifacts = artifacts;
        stage.metrics = metrics;
        this.eventEmitter.emit('pipeline.stage.completed', { pipeline, stage });
        if (status === 'failed') {
            pipeline.status = 'failed';
            pipeline.endTime = new Date();
            pipeline.duration =
                pipeline.endTime.getTime() - pipeline.startTime.getTime();
            this.eventEmitter.emit('pipeline.failed', pipeline);
            this.logger.error(`Pipeline ${pipelineId} failed at stage ${stageId}`);
        }
        else {
            const nextStage = pipeline.stages.find(s => s.status === 'pending' &&
                s.dependencies.every(depId => pipeline.stages.find(dep => dep.id === depId)?.status ===
                    'success'));
            if (nextStage != null) {
                await this.startStage(pipelineId, nextStage.id);
            }
            else {
                pipeline.status = 'success';
                pipeline.endTime = new Date();
                pipeline.duration =
                    pipeline.endTime.getTime() - pipeline.startTime.getTime();
                this.eventEmitter.emit('pipeline.success', pipeline);
                this.logger.log(`Pipeline ${pipelineId} completed successfully`);
            }
        }
        return stage;
    }
    async deployToEnvironment(pipelineId, environment, strategy = 'rolling') {
        const pipeline = this.pipelines.get(pipelineId);
        if (!pipeline) {
            throw new Error(`Pipeline ${pipelineId} not found`);
        }
        if (pipeline.status !== 'success') {
            throw new Error(`Pipeline ${pipelineId} is not successful`);
        }
        const env = this.environments.get(environment);
        if (env == null) {
            throw new Error(`Environment ${environment} not found`);
        }
        const deploymentId = `deployment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const deployment = {
            id: deploymentId,
            pipelineId,
            environment,
            version: pipeline.version,
            strategy,
            status: 'pending',
            startTime: new Date(),
            replicas: env.replicas,
            healthChecks: {
                liveness: false,
                readiness: false,
                startup: false,
            },
            metrics: {},
        };
        this.deployments.set(deploymentId, deployment);
        await this.startDeployment(deploymentId);
        this.logger.log(`Started deployment ${deploymentId} to ${environment}`);
        return deployment;
    }
    async startDeployment(deploymentId) {
        const deployment = this.deployments.get(deploymentId);
        if (!deployment) {
            return;
        }
        deployment.status = 'running';
        setTimeout(() => {
            void this.completeDeployment(deploymentId, 'success');
        }, Math.random() * 30000 + 10000);
        this.logger.log(`Deployment ${deploymentId} started`);
    }
    async completeDeployment(deploymentId, status, metrics = {}) {
        const deployment = this.deployments.get(deploymentId);
        if (!deployment) {
            throw new Error(`Deployment ${deploymentId} not found`);
        }
        deployment.status = status;
        deployment.endTime = new Date();
        deployment.duration =
            deployment.endTime.getTime() - deployment.startTime.getTime();
        deployment.metrics = metrics;
        if (status === 'success') {
            deployment.healthChecks = {
                liveness: true,
                readiness: true,
                startup: true,
            };
            const env = this.environments.get(deployment.environment);
            if (env != null) {
                env.lastDeployment = deploymentId;
                env.healthStatus = 'healthy';
            }
        }
        this.eventEmitter.emit('deployment.completed', deployment);
        this.logger.log(`Deployment ${deploymentId} completed with status: ${status}`);
        return deployment;
    }
    async rollbackDeployment(deploymentId, reason, rolledBackBy) {
        const deployment = this.deployments.get(deploymentId);
        if (!deployment) {
            throw new Error(`Deployment ${deploymentId} not found`);
        }
        deployment.status = 'rolled_back';
        deployment.endTime = new Date();
        deployment.duration =
            deployment.endTime.getTime() - deployment.startTime.getTime();
        deployment.rollbackInfo = {
            previousVersion: deployment.version,
            rollbackTime: new Date(),
            reason,
        };
        this.eventEmitter.emit('deployment.rolled_back', {
            deployment,
            rolledBackBy,
        });
        this.logger.log(`Deployment ${deploymentId} rolled back by ${rolledBackBy}: ${reason}`);
        return deployment;
    }
    async getPipeline(pipelineId) {
        return this.pipelines.get(pipelineId) ?? null;
    }
    async getAllPipelines(filters) {
        let pipelines = Array.from(this.pipelines.values());
        if (filters != null) {
            if (filters.status != null && filters.status !== '') {
                pipelines = pipelines.filter(p => p.status === filters.status);
            }
            if (filters.environment != null && filters.environment !== '') {
                pipelines = pipelines.filter(p => p.environment === filters.environment);
            }
            if (filters.branch != null && filters.branch !== '') {
                pipelines = pipelines.filter(p => p.branch === filters.branch);
            }
        }
        pipelines = pipelines.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            pipelines = pipelines.slice(0, filters.limit);
        }
        return pipelines;
    }
    async getDeployment(deploymentId) {
        return this.deployments.get(deploymentId) ?? null;
    }
    async getAllDeployments(filters) {
        let deployments = Array.from(this.deployments.values());
        if (filters != null) {
            if (filters.environment != null && filters.environment !== '') {
                deployments = deployments.filter(d => d.environment === filters.environment);
            }
            if (filters.status != null && filters.status !== '') {
                deployments = deployments.filter(d => d.status === filters.status);
            }
        }
        deployments = deployments.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            deployments = deployments.slice(0, filters.limit);
        }
        return deployments;
    }
    async getEnvironment(name) {
        return this.environments.get(name) ?? null;
    }
    async getAllEnvironments() {
        return Array.from(this.environments.values());
    }
    async updateEnvironmentStatus(name, status, healthStatus) {
        const env = this.environments.get(name);
        if (!env) {
            return null;
        }
        env.status = status;
        env.healthStatus = healthStatus;
        this.logger.log(`Environment ${name} status updated: ${status}, health: ${healthStatus}`);
        return env;
    }
    async getPipelineMetrics(timeRange) {
        const pipelines = Array.from(this.pipelines.values()).filter(p => p.createdAt >= timeRange.from && p.createdAt <= timeRange.to);
        const deployments = Array.from(this.deployments.values()).filter(d => d.startTime >= timeRange.from && d.startTime <= timeRange.to);
        const totalPipelines = pipelines.length;
        const successfulPipelines = pipelines.filter(p => p.status === 'success').length;
        const failedPipelines = pipelines.filter(p => p.status === 'failed').length;
        const completedPipelines = pipelines.filter(p => p.duration != null);
        const averageDuration = completedPipelines.length > 0
            ? completedPipelines.reduce((sum, p) => sum + (p.duration ?? 0), 0) /
                completedPipelines.length
            : 0;
        const pipelinesByStatus = pipelines.reduce((acc, p) => {
            acc[p.status] = (acc[p.status] ?? 0) + 1;
            return acc;
        }, {});
        const deploymentsByEnvironment = deployments.reduce((acc, d) => {
            acc[d.environment] = (acc[d.environment] ?? 0) + 1;
            return acc;
        }, {});
        return {
            totalPipelines,
            successfulPipelines,
            failedPipelines,
            averageDuration,
            pipelinesByStatus,
            deploymentsByEnvironment,
        };
    }
};
UnifiedCICDPipelineService = UnifiedCICDPipelineService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], UnifiedCICDPipelineService);



/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InfrastructureOrchestrationService: () => (/* binding */ InfrastructureOrchestrationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var InfrastructureOrchestrationService_1;
var _a, _b;



let InfrastructureOrchestrationService = InfrastructureOrchestrationService_1 = class InfrastructureOrchestrationService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(InfrastructureOrchestrationService_1.name);
        this.stacks = new Map();
        this.resources = new Map();
        this.templates = new Map();
        this.deploymentPlans = new Map();
        this._configService.get('INFRASTRUCTURE_ENABLED');
        this.initializeTemplates();
    }
    initializeTemplates() {
        const templates = [
            {
                id: 'basic-web-stack',
                name: 'Basic Web Stack',
                description: 'Basic web application stack with load balancer, compute, and database',
                version: '1.0.0',
                provider: 'kubernetes',
                template: {
                    apiVersion: 'v1',
                    kind: 'Namespace',
                    metadata: {
                        name: '${namespace}',
                    },
                },
                parameters: [
                    {
                        name: 'namespace',
                        type: 'string',
                        description: 'Kubernetes namespace',
                        defaultValue: 'default',
                        required: true,
                    },
                    {
                        name: 'replicas',
                        type: 'number',
                        description: 'Number of replicas',
                        defaultValue: 3,
                        required: false,
                    },
                    {
                        name: 'image',
                        type: 'string',
                        description: 'Container image',
                        required: true,
                    },
                ],
                outputs: [
                    {
                        name: 'namespace',
                        description: 'Created namespace',
                        value: '${namespace}',
                    },
                    {
                        name: 'service_url',
                        description: 'Service URL',
                        value: 'http://${namespace}.example.com',
                    },
                ],
                tags: ['web', 'basic', 'kubernetes'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'microservices-stack',
                name: 'Microservices Stack',
                description: 'Complete microservices stack with API Gateway, services, and monitoring',
                version: '1.0.0',
                provider: 'kubernetes',
                template: {
                    apiVersion: 'apps/v1',
                    kind: 'Deployment',
                    metadata: {
                        name: '${service_name}',
                        namespace: '${namespace}',
                    },
                    spec: {
                        replicas: '${replicas}',
                        selector: {
                            matchLabels: {
                                app: '${service_name}',
                            },
                        },
                        template: {
                            metadata: {
                                labels: {
                                    app: '${service_name}',
                                },
                            },
                            spec: {
                                containers: [
                                    {
                                        name: '${service_name}',
                                        image: '${image}',
                                        ports: [
                                            {
                                                containerPort: '${port}',
                                            },
                                        ],
                                    },
                                ],
                            },
                        },
                    },
                },
                parameters: [
                    {
                        name: 'namespace',
                        type: 'string',
                        description: 'Kubernetes namespace',
                        required: true,
                    },
                    {
                        name: 'service_name',
                        type: 'string',
                        description: 'Service name',
                        required: true,
                    },
                    {
                        name: 'image',
                        type: 'string',
                        description: 'Container image',
                        required: true,
                    },
                    {
                        name: 'replicas',
                        type: 'number',
                        description: 'Number of replicas',
                        defaultValue: 2,
                        required: false,
                    },
                    {
                        name: 'port',
                        type: 'number',
                        description: 'Container port',
                        defaultValue: 3000,
                        required: false,
                    },
                ],
                outputs: [
                    {
                        name: 'deployment_name',
                        description: 'Deployment name',
                        value: '${service_name}',
                    },
                    {
                        name: 'service_url',
                        description: 'Service URL',
                        value: 'http://${service_name}.${namespace}.svc.cluster.local',
                    },
                ],
                tags: ['microservices', 'kubernetes', 'api'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'database-stack',
                name: 'Database Stack',
                description: 'Database stack with PostgreSQL and Redis',
                version: '1.0.0',
                provider: 'kubernetes',
                template: {
                    apiVersion: 'apps/v1',
                    kind: 'StatefulSet',
                    metadata: {
                        name: '${db_name}',
                        namespace: '${namespace}',
                    },
                    spec: {
                        serviceName: '${db_name}',
                        replicas: 1,
                        selector: {
                            matchLabels: {
                                app: '${db_name}',
                            },
                        },
                        template: {
                            metadata: {
                                labels: {
                                    app: '${db_name}',
                                },
                            },
                            spec: {
                                containers: [
                                    {
                                        name: '${db_name}',
                                        image: '${db_image}',
                                        ports: [
                                            {
                                                containerPort: '${db_port}',
                                            },
                                        ],
                                        env: [
                                            {
                                                name: 'POSTGRES_DB',
                                                value: '${db_name}',
                                            },
                                            {
                                                name: 'POSTGRES_USER',
                                                value: '${db_user}',
                                            },
                                            {
                                                name: 'POSTGRES_PASSWORD',
                                                valueFrom: {
                                                    secretKeyRef: {
                                                        name: '${db_name}-secret',
                                                        key: 'password',
                                                    },
                                                },
                                            },
                                        ],
                                    },
                                ],
                            },
                        },
                    },
                },
                parameters: [
                    {
                        name: 'namespace',
                        type: 'string',
                        description: 'Kubernetes namespace',
                        required: true,
                    },
                    {
                        name: 'db_name',
                        type: 'string',
                        description: 'Database name',
                        required: true,
                    },
                    {
                        name: 'db_image',
                        type: 'string',
                        description: 'Database image',
                        defaultValue: 'postgres:15',
                        required: false,
                    },
                    {
                        name: 'db_port',
                        type: 'number',
                        description: 'Database port',
                        defaultValue: 5432,
                        required: false,
                    },
                    {
                        name: 'db_user',
                        type: 'string',
                        description: 'Database user',
                        defaultValue: 'postgres',
                        required: false,
                    },
                ],
                outputs: [
                    {
                        name: 'db_host',
                        description: 'Database host',
                        value: '${db_name}.${namespace}.svc.cluster.local',
                    },
                    {
                        name: 'db_port',
                        description: 'Database port',
                        value: '${db_port}',
                    },
                ],
                tags: ['database', 'postgresql', 'kubernetes'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        templates.forEach(template => {
            this.templates.set(template.id, template);
        });
        this.logger.log(`Initialized ${templates.length} infrastructure templates`);
    }
    async createStack(templateId, name, environment, parameters, deployedBy, description) {
        const template = this.templates.get(templateId);
        if (!template) {
            throw new Error(`Template ${templateId} not found`);
        }
        this.validateParameters(template.parameters, parameters);
        const stackId = `stack-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const stack = {
            id: stackId,
            name,
            description: description ?? template.description,
            environment,
            version: template.version,
            status: 'pending',
            resources: [],
            outputs: {},
            parameters,
            createdAt: new Date(),
            updatedAt: new Date(),
            deployedBy,
        };
        this.stacks.set(stackId, stack);
        const plan = await this.createDeploymentPlan(stackId, 'create', deployedBy);
        await this.approveDeploymentPlan(plan.id, deployedBy);
        this.logger.log(`Created infrastructure stack: ${stackId}`);
        return stack;
    }
    async deployStack(stackId) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            throw new Error(`Stack ${stackId} not found`);
        }
        if (stack.status !== 'pending') {
            throw new Error(`Stack ${stackId} is not in pending status`);
        }
        stack.status = 'deploying';
        stack.updatedAt = new Date();
        this.eventEmitter.emit('infrastructure.stack.deploying', stack);
        setTimeout(() => {
            void this.completeStackDeployment(stackId, 'deployed');
        }, Math.random() * 30000 + 10000);
        this.logger.log(`Started deployment of stack: ${stackId}`);
        return stack;
    }
    async completeStackDeployment(stackId, status, outputs = {}) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            throw new Error(`Stack ${stackId} not found`);
        }
        stack.status = status;
        stack.updatedAt = new Date();
        stack.outputs = outputs;
        if (status === 'deployed') {
            stack.deployedAt = new Date();
            await this.createStackResources(stack);
        }
        this.eventEmitter.emit('infrastructure.stack.deployed', stack);
        this.logger.log(`Stack ${stackId} deployment completed with status: ${status}`);
        return stack;
    }
    async createStackResources(stack) {
        const template = this.templates.get(stack.name);
        if (!template) {
            return;
        }
        const resources = [
            {
                id: `resource-${stack.id}-namespace`,
                name: `${stack.name}-namespace`,
                type: 'compute',
                provider: 'kubernetes',
                status: 'running',
                region: 'default',
                configuration: {
                    kind: 'Namespace',
                    metadata: {
                        name: typeof stack.parameters.namespace === 'string'
                            ? stack.parameters.namespace
                            : 'default',
                    },
                },
                tags: {
                    stack: stack.id,
                    environment: stack.environment,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
                dependencies: [],
                outputs: {
                    name: typeof stack.parameters.namespace === 'string'
                        ? stack.parameters.namespace
                        : 'default',
                },
            },
            {
                id: `resource-${stack.id}-deployment`,
                name: `${stack.name}-deployment`,
                type: 'compute',
                provider: 'kubernetes',
                status: 'running',
                region: 'default',
                configuration: {
                    kind: 'Deployment',
                    metadata: {
                        name: typeof stack.parameters.service_name === 'string'
                            ? stack.parameters.service_name
                            : stack.name,
                        namespace: typeof stack.parameters.namespace === 'string'
                            ? stack.parameters.namespace
                            : 'default',
                    },
                },
                tags: {
                    stack: stack.id,
                    environment: stack.environment,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
                dependencies: [`resource-${stack.id}-namespace`],
                outputs: {
                    name: typeof stack.parameters.service_name === 'string'
                        ? stack.parameters.service_name
                        : stack.name,
                },
            },
        ];
        for (const resource of resources) {
            this.resources.set(resource.id, resource);
            stack.resources.push(resource);
        }
        this.logger.log(`Created ${resources.length} resources for stack ${stack.id}`);
    }
    async updateStack(stackId, parameters, updatedBy) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            throw new Error(`Stack ${stackId} not found`);
        }
        if (stack.status !== 'deployed') {
            throw new Error(`Stack ${stackId} is not deployed`);
        }
        await this.createDeploymentPlan(stackId, 'update', updatedBy);
        stack.parameters = { ...stack.parameters, ...parameters };
        stack.updatedAt = new Date();
        this.logger.log(`Updated stack ${stackId} parameters`);
        return stack;
    }
    async destroyStack(stackId, _destroyedBy) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            throw new Error(`Stack ${stackId} not found`);
        }
        stack.status = 'destroying';
        stack.updatedAt = new Date();
        this.eventEmitter.emit('infrastructure.stack.destroying', stack);
        setTimeout(() => {
            void this.completeStackDestruction(stackId);
        }, Math.random() * 20000 + 5000);
        this.logger.log(`Started destruction of stack: ${stackId}`);
        return stack;
    }
    async completeStackDestruction(stackId) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            return;
        }
        for (const resource of stack.resources) {
            this.resources.delete(resource.id);
        }
        this.stacks.delete(stackId);
        this.eventEmitter.emit('infrastructure.stack.destroyed', { stackId });
        this.logger.log(`Stack ${stackId} destroyed successfully`);
    }
    async createDeploymentPlan(stackId, action, createdBy) {
        const stack = this.stacks.get(stackId);
        if (!stack) {
            throw new Error(`Stack ${stackId} not found`);
        }
        const planId = `plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const changes = stack.resources.map(resource => ({
            resourceId: resource.id,
            action: action === 'destroy'
                ? 'delete'
                : action === 'create'
                    ? 'create'
                    : 'update',
            changes: {},
        }));
        const plan = {
            id: planId,
            stackId,
            action,
            changes: changes.map(change => ({
                ...change,
                action: change.action,
            })),
            estimatedDuration: Math.random() * 30000 + 10000,
            riskLevel: action === 'destroy' ? 'high' : action === 'update' ? 'medium' : 'low',
            approvalRequired: action === 'destroy' || action === 'update',
            createdAt: new Date(),
            createdBy,
        };
        this.deploymentPlans.set(planId, plan);
        this.logger.log(`Created deployment plan: ${planId} for stack ${stackId}`);
        return plan;
    }
    async approveDeploymentPlan(planId, approvedBy) {
        const plan = this.deploymentPlans.get(planId);
        if (!plan) {
            throw new Error(`Deployment plan ${planId} not found`);
        }
        plan.approvedBy = approvedBy;
        plan.approvedAt = new Date();
        this.logger.log(`Deployment plan ${planId} approved by ${approvedBy}`);
        return plan;
    }
    async getStack(stackId) {
        return this.stacks.get(stackId) ?? null;
    }
    async getAllStacks(filters) {
        let stacks = Array.from(this.stacks.values());
        if (filters != null) {
            if (filters.environment != null && filters.environment !== '') {
                stacks = stacks.filter(s => s.environment === filters.environment);
            }
            if (filters.status != null && filters.status !== '') {
                stacks = stacks.filter(s => s.status === filters.status);
            }
        }
        stacks = stacks.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            stacks = stacks.slice(0, filters.limit);
        }
        return stacks;
    }
    async getResource(resourceId) {
        return this.resources.get(resourceId) ?? null;
    }
    async getAllResources(filters) {
        let resources = Array.from(this.resources.values());
        if (filters != null) {
            if (filters.type != null && filters.type !== '') {
                resources = resources.filter(r => r.type === filters.type);
            }
            if (filters.provider != null && filters.provider !== '') {
                resources = resources.filter(r => r.provider === filters.provider);
            }
            if (filters.status != null && filters.status !== '') {
                resources = resources.filter(r => r.status === filters.status);
            }
        }
        resources = resources.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            resources = resources.slice(0, filters.limit);
        }
        return resources;
    }
    async getTemplate(templateId) {
        return this.templates.get(templateId) ?? null;
    }
    async getAllTemplates() {
        return Array.from(this.templates.values());
    }
    async getDeploymentPlan(planId) {
        return this.deploymentPlans.get(planId) ?? null;
    }
    async getAllDeploymentPlans(filters) {
        let plans = Array.from(this.deploymentPlans.values());
        if (filters) {
            if (filters.stackId != null && filters.stackId !== '') {
                plans = plans.filter(p => p.stackId === filters.stackId);
            }
            if (filters.action != null && filters.action !== '') {
                plans = plans.filter(p => p.action === filters.action);
            }
        }
        plans = plans.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            plans = plans.slice(0, filters.limit);
        }
        return plans;
    }
    validateParameters(parameterDefinitions, parameters) {
        for (const paramDef of parameterDefinitions) {
            if (paramDef.required && !(paramDef.name in parameters)) {
                throw new Error(`Required parameter ${paramDef.name} is missing`);
            }
        }
    }
    async getInfrastructureMetrics() {
        const stacks = Array.from(this.stacks.values());
        const resources = Array.from(this.resources.values());
        const templates = Array.from(this.templates.values());
        const stacksByStatus = stacks.reduce((acc, stack) => {
            acc[stack.status] = (acc[stack.status] ?? 0) + 1;
            return acc;
        }, {});
        const stacksByEnvironment = stacks.reduce((acc, stack) => {
            acc[stack.environment] = (acc[stack.environment] ?? 0) + 1;
            return acc;
        }, {});
        const resourcesByType = resources.reduce((acc, resource) => {
            acc[resource.type] = (acc[resource.type] ?? 0) + 1;
            return acc;
        }, {});
        const resourcesByProvider = resources.reduce((acc, resource) => {
            acc[resource.provider] = (acc[resource.provider] ?? 0) + 1;
            return acc;
        }, {});
        return {
            totalStacks: stacks.length,
            stacksByStatus,
            stacksByEnvironment,
            totalResources: resources.length,
            resourcesByType,
            resourcesByProvider,
            totalTemplates: templates.length,
        };
    }
};
InfrastructureOrchestrationService = InfrastructureOrchestrationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], InfrastructureOrchestrationService);



/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisasterRecoveryModule: () => (/* binding */ DisasterRecoveryModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var _services_incident_response_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(91);
/* harmony import */ var _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92);
/* harmony import */ var _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(93);
/* harmony import */ var _controllers_disaster_recovery_controller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(94);
/* harmony import */ var _controllers_regional_failover_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(97);
/* harmony import */ var _controllers_network_resilience_controller__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(100);
/* harmony import */ var _controllers_geographic_routing_controller__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(103);
/* harmony import */ var _controllers_incident_response_controller__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(106);
/* harmony import */ var _controllers_capacity_planning_controller__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(109);
/* harmony import */ var _controllers_a1_ict_services_controller__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(112);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
















let DisasterRecoveryModule = class DisasterRecoveryModule {
};
DisasterRecoveryModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule],
        providers: [
            _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_2__.DisasterRecoveryService,
            _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_3__.RegionalFailoverService,
            _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__.NetworkResilienceService,
            _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_5__.GeographicRoutingService,
            _services_incident_response_service__WEBPACK_IMPORTED_MODULE_6__.IncidentResponseService,
            _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_7__.CapacityPlanningService,
            _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_8__.A1IctServicesService,
        ],
        controllers: [
            _controllers_disaster_recovery_controller__WEBPACK_IMPORTED_MODULE_9__.DisasterRecoveryController,
            _controllers_regional_failover_controller__WEBPACK_IMPORTED_MODULE_10__.RegionalFailoverController,
            _controllers_network_resilience_controller__WEBPACK_IMPORTED_MODULE_11__.NetworkResilienceController,
            _controllers_geographic_routing_controller__WEBPACK_IMPORTED_MODULE_12__.GeographicRoutingController,
            _controllers_incident_response_controller__WEBPACK_IMPORTED_MODULE_13__.IncidentResponseController,
            _controllers_capacity_planning_controller__WEBPACK_IMPORTED_MODULE_14__.CapacityPlanningController,
            _controllers_a1_ict_services_controller__WEBPACK_IMPORTED_MODULE_15__.A1IctServicesController,
        ],
        exports: [
            _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_2__.DisasterRecoveryService,
            _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_3__.RegionalFailoverService,
            _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__.NetworkResilienceService,
            _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_5__.GeographicRoutingService,
            _services_incident_response_service__WEBPACK_IMPORTED_MODULE_6__.IncidentResponseService,
            _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_7__.CapacityPlanningService,
            _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_8__.A1IctServicesService,
        ],
    })
], DisasterRecoveryModule);



/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisasterRecoveryService: () => (/* binding */ DisasterRecoveryService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DisasterRecoveryService_1;

let DisasterRecoveryService = DisasterRecoveryService_1 = class DisasterRecoveryService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DisasterRecoveryService_1.name);
        this.dataCenters = new Map();
        this.initializeDefaultDataCenters();
    }
    initializeDefaultDataCenters() {
        const defaultDcs = [
            {
                id: 'dc-minsk-primary',
                name: 'Minsk Primary DC',
                region: 'Minsk',
                country: 'BY',
                city: 'Minsk',
                coordinates: { latitude: 53.9045, longitude: 27.5615 },
                status: 'active',
                capacity: { cpu: 1000, memory: 8192, storage: 100000, network: 10000 },
            },
            {
                id: 'dc-minsk-secondary',
                name: 'Minsk Secondary DC',
                region: 'Minsk',
                country: 'BY',
                city: 'Minsk',
                coordinates: { latitude: 53.9045, longitude: 27.5615 },
                status: 'maintenance',
                capacity: { cpu: 800, memory: 6144, storage: 80000, network: 8000 },
            },
            {
                id: 'dc-moscow-primary',
                name: 'Moscow Primary DC',
                region: 'Moscow',
                country: 'RU',
                city: 'Moscow',
                coordinates: { latitude: 55.7558, longitude: 37.6176 },
                status: 'active',
                capacity: { cpu: 1200, memory: 10240, storage: 120000, network: 12000 },
            },
            {
                id: 'dc-moscow-secondary',
                name: 'Moscow Secondary DC',
                region: 'Moscow',
                country: 'RU',
                city: 'Moscow',
                coordinates: { latitude: 55.7558, longitude: 37.6176 },
                status: 'maintenance',
                capacity: { cpu: 1000, memory: 8192, storage: 100000, network: 10000 },
            },
        ];
        defaultDcs.forEach(dc => this.dataCenters.set(dc.id, dc));
        this.logger.log(`Initialized ${defaultDcs.length} default data centers`);
    }
    async getAllDataCenters() {
        return Array.from(this.dataCenters.values());
    }
    async getDataCenterById(id) {
        return this.dataCenters.get(id) ?? null;
    }
    async createDataCenter(createDto) {
        const id = `dc-${Date.now()}`;
        const dataCenter = {
            id,
            name: createDto.name,
            region: createDto.region,
            country: createDto.country,
            city: createDto.city,
            coordinates: createDto.coordinates,
            status: 'active',
            capacity: createDto.capacity,
        };
        this.dataCenters.set(id, dataCenter);
        this.logger.log(`Created data center: ${id}`);
        return dataCenter;
    }
    async updateDataCenter(id, updateDto) {
        const dataCenter = this.dataCenters.get(id);
        if (!dataCenter) {
            return null;
        }
        const updatedDataCenter = {
            ...dataCenter,
            name: updateDto.name ?? dataCenter.name,
            region: updateDto.region ?? dataCenter.region,
            country: updateDto.country ?? dataCenter.country,
            city: updateDto.city ?? dataCenter.city,
            coordinates: updateDto.coordinates ?? dataCenter.coordinates,
            capacity: updateDto.capacity ?? dataCenter.capacity,
            status: updateDto.status ?? dataCenter.status,
        };
        this.dataCenters.set(id, updatedDataCenter);
        this.logger.log(`Updated data center: ${id}`);
        return updatedDataCenter;
    }
    async deleteDataCenter(id) {
        const deleted = this.dataCenters.delete(id);
        if (deleted) {
            this.logger.log(`Deleted data center: ${id}`);
        }
        return deleted;
    }
    async getDataCentersStatus() {
        const status = {};
        for (const [id, dc] of this.dataCenters) {
            status[id] = dc.status;
        }
        return status;
    }
    async checkDataCenterHealth(id) {
        const dataCenter = this.dataCenters.get(id);
        if (!dataCenter) {
            return null;
        }
        const health = {
            uptime: 99.99,
            lastCheck: new Date(),
            status: 'healthy',
        };
        return health;
    }
    async getDataCentersStatistics() {
        const stats = {
            total: this.dataCenters.size,
            active: 0,
            standby: 0,
            maintenance: 0,
            offline: 0,
        };
        for (const dc of this.dataCenters.values()) {
            stats[dc.status]++;
        }
        return stats;
    }
    async findDataCentersByRegion(region) {
        return Array.from(this.dataCenters.values()).filter(dc => dc.region.toLowerCase() === region.toLowerCase());
    }
    async findDataCentersByCountry(country) {
        return Array.from(this.dataCenters.values()).filter(dc => dc.country === country);
    }
    async findNearestDataCenter(latitude, longitude) {
        let nearestDc = null;
        let minDistance = Infinity;
        for (const dc of this.dataCenters.values()) {
            if (dc.status !== 'active')
                continue;
            const distance = this.calculateDistance(latitude, longitude, dc.coordinates.latitude, dc.coordinates.longitude);
            if (distance < minDistance) {
                minDistance = distance;
                nearestDc = dc;
            }
        }
        return nearestDc;
    }
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = this.toRadians(lat2 - lat1);
        const dLon = this.toRadians(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.toRadians(lat1)) *
                Math.cos(this.toRadians(lat2)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
    manageDatacenter(datacenterId) {
        const dc = this.dataCenters.get(datacenterId);
        if (!dc) {
            return {
                id: datacenterId,
                status: 'maintenance',
            };
        }
        return {
            id: dc.id,
            status: dc.status === 'offline' ? 'standby' : dc.status,
        };
    }
    checkDatacenterHealth(datacenterId) {
        const dc = this.dataCenters.get(datacenterId);
        if (!dc) {
            return {
                datacenterId,
                status: 'unhealthy',
            };
        }
        const healthScore = Math.random();
        let status;
        if (healthScore > 0.7) {
            status = 'healthy';
        }
        else if (healthScore > 0.3) {
            status = 'degraded';
        }
        else {
            status = 'unhealthy';
        }
        return {
            datacenterId,
            status,
        };
    }
    getDatacenterStatistics(datacenterId) {
        const dc = this.dataCenters.get(datacenterId);
        if (!dc) {
            return {
                datacenterId,
                uptime: 0,
                availability: 0,
            };
        }
        return {
            datacenterId,
            uptime: Math.floor(Math.random() * 100) + 80,
            availability: Math.floor(Math.random() * 100) + 90,
        };
    }
    performDisasterRecoveryTest(datacenterId) {
        const dc = this.dataCenters.get(datacenterId);
        if (!dc) {
            return {
                datacenterId,
                status: 'failed',
            };
        }
        const testResult = Math.random();
        let status;
        if (testResult > 0.8) {
            status = 'passed';
        }
        else if (testResult > 0.4) {
            status = 'in_progress';
        }
        else {
            status = 'failed';
        }
        return {
            datacenterId,
            status,
        };
    }
};
DisasterRecoveryService = DisasterRecoveryService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DisasterRecoveryService);



/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegionalFailoverService: () => (/* binding */ RegionalFailoverService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var RegionalFailoverService_1;

let RegionalFailoverService = RegionalFailoverService_1 = class RegionalFailoverService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(RegionalFailoverService_1.name);
        this.failoverConfigs = new Map();
        this.failoverEvents = new Map();
        this.failoverHistory = [];
        this.initializeDefaultFailoverConfigs();
    }
    initializeDefaultFailoverConfigs() {
        const defaultConfigs = [
            {
                id: 'failover-by-primary',
                primaryDc: 'dc-minsk-primary',
                secondaryDc: 'dc-minsk-secondary',
                autoFailover: true,
                failoverThreshold: 30,
                recoveryTimeObjective: 300,
                recoveryPointObjective: 60,
                healthChecks: {
                    interval: 10,
                    timeout: 5,
                    retries: 3,
                },
            },
            {
                id: 'failover-ru-primary',
                primaryDc: 'dc-moscow-primary',
                secondaryDc: 'dc-moscow-secondary',
                autoFailover: true,
                failoverThreshold: 30,
                recoveryTimeObjective: 300,
                recoveryPointObjective: 60,
                healthChecks: {
                    interval: 10,
                    timeout: 5,
                    retries: 3,
                },
            },
            {
                id: 'failover-cross-region',
                primaryDc: 'dc-minsk-primary',
                secondaryDc: 'dc-moscow-primary',
                autoFailover: false,
                failoverThreshold: 60,
                recoveryTimeObjective: 600,
                recoveryPointObjective: 300,
                healthChecks: {
                    interval: 15,
                    timeout: 10,
                    retries: 5,
                },
            },
        ];
        defaultConfigs.forEach(config => this.failoverConfigs.set(config.id, config));
        this.logger.log(`Initialized ${defaultConfigs.length} default failover configurations`);
    }
    async getAllFailoverConfigs() {
        return Array.from(this.failoverConfigs.values());
    }
    async getFailoverConfigById(id) {
        return this.failoverConfigs.get(id) ?? null;
    }
    async createFailoverConfig(createDto) {
        const id = `failover-${Date.now()}`;
        const config = {
            id,
            primaryDc: createDto.primaryDc,
            secondaryDc: createDto.secondaryDc,
            autoFailover: createDto.autoFailover,
            failoverThreshold: createDto.failoverThreshold,
            recoveryTimeObjective: createDto.recoveryTimeObjective,
            recoveryPointObjective: createDto.recoveryPointObjective,
            healthChecks: createDto.healthChecks,
        };
        this.failoverConfigs.set(id, config);
        this.logger.log(`Created failover config: ${id}`);
        return config;
    }
    async updateFailoverConfig(id, updateDto) {
        const config = this.failoverConfigs.get(id);
        if (!config) {
            return null;
        }
        const updatedConfig = {
            ...config,
            primaryDc: updateDto.primaryDc ?? config.primaryDc,
            secondaryDc: updateDto.secondaryDc ?? config.secondaryDc,
            autoFailover: updateDto.autoFailover ?? config.autoFailover,
            failoverThreshold: updateDto.failoverThreshold ?? config.failoverThreshold,
            recoveryTimeObjective: updateDto.recoveryTimeObjective ?? config.recoveryTimeObjective,
            recoveryPointObjective: updateDto.recoveryPointObjective ?? config.recoveryPointObjective,
            healthChecks: updateDto.healthChecks ?? config.healthChecks,
        };
        this.failoverConfigs.set(id, updatedConfig);
        this.logger.log(`Updated failover config: ${id}`);
        return updatedConfig;
    }
    async deleteFailoverConfig(id) {
        const deleted = this.failoverConfigs.delete(id);
        if (deleted) {
            this.logger.log(`Deleted failover config: ${id}`);
        }
        return deleted;
    }
    async performAutoFailover(configId) {
        const config = this.failoverConfigs.get(configId);
        if (!config) {
            return {
                success: false,
                action: 'none',
                reason: 'Configuration not found',
                duration: 0,
            };
        }
        if (!config.autoFailover) {
            return {
                success: false,
                action: 'none',
                reason: 'Auto failover is disabled for this configuration',
                duration: 0,
            };
        }
        const startTime = Date.now();
        try {
            const primaryHealth = await this.checkDataCenterHealth();
            const secondaryHealth = await this.checkDataCenterHealth();
            if (primaryHealth?.status === 'critical' &&
                secondaryHealth?.status === 'healthy') {
                await this.executeFailover(config, 'primary-failure');
                const duration = Date.now() - startTime;
                this.logFailoverAction(configId, 'failover', 'Primary DC health check failed', duration);
                return {
                    success: true,
                    action: 'failover',
                    reason: 'Primary DC health check failed',
                    duration,
                };
            }
            else if (primaryHealth?.status === 'healthy' &&
                secondaryHealth?.status === 'critical') {
                await this.executeFailback(config, 'secondary-failure');
                const duration = Date.now() - startTime;
                this.logFailoverAction(configId, 'failback', 'Secondary DC health check failed', duration);
                return {
                    success: true,
                    action: 'failback',
                    reason: 'Secondary DC health check failed',
                    duration,
                };
            }
            return {
                success: true,
                action: 'none',
                reason: 'No failover required',
                duration: Date.now() - startTime,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Auto failover failed for config ${configId}: ${error}`);
            return {
                success: false,
                action: 'none',
                reason: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
                duration,
            };
        }
    }
    async manualFailover(configId, reason) {
        const config = this.failoverConfigs.get(configId);
        if (!config) {
            return {
                success: false,
                action: 'none',
                reason: 'Configuration not found',
                duration: 0,
            };
        }
        const startTime = Date.now();
        try {
            await this.executeFailover(config, reason);
            const duration = Date.now() - startTime;
            this.logFailoverAction(configId, 'failover', reason, duration);
            return {
                success: true,
                action: 'failover',
                reason,
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Manual failover failed for config ${configId}: ${error}`);
            return {
                success: false,
                action: 'none',
                reason: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
                duration,
            };
        }
    }
    async manualFailback(configId, reason) {
        const config = this.failoverConfigs.get(configId);
        if (!config) {
            return {
                success: false,
                action: 'none',
                reason: 'Configuration not found',
                duration: 0,
            };
        }
        const startTime = Date.now();
        try {
            await this.executeFailback(config, reason);
            const duration = Date.now() - startTime;
            this.logFailoverAction(configId, 'failback', reason, duration);
            return {
                success: true,
                action: 'failback',
                reason,
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Manual failback failed for config ${configId}: ${error}`);
            return {
                success: false,
                action: 'none',
                reason: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
                duration,
            };
        }
    }
    async executeFailover(config, reason) {
        this.logger.log(`Executing failover for config ${config.id}: ${reason}`);
        await this.delay(1000);
        this.logger.log(`Failover completed for config ${config.id}`);
        return true;
    }
    async executeFailback(config, reason) {
        this.logger.log(`Executing failback for config ${config.id}: ${reason}`);
        await this.delay(1000);
        this.logger.log(`Failback completed for config ${config.id}`);
        return true;
    }
    async checkDataCenterHealth() {
        const random = Math.random();
        let status;
        if (random > 0.8) {
            status = 'critical';
        }
        else if (random > 0.6) {
            status = 'warning';
        }
        else {
            status = 'healthy';
        }
        return { status };
    }
    logFailoverAction(configId, action, reason, duration) {
        this.failoverHistory.push({
            timestamp: new Date(),
            configId,
            action,
            details: reason,
            duration,
        });
        if (this.failoverHistory.length > 100) {
            this.failoverHistory.shift();
        }
    }
    async getFailoverHistory(limit = 50) {
        return this.failoverHistory.slice(-limit);
    }
    async getFailoverStatistics() {
        const events = Array.from(this.failoverEvents.values());
        const failoverEvents = events.filter(event => event.action === 'failover');
        const failbackEvents = events.filter(event => event.action === 'failback');
        const totalFailovers = failoverEvents.length;
        const totalFailbacks = failbackEvents.length;
        const failoverTimes = failoverEvents
            .filter(event => event.action === 'failover')
            .map(event => event.duration);
        const failbackTimes = failbackEvents
            .filter(event => event.action === 'failback')
            .map(event => event.duration);
        const averageFailoverTime = failoverTimes.length > 0
            ? failoverTimes.reduce((sum, time) => sum + time, 0) /
                failoverTimes.length
            : 0;
        const averageFailbackTime = failbackTimes.length > 0
            ? failbackTimes.reduce((sum, time) => sum + time, 0) /
                failbackTimes.length
            : 0;
        const lastFailover = failoverEvents.length > 0
            ? new Date(Math.max(...failoverEvents.map(e => e.timestamp.getTime())))
            : undefined;
        const lastFailback = failbackEvents.length > 0
            ? new Date(Math.max(...failbackEvents.map(e => e.timestamp.getTime())))
            : undefined;
        return {
            totalFailovers,
            totalFailbacks,
            averageFailoverTime,
            averageFailbackTime,
            ...(lastFailover && { lastFailover }),
            ...(lastFailback && { lastFailback }),
        };
    }
    delay(ms) {
        return new Promise(resolve => globalThis.setTimeout(resolve, ms));
    }
    configureFailover(config) {
        const failoverId = `failover-${Date.now()}`;
        return {
            id: failoverId,
            primaryDatacenter: config.primaryDatacenter,
            secondaryDatacenter: config.secondaryDatacenter,
            autoSwitch: config.autoSwitch,
            status: 'active',
        };
    }
    performAutomaticFailover(datacenterId) {
        return {
            sourceDatacenter: datacenterId,
            targetDatacenter: `${datacenterId}-backup`,
            status: 'success',
            duration: 15000,
        };
    }
    performManualFailover(sourceDatacenter, targetDatacenter) {
        return {
            sourceDatacenter,
            targetDatacenter,
            status: 'success',
            duration: 20000,
        };
    }
    getFailoverStatus(datacenterId) {
        return {
            datacenterId,
            status: 'active',
            lastCheck: new Date(),
        };
    }
};
RegionalFailoverService = RegionalFailoverService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], RegionalFailoverService);



/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkResilienceService: () => (/* binding */ NetworkResilienceService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NetworkResilienceService_1;

let NetworkResilienceService = NetworkResilienceService_1 = class NetworkResilienceService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(NetworkResilienceService_1.name);
        this.networkLinks = new Map();
        this.networkHistory = [];
        this.initializeDefaultNetworkLinks();
    }
    initializeDefaultNetworkLinks() {
        const defaultLinks = [
            {
                id: 'link-minsk-primary-secondary',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-minsk-secondary',
                type: 'primary',
                bandwidth: 10000,
                latency: 1,
                status: 'active',
                provider: 'Beltelecom',
                lastCheck: new Date(),
            },
            {
                id: 'link-minsk-primary-backup',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-minsk-secondary',
                type: 'backup',
                bandwidth: 1000,
                latency: 2,
                status: 'active',
                provider: 'A1',
                lastCheck: new Date(),
            },
            {
                id: 'link-moscow-primary-secondary',
                sourceDc: 'dc-moscow-primary',
                targetDc: 'dc-moscow-secondary',
                type: 'primary',
                bandwidth: 10000,
                latency: 1,
                status: 'active',
                provider: 'Rostelecom',
                lastCheck: new Date(),
            },
            {
                id: 'link-moscow-primary-backup',
                sourceDc: 'dc-moscow-primary',
                targetDc: 'dc-moscow-secondary',
                type: 'backup',
                bandwidth: 1000,
                latency: 2,
                status: 'active',
                provider: 'MTS',
                lastCheck: new Date(),
            },
            {
                id: 'link-minsk-moscow-primary',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-moscow-primary',
                type: 'primary',
                bandwidth: 5000,
                latency: 15,
                status: 'active',
                provider: 'Beltelecom-Rostelecom',
                lastCheck: new Date(),
            },
            {
                id: 'link-minsk-moscow-backup',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-moscow-primary',
                type: 'backup',
                bandwidth: 1000,
                latency: 25,
                status: 'active',
                provider: 'A1-MTS',
                lastCheck: new Date(),
            },
            {
                id: 'link-peering-becloud',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-minsk-secondary',
                type: 'peering',
                bandwidth: 500,
                latency: 5,
                status: 'active',
                provider: 'BeCloud',
                lastCheck: new Date(),
            },
            {
                id: 'link-peering-hoster',
                sourceDc: 'dc-minsk-primary',
                targetDc: 'dc-minsk-secondary',
                type: 'peering',
                bandwidth: 500,
                latency: 5,
                status: 'active',
                provider: 'Hoster.by',
                lastCheck: new Date(),
            },
        ];
        defaultLinks.forEach(link => this.networkLinks.set(link.id, link));
        this.logger.log(`Initialized ${defaultLinks.length} default network links`);
    }
    async getAllNetworkLinks() {
        return Array.from(this.networkLinks.values());
    }
    async getNetworkLinkById(id) {
        return this.networkLinks.get(id) ?? null;
    }
    async createNetworkLink(createDto) {
        const id = `link-${Date.now()}`;
        const link = {
            id,
            ...createDto,
            status: 'active',
            lastCheck: new Date(),
        };
        this.networkLinks.set(id, link);
        this.logger.log(`Created network link: ${id}`);
        return link;
    }
    async updateNetworkLink(id, updateDto) {
        const link = this.networkLinks.get(id);
        if (!link) {
            return null;
        }
        const updatedLink = {
            ...link,
            sourceDc: updateDto.sourceDc ?? link.sourceDc,
            targetDc: updateDto.targetDc ?? link.targetDc,
            type: updateDto.type ?? link.type,
            bandwidth: updateDto.bandwidth ?? link.bandwidth,
            latency: updateDto.latency ?? link.latency,
            provider: updateDto.provider ?? link.provider,
            lastCheck: new Date(),
        };
        this.networkLinks.set(id, updatedLink);
        this.logger.log(`Updated network link: ${id}`);
        return updatedLink;
    }
    async deleteNetworkLink(id) {
        const deleted = this.networkLinks.delete(id);
        if (deleted) {
            this.logger.log(`Deleted network link: ${id}`);
        }
        return deleted;
    }
    async checkLinkHealth(linkId) {
        const link = this.networkLinks.get(linkId);
        if (!link) {
            return null;
        }
        try {
            const health = await this.performHealthCheck(link);
            link.status = health.status;
            link.latency = health.latency;
            link.lastCheck = new Date();
            this.networkLinks.set(linkId, link);
            this.logLinkHealth(linkId, health);
            return health;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Health check failed for link ${linkId}: ${errorMessage}`);
            const health = {
                status: 'down',
                latency: -1,
                bandwidth: 0,
                error: errorMessage,
            };
            this.logLinkHealth(linkId, health);
            return health;
        }
    }
    async performHealthCheck(link) {
        const random = Math.random();
        let status;
        let latency;
        let bandwidth;
        if (random > 0.9) {
            status = 'down';
            latency = -1;
            bandwidth = 0;
        }
        else if (random > 0.7) {
            status = 'degraded';
            latency = link.latency * (1 + Math.random() * 2);
            bandwidth = link.bandwidth * (0.5 + Math.random() * 0.3);
        }
        else {
            status = 'active';
            latency = link.latency * (0.8 + Math.random() * 0.4);
            bandwidth = link.bandwidth * (0.9 + Math.random() * 0.2);
        }
        await this.delay(100);
        return {
            status,
            latency: Math.round(latency * 100) / 100,
            bandwidth: Math.round(bandwidth),
        };
    }
    logLinkHealth(linkId, health) {
        this.networkHistory.push({
            timestamp: new Date(),
            linkId,
            action: 'health_check',
            details: JSON.stringify(health),
            bandwidth: health.bandwidth,
            ...(health.error != null &&
                health.error !== '' && { error: health.error }),
        });
        if (this.networkHistory.length > 1000) {
            this.networkHistory.shift();
        }
    }
    async getLinkHealthHistory(linkId, limit = 100) {
        let history = this.networkHistory;
        if (linkId != null && linkId !== '') {
            history = history.filter(h => h.linkId === linkId);
        }
        return history.slice(-limit);
    }
    async getNetworkLinksStatistics() {
        const stats = {
            total: this.networkLinks.size,
            active: 0,
            degraded: 0,
            down: 0,
            averageLatency: 0,
            totalBandwidth: 0,
            providers: {},
        };
        let totalLatency = 0;
        let activeLinks = 0;
        for (const link of this.networkLinks.values()) {
            stats[link.status]++;
            stats.totalBandwidth += link.bandwidth;
            if (link.status !== 'down') {
                totalLatency += link.latency;
                activeLinks++;
            }
            stats.providers[link.provider] =
                (stats.providers[link.provider] ?? 0) + 1;
        }
        stats.averageLatency =
            activeLinks > 0
                ? Math.round((totalLatency / activeLinks) * 100) / 100
                : 0;
        return stats;
    }
    async findLinksByType(type) {
        return Array.from(this.networkLinks.values()).filter(link => link.type === type);
    }
    async findLinksByProvider(provider) {
        return Array.from(this.networkLinks.values()).filter(link => link.provider.toLowerCase().includes(provider.toLowerCase()));
    }
    async findLinksBetweenDCs(sourceDc, targetDc) {
        return Array.from(this.networkLinks.values()).filter(link => link.sourceDc === sourceDc && link.targetDc === targetDc);
    }
    async getAlternativeRoutes(sourceDc, targetDc) {
        const directLinks = await this.findLinksBetweenDCs(sourceDc, targetDc);
        if (directLinks.length === 0) {
            const intermediateRoutes = [];
            for (const link of this.networkLinks.values()) {
                if (link.sourceDc === sourceDc) {
                    const secondLink = Array.from(this.networkLinks.values()).find(l => l.sourceDc === link.targetDc && l.targetDc === targetDc);
                    if (secondLink) {
                        intermediateRoutes.push(link, secondLink);
                    }
                }
            }
            return intermediateRoutes;
        }
        return directLinks;
    }
    async testLinkBandwidth(linkId) {
        const link = this.networkLinks.get(linkId);
        if (!link) {
            throw new Error(`Network link ${linkId} not found`);
        }
        const measuredBandwidth = link.bandwidth * (0.7 + Math.random() * 0.6);
        const efficiency = (measuredBandwidth / link.bandwidth) * 100;
        let status;
        if (efficiency >= 95) {
            status = 'optimal';
        }
        else if (efficiency >= 80) {
            status = 'good';
        }
        else if (efficiency >= 60) {
            status = 'poor';
        }
        else {
            status = 'critical';
        }
        return {
            measuredBandwidth: Math.round(measuredBandwidth),
            expectedBandwidth: link.bandwidth,
            efficiency: Math.round(efficiency * 100) / 100,
            status,
        };
    }
    async startLinkMonitoring(linkId, intervalMs = 5000) {
        const link = this.networkLinks.get(linkId);
        if (!link) {
            return {
                success: false,
                message: `Network link ${linkId} not found`,
            };
        }
        this.logger.log(`Started monitoring for link ${linkId} with interval ${intervalMs}ms`);
        return {
            success: true,
            message: `Monitoring started for link ${linkId}`,
        };
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    manageNetworkLine(lineId) {
        return {
            id: lineId,
            status: 'active',
            bandwidth: 10000,
            latency: 5,
        };
    }
    checkNetworkHealth(lineId) {
        return {
            lineId,
            status: 'healthy',
            bandwidth: 10000,
            latency: 5,
        };
    }
    configureAlternativeRoutes(config) {
        return {
            primaryLineId: config.primaryLineId,
            alternativeRoutes: config.backupLineIds,
            status: 'configured',
        };
    }
    performNetworkFailover(lineId) {
        return {
            lineId,
            status: 'success',
            duration: 5000,
        };
    }
};
NetworkResilienceService = NetworkResilienceService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], NetworkResilienceService);



/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeographicRoutingService: () => (/* binding */ GeographicRoutingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var GeographicRoutingService_1;

let GeographicRoutingService = GeographicRoutingService_1 = class GeographicRoutingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(GeographicRoutingService_1.name);
        this.routes = new Map();
        this.dataCenters = new Map();
        this.routingHistory = [];
        this.initializeDefaultRoutes();
    }
    initializeDefaultRoutes() {
        const defaultRoutes = [
            {
                id: 'route-minsk-users',
                userLocation: {
                    country: 'BY',
                    region: 'Minsk',
                    city: 'Minsk',
                    coordinates: { latitude: 53.9045, longitude: 27.5615 },
                },
                targetDc: 'dc-minsk-primary',
                routingStrategy: 'nearest',
                metrics: { latency: 1, bandwidth: 10000, cost: 0.1 },
                lastUpdated: new Date(),
            },
            {
                id: 'route-moscow-users',
                userLocation: {
                    country: 'RU',
                    region: 'Moscow',
                    city: 'Moscow',
                    coordinates: { latitude: 55.7558, longitude: 37.6176 },
                },
                targetDc: 'dc-moscow-primary',
                routingStrategy: 'nearest',
                metrics: { latency: 1, bandwidth: 12000, cost: 0.15 },
                lastUpdated: new Date(),
            },
            {
                id: 'route-st-petersburg-users',
                userLocation: {
                    country: 'RU',
                    region: 'Saint Petersburg',
                    city: 'Saint Petersburg',
                    coordinates: { latitude: 59.9311, longitude: 30.3609 },
                },
                targetDc: 'dc-moscow-primary',
                routingStrategy: 'lowest-latency',
                metrics: { latency: 8, bandwidth: 8000, cost: 0.2 },
                lastUpdated: new Date(),
            },
            {
                id: 'route-gomel-users',
                userLocation: {
                    country: 'BY',
                    region: 'Gomel',
                    city: 'Gomel',
                    coordinates: { latitude: 52.4412, longitude: 30.9878 },
                },
                targetDc: 'dc-minsk-primary',
                routingStrategy: 'nearest',
                metrics: { latency: 3, bandwidth: 6000, cost: 0.12 },
                lastUpdated: new Date(),
            },
        ];
        defaultRoutes.forEach(route => this.routes.set(route.id, route));
        this.logger.log(`Initialized ${defaultRoutes.length} default geographic routes`);
    }
    async getAllRoutes() {
        return Array.from(this.routes.values());
    }
    async getRouteById(id) {
        return this.routes.get(id) ?? null;
    }
    async createRoute(createDto) {
        const id = `route-${Date.now()}`;
        const route = {
            id,
            userLocation: createDto.userLocation,
            targetDc: createDto.targetDc,
            routingStrategy: createDto.routingStrategy,
            metrics: createDto.metrics ?? {
                latency: 0,
                bandwidth: 0,
                cost: 0,
            },
            lastUpdated: new Date(),
        };
        this.routes.set(id, route);
        this.logger.log(`Created geographic route: ${id}`);
        return route;
    }
    async updateRoute(id, updateDto) {
        const route = this.routes.get(id);
        if (!route) {
            return null;
        }
        const updatedRoute = {
            ...route,
            userLocation: updateDto.userLocation ?? route.userLocation,
            targetDc: updateDto.targetDc ?? route.targetDc,
            routingStrategy: updateDto.routingStrategy ?? route.routingStrategy,
            metrics: updateDto.metrics ?? route.metrics,
            lastUpdated: new Date(),
        };
        this.routes.set(id, updatedRoute);
        this.logger.log(`Updated geographic route: ${id}`);
        return updatedRoute;
    }
    async deleteRoute(id) {
        const deleted = this.routes.delete(id);
        if (deleted) {
            this.logger.log(`Deleted geographic route: ${id}`);
        }
        return deleted;
    }
    async determineOptimalDataCenter(userLocation, strategy, availableDCs) {
        const startTime = Date.now();
        if (!availableDCs || availableDCs.length === 0) {
            availableDCs = Array.from(this.dataCenters.values());
        }
        if (availableDCs.length === 0) {
            this.logger.warn('No available data centers for routing');
            return null;
        }
        let selectedDc = null;
        let route = null;
        switch (strategy) {
            case 'nearest':
                selectedDc = this.findNearestDataCenter(userLocation, availableDCs);
                break;
            case 'lowest-latency':
                selectedDc = this.findLowestLatencyDataCenter(userLocation, availableDCs);
                break;
            case 'least-loaded':
                selectedDc = this.findLeastLoadedDataCenter(userLocation, availableDCs);
                break;
            case 'cost-optimized':
                selectedDc = this.findCostOptimizedDataCenter(userLocation, availableDCs);
                break;
            default:
                selectedDc = this.findNearestDataCenter(userLocation, availableDCs);
        }
        if (!selectedDc) {
            this.logger.warn('Could not determine optimal data center');
            return null;
        }
        route = await this.createOptimalRoute(userLocation, selectedDc.id, strategy);
        const processingTime = Date.now() - startTime;
        this.logRoutingDecision(userLocation, selectedDc.id, strategy, processingTime);
        return {
            selectedDc: selectedDc.id,
            route,
            metrics: {
                latency: 0,
                bandwidth: 0,
                cost: 0,
            },
            processingTime,
        };
    }
    async createOptimalRoute(userLocation, dcId, strategy) {
        const dc = await this.getDataCenterById(dcId);
        if (!dc) {
            throw new Error(`Data center ${dcId} not found`);
        }
        const metrics = await this.calculateMetrics(userLocation, dc);
        return {
            id: `route-${Date.now()}`,
            userLocation,
            targetDc: dcId,
            routingStrategy: strategy,
            metrics,
            lastUpdated: new Date(),
        };
    }
    findNearestDataCenter(userLocation, availableDCs) {
        if (availableDCs.length === 0)
            return null;
        let nearestDc = null;
        let minDistance = Infinity;
        for (const dc of availableDCs) {
            const distance = this.calculateDistance(userLocation.coordinates.latitude, userLocation.coordinates.longitude, dc.coordinates.latitude, dc.coordinates.longitude);
            if (distance < minDistance) {
                minDistance = distance;
                nearestDc = dc;
            }
        }
        return nearestDc;
    }
    findLowestLatencyDataCenter(userLocation, availableDCs) {
        if (availableDCs.length === 0)
            return null;
        let lowestLatencyDc = null;
        let minLatency = Infinity;
        for (const dc of availableDCs) {
            const distance = this.calculateDistance(userLocation.coordinates.latitude, userLocation.coordinates.longitude, dc.coordinates.latitude, dc.coordinates.longitude);
            const estimatedLatency = distance * 0.1;
            if (estimatedLatency < minLatency) {
                minLatency = estimatedLatency;
                lowestLatencyDc = dc;
            }
        }
        return lowestLatencyDc;
    }
    findLeastLoadedDataCenter(_userLocation, availableDCs) {
        if (availableDCs.length === 0)
            return null;
        let leastLoadedDc = null;
        let minLoad = Infinity;
        for (const dc of availableDCs) {
            const load = dc.status === 'active' ? 0 : dc.status === 'maintenance' ? 50 : 100;
            if (load < minLoad) {
                minLoad = load;
                leastLoadedDc = dc;
            }
        }
        return leastLoadedDc;
    }
    findCostOptimizedDataCenter(_userLocation, availableDCs) {
        if (availableDCs.length === 0)
            return null;
        let costOptimizedDc = null;
        let minCost = Infinity;
        for (const dc of availableDCs) {
            const cost = dc.country === 'BY' ? 1 : dc.country === 'RU' ? 1.2 : 1.5;
            if (cost < minCost) {
                minCost = cost;
                costOptimizedDc = dc;
            }
        }
        return costOptimizedDc;
    }
    async calculateMetrics(userLocation, dc) {
        const distance = this.calculateDistance(userLocation.coordinates.latitude, userLocation.coordinates.longitude, dc.coordinates.latitude, dc.coordinates.longitude);
        const latency = Math.max(1, Math.round(distance / 100) + 1);
        const bandwidth = Math.max(1000, 10000 - distance * 10);
        const cost = dc.country === 'BY' ? 0.1 + distance * 0.0005 : 0.15 + distance * 0.0008;
        return {
            latency,
            bandwidth: Math.round(bandwidth),
            cost: Math.round(cost * 1000) / 1000,
        };
    }
    async getDataCenterById(id) {
        return this.dataCenters.get(id) ?? null;
    }
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = this.toRadians(lat2 - lat1);
        const dLon = this.toRadians(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this.toRadians(lat1)) *
                Math.cos(this.toRadians(lat2)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
    logRoutingDecision(userLocation, _selectedDc, routingStrategy, processingTime) {
        this.routingHistory.push({
            timestamp: new Date(),
            userId: `user-${Date.now()}`,
            userLocation,
            routingStrategy,
            metrics: { latency: 0, bandwidth: 0, cost: 0 },
            processingTime,
        });
        if (this.routingHistory.length > 1000) {
            this.routingHistory.shift();
        }
    }
    async getRoutingHistory(limit = 100) {
        return this.routingHistory.slice(-limit);
    }
    async getRoutingStatistics() {
        const stats = {
            totalRoutes: this.routingHistory.length,
            averageProcessingTime: 0,
            strategyUsage: {},
            countryDistribution: {},
            averageLatency: 0,
            averageBandwidth: 0,
            averageCost: 0,
        };
        if (this.routingHistory.length === 0) {
            return stats;
        }
        let totalProcessingTime = 0;
        let totalLatency = 0;
        let totalBandwidth = 0;
        let totalCost = 0;
        for (const route of this.routingHistory) {
            totalProcessingTime += route.processingTime;
            totalLatency += route.metrics.latency;
            totalBandwidth += route.metrics.bandwidth;
            totalCost += route.metrics.cost;
            stats.strategyUsage[route.routingStrategy] =
                (stats.strategyUsage[route.routingStrategy] ?? 0) + 1;
            stats.countryDistribution[route.userLocation.country] =
                (stats.countryDistribution[route.userLocation.country] ?? 0) + 1;
        }
        stats.averageProcessingTime = Math.round(totalProcessingTime / this.routingHistory.length);
        stats.averageLatency = Math.round(totalLatency / this.routingHistory.length);
        stats.averageBandwidth = Math.round(totalBandwidth / this.routingHistory.length);
        stats.averageCost =
            Math.round((totalCost / this.routingHistory.length) * 1000) / 1000;
        return stats;
    }
    async findRoutesByCountry(country) {
        return Array.from(this.routes.values()).filter(route => route.userLocation.country.toLowerCase() === country.toLowerCase());
    }
    async findRoutesByRegion(region) {
        return Array.from(this.routes.values()).filter(route => route.userLocation.region.toLowerCase().includes(region.toLowerCase()));
    }
    async findRoutesByStrategy(strategy) {
        return Array.from(this.routes.values()).filter(route => route.routingStrategy === strategy);
    }
    determineOptimalDatacenter(userLocation) {
        return {
            country: userLocation.country,
            region: userLocation.region,
            datacenterId: `dc-${userLocation.country.toLowerCase()}-primary`,
            latency: 5,
        };
    }
    configureRoutingStrategies(config) {
        return {
            country: config.country,
            region: config.region,
            strategy: 'nearest',
            weights: {
                latency: config.latencyWeight,
                cost: config.costWeight,
                bandwidth: config.bandwidthWeight,
            },
        };
    }
    performGeographicRouting(userLocation) {
        return {
            country: userLocation.country,
            region: userLocation.region,
            targetDatacenter: `dc-${userLocation.country.toLowerCase()}-primary`,
            route: [
                `user-${userLocation.country}`,
                `dc-${userLocation.country.toLowerCase()}-primary`,
            ],
            estimatedLatency: 5,
        };
    }
    getRoutingMetrics(datacenterId) {
        return {
            datacenterId,
            latency: 5,
            bandwidth: 10000,
            cost: 0.1,
            uptime: 99.9,
        };
    }
};
GeographicRoutingService = GeographicRoutingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], GeographicRoutingService);



/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentResponseService: () => (/* binding */ IncidentResponseService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var IncidentResponseService_1;

let IncidentResponseService = IncidentResponseService_1 = class IncidentResponseService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(IncidentResponseService_1.name);
        this.incidents = new Map();
        this.incidentHistory = [];
        this.initializeDefaultIncidents();
    }
    initializeDefaultIncidents() {
        const defaultIncidents = [
            {
                id: 'incident-power-outage-minsk',
                type: 'power-outage',
                severity: 'high',
                affectedDcs: ['dc-minsk-primary', 'dc-minsk-secondary'],
                description: 'Отключение электроснабжения в дата-центре Минск',
                detectedAt: new Date(),
                status: 'resolved',
                actions: [
                    {
                        id: 'action-1',
                        description: 'Автоматическое переключение на резервный источник питания',
                        type: 'automatic',
                        status: 'completed',
                        startedAt: new Date(),
                        completedAt: new Date(),
                        result: 'Успешно переключено на UPS',
                    },
                ],
                playbook: 'power-outage-response',
            },
            {
                id: 'incident-network-failure-moscow',
                type: 'network-failure',
                severity: 'medium',
                affectedDcs: ['dc-moscow-primary'],
                description: 'Сбой сетевого оборудования в дата-центре Москва',
                detectedAt: new Date(),
                status: 'responding',
                actions: [
                    {
                        id: 'action-2',
                        description: 'Переключение на резервный канал связи',
                        type: 'automatic',
                        status: 'in-progress',
                        startedAt: new Date(),
                    },
                ],
                playbook: 'network-failure-response',
            },
        ];
        defaultIncidents.forEach(incident => this.incidents.set(incident.id, incident));
        this.logger.log(`Initialized ${defaultIncidents.length} default incidents`);
    }
    async getAllIncidents() {
        return Array.from(this.incidents.values());
    }
    async getIncidentById(id) {
        return this.incidents.get(id) ?? null;
    }
    async createIncident(createDto) {
        const id = `incident-${Date.now()}`;
        const incident = {
            id,
            type: createDto.type,
            severity: createDto.severity,
            affectedDcs: createDto.affectedDcs,
            description: createDto.description,
            detectedAt: new Date(),
            status: 'detected',
            actions: [],
            playbook: createDto.playbook,
        };
        this.incidents.set(id, incident);
        this.logger.log(`Created incident: ${id}`);
        this.logIncidentAction(id, 'created', `Incident created: ${createDto.type}`);
        return incident;
    }
    async updateIncident(id, updateDto) {
        const incident = this.incidents.get(id);
        if (!incident) {
            return null;
        }
        const updatedIncident = {
            ...incident,
            type: updateDto.type ?? incident.type,
            severity: updateDto.severity ?? incident.severity,
            affectedDcs: updateDto.affectedDcs ?? incident.affectedDcs,
            description: updateDto.description ?? incident.description,
            status: updateDto.status ?? incident.status,
            playbook: updateDto.playbook ?? incident.playbook,
        };
        this.incidents.set(id, updatedIncident);
        this.logger.log(`Updated incident: ${id}`);
        this.logIncidentAction(id, 'updated', `Incident updated: ${updateDto.type ?? incident.type}`);
        return updatedIncident;
    }
    async deleteIncident(id) {
        const deleted = this.incidents.delete(id);
        if (deleted) {
            this.logger.log(`Deleted incident: ${id}`);
            this.logIncidentAction(id, 'deleted', 'Incident deleted');
        }
        return deleted;
    }
    async addActionToIncident(incidentId, action) {
        const incident = this.incidents.get(incidentId);
        if (!incident) {
            return null;
        }
        const newAction = {
            id: `action-${Date.now()}`,
            ...action,
        };
        incident.actions.push(newAction);
        this.incidents.set(incidentId, incident);
        this.logger.log(`Added action to incident ${incidentId}: ${action.description}`);
        this.logIncidentAction(incidentId, 'action-added', `Action added: ${action.description}`);
        return newAction;
    }
    async updateActionStatus(incidentId, actionId, status, result, error) {
        const incident = this.incidents.get(incidentId);
        if (!incident) {
            return null;
        }
        const action = incident.actions.find(a => a.id === actionId);
        if (!action) {
            return null;
        }
        action.status = status;
        if (status === 'in-progress' && !action.startedAt) {
            action.startedAt = new Date();
        }
        else if (status === 'completed' && !action.completedAt) {
            action.completedAt = new Date();
        }
        if (result != null && result !== '') {
            action.result = result;
        }
        if (error != null && error !== '') {
            action.error = error;
        }
        this.incidents.set(incidentId, incident);
        this.logger.log(`Updated action status in incident ${incidentId}: ${actionId} -> ${status}`);
        this.logIncidentAction(incidentId, 'action-updated', `Action ${actionId} status updated to ${status}`);
        return action;
    }
    async executeRecoveryProcedures(incidentId) {
        const incident = this.incidents.get(incidentId);
        if (!incident) {
            return {
                success: false,
                actionsExecuted: 0,
                totalActions: 0,
                errors: ['Incident not found'],
            };
        }
        if (incident.status === 'resolved') {
            return {
                success: true,
                actionsExecuted: 0,
                totalActions: 0,
                errors: ['Incident already resolved'],
            };
        }
        this.logger.log(`Executing recovery procedures for incident: ${incidentId}`);
        const errors = [];
        let actionsExecuted = 0;
        const totalActions = incident.actions.length;
        for (const action of incident.actions) {
            if (action.type === 'automatic' && action.status === 'pending') {
                try {
                    await this.executeAction(action);
                    await this.updateActionStatus(incidentId, action.id, 'completed', 'Action executed successfully');
                    actionsExecuted++;
                }
                catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                    await this.updateActionStatus(incidentId, action.id, 'failed', undefined, errorMessage);
                    errors.push(`Action ${action.id}: ${errorMessage}`);
                }
            }
        }
        const allActionsCompleted = incident.actions.every(action => action.status === 'completed');
        if (allActionsCompleted) {
            incident.status = 'resolved';
            incident.resolvedAt = new Date();
            this.incidents.set(incidentId, incident);
            this.logIncidentAction(incidentId, 'resolved', 'All recovery procedures completed');
        }
        const success = errors.length === 0;
        return {
            success,
            actionsExecuted,
            totalActions,
            errors,
        };
    }
    async executeAction(action) {
        this.logger.log(`Executing action: ${action.description}`);
        await this.delay(1000 + Math.random() * 2000);
        this.logger.log(`Action completed: ${action.description}`);
    }
    async findIncidentsByType(type) {
        return Array.from(this.incidents.values()).filter(incident => incident.type === type);
    }
    async findIncidentsBySeverity(severity) {
        return Array.from(this.incidents.values()).filter(incident => incident.severity === severity);
    }
    async findIncidentsByStatus(status) {
        return Array.from(this.incidents.values()).filter(incident => incident.status === status);
    }
    async getActiveIncidents() {
        return Array.from(this.incidents.values()).filter(incident => incident.status !== 'resolved');
    }
    async getIncidentHistory(limit = 100) {
        return this.incidentHistory.slice(-limit);
    }
    async getIncidentStatistics() {
        const incidents = Array.from(this.incidents.values());
        const totalIncidents = incidents.length;
        const activeIncidents = incidents.filter(incident => incident.status === 'detected' || incident.status === 'responding').length;
        const resolvedIncidents = incidents.filter(incident => incident.status === 'resolved').length;
        const incidentsByType = {};
        const incidentsBySeverity = {};
        incidents.forEach(incident => {
            incidentsByType[incident.type] =
                (incidentsByType[incident.type] ?? 0) + 1;
            incidentsBySeverity[incident.severity] =
                (incidentsBySeverity[incident.severity] ?? 0) + 1;
        });
        const resolvedIncidentTimes = incidents
            .filter(incident => incident.status === 'resolved' && incident.resolvedAt != null)
            .map(incident => {
            if (incident.resolvedAt == null)
                return 0;
            return incident.resolvedAt.getTime() - incident.detectedAt.getTime();
        })
            .filter(time => time > 0);
        const averageResolutionTime = resolvedIncidentTimes.length > 0
            ? resolvedIncidentTimes.reduce((sum, time) => sum + time, 0) / resolvedIncidentTimes.length
            : 0;
        const lastIncident = incidents.length > 0
            ? new Date(Math.max(...incidents.map(i => i.detectedAt.getTime())))
            : undefined;
        return {
            totalIncidents,
            activeIncidents,
            resolvedIncidents,
            incidentsByType,
            incidentsBySeverity,
            averageResolutionTime,
            ...(lastIncident && { lastIncident }),
        };
    }
    logIncidentAction(incidentId, action, details) {
        this.incidentHistory.push({
            timestamp: new Date(),
            incidentId,
            action,
            details,
            result: '',
        });
        if (this.incidentHistory.length > 1000) {
            this.incidentHistory.shift();
        }
    }
    delay(ms) {
        return new Promise(resolve => globalThis.setTimeout(resolve, ms));
    }
    manageIncident(config) {
        const incidentId = `incident-${Date.now()}`;
        return {
            incidentId,
            type: config.type,
            severity: config.severity,
            status: 'detected',
        };
    }
    createRecoveryPlan(incidentId) {
        return {
            incidentId,
            planId: `plan-${Date.now()}`,
            steps: ['Analyze incident', 'Implement solution', 'Verify recovery'],
            estimatedTime: 30,
        };
    }
    executeRecoveryPlan(planId) {
        return {
            planId,
            status: 'completed',
            progress: 100,
        };
    }
    escalateIncident(incidentId) {
        return {
            incidentId,
            status: 'escalated',
            escalationLevel: 2,
        };
    }
};
IncidentResponseService = IncidentResponseService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], IncidentResponseService);



/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CapacityPlanningService: () => (/* binding */ CapacityPlanningService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CapacityPlanningService_1;

let CapacityPlanningService = CapacityPlanningService_1 = class CapacityPlanningService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CapacityPlanningService_1.name);
        this.capacityPlans = new Map();
        this.scalingActions = new Map();
        this.initializeDefaultCapacityPlans();
    }
    initializeDefaultCapacityPlans() {
        const defaultPlans = [
            {
                id: 'plan-minsk-primary-q1-2024',
                dcId: 'dc-minsk-primary',
                period: {
                    start: new Date('2024-01-01'),
                    end: new Date('2024-03-31'),
                },
                currentCapacity: {
                    cpu: 1000,
                    memory: 8192,
                    storage: 100000,
                    network: 10000,
                },
                projectedDemand: {
                    cpu: 1200,
                    memory: 10240,
                    storage: 120000,
                    network: 12000,
                },
                scalingActions: [
                    {
                        id: 'action-1',
                        type: 'scale-up',
                        resource: 'cpu',
                        amount: 200,
                        priority: 'high',
                        estimatedCost: 5000,
                        implementationDate: new Date('2024-02-01'),
                        status: 'planned',
                    },
                ],
                status: 'approved',
            },
            {
                id: 'plan-moscow-primary-q1-2024',
                dcId: 'dc-moscow-primary',
                period: {
                    start: new Date('2024-01-01'),
                    end: new Date('2024-03-31'),
                },
                currentCapacity: {
                    cpu: 1200,
                    memory: 10240,
                    storage: 120000,
                    network: 12000,
                },
                projectedDemand: {
                    cpu: 1500,
                    memory: 12288,
                    storage: 150000,
                    network: 15000,
                },
                scalingActions: [
                    {
                        id: 'action-2',
                        type: 'scale-out',
                        resource: 'storage',
                        amount: 30000,
                        priority: 'medium',
                        estimatedCost: 8000,
                        implementationDate: new Date('2024-02-15'),
                        status: 'planned',
                    },
                ],
                status: 'draft',
            },
        ];
        defaultPlans.forEach(plan => this.capacityPlans.set(plan.id, plan));
        this.logger.log(`Initialized ${defaultPlans.length} default capacity plans`);
    }
    async getAllCapacityPlans() {
        return Array.from(this.capacityPlans.values());
    }
    async getCapacityPlanById(id) {
        return this.capacityPlans.get(id) ?? null;
    }
    async createCapacityPlan(createDto) {
        const id = `plan-${Date.now()}`;
        const plan = {
            id,
            dcId: createDto.dcId,
            period: createDto.period,
            currentCapacity: createDto.currentCapacity,
            projectedDemand: createDto.projectedDemand,
            scalingActions: [],
            status: 'draft',
        };
        this.capacityPlans.set(id, plan);
        this.logger.log(`Created capacity plan: ${id}`);
        return plan;
    }
    async updateCapacityPlan(id, updateDto) {
        const plan = this.capacityPlans.get(id);
        if (!plan) {
            return null;
        }
        const updatedPlan = {
            ...plan,
            dcId: updateDto.dcId ?? plan.dcId,
            period: updateDto.period ?? plan.period,
            currentCapacity: updateDto.currentCapacity ?? plan.currentCapacity,
            projectedDemand: updateDto.projectedDemand ?? plan.projectedDemand,
            status: updateDto.status ?? plan.status,
        };
        this.capacityPlans.set(id, updatedPlan);
        this.logger.log(`Updated capacity plan: ${id}`);
        return updatedPlan;
    }
    async deleteCapacityPlan(id) {
        const deleted = this.capacityPlans.delete(id);
        if (deleted) {
            this.logger.log(`Deleted capacity plan: ${id}`);
        }
        return deleted;
    }
    async addScalingAction(planId, action) {
        const plan = this.capacityPlans.get(planId);
        if (!plan) {
            return null;
        }
        const newAction = {
            id: `action-${Date.now()}`,
            ...action,
        };
        plan.scalingActions.push(newAction);
        this.capacityPlans.set(planId, plan);
        this.logger.log(`Added scaling action to plan ${planId}: ${action.type} ${action.resource}`);
        return newAction;
    }
    async updateScalingActionStatus(planId, actionId, status) {
        const plan = this.capacityPlans.get(planId);
        if (!plan) {
            return null;
        }
        const action = plan.scalingActions.find(a => a.id === actionId);
        if (!action) {
            return null;
        }
        action.status = status;
        this.capacityPlans.set(planId, plan);
        this.logger.log(`Updated scaling action status in plan ${planId}: ${actionId} -> ${status}`);
        return action;
    }
    async analyzeCapacityNeeds(dcId) {
        this.logger.log(`Analyzing capacity needs for DC: ${dcId}`);
        const currentCapacity = {
            cpu: 1000,
            memory: 8192,
            storage: 100000,
            network: 10000,
        };
        const projectedDemand = {
            cpu: Math.round(currentCapacity.cpu * (1 + Math.random() * 0.5)),
            memory: Math.round(currentCapacity.memory * (1 + Math.random() * 0.3)),
            storage: Math.round(currentCapacity.storage * (1 + Math.random() * 0.4)),
            network: Math.round(currentCapacity.network * (1 + Math.random() * 0.2)),
        };
        const capacityGap = {
            cpu: Math.max(0, projectedDemand.cpu - currentCapacity.cpu),
            memory: Math.max(0, projectedDemand.memory - currentCapacity.memory),
            storage: Math.max(0, projectedDemand.storage - currentCapacity.storage),
            network: Math.max(0, projectedDemand.network - currentCapacity.network),
        };
        const recommendations = [];
        if (capacityGap.cpu > 0) {
            recommendations.push({
                resource: 'cpu',
                action: 'scale-up',
                amount: capacityGap.cpu,
                priority: (capacityGap.cpu > 200
                    ? 'critical'
                    : capacityGap.cpu > 100
                        ? 'high'
                        : 'medium'),
                estimatedCost: capacityGap.cpu * 25,
            });
        }
        if (capacityGap.memory > 0) {
            recommendations.push({
                resource: 'memory',
                action: 'scale-up',
                amount: capacityGap.memory,
                priority: (capacityGap.memory > 2048
                    ? 'critical'
                    : capacityGap.memory > 100
                        ? 'high'
                        : 'medium'),
                estimatedCost: capacityGap.memory * 2,
            });
        }
        if (capacityGap.storage > 0) {
            recommendations.push({
                resource: 'storage',
                action: 'scale-out',
                amount: capacityGap.storage,
                priority: (capacityGap.storage > 50000
                    ? 'critical'
                    : capacityGap.storage > 25000
                        ? 'high'
                        : 'medium'),
                estimatedCost: capacityGap.storage * 0.1,
            });
        }
        if (capacityGap.network > 0) {
            recommendations.push({
                resource: 'network',
                action: 'scale-up',
                amount: capacityGap.network,
                priority: (capacityGap.network > 5000
                    ? 'critical'
                    : capacityGap.network > 2500
                        ? 'high'
                        : 'medium'),
                estimatedCost: capacityGap.network * 0.5,
            });
        }
        return {
            currentCapacity,
            projectedDemand,
            capacityGap,
            recommendations: recommendations.map(rec => ({
                ...rec,
                _resource: rec.resource,
            })),
        };
    }
    async performStressTest(dcId, testScenario) {
        this.logger.log(`Performing stress test for DC: ${dcId} with scenario: ${JSON.stringify(testScenario)}`);
        const startTime = Date.now();
        const duration = testScenario.duration;
        await this.delay(Math.min(duration * 1000, 100));
        const testDuration = Date.now() - startTime;
        const results = {
            cpu: {
                maxUsage: Math.min(100, testScenario.cpuLoad * (1 + Math.random() * 0.2)),
                averageUsage: testScenario.cpuLoad,
                bottlenecks: testScenario.cpuLoad > 80 ? ['CPU utilization exceeded 80%'] : [],
            },
            memory: {
                maxUsage: Math.min(100, testScenario.memoryLoad * (1 + Math.random() * 0.15)),
                averageUsage: testScenario.memoryLoad,
                bottlenecks: testScenario.memoryLoad > 85
                    ? ['Memory usage approaching limits']
                    : [],
            },
            storage: {
                maxUsage: Math.min(100, testScenario.storageLoad * (1 + Math.random() * 0.1)),
                averageUsage: testScenario.storageLoad,
                bottlenecks: testScenario.storageLoad > 90 ? ['Storage capacity critical'] : [],
            },
            network: {
                maxUsage: Math.min(100, testScenario.networkLoad * (1 + Math.random() * 0.25)),
                averageUsage: testScenario.networkLoad,
                bottlenecks: testScenario.networkLoad > 75
                    ? ['Network bandwidth constraints']
                    : [],
            },
        };
        const recommendations = [];
        if (results.cpu.maxUsage > 90) {
            recommendations.push('Critical: Immediate CPU scaling required');
        }
        else if (results.cpu.maxUsage > 80) {
            recommendations.push('High: Plan CPU scaling within 1 month');
        }
        if (results.memory.maxUsage > 95) {
            recommendations.push('Critical: Immediate memory scaling required');
        }
        else if (results.memory.maxUsage > 85) {
            recommendations.push('High: Plan memory scaling within 2 weeks');
        }
        if (results.storage.maxUsage > 95) {
            recommendations.push('Critical: Immediate storage scaling required');
        }
        else if (results.storage.maxUsage > 90) {
            recommendations.push('High: Plan storage scaling within 1 month');
        }
        if (results.network.maxUsage > 90) {
            recommendations.push('Critical: Immediate network scaling required');
        }
        else if (results.network.maxUsage > 75) {
            recommendations.push('Medium: Monitor network usage and plan scaling');
        }
        const success = recommendations.filter(r => r.includes('Critical')).length === 0;
        return {
            success,
            results,
            recommendations,
            testDuration,
        };
    }
    async findPlansByDataCenter(dcId) {
        return Array.from(this.capacityPlans.values()).filter(plan => plan.dcId === dcId);
    }
    async findPlansByStatus(status) {
        return Array.from(this.capacityPlans.values()).filter(plan => plan.status === status);
    }
    async findPlansByPeriod(start, end) {
        return Array.from(this.capacityPlans.values()).filter(plan => plan.period.start >= start && plan.period.end <= end);
    }
    async getScalingHistory() {
        return [];
    }
    analyzeCurrentCapacity(datacenterId) {
        return {
            datacenterId,
            cpu: 1000,
            memory: 8192,
            storage: 100000,
            network: 10000,
        };
    }
    createScalingPlan(datacenterId) {
        return {
            datacenterId,
            recommendations: ['Scale CPU by 200 units', 'Add 2TB storage'],
            priority: 'short_term',
        };
    }
    setPerformanceBaseline(datacenterId, metrics) {
        return {
            datacenterId,
            ...metrics,
        };
    }
    async getCapacityPlanningStatistics() {
        const plans = Array.from(this.capacityPlans.values());
        const actions = Array.from(this.scalingActions.values());
        const totalPlans = plans.length;
        const draftPlans = plans.filter(plan => plan.status === 'draft').length;
        const approvedPlans = plans.filter(plan => plan.status === 'approved').length;
        const implementedPlans = plans.filter(plan => plan.status === 'implemented').length;
        const reviewedPlans = plans.filter(plan => plan.status === 'reviewed').length;
        const totalScalingActions = actions.length;
        const totalCost = plans.reduce((sum, plan) => {
            const planCost = plan.scalingActions.reduce((actionSum, action) => actionSum + action.estimatedCost, 0);
            return sum + planCost;
        }, 0);
        const averageCostPerPlan = totalPlans > 0 ? totalCost / totalPlans : 0;
        const lastUpdated = plans.length > 0
            ? new Date(Math.max(...plans.map(p => p.period.end.getTime())))
            : undefined;
        return {
            totalPlans,
            draftPlans,
            approvedPlans,
            implementedPlans,
            reviewedPlans,
            totalScalingActions,
            averageCostPerPlan,
            ...(lastUpdated && { lastUpdated }),
        };
    }
    delay(ms) {
        return new Promise(resolve => globalThis.setTimeout(resolve, ms));
    }
};
CapacityPlanningService = CapacityPlanningService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CapacityPlanningService);



/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A1IctServicesService: () => (/* binding */ A1IctServicesService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var A1IctServicesService_1;

let A1IctServicesService = A1IctServicesService_1 = class A1IctServicesService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(A1IctServicesService_1.name);
        this.services = new Map();
        this.serviceRequests = new Map();
        this.serviceHistory = [];
        this.initializeDefaultServices();
        this.logger.log(`Initialized ${this.services.size} default A1 ICT services`);
    }
    initializeDefaultServices() {
        const draasService = {
            id: 'draas-001',
            name: 'DRaaS Premium Service',
            type: 'DRaaS',
            dcId: 'dc-001',
            configuration: {
                sla: 99.99,
                backupRetention: 30,
                recoveryTime: 4,
                replicationFrequency: 15,
            },
            status: 'active',
            cost: 5000,
            contractEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        };
        const baasService = {
            id: 'baas-001',
            name: 'BaaS Enterprise Service',
            type: 'BaaS',
            dcId: 'dc-002',
            configuration: {
                sla: 99.9,
                backupRetention: 90,
                recoveryTime: 8,
                replicationFrequency: 30,
            },
            status: 'active',
            cost: 3000,
            contractEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        };
        const tier3Service = {
            id: 'tier3-001',
            name: 'Tier III Data Center Service',
            type: 'TierIII-DC',
            dcId: 'dc-003',
            configuration: {
                sla: 99.982,
                backupRetention: 60,
                recoveryTime: 2,
                replicationFrequency: 10,
            },
            status: 'active',
            cost: 8000,
            contractEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        };
        this.services.set(draasService.id, draasService);
        this.services.set(baasService.id, baasService);
        this.services.set(tier3Service.id, tier3Service);
    }
    async getAllServices() {
        return Array.from(this.services.values());
    }
    async getServiceById(id) {
        return this.services.get(id) ?? null;
    }
    async createService(createDto) {
        const id = `service-${Date.now()}`;
        const service = {
            id,
            name: createDto.name ?? `Service ${id}`,
            type: createDto.type,
            dcId: createDto.dcId,
            configuration: createDto.configuration,
            status: createDto.status ?? 'active',
            cost: createDto.cost,
            contractEndDate: createDto.contractEndDate,
        };
        this.services.set(id, service);
        this.logger.log(`Created A1 ICT service: ${id}`);
        return service;
    }
    async updateService(id, updateDto) {
        const service = this.services.get(id);
        if (!service) {
            return null;
        }
        const updatedService = {
            ...service,
            name: updateDto.name ?? service.name,
            type: updateDto.type ?? service.type,
            dcId: updateDto.dcId ?? service.dcId,
            configuration: updateDto.configuration ?? service.configuration,
            status: updateDto.status ?? service.status,
            cost: updateDto.cost ?? service.cost,
            contractEndDate: updateDto.contractEndDate ?? service.contractEndDate,
        };
        this.services.set(id, updatedService);
        this.logger.log(`Updated A1 ICT service: ${id}`);
        return updatedService;
    }
    async deleteService(id) {
        const deleted = this.services.delete(id);
        if (deleted) {
            this.logger.log(`Deleted A1 ICT service: ${id}`);
        }
        return deleted;
    }
    async createServiceRequest(serviceId, request) {
        const service = this.services.get(serviceId);
        if (!service) {
            return null;
        }
        const serviceRequest = {
            id: `request-${Date.now()}`,
            serviceType: request.serviceType,
            dcId: request.dcId,
            configuration: request.configuration,
            cost: request.cost,
            contractEndDate: request.contractEndDate,
            status: 'pending',
            requestedAt: new Date(),
        };
        this.serviceRequests.set(serviceRequest.id, serviceRequest);
        this.logger.log(`Created service request: ${serviceRequest.id} for service: ${serviceId}`);
        return serviceRequest;
    }
    async updateServiceRequestStatus(requestId, status, notes) {
        const request = this.serviceRequests.get(requestId);
        if (!request) {
            return null;
        }
        request.status = status;
        if (notes != null) {
            request.notes = notes;
        }
        if (status === 'approved' && !request.processedAt) {
            request.processedAt = new Date();
        }
        this.serviceRequests.set(requestId, request);
        this.logger.log(`Updated service request status: ${requestId} -> ${status}`);
        return request;
    }
    async getAllServiceRequests() {
        return Array.from(this.serviceRequests.values());
    }
    async getServiceRequestById(id) {
        return this.serviceRequests.get(id) ?? null;
    }
    async getServiceRequestsByStatus(status) {
        return Array.from(this.serviceRequests.values()).filter(request => request.status === status);
    }
    async findServicesByType(type) {
        return Array.from(this.services.values()).filter(service => service.type === type);
    }
    async findServicesByDataCenter(dcId) {
        return Array.from(this.services.values()).filter(service => service.dcId === dcId);
    }
    async calculateServiceCost(serviceId, requirements) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error(`Service ${serviceId} not found`);
        }
        const cpuCost = requirements.cpu * 0.1;
        const memoryCost = requirements.memory * 0.05;
        const storageCost = requirements.storage * 0.001;
        const bandwidthCost = requirements.network * 0.1;
        const monthlyCost = cpuCost + memoryCost + storageCost + bandwidthCost;
        const totalCost = monthlyCost * requirements.duration + service.cost * 0.2;
        const setupCost = service.cost * 0.2;
        const breakdown = {
            cpu: cpuCost,
            memory: memoryCost,
            storage: storageCost,
            bandwidth: bandwidthCost,
            setup: setupCost,
        };
        return {
            monthlyCost: Math.round(monthlyCost * 100) / 100,
            totalCost: Math.round(totalCost * 100) / 100,
            setupCost,
            bandwidthCost: Math.round(bandwidthCost * 100) / 100,
            breakdown,
        };
    }
    async checkServiceAvailability(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error(`Service ${serviceId} not found`);
        }
        const baseCapacity = {
            cpu: service.type === 'DRaaS' ? 500 : service.type === 'BaaS' ? 200 : 2000,
            memory: service.type === 'DRaaS'
                ? 4096
                : service.type === 'BaaS'
                    ? 2048
                    : 16384,
            storage: service.type === 'DRaaS'
                ? 50000
                : service.type === 'BaaS'
                    ? 100000
                    : 200000,
            network: service.type === 'DRaaS'
                ? 5000
                : service.type === 'BaaS'
                    ? 2000
                    : 20000,
        };
        const usedCapacity = {
            cpu: Math.round(baseCapacity.cpu * (0.3 + Math.random() * 0.4)),
            memory: Math.round(baseCapacity.memory * (0.2 + Math.random() * 0.5)),
            storage: Math.round(baseCapacity.storage * (0.4 + Math.random() * 0.4)),
            network: Math.round(baseCapacity.network * (0.1 + Math.random() * 0.3)),
        };
        const utilization = {
            cpu: Math.round((usedCapacity.cpu / baseCapacity.cpu) * 100),
            memory: Math.round((usedCapacity.memory / baseCapacity.memory) * 100),
            storage: Math.round((usedCapacity.storage / baseCapacity.storage) * 100),
            network: Math.round((usedCapacity.network / baseCapacity.network) * 100),
        };
        const available = utilization.cpu < 90 &&
            utilization.memory < 90 &&
            utilization.storage < 95;
        return {
            available,
            currentCapacity: baseCapacity,
            usedCapacity,
            utilization,
        };
    }
    async getServiceHistory(limit = 100) {
        return this.serviceHistory.slice(-limit);
    }
    async getA1IctServicesStatistics() {
        const stats = {
            totalServices: this.services.size,
            activeServices: 0,
            servicesByType: {},
            servicesByDataCenter: {},
            totalRequests: this.serviceRequests.size,
            requestsByStatus: {},
            averageSLA: 0,
            averageRecoveryTime: 0,
        };
        let totalSLA = 0;
        let totalRecoveryTime = 0;
        for (const service of this.services.values()) {
            if (service.status === 'active') {
                stats.activeServices++;
            }
            stats.servicesByType[service.type] =
                (stats.servicesByType[service.type] ?? 0) + 1;
            stats.servicesByDataCenter[service.dcId] =
                (stats.servicesByDataCenter[service.dcId] ?? 0) + 1;
            totalSLA += service.configuration.sla;
            totalRecoveryTime += service.configuration.recoveryTime;
        }
        for (const request of this.serviceRequests.values()) {
            stats.requestsByStatus[request.status] =
                (stats.requestsByStatus[request.status] ?? 0) + 1;
        }
        if (this.services.size > 0) {
            stats.averageSLA =
                Math.round((totalSLA / this.services.size) * 100) / 100;
            stats.averageRecoveryTime = Math.round(totalRecoveryTime / this.services.size);
        }
        return stats;
    }
    async scaleService(serviceId, scaleConfig) {
        const service = this.services.get(serviceId);
        if (!service) {
            return false;
        }
        this.logger.log(`Scaling service ${serviceId} with config:`, scaleConfig);
        this.serviceHistory.push({
            timestamp: new Date(),
            serviceId,
            action: 'scale',
            details: JSON.stringify(scaleConfig),
            result: 'success',
        });
        return true;
    }
    async getBackupStatus(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error('Service not found');
        }
        return {
            status: 'active',
            lastBackup: new Date(Date.now() - 24 * 60 * 60 * 1000),
            nextBackup: new Date(Date.now() + 60 * 60 * 1000),
        };
    }
    async triggerBackup(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error('Service not found');
        }
        const backupId = `backup-${Date.now()}`;
        this.logger.log(`Triggered backup for service ${serviceId}: ${backupId}`);
        return {
            success: true,
            backupId,
        };
    }
    async getRecoveryPoints(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error('Service not found');
        }
        return [
            {
                id: 'rp-1',
                timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000),
                type: 'daily',
                size: 1024 * 1024 * 100,
            },
            {
                id: 'rp-2',
                timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
                type: 'weekly',
                size: 1024 * 1024 * 500,
            },
        ];
    }
    async recoverService(serviceId, recoveryPointId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error('Service not found');
        }
        this.logger.log(`Recovering service ${serviceId} from point ${recoveryPointId}`);
        return {
            success: true,
            recoveryTime: 120,
        };
    }
    async getPerformanceMetrics(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            throw new Error('Service not found');
        }
        return {
            cpu: { usage: 45.2, average: 42.1, peak: 78.9 },
            memory: { usage: 67.8, average: 65.2, peak: 89.1 },
            storage: { usage: 23.1, average: 22.8, peak: 45.6 },
            network: { usage: 89.5, average: 87.2, peak: 95.3 },
            sla: { uptime: 99.9, responseTime: 150, throughput: 1000 },
        };
    }
    async getServicesAnalytics() {
        const services = Array.from(this.services.values());
        return {
            totalServices: services.length,
            activeServices: services.filter(s => s.status === 'active').length,
            servicesByType: services.reduce((acc, service) => {
                acc[service.type] = (acc[service.type] ?? 0) + 1;
                return acc;
            }, {}),
            servicesByLocation: { BY: services.length, RU: 0 },
            servicesByTier: {
                'Tier-III': services.length,
                'Tier-II': 0,
                'Tier-I': 0,
            },
            totalRequests: 0,
            requestsByStatus: { pending: 0, 'in-progress': 0, completed: 0 },
            averageSLA: { uptime: 99.9, responseTime: 150, recoveryTime: 240 },
        };
    }
    async getPerformanceAnalytics() {
        return {
            averageCPU: 45.2,
            averageMemory: 67.8,
            averageStorage: 23.1,
            averageNetwork: 89.5,
            slaCompliance: 99.9,
            costEfficiency: 85.2,
        };
    }
    async getCostAnalytics() {
        const services = Array.from(this.services.values());
        return {
            totalMonthlyCost: services.reduce((sum, service) => sum + service.cost, 0),
            costByService: { 'service-1': 10000, 'service-2': 15000 },
            costByType: services.reduce((acc, service) => {
                acc[service.type] = (acc[service.type] ?? 0) + service.cost;
                return acc;
            }, {}),
            costTrends: [
                { month: '2024-02', cost: 22000 },
                { month: '2024-03', cost: 25000 },
            ],
            savings: 5000,
        };
    }
    manageDRaaS(config) {
        return {
            clientId: config.clientId,
            serviceId: `draas-${Date.now()}`,
            status: 'active',
            sla: 99.99,
        };
    }
    manageBaaS(config) {
        return {
            clientId: config.clientId,
            serviceId: `baas-${Date.now()}`,
            status: 'active',
            sla: 99.9,
        };
    }
    manageTierIIIDC(config) {
        return {
            clientId: config.clientId,
            serviceId: `tier3-${Date.now()}`,
            status: 'active',
            sla: 99.982,
        };
    }
    getServiceMetrics(_serviceId) {
        return {
            clientId: `client-${Date.now()}`,
            uptime: 99.9,
            responseTime: 150,
            throughput: 1000,
            cost: 5000,
        };
    }
};
A1IctServicesService = A1IctServicesService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], A1IctServicesService);



/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisasterRecoveryController: () => (/* binding */ DisasterRecoveryController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_data_center_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/* harmony import */ var _dto_update_data_center_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96);
/* harmony import */ var _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(87);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DisasterRecoveryController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;





let DisasterRecoveryController = DisasterRecoveryController_1 = class DisasterRecoveryController {
    constructor(disasterRecoveryService) {
        this.disasterRecoveryService = disasterRecoveryService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DisasterRecoveryController_1.name);
    }
    async getAllDataCenters() {
        this.logger.log('Getting all data centers');
        return this.disasterRecoveryService.getAllDataCenters();
    }
    async getDataCenterById(id) {
        this.logger.log(`Getting data center by ID: ${id}`);
        return this.disasterRecoveryService.getDataCenterById(id);
    }
    async createDataCenter(createDto) {
        this.logger.log('Creating new data center');
        return this.disasterRecoveryService.createDataCenter(createDto);
    }
    async updateDataCenter(id, updateDto) {
        this.logger.log(`Updating data center: ${id}`);
        return this.disasterRecoveryService.updateDataCenter(id, updateDto);
    }
    async deleteDataCenter(id) {
        this.logger.log(`Deleting data center: ${id}`);
        const deleted = await this.disasterRecoveryService.deleteDataCenter(id);
        return { success: deleted };
    }
    async checkDataCenterHealth(id) {
        this.logger.log(`Checking health for data center: ${id}`);
        return this.disasterRecoveryService.checkDataCenterHealth(id);
    }
    async getDataCentersStatus() {
        this.logger.log('Getting data centers status overview');
        return this.disasterRecoveryService.getDataCentersStatus();
    }
    async getDataCentersStatistics() {
        this.logger.log('Getting data centers statistics overview');
        return this.disasterRecoveryService.getDataCentersStatistics();
    }
    async findDataCentersByRegion(region) {
        this.logger.log(`Finding data centers by region: ${region}`);
        return this.disasterRecoveryService.findDataCentersByRegion(region);
    }
    async findDataCentersByCountry(country) {
        this.logger.log(`Finding data centers by country: ${country}`);
        return this.disasterRecoveryService.findDataCentersByCountry(country);
    }
    async findNearestDataCenter(latitude, longitude) {
        this.logger.log(`Finding nearest data center for coordinates: ${latitude}, ${longitude}`);
        return this.disasterRecoveryService.findNearestDataCenter(latitude, longitude);
    }
    async getSystemHealth() {
        this.logger.log('Checking disaster recovery system health');
        const allDCs = await this.disasterRecoveryService.getAllDataCenters();
        const activeDCs = allDCs.filter(dc => dc.status === 'active');
        return {
            status: 'healthy',
            timestamp: new Date(),
            dataCenters: allDCs.length,
            activeDataCenters: activeDCs.length,
            system: 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting disaster recovery system overview');
        const allDCs = await this.disasterRecoveryService.getAllDataCenters();
        const stats = await this.disasterRecoveryService.getDataCentersStatistics();
        const countries = [...new Set(allDCs.map(dc => dc.country))];
        const regions = [...new Set(allDCs.map(dc => dc.region))];
        return {
            totalDataCenters: stats.total,
            activeDataCenters: stats.active,
            standbyDataCenters: stats.standby,
            maintenanceDataCenters: stats.maintenance,
            offlineDataCenters: stats.offline,
            countries,
            regions,
            lastUpdated: new Date(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all data centers',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], DisasterRecoveryController.prototype, "getAllDataCenters", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get data center by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data center found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Data center not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], DisasterRecoveryController.prototype, "getDataCenterById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('data-centers'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Data center created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_data_center_dto__WEBPACK_IMPORTED_MODULE_2__.CreateDataCenterDto !== "undefined" && _dto_create_data_center_dto__WEBPACK_IMPORTED_MODULE_2__.CreateDataCenterDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], DisasterRecoveryController.prototype, "createDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('data-centers/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data center updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Data center not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_data_center_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateDataCenterDto !== "undefined" && _dto_update_data_center_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateDataCenterDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], DisasterRecoveryController.prototype, "updateDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('data-centers/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data center deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Data center not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], DisasterRecoveryController.prototype, "deleteDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/:id/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check data center health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data center health status',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Data center not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], DisasterRecoveryController.prototype, "checkDataCenterHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/status/overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get status overview of all data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data centers status overview',
        type: Object,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], DisasterRecoveryController.prototype, "getDataCentersStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/statistics/overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get statistics overview of all data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data centers statistics overview',
        type: Object,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], DisasterRecoveryController.prototype, "getDataCentersStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/search/region'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find data centers by region' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'region', description: 'Region name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data centers found in region',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('region')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], DisasterRecoveryController.prototype, "findDataCentersByRegion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/search/country'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find data centers by country' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'country', description: 'Country code (BY or RU)' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Data centers found in country',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('country')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], DisasterRecoveryController.prototype, "findDataCentersByCountry", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('data-centers/search/nearest'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find nearest data center by coordinates' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'latitude', description: 'Latitude coordinate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'longitude', description: 'Longitude coordinate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Nearest data center found',
        type: Object,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('latitude')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('longitude')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], DisasterRecoveryController.prototype, "findNearestDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check disaster recovery system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                dataCenters: { type: 'number', example: 4 },
                activeDataCenters: { type: 'number', example: 4 },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], DisasterRecoveryController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get disaster recovery system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalDataCenters: { type: 'number' },
                activeDataCenters: { type: 'number' },
                standbyDataCenters: { type: 'number' },
                maintenanceDataCenters: { type: 'number' },
                offlineDataCenters: { type: 'number' },
                countries: { type: 'array', items: { type: 'string' } },
                regions: { type: 'array', items: { type: 'string' } },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], DisasterRecoveryController.prototype, "getSystemOverview", null);
DisasterRecoveryController = DisasterRecoveryController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Disaster Recovery'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('disaster-recovery'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_4__.DisasterRecoveryService !== "undefined" && _services_disaster_recovery_service__WEBPACK_IMPORTED_MODULE_4__.DisasterRecoveryService) === "function" ? _a : Object])
], DisasterRecoveryController);



/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateDataCenterDto: () => (/* binding */ CreateDataCenterDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateDataCenterDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateDataCenterDto.prototype, "name", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateDataCenterDto.prototype, "region", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['RU', 'BY']),
    __metadata("design:type", String)
], CreateDataCenterDto.prototype, "country", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateDataCenterDto.prototype, "city", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateDataCenterDto.prototype, "coordinates", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateDataCenterDto.prototype, "capacity", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['active', 'maintenance', 'offline']),
    __metadata("design:type", String)
], CreateDataCenterDto.prototype, "status", void 0);


/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateDataCenterDto: () => (/* binding */ UpdateDataCenterDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_data_center_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);


class UpdateDataCenterDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_data_center_dto__WEBPACK_IMPORTED_MODULE_1__.CreateDataCenterDto) {
}


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegionalFailoverController: () => (/* binding */ RegionalFailoverController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_failover_config_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _dto_update_failover_config_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99);
/* harmony import */ var _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RegionalFailoverController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;





let RegionalFailoverController = RegionalFailoverController_1 = class RegionalFailoverController {
    constructor(regionalFailoverService) {
        this.regionalFailoverService = regionalFailoverService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(RegionalFailoverController_1.name);
    }
    async getAllFailoverConfigs() {
        this.logger.log('Getting all failover configurations');
        return this.regionalFailoverService.getAllFailoverConfigs();
    }
    async getFailoverConfigById(id) {
        this.logger.log(`Getting failover config by ID: ${id}`);
        return this.regionalFailoverService.getFailoverConfigById(id);
    }
    async createFailoverConfig(createDto) {
        this.logger.log('Creating new failover configuration');
        return this.regionalFailoverService.createFailoverConfig(createDto);
    }
    async updateFailoverConfig(id, updateDto) {
        this.logger.log(`Updating failover config: ${id}`);
        return this.regionalFailoverService.updateFailoverConfig(id, updateDto);
    }
    async deleteFailoverConfig(id) {
        this.logger.log(`Deleting failover config: ${id}`);
        const deleted = await this.regionalFailoverService.deleteFailoverConfig(id);
        return { success: deleted };
    }
    async performAutoFailover(id) {
        this.logger.log(`Performing auto failover for config: ${id}`);
        return this.regionalFailoverService.performAutoFailover(id);
    }
    async manualFailover(id, reason) {
        this.logger.log(`Performing manual failover for config: ${id}, reason: ${reason}`);
        return this.regionalFailoverService.manualFailover(id, reason);
    }
    async manualFailback(id, reason) {
        this.logger.log(`Performing manual failback for config: ${id}, reason: ${reason}`);
        return this.regionalFailoverService.manualFailback(id, reason);
    }
    async getFailoverHistory(limit = 50) {
        this.logger.log(`Getting failover history with limit: ${limit}`);
        const history = await this.regionalFailoverService.getFailoverHistory(limit);
        return history.map(item => ({
            timestamp: item.timestamp,
            configId: item.configId,
            action: item.action,
            reason: item.details,
            duration: item.duration,
        }));
    }
    async getFailoverStatistics() {
        this.logger.log('Getting failover statistics');
        return this.regionalFailoverService.getFailoverStatistics();
    }
    async getSystemHealth() {
        this.logger.log('Checking regional failover system health');
        const allConfigs = await this.regionalFailoverService.getAllFailoverConfigs();
        const autoFailoverConfigs = allConfigs.filter(config => config.autoFailover);
        return {
            status: 'healthy',
            timestamp: new Date(),
            totalConfigs: allConfigs.length,
            activeConfigs: allConfigs.length,
            autoFailoverEnabled: autoFailoverConfigs.length,
            system: 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting regional failover system overview');
        const allConfigs = await this.regionalFailoverService.getAllFailoverConfigs();
        const autoFailoverConfigs = allConfigs.filter(config => config.autoFailover);
        const manualConfigs = allConfigs.filter(config => !config.autoFailover);
        const primaryDCs = [...new Set(allConfigs.map(config => config.primaryDc))];
        const secondaryDCs = [
            ...new Set(allConfigs.map(config => config.secondaryDc)),
        ];
        const totalRTO = allConfigs.reduce((sum, config) => sum + config.recoveryTimeObjective, 0);
        const totalRPO = allConfigs.reduce((sum, config) => sum + config.recoveryPointObjective, 0);
        return {
            totalConfigurations: allConfigs.length,
            autoFailoverEnabled: autoFailoverConfigs.length,
            manualFailoverOnly: manualConfigs.length,
            primaryDCs,
            secondaryDCs,
            averageRTO: allConfigs.length > 0 ? Math.round(totalRTO / allConfigs.length) : 0,
            averageRPO: allConfigs.length > 0 ? Math.round(totalRPO / allConfigs.length) : 0,
            lastUpdated: new Date(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('configs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all failover configurations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all failover configurations',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], RegionalFailoverController.prototype, "getAllFailoverConfigs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('configs/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover configuration by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Failover configuration found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Failover configuration not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], RegionalFailoverController.prototype, "getFailoverConfigById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('configs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new failover configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Failover configuration created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_failover_config_dto__WEBPACK_IMPORTED_MODULE_2__.CreateFailoverConfigDto !== "undefined" && _dto_create_failover_config_dto__WEBPACK_IMPORTED_MODULE_2__.CreateFailoverConfigDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], RegionalFailoverController.prototype, "createFailoverConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('configs/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update failover configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Failover configuration updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Failover configuration not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_failover_config_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateFailoverConfigDto !== "undefined" && _dto_update_failover_config_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateFailoverConfigDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], RegionalFailoverController.prototype, "updateFailoverConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('configs/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete failover configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Failover configuration deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Failover configuration not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], RegionalFailoverController.prototype, "deleteFailoverConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('configs/:id/auto-failover'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform automatic failover for configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Auto failover completed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                action: { type: 'string', enum: ['failover', 'failback', 'none'] },
                reason: { type: 'string' },
                duration: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], RegionalFailoverController.prototype, "performAutoFailover", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('configs/:id/manual-failover'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform manual failover to secondary DC' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'reason', description: 'Reason for manual failover' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Manual failover completed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                action: { type: 'string', enum: ['failover', 'failback', 'none'] },
                reason: { type: 'string' },
                duration: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('reason')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], RegionalFailoverController.prototype, "manualFailover", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('configs/:id/manual-failback'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform manual failback to primary DC' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Failover configuration ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'reason', description: 'Reason for manual failback' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Manual failback completed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                action: { type: 'string', enum: ['failover', 'failback', 'none'] },
                reason: { type: 'string' },
                duration: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('reason')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], RegionalFailoverController.prototype, "manualFailback", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        description: 'Number of history records to return',
        required: false,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Failover history',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], RegionalFailoverController.prototype, "getFailoverHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('statistics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get failover statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Failover statistics',
        schema: {
            type: 'object',
            properties: {
                totalFailovers: { type: 'number' },
                totalFailbacks: { type: 'number' },
                averageFailoverTime: { type: 'number' },
                averageFailbackTime: { type: 'number' },
                lastFailover: { type: 'string', format: 'date-time' },
                lastFailback: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], RegionalFailoverController.prototype, "getFailoverStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check regional failover system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                totalConfigs: { type: 'number', example: 3 },
                activeConfigs: { type: 'number', example: 3 },
                autoFailoverEnabled: { type: 'number', example: 2 },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], RegionalFailoverController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get regional failover system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalConfigurations: { type: 'number' },
                autoFailoverEnabled: { type: 'number' },
                manualFailoverOnly: { type: 'number' },
                primaryDCs: { type: 'array', items: { type: 'string' } },
                secondaryDCs: { type: 'array', items: { type: 'string' } },
                averageRTO: { type: 'number' },
                averageRPO: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], RegionalFailoverController.prototype, "getSystemOverview", null);
RegionalFailoverController = RegionalFailoverController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Regional Failover'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('regional-failover'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_4__.RegionalFailoverService !== "undefined" && _services_regional_failover_service__WEBPACK_IMPORTED_MODULE_4__.RegionalFailoverService) === "function" ? _a : Object])
], RegionalFailoverController);



/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateFailoverConfigDto: () => (/* binding */ CreateFailoverConfigDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateFailoverConfigDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateFailoverConfigDto.prototype, "primaryDc", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateFailoverConfigDto.prototype, "secondaryDc", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateFailoverConfigDto.prototype, "autoFailover", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateFailoverConfigDto.prototype, "failoverThreshold", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateFailoverConfigDto.prototype, "recoveryTimeObjective", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateFailoverConfigDto.prototype, "recoveryPointObjective", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateFailoverConfigDto.prototype, "healthChecks", void 0);


/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateFailoverConfigDto: () => (/* binding */ UpdateFailoverConfigDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_failover_config_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);


class UpdateFailoverConfigDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_failover_config_dto__WEBPACK_IMPORTED_MODULE_1__.CreateFailoverConfigDto) {
}


/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkResilienceController: () => (/* binding */ NetworkResilienceController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_network_link_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _dto_update_network_link_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(102);
/* harmony import */ var _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NetworkResilienceController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;





let NetworkResilienceController = NetworkResilienceController_1 = class NetworkResilienceController {
    constructor(networkResilienceService) {
        this.networkResilienceService = networkResilienceService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(NetworkResilienceController_1.name);
    }
    async getAllNetworkLinks() {
        this.logger.log('Getting all network links');
        return this.networkResilienceService.getAllNetworkLinks();
    }
    async getNetworkLinkById(id) {
        this.logger.log(`Getting network link by ID: ${id}`);
        return this.networkResilienceService.getNetworkLinkById(id);
    }
    async createNetworkLink(createDto) {
        this.logger.log('Creating new network link');
        return this.networkResilienceService.createNetworkLink(createDto);
    }
    async updateNetworkLink(id, updateDto) {
        this.logger.log(`Updating network link: ${id}`);
        return this.networkResilienceService.updateNetworkLink(id, updateDto);
    }
    async deleteNetworkLink(id) {
        this.logger.log(`Deleting network link: ${id}`);
        const deleted = await this.networkResilienceService.deleteNetworkLink(id);
        return { success: deleted };
    }
    async checkLinkHealth(id) {
        this.logger.log(`Checking health for network link: ${id}`);
        return this.networkResilienceService.checkLinkHealth(id);
    }
    async findLinksByType(type) {
        this.logger.log(`Finding network links by type: ${type}`);
        return this.networkResilienceService.findLinksByType(type);
    }
    async findLinksByProvider(provider) {
        this.logger.log(`Finding network links by provider: ${provider}`);
        return this.networkResilienceService.findLinksByProvider(provider);
    }
    async findLinksBetweenDCs(sourceDc, targetDc) {
        this.logger.log(`Finding network links between DCs: ${sourceDc} -> ${targetDc}`);
        return this.networkResilienceService.findLinksBetweenDCs(sourceDc, targetDc);
    }
    async getAlternativeRoutes(sourceDc, targetDc) {
        this.logger.log(`Finding alternative routes between DCs: ${sourceDc} -> ${targetDc}`);
        return this.networkResilienceService.getAlternativeRoutes(sourceDc, targetDc);
    }
    async testLinkBandwidth(id) {
        this.logger.log(`Testing bandwidth for network link: ${id}`);
        return this.networkResilienceService.testLinkBandwidth(id);
    }
    async startLinkMonitoring(id, intervalMs = 5000) {
        this.logger.log(`Starting monitoring for network link: ${id} with interval: ${intervalMs}ms`);
        return this.networkResilienceService.startLinkMonitoring(id, intervalMs);
    }
    async getLinkHealthHistory(id, limit = 100) {
        this.logger.log(`Getting health history for network link: ${id} with limit: ${limit}`);
        const history = await this.networkResilienceService.getLinkHealthHistory(id, limit);
        return history.map(item => ({
            timestamp: item.timestamp,
            linkId: item.linkId,
            status: 'active',
            latency: 1,
            action: item.action,
            details: item.details,
            bandwidth: item.bandwidth,
            ...(item.error != null && item.error !== '' && { error: item.error }),
        }));
    }
    async getNetworkLinksStatistics() {
        this.logger.log('Getting network resilience statistics');
        return this.networkResilienceService.getNetworkLinksStatistics();
    }
    async getSystemHealth() {
        this.logger.log('Checking network resilience system health');
        const stats = await this.networkResilienceService.getNetworkLinksStatistics();
        return {
            status: stats.down > 0
                ? 'degraded'
                : stats.degraded > 0
                    ? 'warning'
                    : 'healthy',
            timestamp: new Date(),
            totalLinks: stats.total,
            activeLinks: stats.active,
            degradedLinks: stats.degraded,
            downLinks: stats.down,
            system: stats.down > 0 ? 'degraded' : 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting network resilience system overview');
        const allLinks = await this.networkResilienceService.getAllNetworkLinks();
        const stats = await this.networkResilienceService.getNetworkLinksStatistics();
        const primaryLinks = allLinks.filter(link => link.type === 'primary').length;
        const backupLinks = allLinks.filter(link => link.type === 'backup').length;
        const peeringLinks = allLinks.filter(link => link.type === 'peering').length;
        const providers = Object.keys(stats.providers);
        return {
            totalLinks: stats.total,
            primaryLinks,
            backupLinks,
            peeringLinks,
            providers,
            averageLatency: stats.averageLatency,
            totalBandwidth: stats.totalBandwidth,
            lastUpdated: new Date(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all network links' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all network links',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], NetworkResilienceController.prototype, "getAllNetworkLinks", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network link by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network link found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Network link not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], NetworkResilienceController.prototype, "getNetworkLinkById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('links'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new network link' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Network link created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_network_link_dto__WEBPACK_IMPORTED_MODULE_2__.CreateNetworkLinkDto !== "undefined" && _dto_create_network_link_dto__WEBPACK_IMPORTED_MODULE_2__.CreateNetworkLinkDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], NetworkResilienceController.prototype, "createNetworkLink", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('links/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update network link' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network link updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Network link not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_network_link_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateNetworkLinkDto !== "undefined" && _dto_update_network_link_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateNetworkLinkDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], NetworkResilienceController.prototype, "updateNetworkLink", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('links/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete network link' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network link deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Network link not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], NetworkResilienceController.prototype, "deleteNetworkLink", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/:id/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check network link health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network link health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', enum: ['active', 'degraded', 'down'] },
                latency: { type: 'number' },
                bandwidth: { type: 'number' },
                error: { type: 'string' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], NetworkResilienceController.prototype, "checkLinkHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/search/type'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find network links by type' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'type',
        description: 'Link type (primary, backup, peering)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network links found by type',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], NetworkResilienceController.prototype, "findLinksByType", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/search/provider'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find network links by provider' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'provider', description: 'Provider name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network links found by provider',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('provider')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], NetworkResilienceController.prototype, "findLinksByProvider", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/search/between-dcs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find network links between data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'sourceDc', description: 'Source data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'targetDc', description: 'Target data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network links found between data centers',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('sourceDc')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('targetDc')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], NetworkResilienceController.prototype, "findLinksBetweenDCs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/search/alternative-routes'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find alternative routes between data centers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'sourceDc', description: 'Source data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'targetDc', description: 'Target data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Alternative routes found',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('sourceDc')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('targetDc')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], NetworkResilienceController.prototype, "getAlternativeRoutes", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('links/:id/test-bandwidth'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Test network link bandwidth' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Bandwidth test results',
        schema: {
            type: 'object',
            properties: {
                measuredBandwidth: { type: 'number' },
                expectedBandwidth: { type: 'number' },
                efficiency: { type: 'number' },
                status: {
                    type: 'string',
                    enum: ['optimal', 'good', 'poor', 'critical'],
                },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], NetworkResilienceController.prototype, "testLinkBandwidth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('links/:id/start-monitoring'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Start monitoring network link' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'intervalMs',
        description: 'Monitoring interval in milliseconds',
        required: false,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Monitoring started',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                message: { type: 'string' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('intervalMs')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], NetworkResilienceController.prototype, "startLinkMonitoring", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('links/:id/health-history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network link health history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Network link ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        description: 'Number of history records to return',
        required: false,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network link health history',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], NetworkResilienceController.prototype, "getLinkHealthHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('statistics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network resilience statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Network resilience statistics',
        schema: {
            type: 'object',
            properties: {
                total: { type: 'number' },
                active: { type: 'number' },
                degraded: { type: 'number' },
                down: { type: 'number' },
                averageLatency: { type: 'number' },
                totalBandwidth: { type: 'number' },
                providers: { type: 'object' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], NetworkResilienceController.prototype, "getNetworkLinksStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check network resilience system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                totalLinks: { type: 'number', example: 8 },
                activeLinks: { type: 'number', example: 7 },
                degradedLinks: { type: 'number', example: 1 },
                downLinks: { type: 'number', example: 0 },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], NetworkResilienceController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network resilience system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalLinks: { type: 'number' },
                primaryLinks: { type: 'number' },
                backupLinks: { type: 'number' },
                peeringLinks: { type: 'number' },
                providers: { type: 'array', items: { type: 'string' } },
                averageLatency: { type: 'number' },
                totalBandwidth: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], NetworkResilienceController.prototype, "getSystemOverview", null);
NetworkResilienceController = NetworkResilienceController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Network Resilience'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('network-resilience'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__.NetworkResilienceService !== "undefined" && _services_network_resilience_service__WEBPACK_IMPORTED_MODULE_4__.NetworkResilienceService) === "function" ? _a : Object])
], NetworkResilienceController);



/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateNetworkLinkDto: () => (/* binding */ CreateNetworkLinkDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateNetworkLinkDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateNetworkLinkDto.prototype, "sourceDc", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateNetworkLinkDto.prototype, "targetDc", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['backup', 'primary', 'peering']),
    __metadata("design:type", String)
], CreateNetworkLinkDto.prototype, "type", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateNetworkLinkDto.prototype, "bandwidth", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateNetworkLinkDto.prototype, "latency", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateNetworkLinkDto.prototype, "provider", void 0);


/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateNetworkLinkDto: () => (/* binding */ UpdateNetworkLinkDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_network_link_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101);


class UpdateNetworkLinkDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_network_link_dto__WEBPACK_IMPORTED_MODULE_1__.CreateNetworkLinkDto) {
}


/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeographicRoutingController: () => (/* binding */ GeographicRoutingController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_geographic_route_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104);
/* harmony import */ var _dto_update_geographic_route_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(105);
/* harmony import */ var _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(90);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GeographicRoutingController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;





let GeographicRoutingController = GeographicRoutingController_1 = class GeographicRoutingController {
    constructor(geographicRoutingService) {
        this.geographicRoutingService = geographicRoutingService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(GeographicRoutingController_1.name);
    }
    async getAllRoutes() {
        this.logger.log('Getting all geographic routes');
        return this.geographicRoutingService.getAllRoutes();
    }
    async getRouteById(id) {
        this.logger.log(`Getting geographic route by ID: ${id}`);
        return this.geographicRoutingService.getRouteById(id);
    }
    async createRoute(createDto) {
        this.logger.log('Creating new geographic route');
        return this.geographicRoutingService.createRoute(createDto);
    }
    async updateRoute(id, updateDto) {
        this.logger.log(`Updating geographic route: ${id}`);
        return this.geographicRoutingService.updateRoute(id, updateDto);
    }
    async deleteRoute(id) {
        this.logger.log(`Deleting geographic route: ${id}`);
        const deleted = await this.geographicRoutingService.deleteRoute(id);
        return { success: deleted };
    }
    async determineOptimalDataCenter(request) {
        this.logger.log('Determining optimal data center for user location');
        if (!request.strategy) {
            throw new Error('Routing strategy is required');
        }
        return this.geographicRoutingService.determineOptimalDataCenter(request.userLocation, request.strategy, request.availableDCs
            ? request.availableDCs
            : undefined);
    }
    async findRoutesByCountry(country) {
        this.logger.log(`Finding routes by country: ${country}`);
        return this.geographicRoutingService.findRoutesByCountry(country);
    }
    async findRoutesByRegion(region) {
        this.logger.log(`Finding routes by region: ${region}`);
        return this.geographicRoutingService.findRoutesByRegion(region);
    }
    async findRoutesByStrategy(strategy) {
        this.logger.log(`Finding routes by strategy: ${strategy}`);
        if (!strategy) {
            throw new Error('Routing strategy is required');
        }
        return this.geographicRoutingService.findRoutesByStrategy(strategy);
    }
    async getRoutingHistory(limit = 100) {
        this.logger.log(`Getting routing history with limit: ${limit}`);
        const history = await this.geographicRoutingService.getRoutingHistory(limit);
        return history.map(item => ({
            ...item,
            selectedDc: 'dc-minsk-primary',
        }));
    }
    async getRoutingStatistics() {
        this.logger.log('Getting geographic routing statistics');
        return this.geographicRoutingService.getRoutingStatistics();
    }
    async getSystemHealth() {
        this.logger.log('Checking geographic routing system health');
        const allRoutes = await this.geographicRoutingService.getAllRoutes();
        const countries = [
            ...new Set(allRoutes.map(route => route.userLocation.country)),
        ];
        return {
            status: 'healthy',
            timestamp: new Date(),
            totalRoutes: allRoutes.length,
            activeRoutes: allRoutes.length,
            countries,
            system: 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting geographic routing system overview');
        const allRoutes = await this.geographicRoutingService.getAllRoutes();
        const stats = await this.geographicRoutingService.getRoutingStatistics();
        const countries = [
            ...new Set(allRoutes.map(route => route.userLocation.country)),
        ];
        const regions = [
            ...new Set(allRoutes.map(route => route.userLocation.region)),
        ];
        const strategies = [
            ...new Set(allRoutes.map(route => route.routingStrategy)),
        ];
        return {
            totalRoutes: stats.totalRoutes,
            countries,
            regions,
            strategies,
            averageLatency: stats.averageLatency,
            averageBandwidth: stats.averageBandwidth,
            averageCost: stats.averageCost,
            lastUpdated: new Date(),
        };
    }
    async simulateRouting(request) {
        this.logger.log(`Simulating routing for ${request.userLocations.length} user locations`);
        const startTime = Date.now();
        const results = [];
        let totalLatency = 0;
        let totalBandwidth = 0;
        let totalCost = 0;
        const countryDistribution = {};
        for (const userRequest of request.userLocations) {
            const result = await this.geographicRoutingService.determineOptimalDataCenter(userRequest.location, userRequest.strategy ?? 'nearest');
            if (result) {
                results.push({
                    userId: userRequest.userId,
                    location: userRequest.location,
                    selectedDc: result.selectedDc,
                    metrics: result.metrics,
                    processingTime: result.processingTime,
                });
                totalLatency += result.metrics.latency;
                totalBandwidth += result.metrics.bandwidth;
                totalCost += result.metrics.cost;
                const country = userRequest.location.country;
                countryDistribution[country] = (countryDistribution[country] ?? 0) + 1;
            }
        }
        const processingTime = Date.now() - startTime;
        const totalUsers = results.length;
        const summary = {
            totalUsers,
            averageLatency: totalUsers > 0 ? Math.round(totalLatency / totalUsers) : 0,
            averageBandwidth: totalUsers > 0 ? Math.round(totalBandwidth / totalUsers) : 0,
            averageCost: totalUsers > 0 ? Math.round((totalCost / totalUsers) * 1000) / 1000 : 0,
            countryDistribution,
        };
        return {
            results,
            summary,
            processingTime,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('routes'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all geographic routes' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all geographic routes',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], GeographicRoutingController.prototype, "getAllRoutes", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('routes/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get geographic route by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Geographic route ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Geographic route found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Geographic route not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], GeographicRoutingController.prototype, "getRouteById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('routes'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new geographic route' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Geographic route created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_geographic_route_dto__WEBPACK_IMPORTED_MODULE_2__.CreateGeographicRouteDto !== "undefined" && _dto_create_geographic_route_dto__WEBPACK_IMPORTED_MODULE_2__.CreateGeographicRouteDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], GeographicRoutingController.prototype, "createRoute", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('routes/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update geographic route' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Geographic route ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Geographic route updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Geographic route not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_geographic_route_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateGeographicRouteDto !== "undefined" && _dto_update_geographic_route_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateGeographicRouteDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], GeographicRoutingController.prototype, "updateRoute", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('routes/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete geographic route' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Geographic route ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Geographic route deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Geographic route not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], GeographicRoutingController.prototype, "deleteRoute", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('determine-optimal-dc'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Determine optimal data center for user location' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Optimal data center determined',
        schema: {
            type: 'object',
            properties: {
                selectedDc: { type: 'object' },
                route: { type: 'object' },
                metrics: { type: 'object' },
                processingTime: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], GeographicRoutingController.prototype, "determineOptimalDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('routes/search/country'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find routes by country' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'country', description: 'Country code (BY or RU)' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routes found by country',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('country')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], GeographicRoutingController.prototype, "findRoutesByCountry", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('routes/search/region'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find routes by region' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'region', description: 'Region name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routes found by region',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('region')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], GeographicRoutingController.prototype, "findRoutesByRegion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('routes/search/strategy'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find routes by routing strategy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'strategy', description: 'Routing strategy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routes found by strategy',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('strategy')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], GeographicRoutingController.prototype, "findRoutesByStrategy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get routing history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        description: 'Number of history records to return',
        required: false,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routing history',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], GeographicRoutingController.prototype, "getRoutingHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('statistics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get geographic routing statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routing statistics',
        schema: {
            type: 'object',
            properties: {
                totalRoutes: { type: 'number' },
                averageProcessingTime: { type: 'number' },
                strategyUsage: { type: 'object' },
                countryDistribution: { type: 'object' },
                averageLatency: { type: 'number' },
                averageBandwidth: { type: 'number' },
                averageCost: { type: 'number' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], GeographicRoutingController.prototype, "getRoutingStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check geographic routing system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                totalRoutes: { type: 'number', example: 4 },
                activeRoutes: { type: 'number', example: 4 },
                countries: { type: 'array', items: { type: 'string' } },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], GeographicRoutingController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get geographic routing system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalRoutes: { type: 'number' },
                countries: { type: 'array', items: { type: 'string' } },
                regions: { type: 'array', items: { type: 'string' } },
                strategies: { type: 'array', items: { type: 'string' } },
                averageLatency: { type: 'number' },
                averageBandwidth: { type: 'number' },
                averageCost: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], GeographicRoutingController.prototype, "getSystemOverview", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('simulate-routing'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Simulate routing for multiple user locations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Routing simulation completed',
        schema: {
            type: 'object',
            properties: {
                results: { type: 'array', items: { type: 'object' } },
                summary: { type: 'object' },
                processingTime: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], GeographicRoutingController.prototype, "simulateRouting", null);
GeographicRoutingController = GeographicRoutingController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Geographic Routing'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('geographic-routing'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_4__.GeographicRoutingService !== "undefined" && _services_geographic_routing_service__WEBPACK_IMPORTED_MODULE_4__.GeographicRoutingService) === "function" ? _a : Object])
], GeographicRoutingController);



/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateGeographicRouteDto: () => (/* binding */ CreateGeographicRouteDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateGeographicRouteDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateGeographicRouteDto.prototype, "userLocation", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateGeographicRouteDto.prototype, "targetDc", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['nearest', 'lowest-latency', 'least-loaded', 'cost-optimized']),
    __metadata("design:type", String)
], CreateGeographicRouteDto.prototype, "routingStrategy", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateGeographicRouteDto.prototype, "metrics", void 0);


/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateGeographicRouteDto: () => (/* binding */ UpdateGeographicRouteDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_geographic_route_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);


class UpdateGeographicRouteDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_geographic_route_dto__WEBPACK_IMPORTED_MODULE_1__.CreateGeographicRouteDto) {
}


/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentResponseController: () => (/* binding */ IncidentResponseController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_incident_response_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);
/* harmony import */ var _dto_update_incident_response_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
/* harmony import */ var _services_incident_response_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var IncidentResponseController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;





let IncidentResponseController = IncidentResponseController_1 = class IncidentResponseController {
    constructor(incidentResponseService) {
        this.incidentResponseService = incidentResponseService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(IncidentResponseController_1.name);
    }
    async getAllIncidents() {
        this.logger.log('Getting all incidents');
        return this.incidentResponseService.getAllIncidents();
    }
    async getIncidentById(id) {
        this.logger.log(`Getting incident by ID: ${id}`);
        return this.incidentResponseService.getIncidentById(id);
    }
    async createIncident(createDto) {
        this.logger.log('Creating new incident');
        return this.incidentResponseService.createIncident(createDto);
    }
    async updateIncident(id, updateDto) {
        this.logger.log(`Updating incident: ${id}`);
        return this.incidentResponseService.updateIncident(id, updateDto);
    }
    async deleteIncident(id) {
        this.logger.log(`Deleting incident: ${id}`);
        const deleted = await this.incidentResponseService.deleteIncident(id);
        return { success: deleted };
    }
    async addActionToIncident(id, action) {
        this.logger.log(`Adding action to incident: ${id}`);
        return this.incidentResponseService.addActionToIncident(id, action);
    }
    async updateActionStatus(incidentId, actionId, updateData) {
        this.logger.log(`Updating action status: ${actionId} in incident: ${incidentId}`);
        return this.incidentResponseService.updateActionStatus(incidentId, actionId, updateData.status, updateData.result, updateData.error);
    }
    async executeRecoveryProcedures(id) {
        this.logger.log(`Executing recovery procedures for incident: ${id}`);
        return this.incidentResponseService.executeRecoveryProcedures(id);
    }
    async findIncidentsByType(type) {
        this.logger.log(`Finding incidents by type: ${type}`);
        return this.incidentResponseService.findIncidentsByType(type);
    }
    async findIncidentsBySeverity(severity) {
        this.logger.log(`Finding incidents by severity: ${severity}`);
        return this.incidentResponseService.findIncidentsBySeverity(severity);
    }
    async findIncidentsByStatus(status) {
        this.logger.log(`Finding incidents by status: ${status}`);
        return this.incidentResponseService.findIncidentsByStatus(status);
    }
    async getActiveIncidents() {
        this.logger.log('Getting active incidents');
        return this.incidentResponseService.getActiveIncidents();
    }
    async getIncidentHistory(limit = 100) {
        this.logger.log(`Getting incident history with limit: ${limit}`);
        return this.incidentResponseService.getIncidentHistory(limit);
    }
    async getIncidentStatistics() {
        this.logger.log('Getting incident statistics');
        return this.incidentResponseService.getIncidentStatistics();
    }
    async getSystemHealth() {
        this.logger.log('Checking incident response system health');
        const stats = await this.incidentResponseService.getIncidentStatistics();
        return {
            status: stats.activeIncidents > 0 ? 'warning' : 'healthy',
            timestamp: new Date(),
            totalIncidents: stats.totalIncidents,
            activeIncidents: stats.activeIncidents,
            resolvedIncidents: stats.resolvedIncidents,
            system: stats.activeIncidents > 0 ? 'responding' : 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting incident response system overview');
        const stats = await this.incidentResponseService.getIncidentStatistics();
        const incidentTypes = Object.keys(stats.incidentsByType);
        const severityLevels = Object.keys(stats.incidentsBySeverity);
        return {
            totalIncidents: stats.totalIncidents,
            activeIncidents: stats.activeIncidents,
            resolvedIncidents: stats.resolvedIncidents,
            incidentTypes,
            severityLevels,
            averageResolutionTime: stats.averageResolutionTime,
            lastUpdated: new Date(),
        };
    }
    async simulateIncident(request) {
        this.logger.log(`Simulating incident: ${request.type}`);
        const startTime = Date.now();
        const incident = await this.incidentResponseService.createIncident(request);
        const actions = [];
        switch (request.type) {
            case 'power-outage': {
                const powerAction1 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Автоматическое переключение на резервный источник питания',
                    type: 'automatic',
                    status: 'pending',
                });
                const powerAction2 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Уведомление технического персонала',
                    type: 'automatic',
                    status: 'pending',
                });
                if (powerAction1)
                    actions.push(powerAction1);
                if (powerAction2)
                    actions.push(powerAction2);
                break;
            }
            case 'network-failure': {
                const networkAction1 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Переключение на резервный канал связи',
                    type: 'automatic',
                    status: 'pending',
                });
                const networkAction2 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Диагностика сетевого оборудования',
                    type: 'automatic',
                    status: 'pending',
                });
                if (networkAction1)
                    actions.push(networkAction1);
                if (networkAction2)
                    actions.push(networkAction2);
                break;
            }
            case 'hardware-failure': {
                const hardwareAction1 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Переключение на резервное оборудование',
                    type: 'automatic',
                    status: 'pending',
                });
                const hardwareAction2 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Заказ замены оборудования',
                    type: 'automatic',
                    status: 'pending',
                });
                if (hardwareAction1)
                    actions.push(hardwareAction1);
                if (hardwareAction2)
                    actions.push(hardwareAction2);
                break;
            }
            case 'natural-disaster': {
                const disasterAction1 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Активация плана эвакуации',
                    type: 'automatic',
                    status: 'pending',
                });
                const disasterAction2 = await this.incidentResponseService.addActionToIncident(incident.id, {
                    description: 'Переключение на удаленный центр обработки данных',
                    type: 'automatic',
                    status: 'pending',
                });
                if (disasterAction1)
                    actions.push(disasterAction1);
                if (disasterAction2)
                    actions.push(disasterAction2);
                break;
            }
        }
        const simulationTime = Date.now() - startTime;
        return {
            incident,
            actions,
            simulationTime,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all incidents' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all incidents',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], IncidentResponseController.prototype, "getAllIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get incident by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Incident not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], IncidentResponseController.prototype, "getIncidentById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Incident created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_incident_response_dto__WEBPACK_IMPORTED_MODULE_2__.CreateIncidentResponseDto !== "undefined" && _dto_create_incident_response_dto__WEBPACK_IMPORTED_MODULE_2__.CreateIncidentResponseDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], IncidentResponseController.prototype, "createIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('incidents/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Incident not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_incident_response_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateIncidentResponseDto !== "undefined" && _dto_update_incident_response_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateIncidentResponseDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], IncidentResponseController.prototype, "updateIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('incidents/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Incident not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], IncidentResponseController.prototype, "deleteIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents/:id/actions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add action to incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Action added successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Incident not found',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_j = typeof Omit !== "undefined" && Omit) === "function" ? _j : Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], IncidentResponseController.prototype, "addActionToIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('incidents/:incidentId/actions/:actionId/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update action status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'incidentId', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'actionId', description: 'Action ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Action status updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Incident or action not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('incidentId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('actionId')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], IncidentResponseController.prototype, "updateActionStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents/:id/execute-recovery'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Execute recovery procedures for incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Recovery procedures executed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                actionsExecuted: { type: 'number' },
                totalActions: { type: 'number' },
                errors: { type: 'array', items: { type: 'string' } },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], IncidentResponseController.prototype, "executeRecoveryProcedures", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/search/type'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find incidents by type' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'type', description: 'Incident type' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incidents found by type',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], IncidentResponseController.prototype, "findIncidentsByType", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/search/severity'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find incidents by severity' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'severity', description: 'Incident severity' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incidents found by severity',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('severity')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], IncidentResponseController.prototype, "findIncidentsBySeverity", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/search/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find incidents by status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'status', description: 'Incident status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incidents found by status',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], IncidentResponseController.prototype, "findIncidentsByStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/active'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get active incidents' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Active incidents',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], IncidentResponseController.prototype, "getActiveIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get incident history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        description: 'Number of history records to return',
        required: false,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident history',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], IncidentResponseController.prototype, "getIncidentHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('statistics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get incident statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident statistics',
        schema: {
            type: 'object',
            properties: {
                totalIncidents: { type: 'number' },
                activeIncidents: { type: 'number' },
                resolvedIncidents: { type: 'number' },
                incidentsByType: { type: 'object' },
                incidentsBySeverity: { type: 'object' },
                averageResolutionTime: { type: 'number' },
                lastIncident: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], IncidentResponseController.prototype, "getIncidentStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check incident response system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                totalIncidents: { type: 'number', example: 2 },
                activeIncidents: { type: 'number', example: 1 },
                resolvedIncidents: { type: 'number', example: 1 },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], IncidentResponseController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get incident response system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalIncidents: { type: 'number' },
                activeIncidents: { type: 'number' },
                resolvedIncidents: { type: 'number' },
                incidentTypes: { type: 'array', items: { type: 'string' } },
                severityLevels: { type: 'array', items: { type: 'string' } },
                averageResolutionTime: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_v = typeof Promise !== "undefined" && Promise) === "function" ? _v : Object)
], IncidentResponseController.prototype, "getSystemOverview", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('simulate-incident'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Simulate incident for testing' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident simulation completed',
        schema: {
            type: 'object',
            properties: {
                incident: { type: 'object' },
                actions: { type: 'array', items: { type: 'object' } },
                simulationTime: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_w = typeof Promise !== "undefined" && Promise) === "function" ? _w : Object)
], IncidentResponseController.prototype, "simulateIncident", null);
IncidentResponseController = IncidentResponseController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Incident Response'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('incident-response'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_incident_response_service__WEBPACK_IMPORTED_MODULE_4__.IncidentResponseService !== "undefined" && _services_incident_response_service__WEBPACK_IMPORTED_MODULE_4__.IncidentResponseService) === "function" ? _a : Object])
], IncidentResponseController);



/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateIncidentResponseDto: () => (/* binding */ CreateIncidentResponseDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateIncidentResponseDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)([
        'power-outage',
        'network-failure',
        'hardware-failure',
        'natural-disaster',
    ]),
    __metadata("design:type", String)
], CreateIncidentResponseDto.prototype, "type", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['low', 'medium', 'high', 'critical']),
    __metadata("design:type", String)
], CreateIncidentResponseDto.prototype, "severity", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsArray)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)({ each: true }),
    __metadata("design:type", Array)
], CreateIncidentResponseDto.prototype, "affectedDcs", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateIncidentResponseDto.prototype, "description", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateIncidentResponseDto.prototype, "playbook", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['resolved', 'detected', 'responding', 'mitigated']),
    __metadata("design:type", String)
], CreateIncidentResponseDto.prototype, "status", void 0);


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateIncidentResponseDto: () => (/* binding */ UpdateIncidentResponseDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_incident_response_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(107);


class UpdateIncidentResponseDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_incident_response_dto__WEBPACK_IMPORTED_MODULE_1__.CreateIncidentResponseDto) {
}


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CapacityPlanningController: () => (/* binding */ CapacityPlanningController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var _dto_update_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(111);
/* harmony import */ var _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var CapacityPlanningController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;





let CapacityPlanningController = CapacityPlanningController_1 = class CapacityPlanningController {
    constructor(capacityPlanningService) {
        this.capacityPlanningService = capacityPlanningService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CapacityPlanningController_1.name);
    }
    async getAllCapacityPlans() {
        this.logger.log('Getting all capacity plans');
        return this.capacityPlanningService.getAllCapacityPlans();
    }
    async getCapacityPlanById(id) {
        this.logger.log(`Getting capacity plan by ID: ${id}`);
        return this.capacityPlanningService.getCapacityPlanById(id);
    }
    async createCapacityPlan(createDto) {
        this.logger.log('Creating new capacity plan');
        const planWithCurrentCapacity = {
            ...createDto,
            currentCapacity: {
                cpu: 1000,
                memory: 8192,
                storage: 100000,
                network: 10000,
            },
        };
        return this.capacityPlanningService.createCapacityPlan(planWithCurrentCapacity);
    }
    async updateCapacityPlan(id, updateDto) {
        this.logger.log(`Updating capacity plan: ${id}`);
        const cleanUpdateDto = Object.fromEntries(Object.entries(updateDto).filter(([, value]) => value != null));
        const planWithCurrentCapacity = {
            ...cleanUpdateDto,
            currentCapacity: {
                cpu: 1000,
                memory: 8192,
                storage: 100000,
                network: 10000,
            },
        };
        return this.capacityPlanningService.updateCapacityPlan(id, planWithCurrentCapacity);
    }
    async deleteCapacityPlan(id) {
        this.logger.log(`Deleting capacity plan: ${id}`);
        const deleted = await this.capacityPlanningService.deleteCapacityPlan(id);
        return { success: deleted };
    }
    async addScalingAction(id, action) {
        this.logger.log(`Adding scaling action to plan: ${id}`);
        return this.capacityPlanningService.addScalingAction(id, action);
    }
    async updateScalingActionStatus(planId, actionId, updateData) {
        this.logger.log(`Updating scaling action status: ${actionId} in plan: ${planId}`);
        return this.capacityPlanningService.updateScalingActionStatus(planId, actionId, updateData.status);
    }
    async analyzeCapacityNeeds(request) {
        this.logger.log(`Analyzing capacity needs for DC: ${request.dcId}`);
        return this.capacityPlanningService.analyzeCapacityNeeds(request.dcId);
    }
    async performStressTest(request) {
        this.logger.log(`Performing stress test for DC: ${request.dcId}`);
        return this.capacityPlanningService.performStressTest(request.dcId, request.testScenario);
    }
    async findPlansByDataCenter(dcId) {
        this.logger.log(`Finding capacity plans by data center: ${dcId}`);
        return this.capacityPlanningService.findPlansByDataCenter(dcId);
    }
    async findPlansByStatus(status) {
        this.logger.log(`Finding capacity plans by status: ${status}`);
        return this.capacityPlanningService.findPlansByStatus(status);
    }
    async findPlansByPeriod(start, end) {
        this.logger.log(`Finding capacity plans by period: ${start} - ${end}`);
        return this.capacityPlanningService.findPlansByPeriod(new Date(start), new Date(end));
    }
    async getScalingHistory() {
        this.logger.log('Getting scaling history');
        return this.capacityPlanningService.getScalingHistory();
    }
    async getCapacityPlanningStatistics() {
        this.logger.log('Getting capacity planning statistics');
        return this.capacityPlanningService.getCapacityPlanningStatistics();
    }
    async getSystemHealth() {
        this.logger.log('Checking capacity planning system health');
        const stats = await this.capacityPlanningService.getCapacityPlanningStatistics();
        const activePlans = stats.totalPlans - stats.draftPlans;
        return {
            status: 'healthy',
            timestamp: new Date(),
            totalPlans: stats.totalPlans,
            activePlans,
            totalScalingActions: stats.totalScalingActions,
            system: 'operational',
        };
    }
    async getSystemOverview() {
        this.logger.log('Getting capacity planning system overview');
        const stats = await this.capacityPlanningService.getCapacityPlanningStatistics();
        return {
            totalPlans: stats.totalPlans,
            draftPlans: stats.draftPlans,
            approvedPlans: stats.approvedPlans,
            implementedPlans: stats.implementedPlans,
            reviewedPlans: stats.reviewedPlans,
            totalScalingActions: stats.totalScalingActions,
            averageCostPerPlan: stats.averageCostPerPlan,
            lastUpdated: stats.lastUpdated ?? new Date(),
        };
    }
    async simulateCapacityPlanning(request) {
        this.logger.log(`Simulating capacity planning for DC: ${request.dcId}`);
        const startTime = Date.now();
        const plan = await this.capacityPlanningService.createCapacityPlan({
            dcId: request.dcId,
            period: request.period,
            currentCapacity: {
                cpu: 1000,
                memory: 8192,
                storage: 100000,
                network: 10000,
            },
            projectedDemand: {
                cpu: 1200,
                memory: 10240,
                storage: 120000,
                network: 12000,
            },
        });
        const analysis = await this.capacityPlanningService.analyzeCapacityNeeds(request.dcId);
        const stressTest = await this.capacityPlanningService.performStressTest(request.dcId, request.testScenario);
        for (const recommendation of analysis.recommendations) {
            await this.capacityPlanningService.addScalingAction(plan.id, {
                type: recommendation.action,
                resource: recommendation._resource,
                amount: recommendation.amount,
                priority: recommendation.priority,
                estimatedCost: recommendation.estimatedCost,
                implementationDate: new Date(),
                status: 'planned',
            });
        }
        const simulationTime = Date.now() - startTime;
        return {
            plan,
            analysis,
            stressTest,
            simulationTime,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('plans'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all capacity plans' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all capacity plans',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], CapacityPlanningController.prototype, "getAllCapacityPlans", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('plans/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get capacity plan by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Capacity plan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plan found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Capacity plan not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], CapacityPlanningController.prototype, "getCapacityPlanById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('plans'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new capacity plan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Capacity plan created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_2__.CreateCapacityPlanDto !== "undefined" && _dto_create_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_2__.CreateCapacityPlanDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], CapacityPlanningController.prototype, "createCapacityPlan", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('plans/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update capacity plan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Capacity plan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plan updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Capacity plan not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateCapacityPlanDto !== "undefined" && _dto_update_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateCapacityPlanDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], CapacityPlanningController.prototype, "updateCapacityPlan", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('plans/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete capacity plan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Capacity plan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plan deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Capacity plan not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], CapacityPlanningController.prototype, "deleteCapacityPlan", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('plans/:id/scaling-actions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add scaling action to capacity plan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Capacity plan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Scaling action added successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Capacity plan not found',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_j = typeof Omit !== "undefined" && Omit) === "function" ? _j : Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], CapacityPlanningController.prototype, "addScalingAction", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('plans/:planId/scaling-actions/:actionId/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update scaling action status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'planId', description: 'Capacity plan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'actionId', description: 'Scaling action ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling action status updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Capacity plan or action not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('planId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('actionId')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], CapacityPlanningController.prototype, "updateScalingActionStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('analyze-capacity-needs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Analyze capacity needs for data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity analysis completed',
        schema: {
            type: 'object',
            properties: {
                currentCapacity: { type: 'object' },
                projectedDemand: { type: 'object' },
                capacityGap: { type: 'object' },
                recommendations: { type: 'array', items: { type: 'object' } },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], CapacityPlanningController.prototype, "analyzeCapacityNeeds", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('stress-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Perform stress test for data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Stress test completed',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                results: { type: 'object' },
                recommendations: { type: 'array', items: { type: 'string' } },
                testDuration: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], CapacityPlanningController.prototype, "performStressTest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('plans/search/data-center'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find capacity plans by data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'dcId', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plans found by data center',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('dcId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], CapacityPlanningController.prototype, "findPlansByDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('plans/search/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find capacity plans by status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'status', description: 'Plan status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plans found by status',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], CapacityPlanningController.prototype, "findPlansByStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('plans/search/period'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find capacity plans by period' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'start', description: 'Start date' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'end', description: 'End date' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity plans found by period',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('start')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('end')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], CapacityPlanningController.prototype, "findPlansByPeriod", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling-history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get scaling history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling history',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], CapacityPlanningController.prototype, "getScalingHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('statistics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get capacity planning statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity planning statistics',
        schema: {
            type: 'object',
            properties: {
                totalPlans: { type: 'number' },
                draftPlans: { type: 'number' },
                approvedPlans: { type: 'number' },
                implementedPlans: { type: 'number' },
                reviewedPlans: { type: 'number' },
                totalScalingActions: { type: 'number' },
                averageCostPerPlan: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], CapacityPlanningController.prototype, "getCapacityPlanningStatistics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check capacity planning system health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System health status',
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', example: 'healthy' },
                timestamp: { type: 'string', format: 'date-time' },
                totalPlans: { type: 'number', example: 2 },
                activePlans: { type: 'number', example: 2 },
                totalScalingActions: { type: 'number', example: 2 },
                system: { type: 'string', example: 'operational' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], CapacityPlanningController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get capacity planning system overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System overview',
        schema: {
            type: 'object',
            properties: {
                totalPlans: { type: 'number' },
                draftPlans: { type: 'number' },
                approvedPlans: { type: 'number' },
                implementedPlans: { type: 'number' },
                reviewedPlans: { type: 'number' },
                totalScalingActions: { type: 'number' },
                averageCostPerPlan: { type: 'number' },
                lastUpdated: { type: 'string', format: 'date-time' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_v = typeof Promise !== "undefined" && Promise) === "function" ? _v : Object)
], CapacityPlanningController.prototype, "getSystemOverview", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('simulate-capacity-planning'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Simulate capacity planning for testing' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Capacity planning simulation completed',
        schema: {
            type: 'object',
            properties: {
                plan: { type: 'object' },
                analysis: { type: 'object' },
                stressTest: { type: 'object' },
                simulationTime: { type: 'number' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_w = typeof Promise !== "undefined" && Promise) === "function" ? _w : Object)
], CapacityPlanningController.prototype, "simulateCapacityPlanning", null);
CapacityPlanningController = CapacityPlanningController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Capacity Planning'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('capacity-planning'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_4__.CapacityPlanningService !== "undefined" && _services_capacity_planning_service__WEBPACK_IMPORTED_MODULE_4__.CapacityPlanningService) === "function" ? _a : Object])
], CapacityPlanningController);



/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateCapacityPlanDto: () => (/* binding */ CreateCapacityPlanDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

class CreateCapacityPlanDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateCapacityPlanDto.prototype, "dcId", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateCapacityPlanDto.prototype, "period", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateCapacityPlanDto.prototype, "currentCapacity", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateCapacityPlanDto.prototype, "projectedDemand", void 0);


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateCapacityPlanDto: () => (/* binding */ UpdateCapacityPlanDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);


class UpdateCapacityPlanDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_capacity_plan_dto__WEBPACK_IMPORTED_MODULE_1__.CreateCapacityPlanDto) {
}


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A1IctServicesController: () => (/* binding */ A1IctServicesController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dto_create_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _dto_update_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(114);
/* harmony import */ var _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var A1IctServicesController_1;
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;





let A1IctServicesController = A1IctServicesController_1 = class A1IctServicesController {
    constructor(a1IctServicesService) {
        this.a1IctServicesService = a1IctServicesService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(A1IctServicesController_1.name);
    }
    async getAllServices() {
        this.logger.log('Getting all A1 ICT services');
        return this.a1IctServicesService.getAllServices();
    }
    async getServiceById(id) {
        this.logger.log(`Getting A1 ICT service by ID: ${id}`);
        return this.a1IctServicesService.getServiceById(id);
    }
    async createService(createDto) {
        this.logger.log('Creating new A1 ICT service');
        return this.a1IctServicesService.createService(createDto);
    }
    async updateService(id, updateDto) {
        this.logger.log(`Updating A1 ICT service: ${id}`);
        return this.a1IctServicesService.updateService(id, updateDto);
    }
    async deleteService(id) {
        this.logger.log(`Deleting A1 ICT service: ${id}`);
        await this.a1IctServicesService.deleteService(id);
        return { message: 'Service deleted successfully' };
    }
    async findServicesByType(type) {
        this.logger.log(`Finding services by type: ${type}`);
        return this.a1IctServicesService.findServicesByType(type);
    }
    async findServicesByDataCenter(dcId) {
        this.logger.log(`Finding services by data center: ${dcId}`);
        return this.a1IctServicesService.findServicesByDataCenter(dcId);
    }
    async calculateServiceCost(id, requirements) {
        this.logger.log(`Calculating cost for service: ${id}`);
        return this.a1IctServicesService.calculateServiceCost(id, requirements);
    }
    async checkServiceAvailability(id) {
        this.logger.log(`Checking availability for service: ${id}`);
        return this.a1IctServicesService.checkServiceAvailability(id);
    }
    async scaleService(id, scaling) {
        this.logger.log(`Scaling service: ${id}`);
        const result = await this.a1IctServicesService.scaleService(id, scaling);
        return {
            id: result ? '1' : '0',
            name: result ? 'Scaled Service' : 'Failed Service',
            type: 'DRaaS',
            status: result ? 'scaled' : 'failed',
        };
    }
    async getBackupStatus(id) {
        const result = await this.a1IctServicesService.getBackupStatus(id);
        return {
            status: result.status,
            lastBackup: result.lastBackup,
            nextBackup: result.nextBackup,
        };
    }
    async triggerBackup(id) {
        const result = await this.a1IctServicesService.triggerBackup(id);
        return {
            success: result.success,
            backupId: result.backupId,
        };
    }
    async getRecoveryPoints(id) {
        const result = await this.a1IctServicesService.getRecoveryPoints(id);
        return result.map(item => ({
            id: item.id,
            timestamp: item.timestamp,
            type: item.type,
            size: item.size,
        }));
    }
    async recoverService(id) {
        const result = await this.a1IctServicesService.recoverService(id, 'default-recovery-point');
        return {
            success: result.success,
            recoveryTime: result.recoveryTime,
        };
    }
    async getPerformanceMetrics(id) {
        this.logger.log(`Getting performance metrics for service: ${id}`);
        const result = await this.a1IctServicesService.getPerformanceMetrics(id);
        return {
            cpu: result.cpu,
            memory: result.memory,
            storage: result.storage,
            network: result.network,
            sla: result.sla,
        };
    }
    async getServiceRequests(id) {
        this.logger.log(`Getting requests for service: ${id}`);
        return this.a1IctServicesService.getAllServiceRequests();
    }
    async createServiceRequest(id, request) {
        this.logger.log(`Creating request for service: ${id}`);
        const serviceRequest = {
            serviceType: request.type,
            dcId: id,
            configuration: {
                sla: 99.9,
                backupRetention: 30,
                recoveryTime: 4,
                replicationFrequency: 24,
            },
            cost: 0,
            contractEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        };
        const result = await this.a1IctServicesService.createServiceRequest(id, serviceRequest);
        if (!result) {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.NotFoundException('Failed to create service request');
        }
        return result;
    }
    async getServiceRequest(id, requestId) {
        this.logger.log(`Getting request ${requestId} for service: ${id}`);
        const requests = await this.a1IctServicesService.getAllServiceRequests();
        const request = requests.find(r => r.id === requestId);
        if (request == null) {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.NotFoundException('Service request not found');
        }
        return request;
    }
    async updateServiceRequest(id, requestId) {
        this.logger.log(`Updating request ${requestId} for service: ${id}`);
        const result = await this.a1IctServicesService.createServiceRequest(id, {
            serviceType: 'DRaaS',
            dcId: id,
            configuration: {
                sla: 99.9,
                backupRetention: 30,
                recoveryTime: 4,
                replicationFrequency: 24,
            },
            cost: 0,
            contractEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        });
        if (!result) {
            throw new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.NotFoundException('Failed to update service request');
        }
        return result;
    }
    async getServicesAnalytics() {
        this.logger.log('Getting services analytics overview');
        const result = await this.a1IctServicesService.getServicesAnalytics();
        return {
            totalServices: result.totalServices,
            activeServices: result.activeServices,
            servicesByType: result.servicesByType,
            servicesByLocation: result.servicesByLocation,
            servicesByTier: result.servicesByTier,
            totalRequests: result.totalRequests,
            requestsByStatus: result.requestsByStatus,
            averageSLA: result.averageSLA,
        };
    }
    async getPerformanceAnalytics() {
        this.logger.log('Getting services performance analytics');
        const result = await this.a1IctServicesService.getPerformanceAnalytics();
        return {
            averageCPU: result.averageCPU,
            averageMemory: result.averageMemory,
            averageStorage: result.averageStorage,
            averageNetwork: result.averageNetwork,
            slaCompliance: result.slaCompliance,
            costEfficiency: result.costEfficiency,
        };
    }
    async getCostAnalytics() {
        this.logger.log('Getting services cost analytics');
        const result = await this.a1IctServicesService.getCostAnalytics();
        return {
            totalMonthlyCost: result.totalMonthlyCost,
            costByService: result.costByService,
            costByType: result.costByType,
            costTrends: result.costTrends,
            savings: result.savings,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all A1 ICT services' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of all A1 ICT services',
        type: [Object],
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], A1IctServicesController.prototype, "getAllServices", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get A1 ICT service by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service found',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Service not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], A1IctServicesController.prototype, "getServiceById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new A1 ICT service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Service created successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 400,
        description: 'Invalid input data',
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof _dto_create_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_2__.CreateA1IctServiceDto !== "undefined" && _dto_create_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_2__.CreateA1IctServiceDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], A1IctServicesController.prototype, "createService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('services/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update A1 ICT service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service updated successfully',
        type: Object,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Service not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof _dto_update_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateA1IctServiceDto !== "undefined" && _dto_update_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_3__.UpdateA1IctServiceDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], A1IctServicesController.prototype, "updateService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('services/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete A1 ICT service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service deleted successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 404,
        description: 'Service not found',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], A1IctServicesController.prototype, "deleteService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/search/type'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find services by type' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'type',
        description: 'Service type (DRaaS, BaaS, TierIII-DC)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Services found by type',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], A1IctServicesController.prototype, "findServicesByType", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/search/datacenter'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Find services by data center' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'dcId', description: 'Data center ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Services found by data center',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('dcId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], A1IctServicesController.prototype, "findServicesByDataCenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services/:id/calculate-cost'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Calculate service cost' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service cost calculated',
        schema: {
            type: 'object',
            properties: {
                monthlyCost: { type: 'number' },
                totalCost: { type: 'number' },
                setupCost: { type: 'number' },
                bandwidthCost: { type: 'number' },
                breakdown: { type: 'object' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], A1IctServicesController.prototype, "calculateServiceCost", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/availability'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check service availability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service availability status',
        schema: {
            type: 'object',
            properties: {
                available: { type: 'boolean' },
                currentCapacity: { type: 'object' },
                usedCapacity: { type: 'object' },
                utilization: { type: 'object' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], A1IctServicesController.prototype, "checkServiceAvailability", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services/:id/scale'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Scale service resources' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service scaled successfully',
        type: Object,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], A1IctServicesController.prototype, "scaleService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/backup-status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get backup status for a service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Backup status retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], A1IctServicesController.prototype, "getBackupStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services/:id/backup'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Trigger backup for a service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Backup triggered successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_q = typeof Promise !== "undefined" && Promise) === "function" ? _q : Object)
], A1IctServicesController.prototype, "triggerBackup", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/recovery-points'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get available recovery points' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Recovery points retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], A1IctServicesController.prototype, "getRecoveryPoints", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services/:id/recover'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Recover service from backup' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Service recovery initiated' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_s = typeof Promise !== "undefined" && Promise) === "function" ? _s : Object)
], A1IctServicesController.prototype, "recoverService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/performance'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get service performance metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance metrics retrieved',
        schema: {
            type: 'object',
            properties: {
                cpu: { type: 'object' },
                memory: { type: 'object' },
                storage: { type: 'object' },
                network: { type: 'object' },
                sla: { type: 'object' },
            },
        },
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], A1IctServicesController.prototype, "getPerformanceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/requests'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get service requests' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service requests retrieved',
        type: [Object],
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_u = typeof Promise !== "undefined" && Promise) === "function" ? _u : Object)
], A1IctServicesController.prototype, "getServiceRequests", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('services/:id/requests'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create service request' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Service request created successfully',
        type: Object,
    }),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpCode)(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.CREATED),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_v = typeof Promise !== "undefined" && Promise) === "function" ? _v : Object)
], A1IctServicesController.prototype, "createServiceRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/:id/requests/:requestId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get service request by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'requestId', description: 'Request ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service request found',
        type: Object,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('requestId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_w = typeof Promise !== "undefined" && Promise) === "function" ? _w : Object)
], A1IctServicesController.prototype, "getServiceRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('services/:id/requests/:requestId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update service request' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Service ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'requestId', description: 'Request ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service request updated successfully',
        type: Object,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('requestId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", typeof (_x = typeof Promise !== "undefined" && Promise) === "function" ? _x : Object)
], A1IctServicesController.prototype, "updateServiceRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/analytics/overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get services analytics overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Analytics overview retrieved',
        schema: {
            type: 'object',
            properties: {
                totalServices: { type: 'number' },
                activeServices: { type: 'number' },
                servicesByType: { type: 'object' },
                servicesByLocation: { type: 'object' },
                servicesByTier: { type: 'object' },
                totalRequests: { type: 'number' },
                requestsByStatus: { type: 'object' },
                averageSLA: { type: 'object' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_y = typeof Promise !== "undefined" && Promise) === "function" ? _y : Object)
], A1IctServicesController.prototype, "getServicesAnalytics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/analytics/performance'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get services performance analytics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance analytics retrieved',
        schema: {
            type: 'object',
            properties: {
                averageCPU: { type: 'number' },
                averageMemory: { type: 'number' },
                averageStorage: { type: 'number' },
                averageNetwork: { type: 'number' },
                slaCompliance: { type: 'number' },
                costEfficiency: { type: 'number' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_z = typeof Promise !== "undefined" && Promise) === "function" ? _z : Object)
], A1IctServicesController.prototype, "getPerformanceAnalytics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('services/analytics/costs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get services cost analytics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Cost analytics retrieved',
        schema: {
            type: 'object',
            properties: {
                totalMonthlyCost: { type: 'number' },
                costByService: { type: 'object' },
                costByType: { type: 'object' },
                costTrends: { type: 'array' },
                savings: { type: 'number' },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_0 = typeof Promise !== "undefined" && Promise) === "function" ? _0 : Object)
], A1IctServicesController.prototype, "getCostAnalytics", null);
A1IctServicesController = A1IctServicesController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('A1 ICT Services'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('a1-ict-services'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_4__.A1IctServicesService !== "undefined" && _services_a1_ict_services_service__WEBPACK_IMPORTED_MODULE_4__.A1IctServicesService) === "function" ? _a : Object])
], A1IctServicesController);



/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateA1IctServiceDto: () => (/* binding */ CreateA1IctServiceDto)
/* harmony export */ });
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;

class CreateA1IctServiceDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsIn)(['DRaaS', 'BaaS', 'TierIII-DC']),
    __metadata("design:type", String)
], CreateA1IctServiceDto.prototype, "type", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateA1IctServiceDto.prototype, "dcId", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsObject)(),
    __metadata("design:type", Object)
], CreateA1IctServiceDto.prototype, "configuration", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsNumber)(),
    __metadata("design:type", Number)
], CreateA1IctServiceDto.prototype, "cost", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsDateString)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CreateA1IctServiceDto.prototype, "contractEndDate", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateA1IctServiceDto.prototype, "name", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_0__.IsString)(),
    __metadata("design:type", String)
], CreateA1IctServiceDto.prototype, "status", void 0);


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UpdateA1IctServiceDto: () => (/* binding */ UpdateA1IctServiceDto)
/* harmony export */ });
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _create_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113);


class UpdateA1IctServiceDto extends (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_0__.PartialType)(_create_a1_ict_service_dto__WEBPACK_IMPORTED_MODULE_1__.CreateA1IctServiceDto) {
}


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FeatureFlagsModule: () => (/* binding */ FeatureFlagsModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config_snapshot_testing_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(116);
/* harmony import */ var _env_schema_generator_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(133);
/* harmony import */ var _feature_flags_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(134);
/* harmony import */ var _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(135);
/* harmony import */ var _test_fixtures_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(136);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






let FeatureFlagsModule = class FeatureFlagsModule {
};
FeatureFlagsModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        providers: [
            _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__.FeatureFlagsService,
            _config_snapshot_testing_service__WEBPACK_IMPORTED_MODULE_1__.ConfigSnapshotTestingService,
            _test_fixtures_service__WEBPACK_IMPORTED_MODULE_5__.TestFixturesService,
            _env_schema_generator_service__WEBPACK_IMPORTED_MODULE_2__.EnvSchemaGeneratorService,
        ],
        controllers: [_feature_flags_controller__WEBPACK_IMPORTED_MODULE_3__.FeatureFlagsController],
        exports: [
            _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__.FeatureFlagsService,
            _config_snapshot_testing_service__WEBPACK_IMPORTED_MODULE_1__.ConfigSnapshotTestingService,
            _test_fixtures_service__WEBPACK_IMPORTED_MODULE_5__.TestFixturesService,
            _env_schema_generator_service__WEBPACK_IMPORTED_MODULE_2__.EnvSchemaGeneratorService,
        ],
    })
], FeatureFlagsModule);



/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigSnapshotTestingService: () => (/* binding */ ConfigSnapshotTestingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config_env_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ConfigSnapshotTestingService_1;


let ConfigSnapshotTestingService = ConfigSnapshotTestingService_1 = class ConfigSnapshotTestingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ConfigSnapshotTestingService_1.name);
        this.snapshots = new Map();
        this.tests = new Map();
        this.results = [];
        this.initializeDefaultSnapshots();
        this.initializeDefaultTests();
    }
    async createSnapshot(name, description) {
        const config = (0,_config_env_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
        const configObj = JSON.parse(JSON.stringify(config));
        const checksum = this.calculateChecksum(configObj);
        const snapshot = {
            id: this.generateId(),
            name,
            description: description ?? '',
            config: configObj,
            timestamp: new Date(),
            environment: process.env.NODE_ENV ?? 'development',
            version: process.env.npm_package_version ?? '1.0.0',
            checksum,
        };
        this.snapshots.set(snapshot.id, snapshot);
        this.logger.log(`Created config snapshot: ${snapshot.id}`, {
            name,
            checksum,
        });
        return snapshot;
    }
    getSnapshot(snapshotId) {
        return this.snapshots.get(snapshotId);
    }
    getAllSnapshots() {
        return Array.from(this.snapshots.values());
    }
    createTest(test) {
        const testWithId = {
            ...test,
            id: this.generateId(),
        };
        this.tests.set(testWithId.id, testWithId);
        this.logger.log(`Created config test: ${testWithId.id}`, {
            name: test.name,
        });
        return testWithId;
    }
    async runTest(testId) {
        const test = this.tests.get(testId);
        if (!test) {
            throw new Error(`Test not found: ${testId}`);
        }
        const snapshot = this.snapshots.get(test.snapshotId);
        if (!snapshot) {
            throw new Error(`Snapshot not found: ${test.snapshotId}`);
        }
        const startTime = Date.now();
        let passed = false;
        let error;
        try {
            const result = await Promise.race([
                test.testFunction(snapshot.config),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), test.timeout ?? 5000)),
            ]);
            passed = result === test.expectedResult;
        }
        catch (err) {
            error = err instanceof Error ? err.message : 'Unknown error';
            passed = false;
        }
        const duration = Date.now() - startTime;
        const result = {
            testId,
            snapshotId: test.snapshotId,
            passed,
            duration,
            error: error ?? '',
            timestamp: new Date(),
            configUsed: snapshot.config,
        };
        this.results.push(result);
        this.logger.log(`Test completed: ${testId}`, { passed, duration, error });
        return result;
    }
    async runAllTests(snapshotId) {
        const tests = Array.from(this.tests.values()).filter(test => test.snapshotId === snapshotId);
        const results = [];
        for (const test of tests) {
            const result = await this.runTest(test.id);
            results.push(result);
        }
        return results;
    }
    getTestResults(testId) {
        if (testId != null && testId !== '') {
            return this.results.filter(result => result.testId === testId);
        }
        return this.results;
    }
    compareSnapshots(snapshotId1, snapshotId2) {
        const snapshot1 = this.snapshots.get(snapshotId1);
        const snapshot2 = this.snapshots.get(snapshotId2);
        if (!snapshot1 || !snapshot2) {
            throw new Error('One or both snapshots not found');
        }
        const keys1 = Object.keys(snapshot1.config);
        const keys2 = Object.keys(snapshot2.config);
        const added = keys2.filter(key => !keys1.includes(key));
        const removed = keys1.filter(key => !keys2.includes(key));
        const unchanged = keys1.filter(key => keys2.includes(key) &&
            JSON.stringify(snapshot1.config[key]) ===
                JSON.stringify(snapshot2.config[key]));
        const differences = {};
        keys1.forEach(key => {
            if (keys2.includes(key) && !unchanged.includes(key)) {
                differences[key] = {
                    old: snapshot1.config[key],
                    new: snapshot2.config[key],
                };
            }
        });
        return { differences, added, removed, unchanged };
    }
    validateSnapshot(snapshotId) {
        const snapshot = this.snapshots.get(snapshotId);
        if (!snapshot)
            return false;
        const currentChecksum = this.calculateChecksum(snapshot.config);
        return currentChecksum === snapshot.checksum;
    }
    cleanupOldSnapshots(maxAge) {
        const cutoff = new Date(Date.now() - maxAge);
        let deleted = 0;
        for (const [id, snapshot] of this.snapshots.entries()) {
            if (snapshot.timestamp < cutoff) {
                this.snapshots.delete(id);
                deleted++;
            }
        }
        this.logger.log(`Cleaned up ${deleted} old snapshots`);
        return deleted;
    }
    initializeDefaultSnapshots() {
        void this.createSnapshot('initial', 'Initial configuration snapshot');
    }
    initializeDefaultTests() {
        this.createTest({
            snapshotId: 'initial',
            name: 'Required Environment Variables',
            description: 'Check that all required environment variables are present',
            testFunction: config => {
                const required = ['NODE_ENV', 'PORT', 'DATABASE_URL'];
                return required.every(key => config[key] != null && config[key] !== '');
            },
            expectedResult: true,
        });
        this.createTest({
            snapshotId: 'initial',
            name: 'Configuration Validation',
            description: 'Validate that configuration is properly structured',
            testFunction: config => {
                return typeof config === 'object';
            },
            expectedResult: true,
        });
    }
    generateId() {
        return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    calculateChecksum(obj) {
        const str = JSON.stringify(obj, Object.keys(obj).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }
        return hash.toString(36);
    }
};
ConfigSnapshotTestingService = ConfigSnapshotTestingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ConfigSnapshotTestingService);



/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getConfig: () => (/* binding */ getConfig),
/* harmony export */   getDatabaseConfig: () => (/* binding */ getDatabaseConfig),
/* harmony export */   getFeatureFlagsConfig: () => (/* binding */ getFeatureFlagsConfig),
/* harmony export */   getMonitoringConfig: () => (/* binding */ getMonitoringConfig),
/* harmony export */   getRedisConfig: () => (/* binding */ getRedisConfig),
/* harmony export */   getSecurityConfig: () => (/* binding */ getSecurityConfig),
/* harmony export */   isFeatureEnabled: () => (/* binding */ isFeatureEnabled),
/* harmony export */   validateAndLoadConfig: () => (/* binding */ validateAndLoadConfig),
/* harmony export */   validateProductionEnv: () => (/* binding */ validateProductionEnv)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(118);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);

const envSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({
    NODE_ENV: zod__WEBPACK_IMPORTED_MODULE_0__["enum"](['development', 'production', 'test'])
        .default('development'),
    PORT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(3001),
    DATABASE_URL: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DB_HOST: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DB_PORT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).optional(),
    DB_NAME: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DB_USER: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DB_PASSWORD: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SUPABASE_URL: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SUPABASE_ANON_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SUPABASE_SERVICE_ROLE_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    REDIS_HOST: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('localhost'),
    REDIS_PORT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(6379),
    REDIS_PASSWORD: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    JWT_SECRET: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    JWT_EXPIRES_IN: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('1d'),
    SENTRY_DSN: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    JAEGER_ENDPOINT: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    ELASTICSEARCH_NODE: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    PROMETHEUS_GATEWAY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    ENCRYPTION_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    API_KEY_SECRET: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    FEATURE_NEW_DASHBOARD: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(false),
    FEATURE_AI_ANALYTICS: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(false),
    FEATURE_AUTO_SCALING: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(false),
    OPENAI_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    TELEGRAM_BOT_TOKEN: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SLACK_WEBHOOK_URL: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    RATE_LIMIT_TTL: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(60),
    RATE_LIMIT_LIMIT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(10),
    KONG_ADMIN_URL: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('http://localhost:8001'),
    KONG_PROXY_URL: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('http://localhost:8000'),
    KONG_ADMIN_PORT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(8001),
    KONG_PROXY_PORT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(8000),
    CIRCUIT_BREAKER_TIMEOUT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(3000),
    CIRCUIT_BREAKER_ERROR_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(5),
    CIRCUIT_BREAKER_RESET_TIMEOUT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(60000),
    CIRCUIT_BREAKER_VOLUME_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(10),
    RATE_LIMIT_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    RATE_LIMIT_MAX_REQUESTS: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(100),
    RATE_LIMIT_WINDOW_MS: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(60000),
    LOAD_BALANCER_ALGORITHM: zod__WEBPACK_IMPORTED_MODULE_0__["enum"](['round-robin', 'least-connections', 'weighted', 'ip-hash'])
        .default('round-robin'),
    LOAD_BALANCER_HEALTH_CHECK_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(30000),
    SERVICE_DISCOVERY_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    SERVICE_DISCOVERY_REFRESH_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(30000),
    DISASTER_RECOVERY_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    DISASTER_RECOVERY_RTO_TARGET: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(300000),
    DISASTER_RECOVERY_RPO_TARGET: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(60000),
    DISASTER_RECOVERY_MAX_FAILOVER_TIME: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(600000),
    DISASTER_RECOVERY_HEALTH_CHECK_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(30000),
    REGIONAL_FAILOVER_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    REGIONAL_FAILOVER_AUTO_SWITCH: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    REGIONAL_FAILOVER_MANUAL_OVERRIDE: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(false),
    REGIONAL_FAILOVER_NOTIFICATION_CHANNELS: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .default('email,telegram,slack'),
    NETWORK_RESILIENCE_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    NETWORK_RESILIENCE_BACKUP_CHANNELS: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    NETWORK_RESILIENCE_PEERING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    NETWORK_RESILIENCE_LATENCY_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(100),
    GEOGRAPHIC_ROUTING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    GEOGRAPHIC_ROUTING_DEFAULT_REGION: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('RU'),
    GEOGRAPHIC_ROUTING_FALLBACK_REGION: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('BY'),
    GEOGRAPHIC_ROUTING_LATENCY_WEIGHT: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(0.6),
    INCIDENT_RESPONSE_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    INCIDENT_RESPONSE_AUTO_ESCALATION: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    INCIDENT_RESPONSE_ESCALATION_TIMEOUT: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(300000),
    INCIDENT_RESPONSE_NOTIFICATION_CHANNELS: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .default('email,telegram,slack,sms'),
    CAPACITY_PLANNING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    CAPACITY_PLANNING_STRESS_TEST_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(86400000),
    CAPACITY_PLANNING_PERFORMANCE_BASELINE: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    CAPACITY_PLANNING_GROWTH_FORECAST: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(2592000000),
    A1_ICT_SERVICES_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    A1_ICT_DRaaS_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    A1_ICT_BaaS_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    A1_ICT_TIER_III_DC_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    A1_ICT_API_ENDPOINT: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('https://api.a1.by'),
    A1_ICT_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SELECTEL_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SELECTEL_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    VK_CLOUD_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    VK_CLOUD_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    BECLOUD_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    BECLOUD_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    ACTIVECLOUD_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    ACTIVECLOUD_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DATAHATA_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DATAHATA_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    A1_DIGITAL_ACCESS_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    A1_DIGITAL_SECRET_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    HOSTER_BY_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    HOSTER_BY_API_SECRET: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    A1_FLEX_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    A1_FLEX_API_SECRET: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DOMAIN_BY_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    DOMAIN_BY_API_SECRET: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    YANDEX_CLOUD_CDN_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    VK_CLOUD_CDN_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    NGENIX_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    CLOUDMTS_CDN_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    BECLOUD_CDN_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    ERIP_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    BEPAID_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    WEBPAY_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    OPLATI_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    CLOUDPAYMENTS_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    YUKASSA_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    YUMANI_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    TINKOFF_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SBERPAY_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SPB_API_KEY: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),
    SELF_HEALING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    SELF_HEALING_MAX_RETRIES: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(3),
    SELF_HEALING_RETRY_DELAY: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(5000),
    SELF_HEALING_HEALTH_CHECK_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(30000),
    AUTO_SCALING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    AUTO_SCALING_CPU_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(80),
    AUTO_SCALING_MEMORY_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(85),
    AUTO_SCALING_NETWORK_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(75),
    AUTO_SCALING_COOLDOWN_PERIOD: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(300000),
    RESOURCE_OPTIMIZATION_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    RESOURCE_OPTIMIZATION_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(300000),
    RESOURCE_OPTIMIZATION_CPU_TARGET: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(70),
    RESOURCE_OPTIMIZATION_MEMORY_TARGET: zod__WEBPACK_IMPORTED_MODULE_0__.string().transform(Number).default(75),
    COST_MANAGEMENT_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    COST_MANAGEMENT_BUDGET_ALERT_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(90),
    COST_MANAGEMENT_CURRENCY_UPDATE_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(3600000),
    AUTOMATED_MONITORING_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    AUTOMATED_MONITORING_CHECK_INTERVAL: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(60000),
    AUTOMATED_MONITORING_ALERT_COOLDOWN: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(300000),
    OPERATIONAL_RUNBOOKS_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    OPERATIONAL_RUNBOOKS_AUTO_EXECUTION: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(false),
    DEVOPS_INTEGRATION_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    DEVOPS_TERRAFORM_PATH: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('/usr/local/bin/terraform'),
    DEVOPS_ANSIBLE_PATH: zod__WEBPACK_IMPORTED_MODULE_0__.string().default('/usr/local/bin/ansible'),
    COST_OPTIMIZATION_AI_ENABLED: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    COST_OPTIMIZATION_AI_MODEL_PATH: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .default('./models/cost-optimization'),
    COST_OPTIMIZATION_AI_CONFIDENCE_THRESHOLD: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(Number)
        .default(0.8),
    LOG_LEVEL: zod__WEBPACK_IMPORTED_MODULE_0__["enum"](['error', 'warn', 'info', 'debug']).default('info'),
    LOG_FORMAT: zod__WEBPACK_IMPORTED_MODULE_0__["enum"](['json', 'pretty']).default('pretty'),
    ENABLE_SWAGGER: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
    ENABLE_CORS: zod__WEBPACK_IMPORTED_MODULE_0__.string()
        .transform(val => val === 'true')
        .default(true),
});
let validatedConfig = null;
function getConfig() {
    if (!validatedConfig) {
        throw new Error('Configuration not initialized. Call validateAndLoadConfig() first.');
    }
    return validatedConfig;
}
function validateAndLoadConfig() {
    try {
        const parsed = envSchema.parse(process.env);
        validatedConfig = parsed;
        return parsed;
    }
    catch (error) {
        if (error instanceof zod__WEBPACK_IMPORTED_MODULE_1__.ZodError) {
            const errorMessages = error.issues
                .map((err) => `${err.path.join('.')}: ${err.message}`)
                .join('\n');
            throw new Error(`Environment variables validation failed:\n${errorMessages}`);
        }
        throw error;
    }
}
function validateProductionEnv() {
    const config = getConfig();
    if (config.NODE_ENV === 'production') {
        const requiredForProduction = [
            'JWT_SECRET',
            'ENCRYPTION_KEY',
            'SENTRY_DSN',
        ];
        const missing = requiredForProduction.filter(key => {
            const value = process.env[key];
            return value == null || value === '';
        });
        if (missing.length > 0) {
            throw new Error(`Missing required environment variables for production: ${missing.join(', ')}`);
        }
    }
}
function getDatabaseConfig() {
    const config = getConfig();
    if (config.DATABASE_URL != null && config.DATABASE_URL !== '') {
        return { url: config.DATABASE_URL };
    }
    return {
        host: config.DB_HOST,
        port: config.DB_PORT,
        database: config.DB_NAME,
        username: config.DB_USER,
        password: config.DB_PASSWORD,
    };
}
function getRedisConfig() {
    const config = getConfig();
    return {
        host: config.REDIS_HOST,
        port: config.REDIS_PORT,
        password: config.REDIS_PASSWORD,
    };
}
function getFeatureFlagsConfig() {
    const config = getConfig();
    return {
        newDashboard: config.FEATURE_NEW_DASHBOARD,
        aiAnalytics: config.FEATURE_AI_ANALYTICS,
        autoScaling: config.FEATURE_AUTO_SCALING,
    };
}
function isFeatureEnabled(feature) {
    const features = getFeatureFlagsConfig();
    return features[feature];
}
function getSecurityConfig() {
    const config = getConfig();
    return {
        jwtSecret: config.JWT_SECRET,
        jwtExpiresIn: config.JWT_EXPIRES_IN,
        encryptionKey: config.ENCRYPTION_KEY,
        apiKeySecret: config.API_KEY_SECRET,
    };
}
function getMonitoringConfig() {
    const config = getConfig();
    return {
        sentryDsn: config.SENTRY_DSN,
        jaegerEndpoint: config.JAEGER_ENDPOINT,
        elasticsearchNode: config.ELASTICSEARCH_NODE,
        prometheusGateway: config.PROMETHEUS_GATEWAY,
    };
}


/***/ }),
/* 118 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZodAny: () => (/* binding */ ZodAny),
/* harmony export */   ZodArray: () => (/* binding */ ZodArray),
/* harmony export */   ZodBase64: () => (/* binding */ ZodBase64),
/* harmony export */   ZodBase64URL: () => (/* binding */ ZodBase64URL),
/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),
/* harmony export */   ZodBigIntFormat: () => (/* binding */ ZodBigIntFormat),
/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),
/* harmony export */   ZodCIDRv4: () => (/* binding */ ZodCIDRv4),
/* harmony export */   ZodCIDRv6: () => (/* binding */ ZodCIDRv6),
/* harmony export */   ZodCUID: () => (/* binding */ ZodCUID),
/* harmony export */   ZodCUID2: () => (/* binding */ ZodCUID2),
/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),
/* harmony export */   ZodCodec: () => (/* binding */ ZodCodec),
/* harmony export */   ZodCustom: () => (/* binding */ ZodCustom),
/* harmony export */   ZodCustomStringFormat: () => (/* binding */ ZodCustomStringFormat),
/* harmony export */   ZodDate: () => (/* binding */ ZodDate),
/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),
/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   ZodE164: () => (/* binding */ ZodE164),
/* harmony export */   ZodEmail: () => (/* binding */ ZodEmail),
/* harmony export */   ZodEmoji: () => (/* binding */ ZodEmoji),
/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),
/* harmony export */   ZodFile: () => (/* binding */ ZodFile),
/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),
/* harmony export */   ZodGUID: () => (/* binding */ ZodGUID),
/* harmony export */   ZodIPv4: () => (/* binding */ ZodIPv4),
/* harmony export */   ZodIPv6: () => (/* binding */ ZodIPv6),
/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),
/* harmony export */   ZodJWT: () => (/* binding */ ZodJWT),
/* harmony export */   ZodKSUID: () => (/* binding */ ZodKSUID),
/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),
/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),
/* harmony export */   ZodMap: () => (/* binding */ ZodMap),
/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),
/* harmony export */   ZodNanoID: () => (/* binding */ ZodNanoID),
/* harmony export */   ZodNever: () => (/* binding */ ZodNever),
/* harmony export */   ZodNonOptional: () => (/* binding */ ZodNonOptional),
/* harmony export */   ZodNull: () => (/* binding */ ZodNull),
/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),
/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),
/* harmony export */   ZodNumberFormat: () => (/* binding */ ZodNumberFormat),
/* harmony export */   ZodObject: () => (/* binding */ ZodObject),
/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),
/* harmony export */   ZodPipe: () => (/* binding */ ZodPipe),
/* harmony export */   ZodPrefault: () => (/* binding */ ZodPrefault),
/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),
/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),
/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),
/* harmony export */   ZodSet: () => (/* binding */ ZodSet),
/* harmony export */   ZodString: () => (/* binding */ ZodString),
/* harmony export */   ZodStringFormat: () => (/* binding */ ZodStringFormat),
/* harmony export */   ZodSuccess: () => (/* binding */ ZodSuccess),
/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),
/* harmony export */   ZodTemplateLiteral: () => (/* binding */ ZodTemplateLiteral),
/* harmony export */   ZodTransform: () => (/* binding */ ZodTransform),
/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),
/* harmony export */   ZodType: () => (/* binding */ ZodType),
/* harmony export */   ZodULID: () => (/* binding */ ZodULID),
/* harmony export */   ZodURL: () => (/* binding */ ZodURL),
/* harmony export */   ZodUUID: () => (/* binding */ ZodUUID),
/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),
/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),
/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),
/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),
/* harmony export */   ZodXID: () => (/* binding */ ZodXID),
/* harmony export */   _ZodString: () => (/* binding */ _ZodString),
/* harmony export */   _default: () => (/* binding */ _default),
/* harmony export */   _function: () => (/* binding */ _function),
/* harmony export */   any: () => (/* binding */ any),
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   base64: () => (/* binding */ base64),
/* harmony export */   base64url: () => (/* binding */ base64url),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   "catch": () => (/* binding */ _catch),
/* harmony export */   check: () => (/* binding */ check),
/* harmony export */   cidrv4: () => (/* binding */ cidrv4),
/* harmony export */   cidrv6: () => (/* binding */ cidrv6),
/* harmony export */   codec: () => (/* binding */ codec),
/* harmony export */   cuid: () => (/* binding */ cuid),
/* harmony export */   cuid2: () => (/* binding */ cuid2),
/* harmony export */   custom: () => (/* binding */ custom),
/* harmony export */   date: () => (/* binding */ date),
/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnion),
/* harmony export */   e164: () => (/* binding */ e164),
/* harmony export */   email: () => (/* binding */ email),
/* harmony export */   emoji: () => (/* binding */ emoji),
/* harmony export */   "enum": () => (/* binding */ _enum),
/* harmony export */   file: () => (/* binding */ file),
/* harmony export */   float32: () => (/* binding */ float32),
/* harmony export */   float64: () => (/* binding */ float64),
/* harmony export */   "function": () => (/* binding */ _function),
/* harmony export */   guid: () => (/* binding */ guid),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   hex: () => (/* binding */ hex),
/* harmony export */   hostname: () => (/* binding */ hostname),
/* harmony export */   httpUrl: () => (/* binding */ httpUrl),
/* harmony export */   "instanceof": () => (/* binding */ _instanceof),
/* harmony export */   int: () => (/* binding */ int),
/* harmony export */   int32: () => (/* binding */ int32),
/* harmony export */   int64: () => (/* binding */ int64),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   ipv4: () => (/* binding */ ipv4),
/* harmony export */   ipv6: () => (/* binding */ ipv6),
/* harmony export */   json: () => (/* binding */ json),
/* harmony export */   jwt: () => (/* binding */ jwt),
/* harmony export */   keyof: () => (/* binding */ keyof),
/* harmony export */   ksuid: () => (/* binding */ ksuid),
/* harmony export */   lazy: () => (/* binding */ lazy),
/* harmony export */   literal: () => (/* binding */ literal),
/* harmony export */   looseObject: () => (/* binding */ looseObject),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   nan: () => (/* binding */ nan),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   nativeEnum: () => (/* binding */ nativeEnum),
/* harmony export */   never: () => (/* binding */ never),
/* harmony export */   nonoptional: () => (/* binding */ nonoptional),
/* harmony export */   "null": () => (/* binding */ _null),
/* harmony export */   nullable: () => (/* binding */ nullable),
/* harmony export */   nullish: () => (/* binding */ nullish),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   optional: () => (/* binding */ optional),
/* harmony export */   partialRecord: () => (/* binding */ partialRecord),
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   prefault: () => (/* binding */ prefault),
/* harmony export */   preprocess: () => (/* binding */ preprocess),
/* harmony export */   promise: () => (/* binding */ promise),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   record: () => (/* binding */ record),
/* harmony export */   refine: () => (/* binding */ refine),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   strictObject: () => (/* binding */ strictObject),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   stringFormat: () => (/* binding */ stringFormat),
/* harmony export */   stringbool: () => (/* binding */ stringbool),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   superRefine: () => (/* binding */ superRefine),
/* harmony export */   symbol: () => (/* binding */ symbol),
/* harmony export */   templateLiteral: () => (/* binding */ templateLiteral),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   tuple: () => (/* binding */ tuple),
/* harmony export */   uint32: () => (/* binding */ uint32),
/* harmony export */   uint64: () => (/* binding */ uint64),
/* harmony export */   ulid: () => (/* binding */ ulid),
/* harmony export */   undefined: () => (/* binding */ _undefined),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   unknown: () => (/* binding */ unknown),
/* harmony export */   url: () => (/* binding */ url),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   uuidv4: () => (/* binding */ uuidv4),
/* harmony export */   uuidv6: () => (/* binding */ uuidv6),
/* harmony export */   uuidv7: () => (/* binding */ uuidv7),
/* harmony export */   "void": () => (/* binding */ _void),
/* harmony export */   xid: () => (/* binding */ xid)
/* harmony export */ });
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(124);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(132);
/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(129);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(123);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(122);
/* harmony import */ var _iso_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(119);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(130);





const ZodType = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodType", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodType.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    // base methods
    inst.check = (...checks) => {
        return inst.clone({
            ...def,
            checks: [
                ...(def.checks ?? []),
                ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
            ],
        }
        // { parent: true }
        );
    };
    inst.clone = (def, params) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.clone(inst, def, params);
    inst.brand = () => inst;
    inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
    });
    // parsing
    inst.parse = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.parse(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeParse(inst, data, params);
    inst.parseAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.parseAsync(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeParseAsync(inst, data, params);
    inst.spa = inst.safeParseAsync;
    // encoding/decoding
    inst.encode = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.encode(inst, data, params);
    inst.decode = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.decode(inst, data, params);
    inst.encodeAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.encodeAsync(inst, data, params);
    inst.decodeAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.decodeAsync(inst, data, params);
    inst.safeEncode = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeEncode(inst, data, params);
    inst.safeDecode = (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeDecode(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeEncodeAsync(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => _parse_js__WEBPACK_IMPORTED_MODULE_3__.safeDecodeAsync(inst, data, params);
    // refinements
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._overwrite(fn));
    // wrappers
    inst.optional = () => optional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def) => _default(inst, def);
    inst.prefault = (def) => prefault(inst, def);
    // inst.coalesce = (def, params) => coalesce(inst, def, params);
    inst.catch = (params) => _catch(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    // meta
    inst.describe = (description) => {
        const cl = inst.clone();
        _core_index_js__WEBPACK_IMPORTED_MODULE_5__.globalRegistry.add(cl, { description });
        return cl;
    };
    Object.defineProperty(inst, "description", {
        get() {
            return _core_index_js__WEBPACK_IMPORTED_MODULE_5__.globalRegistry.get(inst)?.description;
        },
        configurable: true,
    });
    inst.meta = (...args) => {
        if (args.length === 0) {
            return _core_index_js__WEBPACK_IMPORTED_MODULE_5__.globalRegistry.get(inst);
        }
        const cl = inst.clone();
        _core_index_js__WEBPACK_IMPORTED_MODULE_5__.globalRegistry.add(cl, args[0]);
        return cl;
    };
    // helpers
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
});
/** @internal */
const _ZodString = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("_ZodString", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodString.init(inst, def);
    ZodType.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    // validations
    inst.regex = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._regex(...args));
    inst.includes = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._includes(...args));
    inst.startsWith = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._startsWith(...args));
    inst.endsWith = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._endsWith(...args));
    inst.min = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minLength(...args));
    inst.max = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._maxLength(...args));
    inst.length = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._length(...args));
    inst.nonempty = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lowercase(params));
    inst.uppercase = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._uppercase(params));
    // transforms
    inst.trim = () => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._trim());
    inst.normalize = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._normalize(...args));
    inst.toLowerCase = () => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._toLowerCase());
    inst.toUpperCase = () => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._toUpperCase());
});
const ZodString = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodString", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._email(ZodEmail, params));
    inst.url = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._url(ZodURL, params));
    inst.jwt = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._emoji(ZodEmoji, params));
    inst.guid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._e164(ZodE164, params));
    // iso
    inst.datetime = (params) => inst.check(_iso_js__WEBPACK_IMPORTED_MODULE_6__.datetime(params));
    inst.date = (params) => inst.check(_iso_js__WEBPACK_IMPORTED_MODULE_6__.date(params));
    inst.time = (params) => inst.check(_iso_js__WEBPACK_IMPORTED_MODULE_6__.time(params));
    inst.duration = (params) => inst.check(_iso_js__WEBPACK_IMPORTED_MODULE_6__.duration(params));
});
function string(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._string(ZodString, params);
}
const ZodStringFormat = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodStringFormat", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
});
const ZodEmail = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodEmail", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function email(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._email(ZodEmail, params);
}
const ZodGUID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodGUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function guid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._guid(ZodGUID, params);
}
const ZodUUID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodUUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function uuid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uuid(ZodUUID, params);
}
function uuidv4(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv4(ZodUUID, params);
}
// ZodUUIDv6
function uuidv6(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv6(ZodUUID, params);
}
// ZodUUIDv7
function uuidv7(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uuidv7(ZodUUID, params);
}
const ZodURL = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodURL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function url(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._url(ZodURL, params);
}
function httpUrl(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._url(ZodURL, {
        protocol: /^https?$/,
        hostname: _core_index_js__WEBPACK_IMPORTED_MODULE_7__.domain,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodEmoji = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodEmoji", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function emoji(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._emoji(ZodEmoji, params);
}
const ZodNanoID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNanoID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function nanoid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._nanoid(ZodNanoID, params);
}
const ZodCUID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function cuid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._cuid(ZodCUID, params);
}
const ZodCUID2 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCUID2", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function cuid2(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._cuid2(ZodCUID2, params);
}
const ZodULID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodULID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function ulid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._ulid(ZodULID, params);
}
const ZodXID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodXID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function xid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._xid(ZodXID, params);
}
const ZodKSUID = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodKSUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function ksuid(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._ksuid(ZodKSUID, params);
}
const ZodIPv4 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodIPv4", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function ipv4(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._ipv4(ZodIPv4, params);
}
const ZodIPv6 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodIPv6", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function ipv6(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._ipv6(ZodIPv6, params);
}
const ZodCIDRv4 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCIDRv4", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function cidrv4(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._cidrv4(ZodCIDRv4, params);
}
const ZodCIDRv6 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCIDRv6", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function cidrv6(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._cidrv6(ZodCIDRv6, params);
}
const ZodBase64 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodBase64", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function base64(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._base64(ZodBase64, params);
}
const ZodBase64URL = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodBase64URL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function base64url(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._base64url(ZodBase64URL, params);
}
const ZodE164 = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodE164", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function e164(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._e164(ZodE164, params);
}
const ZodJWT = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodJWT", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function jwt(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._jwt(ZodJWT, params);
}
const ZodCustomStringFormat = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCustomStringFormat", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname(_params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._stringFormat(ZodCustomStringFormat, "hostname", _core_index_js__WEBPACK_IMPORTED_MODULE_7__.hostname, _params);
}
function hex(_params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._stringFormat(ZodCustomStringFormat, "hex", _core_index_js__WEBPACK_IMPORTED_MODULE_7__.hex, _params);
}
function hash(alg, params) {
    const enc = params?.enc ?? "hex";
    const format = `${alg}_${enc}`;
    const regex = _core_index_js__WEBPACK_IMPORTED_MODULE_7__[format];
    if (!regex)
        throw new Error(`Unrecognized hash format: ${format}`);
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._stringFormat(ZodCustomStringFormat, format, regex, params);
}
const ZodNumber = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNumber", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst.gt = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gt(value, params));
    inst.gte = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.min = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.lt = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lt(value, params));
    inst.lte = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(value, params));
    inst.max = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gt(0, params));
    inst.nonnegative = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(0, params));
    inst.negative = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lt(0, params));
    inst.nonpositive = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._multipleOf(value, params));
    inst.step = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._multipleOf(value, params));
    // inst.finite = (params) => inst.check(core.finite(params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue =
        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue =
        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
});
function number(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._number(ZodNumber, params);
}
const ZodNumberFormat = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNumberFormat", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
});
function int(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._int(ZodNumberFormat, params);
}
function float32(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._float32(ZodNumberFormat, params);
}
function float64(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._float64(ZodNumberFormat, params);
}
function int32(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._int32(ZodNumberFormat, params);
}
function uint32(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uint32(ZodNumberFormat, params);
}
const ZodBoolean = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodBoolean", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
});
function boolean(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._boolean(ZodBoolean, params);
}
const ZodBigInt = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodBigInt", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst.gte = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.min = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.gt = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gt(value, params));
    inst.gte = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.min = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.lt = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lt(value, params));
    inst.lte = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(value, params));
    inst.max = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(value, params));
    inst.positive = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
});
function bigint(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._bigint(ZodBigInt, params);
}
const ZodBigIntFormat = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodBigIntFormat", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
});
// int64
function int64(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._int64(ZodBigIntFormat, params);
}
// uint64
function uint64(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._uint64(ZodBigIntFormat, params);
}
const ZodSymbol = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodSymbol", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
});
function symbol(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._symbol(ZodSymbol, params);
}
const ZodUndefined = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodUndefined", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
});
function _undefined(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._undefined(ZodUndefined, params);
}

const ZodNull = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNull", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNull.init(inst, def);
    ZodType.init(inst, def);
});
function _null(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._null(ZodNull, params);
}

const ZodAny = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodAny", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodAny.init(inst, def);
    ZodType.init(inst, def);
});
function any() {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._any(ZodAny);
}
const ZodUnknown = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodUnknown", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
});
function unknown() {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._unknown(ZodUnknown);
}
const ZodNever = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNever", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNever.init(inst, def);
    ZodType.init(inst, def);
});
function never(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._never(ZodNever, params);
}
const ZodVoid = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodVoid", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodVoid.init(inst, def);
    ZodType.init(inst, def);
});
function _void(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._void(ZodVoid, params);
}

const ZodDate = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodDate", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._gte(value, params));
    inst.max = (value, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._date(ZodDate, params);
}
const ZodArray = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodArray", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._length(len, params));
    inst.unwrap = () => inst.element;
});
function array(element, params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._array(ZodArray, element, params);
}
// .keyof
function keyof(schema) {
    const shape = schema._zod.def.shape;
    return _enum(Object.keys(shape));
}
const ZodObject = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodObject", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst, "shape", () => def.shape);
    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
        return _core_index_js__WEBPACK_IMPORTED_MODULE_2__.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
        return _core_index_js__WEBPACK_IMPORTED_MODULE_2__.safeExtend(inst, incoming);
    };
    inst.merge = (other) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.merge(inst, other);
    inst.pick = (mask) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.pick(inst, mask);
    inst.omit = (mask) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.omit(inst, mask);
    inst.partial = (...args) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => _core_index_js__WEBPACK_IMPORTED_MODULE_2__.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
    const def = {
        type: "object",
        get shape() {
            _core_index_js__WEBPACK_IMPORTED_MODULE_2__.assignProp(this, "shape", shape ? _core_index_js__WEBPACK_IMPORTED_MODULE_2__.objectClone(shape) : {});
            return this.shape;
        },
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    };
    return new ZodObject(def);
}
// strictObject
function strictObject(shape, params) {
    return new ZodObject({
        type: "object",
        get shape() {
            _core_index_js__WEBPACK_IMPORTED_MODULE_2__.assignProp(this, "shape", _core_index_js__WEBPACK_IMPORTED_MODULE_2__.objectClone(shape));
            return this.shape;
        },
        catchall: never(),
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
// looseObject
function looseObject(shape, params) {
    return new ZodObject({
        type: "object",
        get shape() {
            _core_index_js__WEBPACK_IMPORTED_MODULE_2__.assignProp(this, "shape", _core_index_js__WEBPACK_IMPORTED_MODULE_2__.objectClone(shape));
            return this.shape;
        },
        catchall: unknown(),
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodUnion = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodUnion", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst.options = def.options;
});
function union(options, params) {
    return new ZodUnion({
        type: "union",
        options: options,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodDiscriminatedUnion = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
    // const [options, params] = args;
    return new ZodDiscriminatedUnion({
        type: "union",
        options,
        discriminator,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodIntersection = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodIntersection", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
});
function intersection(left, right) {
    return new ZodIntersection({
        type: "intersection",
        left: left,
        right: right,
    });
}
const ZodTuple = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodTuple", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest: rest,
    });
});
function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
        type: "tuple",
        items: items,
        rest,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodRecord = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodRecord", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
    return new ZodRecord({
        type: "record",
        keyType,
        valueType: valueType,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
// type alksjf = core.output<core.$ZodRecordKey>;
function partialRecord(keyType, valueType, params) {
    const k = _core_index_js__WEBPACK_IMPORTED_MODULE_2__.clone(keyType);
    k._zod.values = undefined;
    return new ZodRecord({
        type: "record",
        keyType: k,
        valueType: valueType,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodMap = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodMap", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
    return new ZodMap({
        type: "map",
        keyType: keyType,
        valueType: valueType,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodSet = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodSet", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minSize(...args));
    inst.nonempty = (params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minSize(1, params));
    inst.max = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._maxSize(...args));
    inst.size = (...args) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._size(...args));
});
function set(valueType, params) {
    return new ZodSet({
        type: "set",
        valueType: valueType,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodEnum = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodEnum", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
            if (keys.has(value)) {
                newEntries[value] = def.entries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
            entries: newEntries,
        });
    };
    inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
            if (keys.has(value)) {
                delete newEntries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
            entries: newEntries,
        });
    };
});
function _enum(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
        type: "enum",
        entries,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}

/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
function nativeEnum(entries, params) {
    return new ZodEnum({
        type: "enum",
        entries,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodLiteral = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodLiteral", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
        get() {
            if (def.values.length > 1) {
                throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
            }
            return def.values[0];
        },
    });
});
function literal(value, params) {
    return new ZodLiteral({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodFile = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodFile", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (size, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._minSize(size, params));
    inst.max = (size, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._maxSize(size, params));
    inst.mime = (types, params) => inst.check(_checks_js__WEBPACK_IMPORTED_MODULE_4__._mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._file(ZodFile, params);
}
const ZodTransform = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodTransform", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
            throw new _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue) => {
            if (typeof issue === "string") {
                payload.issues.push(_core_index_js__WEBPACK_IMPORTED_MODULE_2__.issue(issue, payload.value, def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = inst);
                // _issue.continue ??= true;
                payload.issues.push(_core_index_js__WEBPACK_IMPORTED_MODULE_2__.issue(_issue));
            }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        payload.value = output;
        return payload;
    };
});
function transform(fn) {
    return new ZodTransform({
        type: "transform",
        transform: fn,
    });
}
const ZodOptional = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodOptional", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
    return new ZodOptional({
        type: "optional",
        innerType: innerType,
    });
}
const ZodNullable = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNullable", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
    return new ZodNullable({
        type: "nullable",
        innerType: innerType,
    });
}
// nullish
function nullish(innerType) {
    return optional(nullable(innerType));
}
const ZodDefault = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodDefault", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
    return new ZodDefault({
        type: "default",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : _core_index_js__WEBPACK_IMPORTED_MODULE_2__.shallowClone(defaultValue);
        },
    });
}
const ZodPrefault = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodPrefault", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
    return new ZodPrefault({
        type: "prefault",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : _core_index_js__WEBPACK_IMPORTED_MODULE_2__.shallowClone(defaultValue);
        },
    });
}
const ZodNonOptional = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNonOptional", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
    return new ZodNonOptional({
        type: "nonoptional",
        innerType: innerType,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodSuccess = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodSuccess", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
    return new ZodSuccess({
        type: "success",
        innerType: innerType,
    });
}
const ZodCatch = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCatch", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
    return new ZodCatch({
        type: "catch",
        innerType: innerType,
        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
    });
}

const ZodNaN = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodNaN", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodNaN.init(inst, def);
    ZodType.init(inst, def);
});
function nan(params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._nan(ZodNaN, params);
}
const ZodPipe = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodPipe", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
});
function pipe(in_, out) {
    return new ZodPipe({
        type: "pipe",
        in: in_,
        out: out,
        // ...util.normalizeParams(params),
    });
}
const ZodCodec = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
    return new ZodCodec({
        type: "pipe",
        in: in_,
        out: out,
        transform: params.decode,
        reverseTransform: params.encode,
    });
}
const ZodReadonly = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodReadonly", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
    return new ZodReadonly({
        type: "readonly",
        innerType: innerType,
    });
}
const ZodTemplateLiteral = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodTemplateLiteral", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
    return new ZodTemplateLiteral({
        type: "template_literal",
        parts,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
}
const ZodLazy = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodLazy", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
    return new ZodLazy({
        type: "lazy",
        getter: getter,
    });
}
const ZodPromise = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodPromise", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
    return new ZodPromise({
        type: "promise",
        innerType: innerType,
    });
}
const ZodFunction = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodFunction", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodFunction.init(inst, def);
    ZodType.init(inst, def);
});
function _function(params) {
    return new ZodFunction({
        type: "function",
        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),
        output: params?.output ?? unknown(),
    });
}

const ZodCustom = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodCustom", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCustom.init(inst, def);
    ZodType.init(inst, def);
});
// custom checks
function check(fn) {
    const ch = new _core_index_js__WEBPACK_IMPORTED_MODULE_8__.$ZodCheck({
        check: "custom",
        // ...util.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
}
function custom(fn, _params) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._refine(ZodCustom, fn, _params);
}
// superRefine
function superRefine(fn) {
    return _checks_js__WEBPACK_IMPORTED_MODULE_4__._superRefine(fn);
}
function _instanceof(cls, params = {
    error: `Input not instance of ${cls.name}`,
}) {
    const inst = new ZodCustom({
        type: "custom",
        check: "custom",
        fn: (data) => data instanceof cls,
        abort: true,
        ..._core_index_js__WEBPACK_IMPORTED_MODULE_2__.normalizeParams(params),
    });
    inst._zod.bag.Class = cls;
    return inst;
}

// stringbool
const stringbool = (...args) => _checks_js__WEBPACK_IMPORTED_MODULE_4__._stringbool({
    Codec: ZodCodec,
    Boolean: ZodBoolean,
    String: ZodString,
}, ...args);
function json(params) {
    const jsonSchema = lazy(() => {
        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);
    });
    return jsonSchema;
}
// preprocess
// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */
function preprocess(fn, schema) {
    return pipe(transform(fn), schema);
}


/***/ }),
/* 119 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZodISODate: () => (/* binding */ ZodISODate),
/* harmony export */   ZodISODateTime: () => (/* binding */ ZodISODateTime),
/* harmony export */   ZodISODuration: () => (/* binding */ ZodISODuration),
/* harmony export */   ZodISOTime: () => (/* binding */ ZodISOTime),
/* harmony export */   date: () => (/* binding */ date),
/* harmony export */   datetime: () => (/* binding */ datetime),
/* harmony export */   duration: () => (/* binding */ duration),
/* harmony export */   time: () => (/* binding */ time)
/* harmony export */ });
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(129);
/* harmony import */ var _schemas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);


const ZodISODateTime = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodISODateTime", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodISODateTime.init(inst, def);
    _schemas_js__WEBPACK_IMPORTED_MODULE_2__.ZodStringFormat.init(inst, def);
});
function datetime(params) {
    return _core_index_js__WEBPACK_IMPORTED_MODULE_3__._isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodISODate", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodISODate.init(inst, def);
    _schemas_js__WEBPACK_IMPORTED_MODULE_2__.ZodStringFormat.init(inst, def);
});
function date(params) {
    return _core_index_js__WEBPACK_IMPORTED_MODULE_3__._isoDate(ZodISODate, params);
}
const ZodISOTime = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodISOTime", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodISOTime.init(inst, def);
    _schemas_js__WEBPACK_IMPORTED_MODULE_2__.ZodStringFormat.init(inst, def);
});
function time(params) {
    return _core_index_js__WEBPACK_IMPORTED_MODULE_3__._isoTime(ZodISOTime, params);
}
const ZodISODuration = /*@__PURE__*/ _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("ZodISODuration", (inst, def) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_1__.$ZodISODuration.init(inst, def);
    _schemas_js__WEBPACK_IMPORTED_MODULE_2__.ZodStringFormat.init(inst, def);
});
function duration(params) {
    return _core_index_js__WEBPACK_IMPORTED_MODULE_3__._isoDuration(ZodISODuration, params);
}


/***/ }),
/* 120 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ZodAsyncError: () => (/* binding */ $ZodAsyncError),
/* harmony export */   $ZodEncodeError: () => (/* binding */ $ZodEncodeError),
/* harmony export */   $brand: () => (/* binding */ $brand),
/* harmony export */   $constructor: () => (/* binding */ $constructor),
/* harmony export */   NEVER: () => (/* binding */ NEVER),
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   globalConfig: () => (/* binding */ globalConfig)
/* harmony export */ });
/** A special constant with type `never` */
const NEVER = Object.freeze({
    status: "aborted",
});
function $constructor(name, initializer, params) {
    function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
            value: inst._zod ?? {},
            enumerable: false,
        });
        (_a = inst._zod).traits ?? (_a.traits = new Set());
        inst._zod.traits.add(name);
        initializer(inst, def);
        // support prototype modifications
        for (const k in _.prototype) {
            if (!(k in inst))
                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
    }
    // doesn't work if Parent has a constructor with arguments
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
        var _a;
        const inst = params?.Parent ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
            fn();
        }
        return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
            if (params?.Parent && inst instanceof params.Parent)
                return true;
            return inst?._zod?.traits?.has(name);
        },
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
}
//////////////////////////////   UTILITIES   ///////////////////////////////////////
const $brand = Symbol("zod_brand");
class $ZodAsyncError extends Error {
    constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
}
class $ZodEncodeError extends Error {
    constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
    }
}
const globalConfig = {};
function config(newConfig) {
    if (newConfig)
        Object.assign(globalConfig, newConfig);
    return globalConfig;
}


/***/ }),
/* 121 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ZodAny: () => (/* binding */ $ZodAny),
/* harmony export */   $ZodArray: () => (/* binding */ $ZodArray),
/* harmony export */   $ZodBase64: () => (/* binding */ $ZodBase64),
/* harmony export */   $ZodBase64URL: () => (/* binding */ $ZodBase64URL),
/* harmony export */   $ZodBigInt: () => (/* binding */ $ZodBigInt),
/* harmony export */   $ZodBigIntFormat: () => (/* binding */ $ZodBigIntFormat),
/* harmony export */   $ZodBoolean: () => (/* binding */ $ZodBoolean),
/* harmony export */   $ZodCIDRv4: () => (/* binding */ $ZodCIDRv4),
/* harmony export */   $ZodCIDRv6: () => (/* binding */ $ZodCIDRv6),
/* harmony export */   $ZodCUID: () => (/* binding */ $ZodCUID),
/* harmony export */   $ZodCUID2: () => (/* binding */ $ZodCUID2),
/* harmony export */   $ZodCatch: () => (/* binding */ $ZodCatch),
/* harmony export */   $ZodCodec: () => (/* binding */ $ZodCodec),
/* harmony export */   $ZodCustom: () => (/* binding */ $ZodCustom),
/* harmony export */   $ZodCustomStringFormat: () => (/* binding */ $ZodCustomStringFormat),
/* harmony export */   $ZodDate: () => (/* binding */ $ZodDate),
/* harmony export */   $ZodDefault: () => (/* binding */ $ZodDefault),
/* harmony export */   $ZodDiscriminatedUnion: () => (/* binding */ $ZodDiscriminatedUnion),
/* harmony export */   $ZodE164: () => (/* binding */ $ZodE164),
/* harmony export */   $ZodEmail: () => (/* binding */ $ZodEmail),
/* harmony export */   $ZodEmoji: () => (/* binding */ $ZodEmoji),
/* harmony export */   $ZodEnum: () => (/* binding */ $ZodEnum),
/* harmony export */   $ZodFile: () => (/* binding */ $ZodFile),
/* harmony export */   $ZodFunction: () => (/* binding */ $ZodFunction),
/* harmony export */   $ZodGUID: () => (/* binding */ $ZodGUID),
/* harmony export */   $ZodIPv4: () => (/* binding */ $ZodIPv4),
/* harmony export */   $ZodIPv6: () => (/* binding */ $ZodIPv6),
/* harmony export */   $ZodISODate: () => (/* binding */ $ZodISODate),
/* harmony export */   $ZodISODateTime: () => (/* binding */ $ZodISODateTime),
/* harmony export */   $ZodISODuration: () => (/* binding */ $ZodISODuration),
/* harmony export */   $ZodISOTime: () => (/* binding */ $ZodISOTime),
/* harmony export */   $ZodIntersection: () => (/* binding */ $ZodIntersection),
/* harmony export */   $ZodJWT: () => (/* binding */ $ZodJWT),
/* harmony export */   $ZodKSUID: () => (/* binding */ $ZodKSUID),
/* harmony export */   $ZodLazy: () => (/* binding */ $ZodLazy),
/* harmony export */   $ZodLiteral: () => (/* binding */ $ZodLiteral),
/* harmony export */   $ZodMap: () => (/* binding */ $ZodMap),
/* harmony export */   $ZodNaN: () => (/* binding */ $ZodNaN),
/* harmony export */   $ZodNanoID: () => (/* binding */ $ZodNanoID),
/* harmony export */   $ZodNever: () => (/* binding */ $ZodNever),
/* harmony export */   $ZodNonOptional: () => (/* binding */ $ZodNonOptional),
/* harmony export */   $ZodNull: () => (/* binding */ $ZodNull),
/* harmony export */   $ZodNullable: () => (/* binding */ $ZodNullable),
/* harmony export */   $ZodNumber: () => (/* binding */ $ZodNumber),
/* harmony export */   $ZodNumberFormat: () => (/* binding */ $ZodNumberFormat),
/* harmony export */   $ZodObject: () => (/* binding */ $ZodObject),
/* harmony export */   $ZodObjectJIT: () => (/* binding */ $ZodObjectJIT),
/* harmony export */   $ZodOptional: () => (/* binding */ $ZodOptional),
/* harmony export */   $ZodPipe: () => (/* binding */ $ZodPipe),
/* harmony export */   $ZodPrefault: () => (/* binding */ $ZodPrefault),
/* harmony export */   $ZodPromise: () => (/* binding */ $ZodPromise),
/* harmony export */   $ZodReadonly: () => (/* binding */ $ZodReadonly),
/* harmony export */   $ZodRecord: () => (/* binding */ $ZodRecord),
/* harmony export */   $ZodSet: () => (/* binding */ $ZodSet),
/* harmony export */   $ZodString: () => (/* binding */ $ZodString),
/* harmony export */   $ZodStringFormat: () => (/* binding */ $ZodStringFormat),
/* harmony export */   $ZodSuccess: () => (/* binding */ $ZodSuccess),
/* harmony export */   $ZodSymbol: () => (/* binding */ $ZodSymbol),
/* harmony export */   $ZodTemplateLiteral: () => (/* binding */ $ZodTemplateLiteral),
/* harmony export */   $ZodTransform: () => (/* binding */ $ZodTransform),
/* harmony export */   $ZodTuple: () => (/* binding */ $ZodTuple),
/* harmony export */   $ZodType: () => (/* binding */ $ZodType),
/* harmony export */   $ZodULID: () => (/* binding */ $ZodULID),
/* harmony export */   $ZodURL: () => (/* binding */ $ZodURL),
/* harmony export */   $ZodUUID: () => (/* binding */ $ZodUUID),
/* harmony export */   $ZodUndefined: () => (/* binding */ $ZodUndefined),
/* harmony export */   $ZodUnion: () => (/* binding */ $ZodUnion),
/* harmony export */   $ZodUnknown: () => (/* binding */ $ZodUnknown),
/* harmony export */   $ZodVoid: () => (/* binding */ $ZodVoid),
/* harmony export */   $ZodXID: () => (/* binding */ $ZodXID),
/* harmony export */   clone: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_2__.clone),
/* harmony export */   isValidBase64: () => (/* binding */ isValidBase64),
/* harmony export */   isValidBase64URL: () => (/* binding */ isValidBase64URL),
/* harmony export */   isValidJWT: () => (/* binding */ isValidJWT)
/* harmony export */ });
/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(122);
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _doc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(125);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(126);
/* harmony import */ var _regexes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(123);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(124);
/* harmony import */ var _versions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(128);







const $ZodType = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def; // set _def property
    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
    inst._zod.version = _versions_js__WEBPACK_IMPORTED_MODULE_1__.version;
    const checks = [...(inst._zod.def.checks ?? [])];
    // if inst is itself a checks.$ZodCheck, run it as a check
    if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
    }
    for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
            fn(inst);
        }
    }
    if (checks.length === 0) {
        // deferred initializer
        // inst._zod.parse is not yet defined
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
            inst._zod.run = inst._zod.parse;
        });
    }
    else {
        const runChecks = (payload, checks, ctx) => {
            let isAborted = _util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(payload);
            let asyncResult;
            for (const ch of checks) {
                if (ch._zod.def.when) {
                    const shouldRun = ch._zod.def.when(payload);
                    if (!shouldRun)
                        continue;
                }
                else if (isAborted) {
                    continue;
                }
                const currLen = payload.issues.length;
                const _ = ch._zod.check(payload);
                if (_ instanceof Promise && ctx?.async === false) {
                    throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
                }
                if (asyncResult || _ instanceof Promise) {
                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                        await _;
                        const nextLen = payload.issues.length;
                        if (nextLen === currLen)
                            return;
                        if (!isAborted)
                            isAborted = _util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(payload, currLen);
                    });
                }
                else {
                    const nextLen = payload.issues.length;
                    if (nextLen === currLen)
                        continue;
                    if (!isAborted)
                        isAborted = _util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(payload, currLen);
                }
            }
            if (asyncResult) {
                return asyncResult.then(() => {
                    return payload;
                });
            }
            return payload;
        };
        // const handleChecksResult = (
        //   checkResult: ParsePayload,
        //   originalResult: ParsePayload,
        //   ctx: ParseContextInternal
        // ): util.MaybeAsync<ParsePayload> => {
        //   // if the checks mutated the value && there are no issues, re-parse the result
        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
        //     return inst._zod.parse(checkResult, ctx);
        //   return originalResult;
        // };
        const handleCanaryResult = (canary, payload, ctx) => {
            // abort if the canary is aborted
            if (_util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(canary)) {
                canary.aborted = true;
                return canary;
            }
            // run checks first, then
            const checkResult = runChecks(payload, checks, ctx);
            if (checkResult instanceof Promise) {
                if (ctx.async === false)
                    throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
            }
            return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
            if (ctx.skipChecks) {
                return inst._zod.parse(payload, ctx);
            }
            if (ctx.direction === "backward") {
                // run canary
                // initial pass (no checks)
                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
                if (canary instanceof Promise) {
                    return canary.then((canary) => {
                        return handleCanaryResult(canary, payload, ctx);
                    });
                }
                return handleCanaryResult(canary, payload, ctx);
            }
            // forward
            const result = inst._zod.parse(payload, ctx);
            if (result instanceof Promise) {
                if (ctx.async === false)
                    throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
                return result.then((result) => runChecks(result, checks, ctx));
            }
            return runChecks(result, checks, ctx);
        };
    }
    inst["~standard"] = {
        validate: (value) => {
            try {
                const r = (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.safeParse)(inst, value);
                return r.success ? { value: r.data } : { issues: r.error?.issues };
            }
            catch (_) {
                return (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.safeParseAsync)(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
            }
        },
        vendor: "zod",
        version: 1,
    };
});

const $ZodString = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? _regexes_js__WEBPACK_IMPORTED_MODULE_4__.string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
        if (def.coerce)
            try {
                payload.value = String(payload.value);
            }
            catch (_) { }
        if (typeof payload.value === "string")
            return payload;
        payload.issues.push({
            expected: "string",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
const $ZodStringFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodStringFormat", (inst, def) => {
    // check initialization must come first
    _checks_js__WEBPACK_IMPORTED_MODULE_5__.$ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
});
const $ZodGUID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.guid);
    $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
        const versionMap = {
            v1: 1,
            v2: 2,
            v3: 3,
            v4: 4,
            v5: 5,
            v6: 6,
            v7: 7,
            v8: 8,
        };
        const v = versionMap[def.version];
        if (v === undefined)
            throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.uuid(v));
    }
    else
        def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.uuid());
    $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.email);
    $ZodStringFormat.init(inst, def);
});
const $ZodURL = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        try {
            // Trim whitespace from input
            const trimmed = payload.value.trim();
            // @ts-ignore
            const url = new URL(trimmed);
            if (def.hostname) {
                def.hostname.lastIndex = 0;
                if (!def.hostname.test(url.hostname)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid hostname",
                        pattern: _regexes_js__WEBPACK_IMPORTED_MODULE_4__.hostname.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            if (def.protocol) {
                def.protocol.lastIndex = 0;
                if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid protocol",
                        pattern: def.protocol.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            // Set the output value based on normalize flag
            if (def.normalize) {
                // Use normalized URL
                payload.value = url.href;
            }
            else {
                // Preserve the original input (trimmed)
                payload.value = trimmed;
            }
            return;
        }
        catch (_) {
            payload.issues.push({
                code: "invalid_format",
                format: "url",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodEmoji = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.emoji());
    $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.nanoid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.cuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.cuid2);
    $ZodStringFormat.init(inst, def);
});
const $ZodULID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.ulid);
    $ZodStringFormat.init(inst, def);
});
const $ZodXID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.xid);
    $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.ksuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.datetime(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.date);
    $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.time(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.duration);
    $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv4`;
    });
});
const $ZodIPv6 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
        try {
            // @ts-ignore
            new URL(`http://[${payload.value}]`);
            // return;
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "ipv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodCIDRv4 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.cidrv4);
    $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.cidrv6); // not used for validation
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        const [address, prefix] = payload.value.split("/");
        try {
            if (!prefix)
                throw new Error();
            const prefixNum = Number(prefix);
            if (`${prefixNum}` !== prefix)
                throw new Error();
            if (prefixNum < 0 || prefixNum > 128)
                throw new Error();
            // @ts-ignore
            new URL(`http://[${address}]`);
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "cidrv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64(data) {
    if (data === "")
        return true;
    if (data.length % 4 !== 0)
        return false;
    try {
        // @ts-ignore
        atob(data);
        return true;
    }
    catch {
        return false;
    }
}
const $ZodBase64 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64URL(data) {
    if (!_regexes_js__WEBPACK_IMPORTED_MODULE_4__.base64url.test(data))
        return false;
    const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
    return isValidBase64(padded);
}
const $ZodBase64URL = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodE164 = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.e164);
    $ZodStringFormat.init(inst, def);
});
//////////////////////////////   ZodJWT   //////////////////////////////
function isValidJWT(token, algorithm = null) {
    try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
            return false;
        const [header] = tokensParts;
        if (!header)
            return false;
        // @ts-ignore
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
            return false;
        if (!parsedHeader.alg)
            return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
            return false;
        return true;
    }
    catch {
        return false;
    }
}
const $ZodJWT = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCustomStringFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        if (def.fn(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodNumber = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? _regexes_js__WEBPACK_IMPORTED_MODULE_4__.number;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Number(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
            return payload;
        }
        const received = typeof input === "number"
            ? Number.isNaN(input)
                ? "NaN"
                : !Number.isFinite(input)
                    ? "Infinity"
                    : undefined
            : undefined;
        payload.issues.push({
            expected: "number",
            code: "invalid_type",
            input,
            inst,
            ...(received ? { received } : {}),
        });
        return payload;
    };
});
const $ZodNumberFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNumber", (inst, def) => {
    _checks_js__WEBPACK_IMPORTED_MODULE_5__.$ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def); // no format checksp
});
const $ZodBoolean = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.boolean;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Boolean(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "boolean")
            return payload;
        payload.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodBigInt = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.bigint;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = BigInt(payload.value);
            }
            catch (_) { }
        if (typeof payload.value === "bigint")
            return payload;
        payload.issues.push({
            expected: "bigint",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
const $ZodBigIntFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodBigInt", (inst, def) => {
    _checks_js__WEBPACK_IMPORTED_MODULE_5__.$ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def); // no format checks
});
const $ZodSymbol = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
            return payload;
        payload.issues.push({
            expected: "symbol",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodUndefined = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__.undefined;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
            return payload;
        payload.issues.push({
            expected: "undefined",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodNull = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_4__["null"];
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
            return payload;
        payload.issues.push({
            expected: "null",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodAny = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
});
const $ZodNever = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
            expected: "never",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
const $ZodVoid = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
            return payload;
        payload.issues.push({
            expected: "void",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodDate = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
            try {
                payload.value = new Date(payload.value);
            }
            catch (_err) { }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
            return payload;
        payload.issues.push({
            expected: "date",
            code: "invalid_type",
            input,
            ...(isDate ? { received: "Invalid Date" } : {}),
            inst,
        });
        return payload;
    };
});
function handleArrayResult(result, final, index) {
    if (result.issues.length) {
        final.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
}
const $ZodArray = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
            payload.issues.push({
                expected: "array",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
            const item = input[i];
            const result = def.element._zod.run({
                value: item,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleArrayResult(result, payload, i)));
            }
            else {
                handleArrayResult(result, payload, i);
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload; //handleArrayResultsAsync(parseResults, final);
    };
});
function handlePropertyResult(result, final, key, input) {
    if (result.issues.length) {
        final.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, result.issues));
    }
    if (result.value === undefined) {
        if (key in input) {
            final.value[key] = undefined;
        }
    }
    else {
        final.value[key] = result.value;
    }
}
function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
        if (!def.shape[k]._zod.traits.has("$ZodType")) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
        }
    }
    const okeys = _util_js__WEBPACK_IMPORTED_MODULE_2__.optionalKeys(def.shape);
    return {
        ...def,
        keys,
        keySet: new Set(keys),
        numKeys: keys.length,
        optionalKeys: new Set(okeys),
    };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    // iterate over input keys
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
        if (keySet.has(key))
            continue;
        if (t === "never") {
            unrecognized.push(key);
            continue;
        }
        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
        }
        else {
            handlePropertyResult(r, payload, key, input);
        }
    }
    if (unrecognized.length) {
        payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst,
        });
    }
    if (!proms.length)
        return payload;
    return Promise.all(proms).then(() => {
        return payload;
    });
}
const $ZodObject = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodObject", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodType.init(inst, def);
    const _normalized = _util_js__WEBPACK_IMPORTED_MODULE_2__.cached(() => normalizeDef(def));
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
            const field = shape[key]._zod;
            if (field.values) {
                propValues[key] ?? (propValues[key] = new Set());
                for (const v of field.values)
                    propValues[key].add(v);
            }
        }
        return propValues;
    });
    const isObject = _util_js__WEBPACK_IMPORTED_MODULE_2__.isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            if (r instanceof Promise) {
                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
            }
            else {
                handlePropertyResult(r, payload, key, input);
            }
        }
        if (!catchall) {
            return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
});
const $ZodObjectJIT = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodObjectJIT", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = _util_js__WEBPACK_IMPORTED_MODULE_2__.cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
        const doc = new _doc_js__WEBPACK_IMPORTED_MODULE_6__.Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
            const k = _util_js__WEBPACK_IMPORTED_MODULE_2__.esc(key);
            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
            ids[key] = `key_${counter++}`;
        }
        // A: preserve key order {
        doc.write(`const newResult = {}`);
        for (const key of normalized.keys) {
            const id = ids[key];
            const k = _util_js__WEBPACK_IMPORTED_MODULE_2__.esc(key);
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject = _util_js__WEBPACK_IMPORTED_MODULE_2__.isObject;
    const jit = !_core_js__WEBPACK_IMPORTED_MODULE_0__.globalConfig.jitless;
    const allowsEval = _util_js__WEBPACK_IMPORTED_MODULE_2__.allowsEval;
    const fastEnabled = jit && allowsEval.value; // && !def.catchall;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
            // always synchronous
            if (!fastpass)
                fastpass = generateFastpass(def.shape);
            payload = fastpass(payload, ctx);
            if (!catchall)
                return payload;
            return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
    };
});
function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
        if (result.issues.length === 0) {
            final.value = result.value;
            return final;
        }
    }
    const nonaborted = results.filter((r) => !_util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(r));
    if (nonaborted.length === 1) {
        final.value = nonaborted[0].value;
        return nonaborted[0];
    }
    final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config()))),
    });
    return final;
}
const $ZodUnion = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return undefined;
    });
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
            const patterns = def.options.map((o) => o._zod.pattern);
            return new RegExp(`^(${patterns.map((p) => _util_js__WEBPACK_IMPORTED_MODULE_2__.cleanRegex(p.source)).join("|")})$`);
        }
        return undefined;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
        if (single) {
            return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
            const result = option._zod.run({
                value: payload.value,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                results.push(result);
                async = true;
            }
            else {
                if (result.issues.length === 0)
                    return result;
                results.push(result);
            }
        }
        if (!async)
            return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results) => {
            return handleUnionResults(results, payload, inst, ctx);
        });
    };
});
const $ZodDiscriminatedUnion = 
/*@__PURE__*/
_core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
            const pv = option._zod.propValues;
            if (!pv || Object.keys(pv).length === 0)
                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
            for (const [k, v] of Object.entries(pv)) {
                if (!propValues[k])
                    propValues[k] = new Set();
                for (const val of v) {
                    propValues[k].add(val);
                }
            }
        }
        return propValues;
    });
    const disc = _util_js__WEBPACK_IMPORTED_MODULE_2__.cached(() => {
        const opts = def.options;
        const map = new Map();
        for (const o of opts) {
            const values = o._zod.propValues?.[def.discriminator];
            if (!values || values.size === 0)
                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
            for (const v of values) {
                if (map.has(v)) {
                    throw new Error(`Duplicate discriminator value "${String(v)}"`);
                }
                map.set(v, o);
            }
        }
        return map;
    });
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!_util_js__WEBPACK_IMPORTED_MODULE_2__.isObject(input)) {
            payload.issues.push({
                code: "invalid_type",
                expected: "object",
                input,
                inst,
            });
            return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
            return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
            return _super(payload, ctx);
        }
        // no matching discriminator
        payload.issues.push({
            code: "invalid_union",
            errors: [],
            note: "No matching discriminator",
            discriminator: def.discriminator,
            input,
            path: [def.discriminator],
            inst,
        });
        return payload;
    };
});
const $ZodIntersection = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
            return Promise.all([left, right]).then(([left, right]) => {
                return handleIntersectionResults(payload, left, right);
            });
        }
        return handleIntersectionResults(payload, left, right);
    };
});
function mergeValues(a, b) {
    // const aType = parse.t(a);
    // const bType = parse.t(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
    }
    if (_util_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(a) && _util_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
                };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
                };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
    if (left.issues.length) {
        result.issues.push(...left.issues);
    }
    if (right.issues.length) {
        result.issues.push(...right.issues);
    }
    if (_util_js__WEBPACK_IMPORTED_MODULE_2__.aborted(result))
        return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
}
const $ZodTuple = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
            payload.issues.push({
                input,
                inst,
                expected: "tuple",
                code: "invalid_type",
            });
            return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
            const tooBig = input.length > items.length;
            const tooSmall = input.length < optStart - 1;
            if (tooBig || tooSmall) {
                payload.issues.push({
                    ...(tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }),
                    input,
                    inst,
                    origin: "array",
                });
                return payload;
            }
        }
        let i = -1;
        for (const item of items) {
            i++;
            if (i >= input.length)
                if (i >= optStart)
                    continue;
            const result = item._zod.run({
                value: input[i],
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleTupleResult(result, payload, i)));
            }
            else {
                handleTupleResult(result, payload, i);
            }
        }
        if (def.rest) {
            const rest = input.slice(items.length);
            for (const el of rest) {
                i++;
                const result = def.rest._zod.run({
                    value: el,
                    issues: [],
                }, ctx);
                if (result instanceof Promise) {
                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));
                }
                else {
                    handleTupleResult(result, payload, i);
                }
            }
        }
        if (proms.length)
            return Promise.all(proms).then(() => payload);
        return payload;
    };
});
function handleTupleResult(result, final, index) {
    if (result.issues.length) {
        final.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
}
const $ZodRecord = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!_util_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(input)) {
            payload.issues.push({
                expected: "record",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
            const values = def.keyType._zod.values;
            payload.value = {};
            for (const key of values) {
                if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                    if (result instanceof Promise) {
                        proms.push(result.then((result) => {
                            if (result.issues.length) {
                                payload.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, result.issues));
                            }
                            payload.value[key] = result.value;
                        }));
                    }
                    else {
                        if (result.issues.length) {
                            payload.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, result.issues));
                        }
                        payload.value[key] = result.value;
                    }
                }
            }
            let unrecognized;
            for (const key in input) {
                if (!values.has(key)) {
                    unrecognized = unrecognized ?? [];
                    unrecognized.push(key);
                }
            }
            if (unrecognized && unrecognized.length > 0) {
                payload.issues.push({
                    code: "unrecognized_keys",
                    input,
                    inst,
                    keys: unrecognized,
                });
            }
        }
        else {
            payload.value = {};
            for (const key of Reflect.ownKeys(input)) {
                if (key === "__proto__")
                    continue;
                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
                if (keyResult instanceof Promise) {
                    throw new Error("Async schemas not supported in object keys currently");
                }
                if (keyResult.issues.length) {
                    payload.issues.push({
                        code: "invalid_key",
                        origin: "record",
                        issues: keyResult.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())),
                        input: key,
                        path: [key],
                        inst,
                    });
                    payload.value[keyResult.value] = keyResult.value;
                    continue;
                }
                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                if (result instanceof Promise) {
                    proms.push(result.then((result) => {
                        if (result.issues.length) {
                            payload.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, result.issues));
                        }
                        payload.value[keyResult.value] = result.value;
                    }));
                }
                else {
                    if (result.issues.length) {
                        payload.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, result.issues));
                    }
                    payload.value[keyResult.value] = result.value;
                }
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload;
    };
});
const $ZodMap = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
            payload.issues.push({
                expected: "map",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        const proms = [];
        payload.value = new Map();
        for (const [key, value] of input) {
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);
            if (keyResult instanceof Promise || valueResult instanceof Promise) {
                proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {
                    handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
                }));
            }
            else {
                handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
            }
        }
        if (proms.length)
            return Promise.all(proms).then(() => payload);
        return payload;
    };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
    if (keyResult.issues.length) {
        if (_util_js__WEBPACK_IMPORTED_MODULE_2__.propertyKeyTypes.has(typeof key)) {
            final.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, keyResult.issues));
        }
        else {
            final.issues.push({
                code: "invalid_key",
                origin: "map",
                input,
                inst,
                issues: keyResult.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())),
            });
        }
    }
    if (valueResult.issues.length) {
        if (_util_js__WEBPACK_IMPORTED_MODULE_2__.propertyKeyTypes.has(typeof key)) {
            final.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_2__.prefixIssues(key, valueResult.issues));
        }
        else {
            final.issues.push({
                origin: "map",
                code: "invalid_element",
                input,
                inst,
                key: key,
                issues: valueResult.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())),
            });
        }
    }
    final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
            payload.issues.push({
                input,
                inst,
                expected: "set",
                code: "invalid_type",
            });
            return payload;
        }
        const proms = [];
        payload.value = new Set();
        for (const item of input) {
            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleSetResult(result, payload)));
            }
            else
                handleSetResult(result, payload);
        }
        if (proms.length)
            return Promise.all(proms).then(() => payload);
        return payload;
    };
});
function handleSetResult(result, final) {
    if (result.issues.length) {
        final.issues.push(...result.issues);
    }
    final.value.add(result.value);
}
const $ZodEnum = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = _util_js__WEBPACK_IMPORTED_MODULE_2__.getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values
        .filter((k) => _util_js__WEBPACK_IMPORTED_MODULE_2__.propertyKeyTypes.has(typeof k))
        .map((o) => (typeof o === "string" ? _util_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegex(o) : o.toString()))
        .join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
            return payload;
        }
        payload.issues.push({
            code: "invalid_value",
            values,
            input,
            inst,
        });
        return payload;
    };
});
const $ZodLiteral = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
    }
    inst._zod.values = new Set(def.values);
    inst._zod.pattern = new RegExp(`^(${def.values
        .map((o) => (typeof o === "string" ? _util_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegex(o) : o ? _util_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegex(o.toString()) : String(o)))
        .join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
            return payload;
        }
        payload.issues.push({
            code: "invalid_value",
            values: def.values,
            input,
            inst,
        });
        return payload;
    };
});
const $ZodFile = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        // @ts-ignore
        if (input instanceof File)
            return payload;
        payload.issues.push({
            expected: "file",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodTransform = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
            const output = _out instanceof Promise ? _out : Promise.resolve(_out);
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        if (_out instanceof Promise) {
            throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
        }
        payload.value = _out;
        return payload;
    };
});
function handleOptionalResult(result, input) {
    if (result.issues.length && input === undefined) {
        return { issues: [], value: undefined };
    }
    return result;
}
const $ZodOptional = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${_util_js__WEBPACK_IMPORTED_MODULE_2__.cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise)
                return result.then((r) => handleOptionalResult(r, payload.value));
            return handleOptionalResult(result, payload.value);
        }
        if (payload.value === undefined) {
            return payload;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNullable = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${_util_js__WEBPACK_IMPORTED_MODULE_2__.cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        // Forward direction (decode): allow null to pass through
        if (payload.value === null)
            return payload;
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodDefault = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    // inst._zod.qin = "true";
    inst._zod.optin = "optional";
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply defaults for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
            /**
             * $ZodDefault returns the default value immediately in forward direction.
             * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
            return payload;
        }
        // Forward direction: continue with default handling
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleDefaultResult(result, def));
        }
        return handleDefaultResult(result, def);
    };
});
function handleDefaultResult(payload, def) {
    if (payload.value === undefined) {
        payload.value = def.defaultValue;
    }
    return payload;
}
const $ZodPrefault = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply prefault for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNonOptional = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleNonOptionalResult(result, inst));
        }
        return handleNonOptionalResult(result, inst);
    };
});
function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === undefined) {
        payload.issues.push({
            code: "invalid_type",
            expected: "nonoptional",
            input: payload.value,
            inst,
        });
    }
    return payload;
}
const $ZodSuccess = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => {
                payload.value = result.issues.length === 0;
                return payload;
            });
        }
        payload.value = result.issues.length === 0;
        return payload;
    };
});
const $ZodCatch = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply catch logic
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => {
                payload.value = result.value;
                if (result.issues.length) {
                    payload.value = def.catchValue({
                        ...payload,
                        error: {
                            issues: result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())),
                        },
                        input: payload.value,
                    });
                    payload.issues = [];
                }
                return payload;
            });
        }
        payload.value = result.value;
        if (result.issues.length) {
            payload.value = def.catchValue({
                ...payload,
                error: {
                    issues: result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_2__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())),
                },
                input: payload.value,
            });
            payload.issues = [];
        }
        return payload;
    };
});
const $ZodNaN = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
            payload.issues.push({
                input: payload.value,
                inst,
                expected: "nan",
                code: "invalid_type",
            });
            return payload;
        }
        return payload;
    };
});
const $ZodPipe = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.in._zod.values);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
                return right.then((right) => handlePipeResult(right, def.in, ctx));
            }
            return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
            return left.then((left) => handlePipeResult(left, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
    };
});
function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
        // prevent further checks
        left.aborted = true;
        return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodCodec = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.in._zod.values);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
            const left = def.in._zod.run(payload, ctx);
            if (left instanceof Promise) {
                return left.then((left) => handleCodecAResult(left, def, ctx));
            }
            return handleCodecAResult(left, def, ctx);
        }
        else {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
                return right.then((right) => handleCodecAResult(right, def, ctx));
            }
            return handleCodecAResult(right, def, ctx);
        }
    };
});
function handleCodecAResult(result, def, ctx) {
    if (result.issues.length) {
        // prevent further checks
        result.aborted = true;
        return result;
    }
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
        const transformed = def.transform(result.value, result);
        if (transformed instanceof Promise) {
            return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
        }
        return handleCodecTxResult(result, transformed, def.out, ctx);
    }
    else {
        const transformed = def.reverseTransform(result.value, result);
        if (transformed instanceof Promise) {
            return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
        }
        return handleCodecTxResult(result, transformed, def.in, ctx);
    }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
    // Check if transform added any issues
    if (left.issues.length) {
        left.aborted = true;
        return left;
    }
    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
const $ZodReadonly = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
    };
});
function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
}
const $ZodTemplateLiteral = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
            // is Zod schema
            if (!part._zod.pattern) {
                // if (!source)
                throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
            }
            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
            if (!source)
                throw new Error(`Invalid template literal part: ${part._zod.traits}`);
            const start = source.startsWith("^") ? 1 : 0;
            const end = source.endsWith("$") ? source.length - 1 : source.length;
            regexParts.push(source.slice(start, end));
        }
        else if (part === null || _util_js__WEBPACK_IMPORTED_MODULE_2__.primitiveTypes.has(typeof part)) {
            regexParts.push(_util_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegex(`${part}`));
        }
        else {
            throw new Error(`Invalid template literal part: ${part}`);
        }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
            payload.issues.push({
                input: payload.value,
                inst,
                expected: "template_literal",
                code: "invalid_type",
            });
            return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
            payload.issues.push({
                input: payload.value,
                inst,
                code: "invalid_format",
                format: def.format ?? "template_literal",
                pattern: inst._zod.pattern.source,
            });
            return payload;
        }
        return payload;
    };
});
const $ZodFunction = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
        if (typeof func !== "function") {
            throw new Error("implement() must be called with a function");
        }
        return function (...args) {
            const parsedArgs = inst._def.input ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(inst._def.input, args) : args;
            const result = Reflect.apply(func, this, parsedArgs);
            if (inst._def.output) {
                return (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(inst._def.output, result);
            }
            return result;
        };
    };
    inst.implementAsync = (func) => {
        if (typeof func !== "function") {
            throw new Error("implementAsync() must be called with a function");
        }
        return async function (...args) {
            const parsedArgs = inst._def.input ? await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parseAsync)(inst._def.input, args) : args;
            const result = await Reflect.apply(func, this, parsedArgs);
            if (inst._def.output) {
                return await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parseAsync)(inst._def.output, result);
            }
            return result;
        };
    };
    inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
            payload.issues.push({
                code: "invalid_type",
                expected: "function",
                input: payload.value,
                inst,
            });
            return payload;
        }
        // Check if output is a promise type to determine if we should use async implementation
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
            payload.value = inst.implementAsync(payload.value);
        }
        else {
            payload.value = inst.implement(payload.value);
        }
        return payload;
    };
    inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
            return new F({
                type: "function",
                input: new $ZodTuple({
                    type: "tuple",
                    items: args[0],
                    rest: args[1],
                }),
                output: inst._def.output,
            });
        }
        return new F({
            type: "function",
            input: args[0],
            output: inst._def.output,
        });
    };
    inst.output = (output) => {
        const F = inst.constructor;
        return new F({
            type: "function",
            input: inst._def.input,
            output,
        });
    };
    return inst;
});
const $ZodPromise = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
});
const $ZodLazy = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    // let _innerType!: any;
    // util.defineLazy(def, "getter", () => {
    //   if (!_innerType) {
    //     _innerType = def.getter();
    //   }
    //   return () => _innerType;
    // });
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "innerType", () => def.getter());
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
    _util_js__WEBPACK_IMPORTED_MODULE_2__.defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
    };
});
const $ZodCustom = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCustom", (inst, def) => {
    _checks_js__WEBPACK_IMPORTED_MODULE_5__.$ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
        return payload;
    };
    inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
            return r.then((r) => handleRefineResult(r, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
    };
});
function handleRefineResult(result, payload, input, inst) {
    if (!result) {
        const _iss = {
            code: "custom",
            input,
            inst, // incorporates params.error into issue reporting
            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
            continue: !inst._zod.def.abort,
            // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
            _iss.params = inst._zod.def.params;
        payload.issues.push(_util_js__WEBPACK_IMPORTED_MODULE_2__.issue(_iss));
    }
}


/***/ }),
/* 122 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ZodCheck: () => (/* binding */ $ZodCheck),
/* harmony export */   $ZodCheckBigIntFormat: () => (/* binding */ $ZodCheckBigIntFormat),
/* harmony export */   $ZodCheckEndsWith: () => (/* binding */ $ZodCheckEndsWith),
/* harmony export */   $ZodCheckGreaterThan: () => (/* binding */ $ZodCheckGreaterThan),
/* harmony export */   $ZodCheckIncludes: () => (/* binding */ $ZodCheckIncludes),
/* harmony export */   $ZodCheckLengthEquals: () => (/* binding */ $ZodCheckLengthEquals),
/* harmony export */   $ZodCheckLessThan: () => (/* binding */ $ZodCheckLessThan),
/* harmony export */   $ZodCheckLowerCase: () => (/* binding */ $ZodCheckLowerCase),
/* harmony export */   $ZodCheckMaxLength: () => (/* binding */ $ZodCheckMaxLength),
/* harmony export */   $ZodCheckMaxSize: () => (/* binding */ $ZodCheckMaxSize),
/* harmony export */   $ZodCheckMimeType: () => (/* binding */ $ZodCheckMimeType),
/* harmony export */   $ZodCheckMinLength: () => (/* binding */ $ZodCheckMinLength),
/* harmony export */   $ZodCheckMinSize: () => (/* binding */ $ZodCheckMinSize),
/* harmony export */   $ZodCheckMultipleOf: () => (/* binding */ $ZodCheckMultipleOf),
/* harmony export */   $ZodCheckNumberFormat: () => (/* binding */ $ZodCheckNumberFormat),
/* harmony export */   $ZodCheckOverwrite: () => (/* binding */ $ZodCheckOverwrite),
/* harmony export */   $ZodCheckProperty: () => (/* binding */ $ZodCheckProperty),
/* harmony export */   $ZodCheckRegex: () => (/* binding */ $ZodCheckRegex),
/* harmony export */   $ZodCheckSizeEquals: () => (/* binding */ $ZodCheckSizeEquals),
/* harmony export */   $ZodCheckStartsWith: () => (/* binding */ $ZodCheckStartsWith),
/* harmony export */   $ZodCheckStringFormat: () => (/* binding */ $ZodCheckStringFormat),
/* harmony export */   $ZodCheckUpperCase: () => (/* binding */ $ZodCheckUpperCase)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _regexes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(123);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(124);
// import { $ZodType } from "./schemas.js";



const $ZodCheck = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date",
};
const $ZodCheckLessThan = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
            if (def.inclusive)
                bag.maximum = def.value;
            else
                bag.exclusiveMaximum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckGreaterThan = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
            if (def.inclusive)
                bag.minimum = def.value;
            else
                bag.exclusiveMinimum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMultipleOf = 
/*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        var _a;
        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
            throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint"
            ? payload.value % def.value === BigInt(0)
            : _util_js__WEBPACK_IMPORTED_MODULE_1__.floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
            return;
        payload.issues.push({
            origin: typeof payload.value,
            code: "not_multiple_of",
            divisor: def.value,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckNumberFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def); // no format checks
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = _util_js__WEBPACK_IMPORTED_MODULE_1__.NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
            bag.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_2__.integer;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
            if (!Number.isInteger(input)) {
                // invalid_format issue
                // payload.issues.push({
                //   expected: def.format,
                //   format: def.format,
                //   code: "invalid_format",
                //   input,
                //   inst,
                // });
                // invalid_type issue
                payload.issues.push({
                    expected: origin,
                    format: def.format,
                    code: "invalid_type",
                    continue: false,
                    input,
                    inst,
                });
                return;
                // not_multiple_of issue
                // payload.issues.push({
                //   code: "not_multiple_of",
                //   origin: "number",
                //   input,
                //   inst,
                //   divisor: 1,
                // });
            }
            if (!Number.isSafeInteger(input)) {
                if (input > 0) {
                    // too_big
                    payload.issues.push({
                        input,
                        code: "too_big",
                        maximum: Number.MAX_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                else {
                    // too_small
                    payload.issues.push({
                        input,
                        code: "too_small",
                        minimum: Number.MIN_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                return;
            }
        }
        if (input < minimum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_small",
                minimum,
                inclusive: true,
                inst,
                continue: !def.abort,
            });
        }
        if (input > maximum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_big",
                maximum,
                inst,
            });
        }
    };
});
const $ZodCheckBigIntFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def); // no format checks
    const [minimum, maximum] = _util_js__WEBPACK_IMPORTED_MODULE_1__.BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
            payload.issues.push({
                origin: "bigint",
                input,
                code: "too_small",
                minimum: minimum,
                inclusive: true,
                inst,
                continue: !def.abort,
            });
        }
        if (input > maximum) {
            payload.issues.push({
                origin: "bigint",
                input,
                code: "too_big",
                maximum,
                inst,
            });
        }
    };
});
const $ZodCheckMaxSize = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
        if (def.maximum < curr)
            inst._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
            return;
        payload.issues.push({
            origin: _util_js__WEBPACK_IMPORTED_MODULE_1__.getSizableOrigin(input),
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMinSize = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMinSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
        if (def.minimum > curr)
            inst._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
            return;
        payload.issues.push({
            origin: _util_js__WEBPACK_IMPORTED_MODULE_1__.getSizableOrigin(input),
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckSizeEquals = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
            return;
        const tooBig = size > def.size;
        payload.issues.push({
            origin: _util_js__WEBPACK_IMPORTED_MODULE_1__.getSizableOrigin(input),
            ...(tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size }),
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMaxLength = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
        if (def.maximum < curr)
            inst._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
            return;
        const origin = _util_js__WEBPACK_IMPORTED_MODULE_1__.getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMinLength = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
        if (def.minimum > curr)
            inst._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
            return;
        const origin = _util_js__WEBPACK_IMPORTED_MODULE_1__.getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLengthEquals = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !_util_js__WEBPACK_IMPORTED_MODULE_1__.nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
            return;
        const origin = _util_js__WEBPACK_IMPORTED_MODULE_1__.getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
            origin,
            ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStringFormat = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(def.pattern);
        }
    });
    if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
            def.pattern.lastIndex = 0;
            if (def.pattern.test(payload.value))
                return;
            payload.issues.push({
                origin: "string",
                code: "invalid_format",
                format: def.format,
                input: payload.value,
                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
                inst,
                continue: !def.abort,
            });
        });
    else
        (_b = inst._zod).check ?? (_b.check = () => { });
});
const $ZodCheckRegex = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "regex",
            input: payload.value,
            pattern: def.pattern.toString(),
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLowerCase = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_2__.lowercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = _regexes_js__WEBPACK_IMPORTED_MODULE_2__.uppercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = _util_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: def.includes,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStartsWith = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${_util_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: def.prefix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckEndsWith = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${_util_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: def.suffix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
///////////////////////////////////
/////    $ZodCheckProperty    /////
///////////////////////////////////
function handleCheckPropertyResult(result, payload, property) {
    if (result.issues.length) {
        payload.issues.push(..._util_js__WEBPACK_IMPORTED_MODULE_1__.prefixIssues(property, result.issues));
    }
}
const $ZodCheckProperty = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
            value: payload.value[def.property],
            issues: [],
        }, {});
        if (result instanceof Promise) {
            return result.then((result) => handleCheckPropertyResult(result, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
    };
});
const $ZodCheckMimeType = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
            return;
        payload.issues.push({
            code: "invalid_value",
            values: def.mime,
            input: payload.value.type,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckOverwrite = /*@__PURE__*/ _core_js__WEBPACK_IMPORTED_MODULE_0__.$constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
    };
});


/***/ }),
/* 123 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64: () => (/* binding */ base64),
/* harmony export */   base64url: () => (/* binding */ base64url),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   browserEmail: () => (/* binding */ browserEmail),
/* harmony export */   cidrv4: () => (/* binding */ cidrv4),
/* harmony export */   cidrv6: () => (/* binding */ cidrv6),
/* harmony export */   cuid: () => (/* binding */ cuid),
/* harmony export */   cuid2: () => (/* binding */ cuid2),
/* harmony export */   date: () => (/* binding */ date),
/* harmony export */   datetime: () => (/* binding */ datetime),
/* harmony export */   domain: () => (/* binding */ domain),
/* harmony export */   duration: () => (/* binding */ duration),
/* harmony export */   e164: () => (/* binding */ e164),
/* harmony export */   email: () => (/* binding */ email),
/* harmony export */   emoji: () => (/* binding */ emoji),
/* harmony export */   extendedDuration: () => (/* binding */ extendedDuration),
/* harmony export */   guid: () => (/* binding */ guid),
/* harmony export */   hex: () => (/* binding */ hex),
/* harmony export */   hostname: () => (/* binding */ hostname),
/* harmony export */   html5Email: () => (/* binding */ html5Email),
/* harmony export */   idnEmail: () => (/* binding */ idnEmail),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   ipv4: () => (/* binding */ ipv4),
/* harmony export */   ipv6: () => (/* binding */ ipv6),
/* harmony export */   ksuid: () => (/* binding */ ksuid),
/* harmony export */   lowercase: () => (/* binding */ lowercase),
/* harmony export */   md5_base64: () => (/* binding */ md5_base64),
/* harmony export */   md5_base64url: () => (/* binding */ md5_base64url),
/* harmony export */   md5_hex: () => (/* binding */ md5_hex),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   "null": () => (/* binding */ _null),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   rfc5322Email: () => (/* binding */ rfc5322Email),
/* harmony export */   sha1_base64: () => (/* binding */ sha1_base64),
/* harmony export */   sha1_base64url: () => (/* binding */ sha1_base64url),
/* harmony export */   sha1_hex: () => (/* binding */ sha1_hex),
/* harmony export */   sha256_base64: () => (/* binding */ sha256_base64),
/* harmony export */   sha256_base64url: () => (/* binding */ sha256_base64url),
/* harmony export */   sha256_hex: () => (/* binding */ sha256_hex),
/* harmony export */   sha384_base64: () => (/* binding */ sha384_base64),
/* harmony export */   sha384_base64url: () => (/* binding */ sha384_base64url),
/* harmony export */   sha384_hex: () => (/* binding */ sha384_hex),
/* harmony export */   sha512_base64: () => (/* binding */ sha512_base64),
/* harmony export */   sha512_base64url: () => (/* binding */ sha512_base64url),
/* harmony export */   sha512_hex: () => (/* binding */ sha512_hex),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   time: () => (/* binding */ time),
/* harmony export */   ulid: () => (/* binding */ ulid),
/* harmony export */   undefined: () => (/* binding */ _undefined),
/* harmony export */   unicodeEmail: () => (/* binding */ unicodeEmail),
/* harmony export */   uppercase: () => (/* binding */ uppercase),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   uuid4: () => (/* binding */ uuid4),
/* harmony export */   uuid6: () => (/* binding */ uuid6),
/* harmony export */   uuid7: () => (/* binding */ uuid7),
/* harmony export */   xid: () => (/* binding */ xid)
/* harmony export */ });
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
 *
 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version) => {
    if (!version)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const uuid4 = /*@__PURE__*/ uuid(4);
const uuid6 = /*@__PURE__*/ uuid(6);
const uuid7 = /*@__PURE__*/ uuid(7);
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/** The classic emailregex.com regex for RFC 5322-compliant emails */
const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const idnEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
    return new RegExp(_emoji, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
// export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
// const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number"
        ? args.precision === -1
            ? `${hhmm}`
            : args.precision === 0
                ? `${hhmm}:[0-5]\\d`
                : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
        : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
}
function time(args) {
    return new RegExp(`^${timeSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetime(args) {
    const time = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
        opts.push("");
    // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
    if (args.offset)
        opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
};
const bigint = /^\d+n?$/;
const integer = /^\d+$/;
const number = /^-?\d+(?:\.\d+)?/i;
const boolean = /true|false/i;
const _null = /null/i;

const _undefined = /undefined/i;

// regex for string with no uppercase letters
const lowercase = /^[^A-Z]*$/;
// regex for string with no lowercase letters
const uppercase = /^[^a-z]*$/;
// regex for hexadecimal strings (any length)
const hex = /^[0-9a-fA-F]*$/;
// Hash regexes for different algorithms and encodings
// Helper function to create base64 regex with exact length and padding
function fixedBase64(bodyLength, padding) {
    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
// Helper function to create base64url regex with exact length (no padding)
function fixedBase64url(length) {
    return new RegExp(`^[A-Za-z0-9-_]{${length}}$`);
}
// MD5 (16 bytes): base64 = 24 chars total (22 + "==")
const md5_hex = /^[0-9a-fA-F]{32}$/;
const md5_base64 = /*@__PURE__*/ fixedBase64(22, "==");
const md5_base64url = /*@__PURE__*/ fixedBase64url(22);
// SHA1 (20 bytes): base64 = 28 chars total (27 + "=")
const sha1_hex = /^[0-9a-fA-F]{40}$/;
const sha1_base64 = /*@__PURE__*/ fixedBase64(27, "=");
const sha1_base64url = /*@__PURE__*/ fixedBase64url(27);
// SHA256 (32 bytes): base64 = 44 chars total (43 + "=")
const sha256_hex = /^[0-9a-fA-F]{64}$/;
const sha256_base64 = /*@__PURE__*/ fixedBase64(43, "=");
const sha256_base64url = /*@__PURE__*/ fixedBase64url(43);
// SHA384 (48 bytes): base64 = 64 chars total (no padding)
const sha384_hex = /^[0-9a-fA-F]{96}$/;
const sha384_base64 = /*@__PURE__*/ fixedBase64(64, "");
const sha384_base64url = /*@__PURE__*/ fixedBase64url(64);
// SHA512 (64 bytes): base64 = 88 chars total (86 + "==")
const sha512_hex = /^[0-9a-fA-F]{128}$/;
const sha512_base64 = /*@__PURE__*/ fixedBase64(86, "==");
const sha512_base64url = /*@__PURE__*/ fixedBase64url(86);


/***/ }),
/* 124 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BIGINT_FORMAT_RANGES: () => (/* binding */ BIGINT_FORMAT_RANGES),
/* harmony export */   Class: () => (/* binding */ Class),
/* harmony export */   NUMBER_FORMAT_RANGES: () => (/* binding */ NUMBER_FORMAT_RANGES),
/* harmony export */   aborted: () => (/* binding */ aborted),
/* harmony export */   allowsEval: () => (/* binding */ allowsEval),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   assertEqual: () => (/* binding */ assertEqual),
/* harmony export */   assertIs: () => (/* binding */ assertIs),
/* harmony export */   assertNever: () => (/* binding */ assertNever),
/* harmony export */   assertNotEqual: () => (/* binding */ assertNotEqual),
/* harmony export */   assignProp: () => (/* binding */ assignProp),
/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array),
/* harmony export */   base64urlToUint8Array: () => (/* binding */ base64urlToUint8Array),
/* harmony export */   cached: () => (/* binding */ cached),
/* harmony export */   captureStackTrace: () => (/* binding */ captureStackTrace),
/* harmony export */   cleanEnum: () => (/* binding */ cleanEnum),
/* harmony export */   cleanRegex: () => (/* binding */ cleanRegex),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   cloneDef: () => (/* binding */ cloneDef),
/* harmony export */   createTransparentProxy: () => (/* binding */ createTransparentProxy),
/* harmony export */   defineLazy: () => (/* binding */ defineLazy),
/* harmony export */   esc: () => (/* binding */ esc),
/* harmony export */   escapeRegex: () => (/* binding */ escapeRegex),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   finalizeIssue: () => (/* binding */ finalizeIssue),
/* harmony export */   floatSafeRemainder: () => (/* binding */ floatSafeRemainder),
/* harmony export */   getElementAtPath: () => (/* binding */ getElementAtPath),
/* harmony export */   getEnumValues: () => (/* binding */ getEnumValues),
/* harmony export */   getLengthableOrigin: () => (/* binding */ getLengthableOrigin),
/* harmony export */   getParsedType: () => (/* binding */ getParsedType),
/* harmony export */   getSizableOrigin: () => (/* binding */ getSizableOrigin),
/* harmony export */   hexToUint8Array: () => (/* binding */ hexToUint8Array),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   issue: () => (/* binding */ issue),
/* harmony export */   joinValues: () => (/* binding */ joinValues),
/* harmony export */   jsonStringifyReplacer: () => (/* binding */ jsonStringifyReplacer),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   mergeDefs: () => (/* binding */ mergeDefs),
/* harmony export */   normalizeParams: () => (/* binding */ normalizeParams),
/* harmony export */   nullish: () => (/* binding */ nullish),
/* harmony export */   numKeys: () => (/* binding */ numKeys),
/* harmony export */   objectClone: () => (/* binding */ objectClone),
/* harmony export */   omit: () => (/* binding */ omit),
/* harmony export */   optionalKeys: () => (/* binding */ optionalKeys),
/* harmony export */   partial: () => (/* binding */ partial),
/* harmony export */   pick: () => (/* binding */ pick),
/* harmony export */   prefixIssues: () => (/* binding */ prefixIssues),
/* harmony export */   primitiveTypes: () => (/* binding */ primitiveTypes),
/* harmony export */   promiseAllObject: () => (/* binding */ promiseAllObject),
/* harmony export */   propertyKeyTypes: () => (/* binding */ propertyKeyTypes),
/* harmony export */   randomString: () => (/* binding */ randomString),
/* harmony export */   required: () => (/* binding */ required),
/* harmony export */   safeExtend: () => (/* binding */ safeExtend),
/* harmony export */   shallowClone: () => (/* binding */ shallowClone),
/* harmony export */   stringifyPrimitive: () => (/* binding */ stringifyPrimitive),
/* harmony export */   uint8ArrayToBase64: () => (/* binding */ uint8ArrayToBase64),
/* harmony export */   uint8ArrayToBase64url: () => (/* binding */ uint8ArrayToBase64url),
/* harmony export */   uint8ArrayToHex: () => (/* binding */ uint8ArrayToHex),
/* harmony export */   unwrapMessage: () => (/* binding */ unwrapMessage)
/* harmony export */ });
// functions
function assertEqual(val) {
    return val;
}
function assertNotEqual(val) {
    return val;
}
function assertIs(_arg) { }
function assertNever(_x) {
    throw new Error();
}
function assert(_) { }
function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries)
        .filter(([k, _]) => numericValues.indexOf(+k) === -1)
        .map(([_, v]) => v);
    return values;
}
function joinValues(array, separator = "|") {
    return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
        return value.toString();
    return value;
}
function cached(getter) {
    const set = false;
    return {
        get value() {
            if (!set) {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
            }
            throw new Error("cached value already set");
        },
    };
}
function nullish(input) {
    return input === null || input === undefined;
}
function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
        const match = stepString.match(/\d?e-(\d?)/);
        if (match?.[1]) {
            stepDecCount = Number.parseInt(match[1]);
        }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
    let value = undefined;
    Object.defineProperty(object, key, {
        get() {
            if (value === EVALUATING) {
                // Circular reference detected, return undefined to break the cycle
                return undefined;
            }
            if (value === undefined) {
                value = EVALUATING;
                value = getter();
            }
            return value;
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
        const descriptors = Object.getOwnPropertyDescriptors(def);
        Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
    if (!path)
        return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
            resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
    });
}
function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
}
function esc(str) {
    return JSON.stringify(str);
}
const captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
    // @ts-ignore
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
    }
    try {
        const F = Function;
        new F("");
        return true;
    }
    catch (_) {
        return false;
    }
});
function isPlainObject(o) {
    if (isObject(o) === false)
        return false;
    // modified constructor
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    // modified prototype
    const prot = ctor.prototype;
    if (isObject(prot) === false)
        return false;
    // ctor doesn't have static `isPrototypeOf`
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
    }
    return true;
}
function shallowClone(o) {
    if (isPlainObject(o))
        return { ...o };
    return o;
}
function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            keyCount++;
        }
    }
    return keyCount;
}
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return "undefined";
        case "string":
            return "string";
        case "number":
            return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
            return "boolean";
        case "function":
            return "function";
        case "bigint":
            return "bigint";
        case "symbol":
            return "symbol";
        case "object":
            if (Array.isArray(data)) {
                return "array";
            }
            if (data === null) {
                return "null";
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return "promise";
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return "map";
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return "set";
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return "date";
            }
            // @ts-ignore
            if (typeof File !== "undefined" && data instanceof File) {
                return "file";
            }
            return "object";
        default:
            throw new Error(`Unknown data type: ${t}`);
    }
};
const propertyKeyTypes = new Set(["string", "number", "symbol"]);
const primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
// zod-specific utils
function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
        cl._zod.parent = inst;
    return cl;
}
function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === "string")
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
        return { ...params, error: () => params.error };
    return params;
}
function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
        get(_, prop, receiver) {
            target ?? (target = getter());
            return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
            target ?? (target = getter());
            return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
            target ?? (target = getter());
            return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
            target ?? (target = getter());
            return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
            target ?? (target = getter());
            return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
            target ?? (target = getter());
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
            target ?? (target = getter());
            return Reflect.defineProperty(target, prop, descriptor);
        },
    });
}
function stringifyPrimitive(value) {
    if (typeof value === "bigint")
        return value.toString() + "n";
    if (typeof value === "string")
        return `"${value}"`;
    return `${value}`;
}
function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
}
const NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-3.4028234663852886e38, 3.4028234663852886e38],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
const BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__*/ BigInt("-9223372036854775808"), /* @__PURE__*/ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt("18446744073709551615")],
};
function pick(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = {};
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                newShape[key] = currDef.shape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function omit(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = { ...schema._zod.def.shape };
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                delete newShape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function extend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    }
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: schema._zod.def.checks,
    };
    return clone(schema, def);
}
function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        get catchall() {
            return b._zod.def.catchall;
        },
        checks: [], // delete existing checks
    });
    return clone(a, def);
}
function partial(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in oldShape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            else {
                for (const key in oldShape) {
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function required(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in shape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            else {
                for (const key in oldShape) {
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
function aborted(x, startIndex = 0) {
    if (x.aborted === true)
        return true;
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true) {
            return true;
        }
    }
    return false;
}
function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
function getSizableOrigin(input) {
    if (input instanceof Set)
        return "set";
    if (input instanceof Map)
        return "map";
    // @ts-ignore
    if (input instanceof File)
        return "file";
    return "unknown";
}
function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}
function cleanEnum(obj) {
    return Object.entries(obj)
        .filter(([k, _]) => {
        // return true if NaN, meaning it's not a number, thus a string key
        return Number.isNaN(Number.parseInt(k, 10));
    })
        .map((el) => el[1]);
}
// Codec utility functions
function base64ToUint8Array(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
        binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
    const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - (base64.length % 4)) % 4);
    return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
    const cleanHex = hex.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
        throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
}
function uint8ArrayToHex(bytes) {
    return Array.from(bytes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
}
// instanceof
class Class {
    constructor(..._args) { }
}


/***/ }),
/* 125 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Doc: () => (/* binding */ Doc)
/* harmony export */ });
class Doc {
    constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
            this.args = args;
    }
    indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
    }
    write(arg) {
        if (typeof arg === "function") {
            arg(this, { execution: "sync" });
            arg(this, { execution: "async" });
            return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
            this.content.push(line);
        }
    }
    compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        // console.log(lines.join("\n"));
        return new F(...args, lines.join("\n"));
    }
}


/***/ }),
/* 126 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _decode: () => (/* binding */ _decode),
/* harmony export */   _decodeAsync: () => (/* binding */ _decodeAsync),
/* harmony export */   _encode: () => (/* binding */ _encode),
/* harmony export */   _encodeAsync: () => (/* binding */ _encodeAsync),
/* harmony export */   _parse: () => (/* binding */ _parse),
/* harmony export */   _parseAsync: () => (/* binding */ _parseAsync),
/* harmony export */   _safeDecode: () => (/* binding */ _safeDecode),
/* harmony export */   _safeDecodeAsync: () => (/* binding */ _safeDecodeAsync),
/* harmony export */   _safeEncode: () => (/* binding */ _safeEncode),
/* harmony export */   _safeEncodeAsync: () => (/* binding */ _safeEncodeAsync),
/* harmony export */   _safeParse: () => (/* binding */ _safeParse),
/* harmony export */   _safeParseAsync: () => (/* binding */ _safeParseAsync),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeAsync: () => (/* binding */ decodeAsync),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   encodeAsync: () => (/* binding */ encodeAsync),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parseAsync: () => (/* binding */ parseAsync),
/* harmony export */   safeDecode: () => (/* binding */ safeDecode),
/* harmony export */   safeDecodeAsync: () => (/* binding */ safeDecodeAsync),
/* harmony export */   safeEncode: () => (/* binding */ safeEncode),
/* harmony export */   safeEncodeAsync: () => (/* binding */ safeEncodeAsync),
/* harmony export */   safeParse: () => (/* binding */ safeParse),
/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(124);



const _parse = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
    }
    if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_1__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())));
        _util_js__WEBPACK_IMPORTED_MODULE_1__.captureStackTrace(e, _params?.callee);
        throw e;
    }
    return result.value;
};
const parse = /* @__PURE__*/ _parse(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_1__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config())));
        _util_js__WEBPACK_IMPORTED_MODULE_1__.captureStackTrace(e, params?.callee);
        throw e;
    }
    return result.value;
};
const parseAsync = /* @__PURE__*/ _parseAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new _core_js__WEBPACK_IMPORTED_MODULE_0__.$ZodAsyncError();
    }
    return result.issues.length
        ? {
            success: false,
            error: new (_Err ?? _errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodError)(result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_1__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config()))),
        }
        : { success: true, data: result.value };
};
const safeParse = /* @__PURE__*/ _safeParse(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    return result.issues.length
        ? {
            success: false,
            error: new _Err(result.issues.map((iss) => _util_js__WEBPACK_IMPORTED_MODULE_1__.finalizeIssue(iss, ctx, _core_js__WEBPACK_IMPORTED_MODULE_0__.config()))),
        }
        : { success: true, data: result.value };
};
const safeParseAsync = /* @__PURE__*/ _safeParseAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse(_Err)(schema, value, ctx);
};
const encode = /* @__PURE__*/ _encode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
    return _parse(_Err)(schema, value, _ctx);
};
const decode = /* @__PURE__*/ _decode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync = /* @__PURE__*/ _encodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync = /* @__PURE__*/ _decodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode = /* @__PURE__*/ _safeEncode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode = /* @__PURE__*/ _safeDecode(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync = /* @__PURE__*/ _safeEncodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync = /* @__PURE__*/ _safeDecodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_2__.$ZodRealError);


/***/ }),
/* 127 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ZodError: () => (/* binding */ $ZodError),
/* harmony export */   $ZodRealError: () => (/* binding */ $ZodRealError),
/* harmony export */   flattenError: () => (/* binding */ flattenError),
/* harmony export */   formatError: () => (/* binding */ formatError),
/* harmony export */   prettifyError: () => (/* binding */ prettifyError),
/* harmony export */   toDotPath: () => (/* binding */ toDotPath),
/* harmony export */   treeifyError: () => (/* binding */ treeifyError)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(124);


const initializer = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false,
    });
    Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false,
    });
    inst.message = JSON.stringify(def, _util_js__WEBPACK_IMPORTED_MODULE_0__.jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false,
    });
};
const $ZodError = (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.$constructor)("$ZodError", initializer);
const $ZodRealError = (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.$constructor)("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error.issues) {
        if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
        }
        else {
            formErrors.push(mapper(sub));
        }
    }
    return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
    const mapper = _mapper ||
        function (issue) {
            return issue.message;
        };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                issue.errors.map((issues) => processError({ issues }));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues });
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues });
            }
            else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
            }
            else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                    const el = issue.path[i];
                    const terminal = i === issue.path.length - 1;
                    if (!terminal) {
                        curr[el] = curr[el] || { _errors: [] };
                    }
                    else {
                        curr[el] = curr[el] || { _errors: [] };
                        curr[el]._errors.push(mapper(issue));
                    }
                    curr = curr[el];
                    i++;
                }
            }
        }
    };
    processError(error);
    return fieldErrors;
}
function treeifyError(error, _mapper) {
    const mapper = _mapper ||
        function (issue) {
            return issue.message;
        };
    const result = { errors: [] };
    const processError = (error, path = []) => {
        var _a, _b;
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                // regular union error
                issue.errors.map((issues) => processError({ issues }, issue.path));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues }, issue.path);
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues }, issue.path);
            }
            else {
                const fullpath = [...path, ...issue.path];
                if (fullpath.length === 0) {
                    result.errors.push(mapper(issue));
                    continue;
                }
                let curr = result;
                let i = 0;
                while (i < fullpath.length) {
                    const el = fullpath[i];
                    const terminal = i === fullpath.length - 1;
                    if (typeof el === "string") {
                        curr.properties ?? (curr.properties = {});
                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                        curr = curr.properties[el];
                    }
                    else {
                        curr.items ?? (curr.items = []);
                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                        curr = curr.items[el];
                    }
                    if (terminal) {
                        curr.errors.push(mapper(issue));
                    }
                    i++;
                }
            }
        }
    };
    processError(error);
    return result;
}
/** Format a ZodError as a human-readable string in the following form.
 *
 * From
 *
 * ```ts
 * ZodError {
 *   issues: [
 *     {
 *       expected: 'string',
 *       code: 'invalid_type',
 *       path: [ 'username' ],
 *       message: 'Invalid input: expected string'
 *     },
 *     {
 *       expected: 'number',
 *       code: 'invalid_type',
 *       path: [ 'favoriteNumbers', 1 ],
 *       message: 'Invalid input: expected number'
 *     }
 *   ];
 * }
 * ```
 *
 * to
 *
 * ```
 * username
 *   ✖ Expected number, received string at "username
 * favoriteNumbers[0]
 *   ✖ Invalid input: expected number
 * ```
 */
function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => (typeof seg === "object" ? seg.key : seg));
    for (const seg of path) {
        if (typeof seg === "number")
            segs.push(`[${seg}]`);
        else if (typeof seg === "symbol")
            segs.push(`[${JSON.stringify(String(seg))}]`);
        else if (/[^\w$]/.test(seg))
            segs.push(`[${JSON.stringify(seg)}]`);
        else {
            if (segs.length)
                segs.push(".");
            segs.push(seg);
        }
    }
    return segs.join("");
}
function prettifyError(error) {
    const lines = [];
    // sort by path length
    const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    // Process each issue
    for (const issue of issues) {
        lines.push(`✖ ${issue.message}`);
        if (issue.path?.length)
            lines.push(`  → at ${toDotPath(issue.path)}`);
    }
    // Convert Map to formatted string
    return lines.join("\n");
}


/***/ }),
/* 128 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = {
    major: 4,
    minor: 1,
    patch: 5,
};


/***/ }),
/* 129 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimePrecision: () => (/* binding */ TimePrecision),
/* harmony export */   _any: () => (/* binding */ _any),
/* harmony export */   _array: () => (/* binding */ _array),
/* harmony export */   _base64: () => (/* binding */ _base64),
/* harmony export */   _base64url: () => (/* binding */ _base64url),
/* harmony export */   _bigint: () => (/* binding */ _bigint),
/* harmony export */   _boolean: () => (/* binding */ _boolean),
/* harmony export */   _catch: () => (/* binding */ _catch),
/* harmony export */   _check: () => (/* binding */ _check),
/* harmony export */   _cidrv4: () => (/* binding */ _cidrv4),
/* harmony export */   _cidrv6: () => (/* binding */ _cidrv6),
/* harmony export */   _coercedBigint: () => (/* binding */ _coercedBigint),
/* harmony export */   _coercedBoolean: () => (/* binding */ _coercedBoolean),
/* harmony export */   _coercedDate: () => (/* binding */ _coercedDate),
/* harmony export */   _coercedNumber: () => (/* binding */ _coercedNumber),
/* harmony export */   _coercedString: () => (/* binding */ _coercedString),
/* harmony export */   _cuid: () => (/* binding */ _cuid),
/* harmony export */   _cuid2: () => (/* binding */ _cuid2),
/* harmony export */   _custom: () => (/* binding */ _custom),
/* harmony export */   _date: () => (/* binding */ _date),
/* harmony export */   _default: () => (/* binding */ _default),
/* harmony export */   _discriminatedUnion: () => (/* binding */ _discriminatedUnion),
/* harmony export */   _e164: () => (/* binding */ _e164),
/* harmony export */   _email: () => (/* binding */ _email),
/* harmony export */   _emoji: () => (/* binding */ _emoji),
/* harmony export */   _endsWith: () => (/* binding */ _endsWith),
/* harmony export */   _enum: () => (/* binding */ _enum),
/* harmony export */   _file: () => (/* binding */ _file),
/* harmony export */   _float32: () => (/* binding */ _float32),
/* harmony export */   _float64: () => (/* binding */ _float64),
/* harmony export */   _gt: () => (/* binding */ _gt),
/* harmony export */   _gte: () => (/* binding */ _gte),
/* harmony export */   _guid: () => (/* binding */ _guid),
/* harmony export */   _includes: () => (/* binding */ _includes),
/* harmony export */   _int: () => (/* binding */ _int),
/* harmony export */   _int32: () => (/* binding */ _int32),
/* harmony export */   _int64: () => (/* binding */ _int64),
/* harmony export */   _intersection: () => (/* binding */ _intersection),
/* harmony export */   _ipv4: () => (/* binding */ _ipv4),
/* harmony export */   _ipv6: () => (/* binding */ _ipv6),
/* harmony export */   _isoDate: () => (/* binding */ _isoDate),
/* harmony export */   _isoDateTime: () => (/* binding */ _isoDateTime),
/* harmony export */   _isoDuration: () => (/* binding */ _isoDuration),
/* harmony export */   _isoTime: () => (/* binding */ _isoTime),
/* harmony export */   _jwt: () => (/* binding */ _jwt),
/* harmony export */   _ksuid: () => (/* binding */ _ksuid),
/* harmony export */   _lazy: () => (/* binding */ _lazy),
/* harmony export */   _length: () => (/* binding */ _length),
/* harmony export */   _literal: () => (/* binding */ _literal),
/* harmony export */   _lowercase: () => (/* binding */ _lowercase),
/* harmony export */   _lt: () => (/* binding */ _lt),
/* harmony export */   _lte: () => (/* binding */ _lte),
/* harmony export */   _map: () => (/* binding */ _map),
/* harmony export */   _max: () => (/* binding */ _lte),
/* harmony export */   _maxLength: () => (/* binding */ _maxLength),
/* harmony export */   _maxSize: () => (/* binding */ _maxSize),
/* harmony export */   _mime: () => (/* binding */ _mime),
/* harmony export */   _min: () => (/* binding */ _gte),
/* harmony export */   _minLength: () => (/* binding */ _minLength),
/* harmony export */   _minSize: () => (/* binding */ _minSize),
/* harmony export */   _multipleOf: () => (/* binding */ _multipleOf),
/* harmony export */   _nan: () => (/* binding */ _nan),
/* harmony export */   _nanoid: () => (/* binding */ _nanoid),
/* harmony export */   _nativeEnum: () => (/* binding */ _nativeEnum),
/* harmony export */   _negative: () => (/* binding */ _negative),
/* harmony export */   _never: () => (/* binding */ _never),
/* harmony export */   _nonnegative: () => (/* binding */ _nonnegative),
/* harmony export */   _nonoptional: () => (/* binding */ _nonoptional),
/* harmony export */   _nonpositive: () => (/* binding */ _nonpositive),
/* harmony export */   _normalize: () => (/* binding */ _normalize),
/* harmony export */   _null: () => (/* binding */ _null),
/* harmony export */   _nullable: () => (/* binding */ _nullable),
/* harmony export */   _number: () => (/* binding */ _number),
/* harmony export */   _optional: () => (/* binding */ _optional),
/* harmony export */   _overwrite: () => (/* binding */ _overwrite),
/* harmony export */   _pipe: () => (/* binding */ _pipe),
/* harmony export */   _positive: () => (/* binding */ _positive),
/* harmony export */   _promise: () => (/* binding */ _promise),
/* harmony export */   _property: () => (/* binding */ _property),
/* harmony export */   _readonly: () => (/* binding */ _readonly),
/* harmony export */   _record: () => (/* binding */ _record),
/* harmony export */   _refine: () => (/* binding */ _refine),
/* harmony export */   _regex: () => (/* binding */ _regex),
/* harmony export */   _set: () => (/* binding */ _set),
/* harmony export */   _size: () => (/* binding */ _size),
/* harmony export */   _startsWith: () => (/* binding */ _startsWith),
/* harmony export */   _string: () => (/* binding */ _string),
/* harmony export */   _stringFormat: () => (/* binding */ _stringFormat),
/* harmony export */   _stringbool: () => (/* binding */ _stringbool),
/* harmony export */   _success: () => (/* binding */ _success),
/* harmony export */   _superRefine: () => (/* binding */ _superRefine),
/* harmony export */   _symbol: () => (/* binding */ _symbol),
/* harmony export */   _templateLiteral: () => (/* binding */ _templateLiteral),
/* harmony export */   _toLowerCase: () => (/* binding */ _toLowerCase),
/* harmony export */   _toUpperCase: () => (/* binding */ _toUpperCase),
/* harmony export */   _transform: () => (/* binding */ _transform),
/* harmony export */   _trim: () => (/* binding */ _trim),
/* harmony export */   _tuple: () => (/* binding */ _tuple),
/* harmony export */   _uint32: () => (/* binding */ _uint32),
/* harmony export */   _uint64: () => (/* binding */ _uint64),
/* harmony export */   _ulid: () => (/* binding */ _ulid),
/* harmony export */   _undefined: () => (/* binding */ _undefined),
/* harmony export */   _union: () => (/* binding */ _union),
/* harmony export */   _unknown: () => (/* binding */ _unknown),
/* harmony export */   _uppercase: () => (/* binding */ _uppercase),
/* harmony export */   _url: () => (/* binding */ _url),
/* harmony export */   _uuid: () => (/* binding */ _uuid),
/* harmony export */   _uuidv4: () => (/* binding */ _uuidv4),
/* harmony export */   _uuidv6: () => (/* binding */ _uuidv6),
/* harmony export */   _uuidv7: () => (/* binding */ _uuidv7),
/* harmony export */   _void: () => (/* binding */ _void),
/* harmony export */   _xid: () => (/* binding */ _xid)
/* harmony export */ });
/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(122);
/* harmony import */ var _schemas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(121);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(124);



function _string(Class, params) {
    return new Class({
        type: "string",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _coercedString(Class, params) {
    return new Class({
        type: "string",
        coerce: true,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _email(Class, params) {
    return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _guid(Class, params) {
    return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uuid(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uuidv4(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uuidv6(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uuidv7(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _url(Class, params) {
    return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _emoji(Class, params) {
    return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _nanoid(Class, params) {
    return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _cuid(Class, params) {
    return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _cuid2(Class, params) {
    return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _ulid(Class, params) {
    return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _xid(Class, params) {
    return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _ksuid(Class, params) {
    return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _ipv4(Class, params) {
    return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _ipv6(Class, params) {
    return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _cidrv4(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _cidrv6(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _base64(Class, params) {
    return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _base64url(Class, params) {
    return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _e164(Class, params) {
    return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _jwt(Class, params) {
    return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
const TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6,
};
function _isoDateTime(Class, params) {
    return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _isoDate(Class, params) {
    return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _isoTime(Class, params) {
    return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _isoDuration(Class, params) {
    return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _number(Class, params) {
    return new Class({
        type: "number",
        checks: [],
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _coercedNumber(Class, params) {
    return new Class({
        type: "number",
        coerce: true,
        checks: [],
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _int(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _float32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float32",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _float64(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float64",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _int32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "int32",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uint32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "uint32",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _boolean(Class, params) {
    return new Class({
        type: "boolean",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _coercedBoolean(Class, params) {
    return new Class({
        type: "boolean",
        coerce: true,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _bigint(Class, params) {
    return new Class({
        type: "bigint",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _coercedBigint(Class, params) {
    return new Class({
        type: "bigint",
        coerce: true,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _int64(Class, params) {
    return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "int64",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uint64(Class, params) {
    return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "uint64",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _symbol(Class, params) {
    return new Class({
        type: "symbol",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _undefined(Class, params) {
    return new Class({
        type: "undefined",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _null(Class, params) {
    return new Class({
        type: "null",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _any(Class) {
    return new Class({
        type: "any",
    });
}
function _unknown(Class) {
    return new Class({
        type: "unknown",
    });
}
function _never(Class, params) {
    return new Class({
        type: "never",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _void(Class, params) {
    return new Class({
        type: "void",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _date(Class, params) {
    return new Class({
        type: "date",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _coercedDate(Class, params) {
    return new Class({
        type: "date",
        coerce: true,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _nan(Class, params) {
    return new Class({
        type: "nan",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _lt(value, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckLessThan({
        check: "less_than",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _lte(value, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckLessThan({
        check: "less_than",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        value,
        inclusive: true,
    });
}

function _gt(value, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckGreaterThan({
        check: "greater_than",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _gte(value, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckGreaterThan({
        check: "greater_than",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        value,
        inclusive: true,
    });
}

function _positive(params) {
    return _gt(0, params);
}
// negative
function _negative(params) {
    return _lt(0, params);
}
// nonpositive
function _nonpositive(params) {
    return _lte(0, params);
}
// nonnegative
function _nonnegative(params) {
    return _gte(0, params);
}
function _multipleOf(value, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMultipleOf({
        check: "multiple_of",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        value,
    });
}
function _maxSize(maximum, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMaxSize({
        check: "max_size",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        maximum,
    });
}
function _minSize(minimum, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMinSize({
        check: "min_size",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        minimum,
    });
}
function _size(size, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckSizeEquals({
        check: "size_equals",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        size,
    });
}
function _maxLength(maximum, params) {
    const ch = new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMaxLength({
        check: "max_length",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        maximum,
    });
    return ch;
}
function _minLength(minimum, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMinLength({
        check: "min_length",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        minimum,
    });
}
function _length(length, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckLengthEquals({
        check: "length_equals",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        length,
    });
}
function _regex(pattern, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        pattern,
    });
}
function _lowercase(params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _uppercase(params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _includes(includes, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        includes,
    });
}
function _startsWith(prefix, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        prefix,
    });
}
function _endsWith(suffix, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
        suffix,
    });
}
function _property(property, schema, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckProperty({
        check: "property",
        property,
        schema,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _mime(types, params) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckMimeType({
        check: "mime_type",
        mime: types,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _overwrite(tx) {
    return new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheckOverwrite({
        check: "overwrite",
        tx,
    });
}
// normalize
function _normalize(form) {
    return _overwrite((input) => input.normalize(form));
}
// trim
function _trim() {
    return _overwrite((input) => input.trim());
}
// toLowerCase
function _toLowerCase() {
    return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
function _toUpperCase() {
    return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
    return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _union(Class, options, params) {
    return new Class({
        type: "union",
        options,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _discriminatedUnion(Class, discriminator, options, params) {
    return new Class({
        type: "union",
        options,
        discriminator,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _intersection(Class, left, right) {
    return new Class({
        type: "intersection",
        left,
        right,
    });
}
// export function _tuple(
//   Class: util.SchemaClass<schemas.$ZodTuple>,
//   items: [],
//   params?: string | $ZodTupleParams
// ): schemas.$ZodTuple<[], null>;
function _tuple(Class, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof _schemas_js__WEBPACK_IMPORTED_MODULE_2__.$ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class({
        type: "tuple",
        items,
        rest,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _record(Class, keyType, valueType, params) {
    return new Class({
        type: "record",
        keyType,
        valueType,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _map(Class, keyType, valueType, params) {
    return new Class({
        type: "map",
        keyType,
        valueType,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _set(Class, valueType, params) {
    return new Class({
        type: "set",
        valueType,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _enum(Class, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    // if (Array.isArray(values)) {
    //   for (const value of values) {
    //     entries[value] = value;
    //   }
    // } else {
    //   Object.assign(entries, values);
    // }
    // const entries: util.EnumLike = {};
    // for (const val of values) {
    //   entries[val] = val;
    // }
    return new Class({
        type: "enum",
        entries,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
function _nativeEnum(Class, entries, params) {
    return new Class({
        type: "enum",
        entries,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _literal(Class, value, params) {
    return new Class({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _file(Class, params) {
    return new Class({
        type: "file",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _transform(Class, fn) {
    return new Class({
        type: "transform",
        transform: fn,
    });
}
function _optional(Class, innerType) {
    return new Class({
        type: "optional",
        innerType,
    });
}
function _nullable(Class, innerType) {
    return new Class({
        type: "nullable",
        innerType,
    });
}
function _default(Class, innerType, defaultValue) {
    return new Class({
        type: "default",
        innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : _util_js__WEBPACK_IMPORTED_MODULE_0__.shallowClone(defaultValue);
        },
    });
}
function _nonoptional(Class, innerType, params) {
    return new Class({
        type: "nonoptional",
        innerType,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _success(Class, innerType) {
    return new Class({
        type: "success",
        innerType,
    });
}
function _catch(Class, innerType, catchValue) {
    return new Class({
        type: "catch",
        innerType,
        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
    });
}
function _pipe(Class, in_, out) {
    return new Class({
        type: "pipe",
        in: in_,
        out,
    });
}
function _readonly(Class, innerType) {
    return new Class({
        type: "readonly",
        innerType,
    });
}
function _templateLiteral(Class, parts, params) {
    return new Class({
        type: "template_literal",
        parts,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
}
function _lazy(Class, getter) {
    return new Class({
        type: "lazy",
        getter,
    });
}
function _promise(Class, innerType) {
    return new Class({
        type: "promise",
        innerType,
    });
}
function _custom(Class, fn, _params) {
    const norm = _util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(_params);
    norm.abort ?? (norm.abort = true); // default to abort:false
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ...norm,
    });
    return schema;
}
// same as _custom but defaults to abort:false
function _refine(Class, fn, _params) {
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(_params),
    });
    return schema;
}
function _superRefine(fn) {
    const ch = _check((payload) => {
        payload.addIssue = (issue) => {
            if (typeof issue === "string") {
                payload.issues.push(_util_js__WEBPACK_IMPORTED_MODULE_0__.issue(issue, payload.value, ch._zod.def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = ch);
                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                payload.issues.push(_util_js__WEBPACK_IMPORTED_MODULE_0__.issue(_issue));
            }
        };
        return fn(payload.value, payload);
    });
    return ch;
}
function _check(fn, params) {
    const ch = new _checks_js__WEBPACK_IMPORTED_MODULE_1__.$ZodCheck({
        check: "custom",
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
}
function _stringbool(Classes, _params) {
    const params = _util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
        truthyArray = truthyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
        falsyArray = falsyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? _schemas_js__WEBPACK_IMPORTED_MODULE_2__.$ZodCodec;
    const _Boolean = Classes.Boolean ?? _schemas_js__WEBPACK_IMPORTED_MODULE_2__.$ZodBoolean;
    const _String = Classes.String ?? _schemas_js__WEBPACK_IMPORTED_MODULE_2__.$ZodString;
    const stringSchema = new _String({ type: "string", error: params.error });
    const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
    const codec = new _Codec({
        type: "pipe",
        in: stringSchema,
        out: booleanSchema,
        transform: ((input, payload) => {
            let data = input;
            if (params.case !== "sensitive")
                data = data.toLowerCase();
            if (truthySet.has(data)) {
                return true;
            }
            else if (falsySet.has(data)) {
                return false;
            }
            else {
                payload.issues.push({
                    code: "invalid_value",
                    expected: "stringbool",
                    values: [...truthySet, ...falsySet],
                    input: payload.value,
                    inst: codec,
                    continue: false,
                });
                return {};
            }
        }),
        reverseTransform: ((input, _payload) => {
            if (input === true) {
                return truthyArray[0] || "true";
            }
            else {
                return falsyArray[0] || "false";
            }
        }),
        error: params.error,
    });
    return codec;
}
function _stringFormat(Class, format, fnOrRegex, _params = {}) {
    const params = _util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(_params);
    const def = {
        ..._util_js__WEBPACK_IMPORTED_MODULE_0__.normalizeParams(_params),
        check: "string_format",
        type: "string",
        format,
        fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
        ...params,
    };
    if (fnOrRegex instanceof RegExp) {
        def.pattern = fnOrRegex;
    }
    const inst = new Class(def);
    return inst;
}


/***/ }),
/* 130 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeAsync: () => (/* binding */ decodeAsync),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   encodeAsync: () => (/* binding */ encodeAsync),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parseAsync: () => (/* binding */ parseAsync),
/* harmony export */   safeDecode: () => (/* binding */ safeDecode),
/* harmony export */   safeDecodeAsync: () => (/* binding */ safeDecodeAsync),
/* harmony export */   safeEncode: () => (/* binding */ safeEncode),
/* harmony export */   safeEncodeAsync: () => (/* binding */ safeEncodeAsync),
/* harmony export */   safeParse: () => (/* binding */ safeParse),
/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync)
/* harmony export */ });
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);


const parse = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._parse(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const parseAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._parseAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeParse = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeParse(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeParseAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeParseAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
// Codec functions
const encode = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._encode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const decode = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._decode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const encodeAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._encodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const decodeAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._decodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeEncode = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeEncode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeDecode = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeDecode(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeEncodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _core_index_js__WEBPACK_IMPORTED_MODULE_0__._safeDecodeAsync(_errors_js__WEBPACK_IMPORTED_MODULE_1__.ZodRealError);


/***/ }),
/* 131 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZodError: () => (/* binding */ ZodError),
/* harmony export */   ZodRealError: () => (/* binding */ ZodRealError)
/* harmony export */ });
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(127);
/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(120);
/* harmony import */ var _core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(124);



const initializer = (inst, issues) => {
    _core_index_js__WEBPACK_IMPORTED_MODULE_0__.$ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
        format: {
            value: (mapper) => _core_index_js__WEBPACK_IMPORTED_MODULE_0__.formatError(inst, mapper),
            // enumerable: false,
        },
        flatten: {
            value: (mapper) => _core_index_js__WEBPACK_IMPORTED_MODULE_0__.flattenError(inst, mapper),
            // enumerable: false,
        },
        addIssue: {
            value: (issue) => {
                inst.issues.push(issue);
                inst.message = JSON.stringify(inst.issues, _core_util_js__WEBPACK_IMPORTED_MODULE_1__.jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        addIssues: {
            value: (issues) => {
                inst.issues.push(...issues);
                inst.message = JSON.stringify(inst.issues, _core_util_js__WEBPACK_IMPORTED_MODULE_1__.jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        isEmpty: {
            get() {
                return inst.issues.length === 0;
            },
            // enumerable: false,
        },
    });
    // Object.defineProperty(inst, "isEmpty", {
    //   get() {
    //     return inst.issues.length === 0;
    //   },
    // });
};
const ZodError = _core_index_js__WEBPACK_IMPORTED_MODULE_2__.$constructor("ZodError", initializer);
const ZodRealError = _core_index_js__WEBPACK_IMPORTED_MODULE_2__.$constructor("ZodError", initializer, {
    Parent: Error,
});
// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
// export type ErrorMapCtx = core.$ZodErrorMapCtx;


/***/ }),
/* 132 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $ZodRegistry: () => (/* binding */ $ZodRegistry),
/* harmony export */   $input: () => (/* binding */ $input),
/* harmony export */   $output: () => (/* binding */ $output),
/* harmony export */   globalRegistry: () => (/* binding */ globalRegistry),
/* harmony export */   registry: () => (/* binding */ registry)
/* harmony export */ });
const $output = Symbol("ZodOutput");
const $input = Symbol("ZodInput");
class $ZodRegistry {
    constructor() {
        this._map = new Map();
        this._idmap = new Map();
    }
    add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
            if (this._idmap.has(meta.id)) {
                throw new Error(`ID ${meta.id} already exists in the registry`);
            }
            this._idmap.set(meta.id, schema);
        }
        return this;
    }
    clear() {
        this._map = new Map();
        this._idmap = new Map();
        return this;
    }
    remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
            this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
    }
    get(schema) {
        // return this._map.get(schema) as any;
        // inherit metadata
        const p = schema._zod.parent;
        if (p) {
            const pm = { ...(this.get(p) ?? {}) };
            delete pm.id; // do not inherit id
            const f = { ...pm, ...this._map.get(schema) };
            return Object.keys(f).length ? f : undefined;
        }
        return this._map.get(schema);
    }
    has(schema) {
        return this._map.has(schema);
    }
}
// registries
function registry() {
    return new $ZodRegistry();
}
const globalRegistry = /*@__PURE__*/ registry();


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvSchemaGeneratorService: () => (/* binding */ EnvSchemaGeneratorService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config_env_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EnvSchemaGeneratorService_1;


let EnvSchemaGeneratorService = EnvSchemaGeneratorService_1 = class EnvSchemaGeneratorService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(EnvSchemaGeneratorService_1.name);
    }
    async generateEnvExample() {
        const config = (0,_config_env_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
        const schema = this.extractSchemaFromConfig(config);
        const content = this.generateEnvContent(schema);
        const result = {
            content,
            fields: schema.fields,
            metadata: schema.metadata,
        };
        this.logger.log('Generated .env.example from Zod schema', {
            fieldCount: schema.fields.length,
            requiredFields: schema.fields.filter(f => f.required).length,
        });
        return result;
    }
    extractSchemaFromConfig(config) {
        const fields = [];
        this.analyzeConfigStructure(config, fields);
        return {
            fields,
            metadata: {
                generatedAt: new Date(),
                version: process.env.npm_package_version ?? '1.0.0',
                environment: process.env.NODE_ENV ?? 'development',
            },
        };
    }
    analyzeConfigStructure(obj, fields, prefix = '') {
        if (typeof obj !== 'object' || obj == null) {
            return;
        }
        for (const [key, value] of Object.entries(obj)) {
            const fieldName = prefix ? `${prefix}_${key}` : key;
            if (typeof value === 'object' && value != null && !Array.isArray(value)) {
                this.analyzeConfigStructure(value, fields, fieldName);
            }
            else {
                const field = {
                    name: fieldName.toUpperCase(),
                    type: this.determineType(value),
                    required: this.isRequired(value),
                    description: this.generateDescription(key),
                    defaultValue: this.generateDefaultValue(value),
                    validation: this.generateValidation(key) ?? {},
                };
                fields.push(field);
            }
        }
    }
    determineType(value) {
        if (typeof value === 'string')
            return 'string';
        if (typeof value === 'number')
            return 'number';
        if (typeof value === 'boolean')
            return 'boolean';
        if (Array.isArray(value))
            return 'array';
        if (typeof value === 'object' && value != null)
            return 'object';
        return 'string';
    }
    isRequired(value) {
        if (value === '' || value === null || value === undefined)
            return true;
        return false;
    }
    generateDescription(key) {
        const descriptions = {
            NODE_ENV: 'Application environment (development, staging, production)',
            PORT: 'Port number for the application server',
            DATABASE_URL: 'Database connection string',
            REDIS_URL: 'Redis connection string',
            JWT_SECRET: 'Secret key for JWT token signing',
            API_KEY: 'API key for external services',
            LOG_LEVEL: 'Logging level (debug, info, warn, error)',
            CORS_ORIGIN: 'Allowed CORS origins',
            RATE_LIMIT_WINDOW: 'Rate limiting window in milliseconds',
            RATE_LIMIT_MAX: 'Maximum requests per window',
        };
        return descriptions[key.toUpperCase()] ?? `Configuration for ${key}`;
    }
    generateDefaultValue(value) {
        if (value === null || value === undefined)
            return '';
        if (typeof value === 'string')
            return value;
        if (typeof value === 'number')
            return value.toString();
        if (typeof value === 'boolean')
            return value.toString();
        if (Array.isArray(value))
            return JSON.stringify(value);
        if (typeof value === 'object')
            return JSON.stringify(value);
        return '';
    }
    generateValidation(key) {
        const validation = {};
        if (key.toLowerCase().includes('port')) {
            validation.min = 1;
            validation.max = 65535;
        }
        if (key.toLowerCase().includes('url')) {
            validation.pattern = '^https?://.+';
        }
        if (key.toLowerCase().includes('email')) {
            validation.pattern = '^[^@]+@[^@]+\\.[^@]+$';
        }
        if (key.toLowerCase().includes('env')) {
            validation.enum = ['development', 'staging', 'production', 'test'];
        }
        if (key.toLowerCase().includes('level')) {
            validation.enum = ['debug', 'info', 'warn', 'error'];
        }
        return Object.keys(validation).length > 0 ? validation : undefined;
    }
    generateEnvContent(schema) {
        let content = `# Environment Configuration\n`;
        content += `# Generated automatically from Zod schema\n`;
        content += `# Generated at: ${schema.metadata.generatedAt.toISOString()}\n`;
        content += `# Version: ${schema.metadata.version}\n`;
        content += `# Environment: ${schema.metadata.environment}\n\n`;
        const categories = this.groupFieldsByCategory(schema.fields);
        for (const [category, fields] of Object.entries(categories)) {
            content += `# ${category}\n`;
            for (const field of fields) {
                content += this.generateFieldLine(field);
            }
            content += '\n';
        }
        return content;
    }
    groupFieldsByCategory(fields) {
        const categories = {
            Application: [],
            Database: [],
            Redis: [],
            Security: [],
            Logging: [],
            'External Services': [],
            'Rate Limiting': [],
            Other: [],
        };
        for (const field of fields) {
            const name = field.name.toLowerCase();
            if (name.includes('node_env') || name.includes('port')) {
                if (categories['Application']) {
                    categories['Application'].push(field);
                }
            }
            else if (name.includes('database') || name.includes('db')) {
                if (categories['Database']) {
                    categories['Database'].push(field);
                }
            }
            else if (name.includes('redis')) {
                if (categories['Redis']) {
                    categories['Redis'].push(field);
                }
            }
            else if (name.includes('jwt') ||
                name.includes('secret') ||
                name.includes('key')) {
                if (categories['Security']) {
                    categories['Security'].push(field);
                }
            }
            else if (name.includes('log')) {
                if (categories['Logging']) {
                    categories['Logging'].push(field);
                }
            }
            else if (name.includes('api') || name.includes('external')) {
                if (categories['External Services']) {
                    categories['External Services'].push(field);
                }
            }
            else if (name.includes('rate') || name.includes('limit')) {
                if (categories['Rate Limiting']) {
                    categories['Rate Limiting'].push(field);
                }
            }
            else {
                if (categories['Other']) {
                    categories['Other'].push(field);
                }
            }
        }
        for (const [category, fields] of Object.entries(categories)) {
            if (fields.length === 0) {
                delete categories[category];
            }
        }
        return categories;
    }
    generateFieldLine(field) {
        let line = `${field.name}=`;
        if (field.defaultValue != null) {
            line += field.defaultValue;
        }
        else if (field.required) {
            line += '<REQUIRED>';
        }
        else {
            line += '<OPTIONAL>';
        }
        if (field.description != null && field.description !== '') {
            line += ` # ${field.description}`;
        }
        return line + '\n';
    }
    async validateEnvFile(envContent) {
        const schema = await this.generateEnvExample();
        const lines = envContent.split('\n');
        const errors = [];
        const warnings = [];
        const missingFields = [];
        for (const field of schema.fields) {
            if (field.required) {
                const hasField = lines.some(line => line.trim().startsWith(`${field.name}=`) &&
                    !line.trim().startsWith('#'));
                if (!hasField) {
                    missingFields.push(field.name);
                    errors.push(`Missing required field: ${field.name}`);
                }
            }
        }
        for (const line of lines) {
            if (line.trim().startsWith('#') || line.trim() === '')
                continue;
            const [key, value] = line.split('=');
            if (key == null || value == null)
                continue;
            const field = schema.fields.find(f => f.name === key.trim());
            if (field == null)
                continue;
            if (field.validation != null) {
                const validationResult = this.validateFieldValue(field, value.trim());
                if (!validationResult.valid) {
                    errors.push(`Invalid value for ${key}: ${validationResult.error}`);
                }
            }
        }
        return {
            valid: errors.length === 0,
            errors,
            warnings,
            missingFields,
        };
    }
    validateFieldValue(field, value) {
        if (field.validation == null)
            return { valid: true };
        if (field.validation.min != null) {
            const numValue = parseFloat(value);
            if (isNaN(numValue) || numValue < field.validation.min) {
                return {
                    valid: false,
                    error: `Value must be >= ${field.validation.min}`,
                };
            }
        }
        if (field.validation.max != null) {
            const numValue = parseFloat(value);
            if (isNaN(numValue) || numValue > field.validation.max) {
                return {
                    valid: false,
                    error: `Value must be <= ${field.validation.max}`,
                };
            }
        }
        if (field.validation.pattern != null && field.validation.pattern !== '') {
            const regex = new RegExp(field.validation.pattern);
            if (!regex.test(value)) {
                return {
                    valid: false,
                    error: `Value must match pattern: ${field.validation.pattern}`,
                };
            }
        }
        if (field.validation.enum != null &&
            field.validation.enum.length > 0 &&
            !field.validation.enum.includes(value)) {
            return {
                valid: false,
                error: `Value must be one of: ${field.validation.enum.join(', ')}`,
            };
        }
        return { valid: true };
    }
};
EnvSchemaGeneratorService = EnvSchemaGeneratorService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], EnvSchemaGeneratorService);



/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FeatureFlagsController: () => (/* binding */ FeatureFlagsController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(135);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;





let FeatureFlagsController = class FeatureFlagsController {
    constructor(featureFlagsService) {
        this.featureFlagsService = featureFlagsService;
    }
    async getAllFlags() {
        return this.featureFlagsService.getAllFlags();
    }
    async getFlag(key) {
        const flag = await this.featureFlagsService.getFlag(key);
        if (!flag) {
            return { error: 'Feature flag not found' };
        }
        return flag;
    }
    async getFlagValue(key, query) {
        const userContext = {
            userId: query.userId ?? '',
            email: query.email ?? '',
            role: query.role ?? '',
            environment: query.environment ?? '',
            custom: query.custom ?? {},
        };
        const value = await this.featureFlagsService.getFlagValue(key, userContext);
        return { key, value, userContext };
    }
    async isFlagEnabled(key, query) {
        const userContext = {
            userId: query.userId ?? '',
            email: query.email ?? '',
            role: query.role ?? '',
            environment: query.environment ?? '',
            custom: query.custom ?? {},
        };
        const enabled = await this.featureFlagsService.isEnabled(key, userContext);
        return { key, enabled, userContext };
    }
    async createFlag(createFlagDto) {
        return this.featureFlagsService.createFlag(createFlagDto);
    }
    async updateFlag(key, updateFlagDto) {
        const updatedFlag = await this.featureFlagsService.updateFlag(key, updateFlagDto);
        if (!updatedFlag) {
            return { error: 'Feature flag not found' };
        }
        return updatedFlag;
    }
    async deleteFlag(key) {
        const deleted = await this.featureFlagsService.deleteFlag(key);
        if (!deleted) {
            return { error: 'Feature flag not found' };
        }
        return { message: 'Feature flag deleted successfully' };
    }
    async getCacheStats() {
        return this.featureFlagsService.getCacheStats();
    }
    async clearCache() {
        return { message: 'Cache cleared successfully' };
    }
    async healthCheck() {
        const healthy = await this.featureFlagsService.healthCheck();
        return {
            service: 'feature-flags',
            status: healthy ? 'healthy' : 'unhealthy',
            timestamp: new Date().toISOString(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all feature flags' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of all feature flags' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "getAllFlags", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get feature flag by key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Feature flag key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Feature flag details' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Feature flag not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "getFlag", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':key/value'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get feature flag value for user' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Feature flag key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'userId', required: false, description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'email', required: false, description: 'User email' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'role', required: false, description: 'User role' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Feature flag value' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Feature flag not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "getFlagValue", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':key/enabled'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check if feature flag is enabled for user' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Feature flag key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'userId', required: false, description: 'User ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'email', required: false, description: 'User email' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'role', required: false, description: 'User role' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Feature flag enabled status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Feature flag not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "isFlagEnabled", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)(),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create new feature flag' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Feature flag created' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Bad request' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "createFlag", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)(':key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update feature flag' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Feature flag key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Feature flag updated' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Feature flag not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "updateFlag", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)(':key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete feature flag' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'Feature flag key' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Feature flag deleted' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Feature flag not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "deleteFlag", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cache/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get cache statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Cache statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "getCacheStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('cache/clear'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clear feature flags cache' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Cache cleared' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 403, description: 'Forbidden' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "clearCache", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Feature flags health check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Health status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], FeatureFlagsController.prototype, "healthCheck", null);
FeatureFlagsController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Feature Flags'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('feature-flags'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_3__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_3__.UserRole.NETWORK_MANAGER),
    __metadata("design:paramtypes", [typeof (_a = typeof _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__.FeatureFlagsService !== "undefined" && _feature_flags_service__WEBPACK_IMPORTED_MODULE_4__.FeatureFlagsService) === "function" ? _a : Object])
], FeatureFlagsController);



/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FeatureFlagsService: () => (/* binding */ FeatureFlagsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _config_env_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var FeatureFlagsService_1;



const FeatureFlagSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    key: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    type: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['boolean', 'string', 'number', 'json']),
    defaultValue: zod__WEBPACK_IMPORTED_MODULE_2__.unknown(),
    rules: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.object({
        condition: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['user_id', 'role', 'environment', 'percentage']),
        value: zod__WEBPACK_IMPORTED_MODULE_2__.unknown(),
        operator: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
            'equals',
            'not_equals',
            'contains',
            'greater_than',
            'less_than',
        ]),
    }))
        .optional(),
    environments: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
});
let FeatureFlagsService = FeatureFlagsService_1 = class FeatureFlagsService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(FeatureFlagsService_1.name);
        this.flags = new Map();
        this.cache = new Map();
        this.initializeConfig();
        this.initializeDefaultFlags();
    }
    initializeConfig() {
        const envConfig = (0,_config_env_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
        this.config = {
            provider: 'custom',
            apiKey: '',
            baseUrl: '',
            environment: envConfig.NODE_ENV,
            cacheEnabled: false,
            cacheTtl: 300,
        };
    }
    initializeDefaultFlags() {
        const defaultFlags = [
            {
                key: 'new-ui-enabled',
                name: 'New UI Enabled',
                description: 'Enable new user interface',
                enabled: true,
                type: 'boolean',
                defaultValue: false,
                environments: ['development', 'staging'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                key: 'beta-features',
                name: 'Beta Features',
                description: 'Enable beta features for testing',
                enabled: true,
                type: 'boolean',
                defaultValue: false,
                rules: undefined,
                environments: ['development', 'staging'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                key: 'rate-limit-percentage',
                name: 'Rate Limit Percentage',
                description: 'Percentage of users to apply rate limiting',
                enabled: true,
                type: 'number',
                defaultValue: 10,
                environments: ['production'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                key: 'maintenance-mode',
                name: 'Maintenance Mode',
                description: 'Enable maintenance mode',
                enabled: false,
                type: 'boolean',
                defaultValue: false,
                environments: ['production', 'staging'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultFlags.forEach(flag => {
            this.flags.set(flag.key, flag);
        });
    }
    async getFlagValue(flagKey, userContext) {
        try {
            const cacheKey = `${flagKey}:${JSON.stringify(userContext)}`;
            if (this.config.cacheEnabled) {
                const cached = this.cache.get(cacheKey);
                if (cached &&
                    Date.now() - cached.timestamp < this.config.cacheTtl * 1000) {
                    return cached.value;
                }
            }
            const flag = this.flags.get(flagKey);
            if (!flag) {
                this.logger.warn(`Feature flag not found: ${flagKey}`);
                return null;
            }
            if (!flag.enabled) {
                return flag.defaultValue;
            }
            if (!flag.environments.includes(this.config.environment)) {
                return flag.defaultValue;
            }
            const value = this.applyRules(flag, userContext);
            if (this.config.cacheEnabled) {
                this.cache.set(cacheKey, { value, timestamp: Date.now() });
            }
            return value;
        }
        catch (error) {
            this.logger.error(`Error getting feature flag ${flagKey}:`, error);
            return null;
        }
    }
    async isEnabled(flagKey, userContext) {
        const value = await this.getFlagValue(flagKey, userContext);
        return Boolean(value);
    }
    async getString(flagKey, userContext) {
        const value = await this.getFlagValue(flagKey, userContext);
        return String(value ?? '');
    }
    async getNumber(flagKey, userContext) {
        const value = await this.getFlagValue(flagKey, userContext);
        return Number(value ?? 0);
    }
    async getJson(flagKey, userContext) {
        const value = await this.getFlagValue(flagKey, userContext);
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return null;
            }
        }
        return value;
    }
    applyRules(flag, userContext) {
        if (!flag.rules || flag.rules.length === 0) {
            return flag.defaultValue;
        }
        const sortedRules = [...flag.rules].sort((a, b) => {
            const priorityA = a.priority ?? 0;
            const priorityB = b.priority ?? 0;
            return priorityB - priorityA;
        });
        for (const rule of sortedRules) {
            if (this.evaluateRule(rule, userContext)) {
                return rule.value;
            }
        }
        return flag.defaultValue;
    }
    evaluateRule(rule, userContext) {
        switch (rule.condition) {
            case 'user_id':
                return this.evaluateCondition(userContext.userId, rule.value, rule.operator);
            case 'role':
                return this.evaluateCondition(userContext.role, rule.value, rule.operator);
            case 'environment':
                return this.evaluateCondition(this.config.environment, rule.value, rule.operator);
            case 'percentage':
                return this.evaluatePercentage(userContext.userId, rule.value);
            default:
                return false;
        }
    }
    evaluateCondition(actual, expected, operator) {
        switch (operator) {
            case 'equals':
                return actual === expected;
            case 'not_equals':
                return actual !== expected;
            case 'contains':
                return String(actual).includes(String(expected));
            case 'greater_than':
                return Number(actual) > Number(expected);
            case 'less_than':
                return Number(actual) < Number(expected);
            default:
                return false;
        }
    }
    evaluatePercentage(userId, percentage) {
        if (userId == null || userId === '')
            return false;
        const hash = this.hashString(userId);
        const userPercentage = hash % 100;
        return userPercentage < percentage;
    }
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }
    async createFlag(flagData) {
        try {
            const validatedFlag = FeatureFlagSchema.parse({
                ...flagData,
                createdAt: new Date(),
                updatedAt: new Date(),
            });
            this.flags.set(validatedFlag.key, validatedFlag);
            this.logger.log(`Feature flag created: ${validatedFlag.key}`);
            return validatedFlag;
        }
        catch (error) {
            this.logger.error('Error creating feature flag:', error);
            throw error;
        }
    }
    async updateFlag(flagKey, updates) {
        const flag = this.flags.get(flagKey);
        if (!flag) {
            return null;
        }
        const updatedFlag = FeatureFlagSchema.parse({
            ...flag,
            ...updates,
            updatedAt: new Date(),
        });
        this.flags.set(flagKey, updatedFlag);
        this.logger.log(`Feature flag updated: ${flagKey}`);
        this.clearCache();
        return updatedFlag;
    }
    async deleteFlag(flagKey) {
        const deleted = this.flags.delete(flagKey);
        if (deleted) {
            this.logger.log(`Feature flag deleted: ${flagKey}`);
            this.clearCache();
        }
        return deleted;
    }
    async getAllFlags() {
        return Array.from(this.flags.values());
    }
    async getFlag(flagKey) {
        return this.flags.get(flagKey) ?? null;
    }
    clearCache() {
        this.cache.clear();
    }
    getCacheStats() {
        return {
            size: this.cache.size,
            hitRate: 0,
        };
    }
    async healthCheck() {
        try {
            const testFlag = await this.isEnabled('new-ui-enabled', {
                userId: 'test',
            });
            return typeof testFlag === 'boolean';
        }
        catch (error) {
            this.logger.error('Feature flags health check failed:', error);
            return false;
        }
    }
};
FeatureFlagsService = FeatureFlagsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], FeatureFlagsService);



/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TestFixturesService: () => (/* binding */ TestFixturesService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var TestFixturesService_1;

let TestFixturesService = TestFixturesService_1 = class TestFixturesService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(TestFixturesService_1.name);
        this.fixtures = new Map();
        this.environments = new Map();
        this.results = [];
        this.initializeDefaultFixtures();
    }
    createFixture(fixture) {
        const fixtureWithId = {
            ...fixture,
            id: this.generateId('fixture'),
        };
        this.fixtures.set(fixtureWithId.id, fixtureWithId);
        this.logger.log(`Created test fixture: ${fixtureWithId.id}`, {
            name: fixture.name,
        });
        return fixtureWithId;
    }
    async createEnvironment(name, description, fixtureIds) {
        const environment = {
            id: this.generateId('env'),
            name,
            description: description ?? '',
            fixtures: fixtureIds
                ? fixtureIds
                    .map(id => this.fixtures.get(id))
                    .filter(Boolean)
                : [],
            config: this.getDefaultTestConfig(),
            createdAt: new Date(),
            isActive: true,
        };
        this.environments.set(environment.id, environment);
        this.logger.log(`Created test environment: ${environment.id}`, {
            name,
            fixtureCount: environment.fixtures.length,
        });
        return environment;
    }
    async setupEnvironment(environmentId) {
        const environment = this.environments.get(environmentId);
        if (!environment) {
            throw new Error(`Environment not found: ${environmentId}`);
        }
        const results = [];
        for (const fixture of environment.fixtures) {
            const result = await this.setupFixture(fixture.id, environmentId);
            results.push(result);
        }
        this.logger.log(`Environment setup completed: ${environmentId}`, {
            totalFixtures: environment.fixtures.length,
            successful: results.filter(r => r.success).length,
        });
        return results;
    }
    async setupFixture(fixtureId, environmentId) {
        const fixture = this.fixtures.get(fixtureId);
        if (!fixture) {
            throw new Error(`Fixture not found: ${fixtureId}`);
        }
        const startTime = Date.now();
        let success = false;
        let error;
        try {
            if (fixture.setup) {
                await fixture.setup();
            }
            success = true;
        }
        catch (err) {
            error = err instanceof Error ? err.message : 'Unknown error';
            success = false;
        }
        const duration = Date.now() - startTime;
        const result = {
            fixtureId,
            environmentId,
            success,
            duration,
            error: error ?? '',
            timestamp: new Date(),
        };
        this.results.push(result);
        this.logger.log(`Fixture setup completed: ${fixtureId}`, {
            success,
            duration,
            error,
        });
        return result;
    }
    async cleanupEnvironment(environmentId) {
        const environment = this.environments.get(environmentId);
        if (!environment) {
            throw new Error(`Environment not found: ${environmentId}`);
        }
        for (const fixture of environment.fixtures) {
            if (fixture.cleanup) {
                try {
                    await fixture.cleanup();
                }
                catch (error) {
                    this.logger.error(`Failed to cleanup fixture: ${fixture.id}`, error);
                }
            }
        }
        environment.isActive = false;
        this.logger.log(`Environment cleanup completed: ${environmentId}`);
    }
    getFixture(fixtureId) {
        return this.fixtures.get(fixtureId);
    }
    getAllFixtures() {
        return Array.from(this.fixtures.values());
    }
    getEnvironment(environmentId) {
        return this.environments.get(environmentId);
    }
    getActiveEnvironments() {
        return Array.from(this.environments.values()).filter(env => env.isActive);
    }
    getFixtureResults(fixtureId) {
        if (fixtureId != null && fixtureId !== '') {
            return this.results.filter(result => result.fixtureId === fixtureId);
        }
        return this.results;
    }
    createUserFixture(userData) {
        return this.createFixture({
            name: `User: ${userData.email}`,
            description: `Test user with role: ${userData.role}`,
            type: 'user',
            data: userData,
            setup: async () => {
                this.logger.log(`Creating test user: ${userData.email}`);
            },
            cleanup: async () => {
                this.logger.log(`Cleaning up test user: ${userData.email}`);
            },
        });
    }
    createDataFixture(name, data) {
        return this.createFixture({
            name,
            description: `Test data fixture: ${name}`,
            type: 'data',
            data,
            setup: async () => {
                this.logger.log(`Setting up test data: ${name}`);
            },
            cleanup: async () => {
                this.logger.log(`Cleaning up test data: ${name}`);
            },
        });
    }
    createMockFixture(name, mockData) {
        return this.createFixture({
            name,
            description: `Mock fixture: ${name}`,
            type: 'mock',
            data: mockData,
            setup: async () => {
                this.logger.log(`Setting up mock: ${name}`);
            },
            cleanup: async () => {
                this.logger.log(`Cleaning up mock: ${name}`);
            },
        });
    }
    async cloneEnvironment(sourceEnvironmentId, newName) {
        const source = this.environments.get(sourceEnvironmentId);
        if (!source) {
            throw new Error(`Source environment not found: ${sourceEnvironmentId}`);
        }
        const cloned = {
            id: this.generateId('env'),
            name: newName,
            description: `Cloned from: ${source.name}`,
            fixtures: [...source.fixtures],
            config: { ...source.config },
            createdAt: new Date(),
            isActive: true,
        };
        this.environments.set(cloned.id, cloned);
        this.logger.log(`Cloned environment: ${sourceEnvironmentId} -> ${cloned.id}`);
        return cloned;
    }
    exportEnvironment(environmentId) {
        const environment = this.environments.get(environmentId);
        if (!environment) {
            throw new Error(`Environment not found: ${environmentId}`);
        }
        return JSON.stringify(environment, null, 2);
    }
    importEnvironment(environmentData) {
        try {
            const environment = JSON.parse(environmentData);
            environment.id = this.generateId('env');
            environment.createdAt = new Date();
            environment.isActive = true;
            this.environments.set(environment.id, environment);
            this.logger.log(`Imported environment: ${environment.id}`);
            return environment;
        }
        catch (error) {
            throw new Error(`Failed to import environment: ${error}`);
        }
    }
    initializeDefaultFixtures() {
        this.createUserFixture({
            email: 'test@example.com',
            role: 'user',
            permissions: ['read'],
        });
        this.createUserFixture({
            email: 'admin@example.com',
            role: 'admin',
            permissions: ['read', 'write', 'delete'],
        });
        this.createDataFixture('sample-cards', {
            cards: [
                { id: '1', name: 'Test Card 1', type: 'loyalty' },
                { id: '2', name: 'Test Card 2', type: 'discount' },
            ],
        });
        this.createMockFixture('external-api', {
            apiResponses: {
                '/users': { status: 200, data: [] },
                '/cards': { status: 200, data: [] },
            },
        });
    }
    getDefaultTestConfig() {
        return {
            database: {
                url: 'postgresql://test:test@localhost:5432/test_db',
                ssl: false,
            },
            redis: {
                url: 'redis://localhost:6379',
            },
            logging: {
                level: 'debug',
                enabled: true,
            },
            testing: {
                timeout: 5000,
                retries: 3,
            },
        };
    }
    generateId(prefix) {
        return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
};
TestFixturesService = TestFixturesService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], TestFixturesService);



/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GatewayModule: () => (/* binding */ GatewayModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(138);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(139);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _nestjs_throttler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(140);
/* harmony import */ var _nestjs_throttler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_nestjs_throttler__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _redis_redis_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60);
/* harmony import */ var _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(141);
/* harmony import */ var _dynamic_scaling_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(142);
/* harmony import */ var _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(143);
/* harmony import */ var _gateway_controller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(144);
/* harmony import */ var _unified_api_gateway_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(150);
/* harmony import */ var _gateway_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(145);
/* harmony import */ var _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(151);
/* harmony import */ var _incident_simulation_controller__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(152);
/* harmony import */ var _incident_simulation_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(153);
/* harmony import */ var _load_balancer_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(146);
/* harmony import */ var _rate_limit_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(147);
/* harmony import */ var _service_discovery_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(149);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


















let GatewayModule = class GatewayModule {
};
GatewayModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule,
            _redis_redis_module__WEBPACK_IMPORTED_MODULE_5__.RedisModule,
            _nestjs_throttler__WEBPACK_IMPORTED_MODULE_4__.ThrottlerModule.forRoot([
                {
                    ttl: 60000,
                    limit: 100,
                },
                {
                    ttl: 3600000,
                    limit: 1000,
                },
            ]),
            _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__.TerminusModule,
            _nestjs_schedule__WEBPACK_IMPORTED_MODULE_2__.ScheduleModule.forRoot(),
        ],
        providers: [
            _gateway_service__WEBPACK_IMPORTED_MODULE_11__.GatewayService,
            _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_12__.UnifiedApiGatewayService,
            _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_6__.CircuitBreakerService,
            _rate_limit_service__WEBPACK_IMPORTED_MODULE_16__.RateLimitService,
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_15__.LoadBalancerService,
            _service_discovery_service__WEBPACK_IMPORTED_MODULE_17__.ServiceDiscoveryService,
            _incident_simulation_service__WEBPACK_IMPORTED_MODULE_14__.IncidentSimulationService,
            _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_8__.DynamicScalingService,
        ],
        controllers: [
            _gateway_controller__WEBPACK_IMPORTED_MODULE_9__.GatewayController,
            _unified_api_gateway_controller__WEBPACK_IMPORTED_MODULE_10__.UnifiedApiGatewayController,
            _incident_simulation_controller__WEBPACK_IMPORTED_MODULE_13__.IncidentSimulationController,
            _dynamic_scaling_controller__WEBPACK_IMPORTED_MODULE_7__.DynamicScalingController,
        ],
        exports: [
            _gateway_service__WEBPACK_IMPORTED_MODULE_11__.GatewayService,
            _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_12__.UnifiedApiGatewayService,
            _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_6__.CircuitBreakerService,
            _rate_limit_service__WEBPACK_IMPORTED_MODULE_16__.RateLimitService,
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_15__.LoadBalancerService,
            _service_discovery_service__WEBPACK_IMPORTED_MODULE_17__.ServiceDiscoveryService,
            _incident_simulation_service__WEBPACK_IMPORTED_MODULE_14__.IncidentSimulationService,
            _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_8__.DynamicScalingService,
        ],
    })
], GatewayModule);



/***/ }),
/* 138 */
/***/ ((module) => {

module.exports = require("@nestjs/schedule");

/***/ }),
/* 139 */
/***/ ((module) => {

module.exports = require("@nestjs/terminus");

/***/ }),
/* 140 */
/***/ ((module) => {

module.exports = require("@nestjs/throttler");

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircuitBreakerService: () => (/* binding */ CircuitBreakerService),
/* harmony export */   CircuitState: () => (/* binding */ CircuitState)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CircuitBreakerService_1;
var _a;


var CircuitState;
(function (CircuitState) {
    CircuitState["CLOSED"] = "CLOSED";
    CircuitState["OPEN"] = "OPEN";
    CircuitState["HALF_OPEN"] = "HALF_OPEN";
})(CircuitState || (CircuitState = {}));
let CircuitBreakerService = CircuitBreakerService_1 = class CircuitBreakerService {
    constructor(_configService) {
        this._configService = _configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CircuitBreakerService_1.name);
        this.circuits = new Map();
        this._configService.get('CIRCUIT_BREAKER_ENABLED');
    }
    getDefaultConfig() {
        return {
            timeout: this._configService.get('CIRCUIT_BREAKER_TIMEOUT', 3000),
            errorThresholdPercentage: this._configService.get('CIRCUIT_BREAKER_ERROR_THRESHOLD', 50),
            resetTimeout: this._configService.get('CIRCUIT_BREAKER_RESET_TIMEOUT', 30000),
            volumeThreshold: this._configService.get('CIRCUIT_BREAKER_VOLUME_THRESHOLD', 10),
        };
    }
    getOrCreateCircuit(name) {
        let circuit = this.circuits.get(name);
        if (!circuit) {
            circuit = {
                state: CircuitState.CLOSED,
                failureCount: 0,
                successCount: 0,
                totalCount: 0,
                fallbackCount: 0,
                lastFailureTime: undefined,
                nextAttemptTime: undefined,
            };
            this.circuits.set(name, circuit);
        }
        return circuit;
    }
    async execute(name, fn, fallback, ...args) {
        const circuit = this.getOrCreateCircuit(name);
        const config = this.getDefaultConfig();
        if (circuit.state === CircuitState.OPEN) {
            if (circuit.nextAttemptTime &&
                Date.now() < circuit.nextAttemptTime.getTime()) {
                this.logger.warn(`Circuit ${name} is OPEN, using fallback`);
                circuit.fallbackCount++;
                if (fallback) {
                    return fallback(...args);
                }
                throw new Error(`Circuit ${name} is OPEN`);
            }
            else {
                circuit.state = CircuitState.HALF_OPEN;
                this.logger.log(`Circuit ${name} is now HALF_OPEN`);
            }
        }
        try {
            const result = await fn(...args);
            circuit.successCount++;
            circuit.totalCount++;
            circuit.failureCount = 0;
            if (circuit.state === CircuitState.HALF_OPEN) {
                circuit.state = CircuitState.CLOSED;
                this.logger.log(`Circuit ${name} is now CLOSED`);
            }
            return result;
        }
        catch (error) {
            circuit.failureCount++;
            circuit.totalCount++;
            circuit.lastFailureTime = new Date();
            const errorRate = (circuit.failureCount / circuit.totalCount) * 100;
            if (circuit.totalCount >= config.volumeThreshold &&
                errorRate >= config.errorThresholdPercentage) {
                circuit.state = CircuitState.OPEN;
                circuit.nextAttemptTime = new Date(Date.now() + config.resetTimeout);
                this.logger.warn(`Circuit ${name} is now OPEN (error rate: ${errorRate.toFixed(2)}%)`);
            }
            if (fallback) {
                this.logger.warn(`Circuit ${name} failure, using fallback`);
                circuit.fallbackCount++;
                return fallback(...args);
            }
            throw error;
        }
    }
    getCircuit(name) {
        return this.circuits.get(name);
    }
    getStats(name) {
        const circuit = this.circuits.get(name);
        if (!circuit)
            return undefined;
        return {
            state: circuit.state,
            failures: circuit.failureCount,
            fallbacks: circuit.fallbackCount,
            successes: circuit.successCount,
            total: circuit.totalCount,
            lastFailureTime: circuit.lastFailureTime,
            nextAttemptTime: circuit.nextAttemptTime,
        };
    }
    getAllStats() {
        const stats = new Map();
        for (const [name, circuit] of this.circuits.entries()) {
            stats.set(name, {
                state: circuit.state,
                failures: circuit.failureCount,
                fallbacks: circuit.fallbackCount,
                successes: circuit.successCount,
                total: circuit.totalCount,
                lastFailureTime: circuit.lastFailureTime,
                nextAttemptTime: circuit.nextAttemptTime,
            });
        }
        return stats;
    }
    resetCircuit(name) {
        const circuit = this.circuits.get(name);
        if (circuit) {
            circuit.state = CircuitState.CLOSED;
            circuit.failureCount = 0;
            circuit.successCount = 0;
            circuit.totalCount = 0;
            circuit.fallbackCount = 0;
            circuit.lastFailureTime = undefined;
            circuit.nextAttemptTime = undefined;
            this.logger.log(`Circuit ${name} has been reset`);
            return true;
        }
        return false;
    }
    async executeWithGracefulDegradation(name, primaryFn, fallbackFn, ...args) {
        try {
            return await this.execute(name, primaryFn, fallbackFn, ...args);
        }
        catch {
            this.logger.warn(`Graceful degradation for ${name}: using fallback`);
            return fallbackFn(...args);
        }
    }
    async executeWithRetry(name, fn, maxRetries = 3, delay = 1000, ...args) {
        let lastError;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await this.execute(name, fn, undefined, ...args);
            }
            catch (error) {
                lastError = error;
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.warn(`Attempt ${attempt} failed for ${name}: ${errorMessage}`);
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay * attempt));
                }
            }
        }
        if (!lastError) {
            throw new Error('Unknown error occurred during retry');
        }
        throw lastError;
    }
    async healthCheck() {
        const circuits = Array.from(this.circuits.values());
        const openCircuits = circuits.filter(circuit => circuit.state === CircuitState.OPEN).length;
        return {
            status: openCircuits === 0 ? 'healthy' : 'degraded',
            circuits: circuits.length,
            openCircuits,
        };
    }
};
CircuitBreakerService = CircuitBreakerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], CircuitBreakerService);



/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicScalingController: () => (/* binding */ DynamicScalingController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(143);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;



let DynamicScalingController = class DynamicScalingController {
    constructor(scalingService) {
        this.scalingService = scalingService;
    }
    async createPolicy(policy) {
        const validPolicy = {
            name: policy.name,
            type: policy.type,
            _service: policy.service,
            metrics: policy.metrics,
            thresholds: policy.thresholds,
            actions: policy.actions,
            minInstances: policy.minInstances,
            maxInstances: policy.maxInstances,
            cooldownPeriod: policy.cooldownPeriod,
            priority: policy.priority,
            enabled: policy.enabled,
            ...(policy.schedule != null && { schedule: policy.schedule }),
            ...(policy.predictiveWindow != null && {
                predictiveWindow: policy.predictiveWindow,
            }),
        };
        return await this.scalingService.createPolicy(validPolicy);
    }
    async getAllPolicies(service, _type, enabled) {
        if (service != null && service !== '') {
            return await this.scalingService.getPoliciesByService(service);
        }
        if (enabled === 'true') {
            return await this.scalingService.getActivePolicies();
        }
        return await this.scalingService.getAllPolicies();
    }
    async getPolicy(id) {
        return await this.scalingService.getPolicy(id);
    }
    async updatePolicy(id, updates) {
        const validUpdates = {
            name: updates.name,
            type: updates.type,
            service: updates.service,
            metrics: updates.metrics,
            thresholds: updates.thresholds,
            actions: updates.actions,
            minInstances: updates.minInstances,
            maxInstances: updates.maxInstances,
            cooldownPeriod: updates.cooldownPeriod,
            priority: updates.priority,
            enabled: updates.enabled,
            ...(updates.schedule != null && { schedule: updates.schedule }),
            ...(updates.predictiveWindow != null && {
                predictiveWindow: updates.predictiveWindow,
            }),
        };
        return await this.scalingService.updatePolicy(id, validUpdates);
    }
    async deletePolicy(id) {
        const success = await this.scalingService.deletePolicy(id);
        if (success) {
            return { message: 'Policy deleted successfully' };
        }
        return { message: 'Policy not found' };
    }
    async evaluateScaling(_service, body) {
        return await this.scalingService.evaluateScaling(_service, body.metrics);
    }
    async executeScaling(decisionId) {
        const success = await this.scalingService.executeScaling(decisionId);
        return {
            message: success
                ? 'Scaling executed successfully'
                : 'Failed to execute scaling',
            success,
        };
    }
    async getAllDecisions(service, status) {
        if (service != null && service !== '') {
            return await this.scalingService.getDecisionsByService(service);
        }
        if (status === 'pending') {
            return await this.scalingService.getPendingDecisions();
        }
        return await this.scalingService.getAllDecisions();
    }
    async getDecision(id) {
        return await this.scalingService.getDecision(id);
    }
    async getScalingHistory(service) {
        return await this.scalingService.getScalingHistory(service);
    }
    async getScalingStats() {
        return await this.scalingService.getScalingStats();
    }
    async simulateMetrics(body) {
        return {
            message: 'Metrics simulation triggered',
            service: body._service,
            timestamp: new Date().toISOString(),
            note: 'Check logs for actual metrics simulation and scaling evaluation',
        };
    }
    async getDemoStatus() {
        const stats = await this.scalingService.getScalingStats();
        const pendingDecisions = await this.scalingService.getPendingDecisions();
        return {
            systemStatus: 'OPERATIONAL',
            autoScaling: 'ENABLED',
            totalPolicies: stats.totalPolicies,
            activePolicies: stats.activePolicies,
            totalScalingEvents: stats.totalScalingEvents,
            successfulScalingEvents: stats.successfulScalingEvents,
            pendingDecisions: pendingDecisions.length,
            averageExecutionTime: `${(stats.averageExecutionTime / 1000).toFixed(1)} seconds`,
            services: stats.services,
            lastUpdated: new Date().toISOString(),
            note: 'System automatically evaluates scaling every 30 seconds',
        };
    }
    async createLoadTest() {
        const services = ['api', 'web'];
        const results = [];
        for (const service of services) {
            const criticalMetrics = {
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.CPU_USAGE]: 95,
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.MEMORY_USAGE]: 90,
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.REQUEST_RATE]: 2500,
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.RESPONSE_TIME]: 1200,
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.ERROR_RATE]: 8,
                [_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric.QUEUE_SIZE]: 100,
            };
            const decisions = await this.scalingService.evaluateScaling(service, criticalMetrics);
            results.push({
                service,
                decisions: decisions.length,
                triggered: decisions.length > 0,
            });
        }
        return {
            message: 'Load test completed',
            results,
            note: 'Check scaling decisions and execution logs',
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('policies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Создать новую политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                name: { type: 'string', description: 'Название политики' },
                type: {
                    type: 'string',
                    enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingPolicyType),
                    description: 'Тип политики',
                },
                service: { type: 'string', description: 'Название сервиса' },
                metrics: {
                    type: 'array',
                    items: { type: 'string', enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric) },
                    description: 'Метрики для отслеживания',
                },
                thresholds: {
                    type: 'object',
                    description: 'Пороговые значения для метрик',
                },
                actions: {
                    type: 'array',
                    items: { type: 'string', enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingAction) },
                    description: 'Действия масштабирования',
                },
                minInstances: {
                    type: 'number',
                    description: 'Минимальное количество инстансов',
                },
                maxInstances: {
                    type: 'number',
                    description: 'Максимальное количество инстансов',
                },
                cooldownPeriod: {
                    type: 'number',
                    description: 'Период cooldown в секундах',
                },
                priority: { type: 'number', description: 'Приоритет политики' },
                enabled: { type: 'boolean', description: 'Включена ли политика' },
                schedule: {
                    type: 'string',
                    description: 'Cron выражение для SCHEDULED политик',
                },
                predictiveWindow: {
                    type: 'number',
                    description: 'Окно предсказания в минутах',
                },
            },
            required: [
                'name',
                'type',
                'service',
                'metrics',
                'thresholds',
                'actions',
                'minInstances',
                'maxInstances',
                'cooldownPeriod',
                'priority',
                'enabled',
            ],
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Политика создана успешно' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Неверные параметры' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "createPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('policies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все политики масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'type', required: false, description: 'Фильтр по типу' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'enabled',
        required: false,
        description: 'Фильтр по статусу',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список политик' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('enabled')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getAllPolicies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('policies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить политику по ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Детали политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Политика не найдена' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('policies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Обновить политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                name: { type: 'string', description: 'Название политики' },
                type: {
                    type: 'string',
                    enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingPolicyType),
                    description: 'Тип политики',
                },
                service: { type: 'string', description: 'Название сервиса' },
                metrics: {
                    type: 'array',
                    items: { type: 'string', enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingMetric) },
                    description: 'Метрики для отслеживания',
                },
                thresholds: {
                    type: 'object',
                    description: 'Пороговые значения для метрик',
                },
                actions: {
                    type: 'array',
                    items: { type: 'string', enum: Object.values(_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.ScalingAction) },
                    description: 'Действия масштабирования',
                },
                minInstances: {
                    type: 'number',
                    description: 'Минимальное количество инстансов',
                },
                maxInstances: {
                    type: 'number',
                    description: 'Максимальное количество инстансов',
                },
                cooldownPeriod: {
                    type: 'number',
                    description: 'Период cooldown в секундах',
                },
                priority: { type: 'number', description: 'Приоритет политики' },
                enabled: { type: 'boolean', description: 'Включена ли политика' },
                schedule: {
                    type: 'string',
                    description: 'Cron выражение для SCHEDULED политик',
                },
                predictiveWindow: {
                    type: 'number',
                    description: 'Окно предсказания в минутах',
                },
            },
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Политика обновлена' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Политика не найдена' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_c = typeof Record !== "undefined" && Record) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "updatePolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('policies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Удалить политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Политика удалена' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Политика не найдена' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "deletePolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('evaluate/:service'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Оценить необходимость масштабирования для сервиса',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                metrics: {
                    type: 'object',
                    description: 'Метрики сервиса',
                },
            },
            required: ['metrics'],
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Результат оценки' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "evaluateScaling", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('execute/:decisionId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Выполнить решение о масштабировании' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'decisionId', description: 'ID решения' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Решение выполнено' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Решение не найдено' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('decisionId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "executeScaling", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('decisions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все решения о масштабировании' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'status',
        required: false,
        description: 'Фильтр по статусу (pending/executed)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список решений' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getAllDecisions", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('decisions/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить решение по ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID решения' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Детали решения' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Решение не найдено' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getDecision", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить историю масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'История масштабирования' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getScalingHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('stats/overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить общую статистику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика масштабирования' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getScalingStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/simulate-metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Демо: Симуляция метрик для тестирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                service: { type: 'string', description: 'Название сервиса' },
            },
            required: ['service'],
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Метрики симулированы' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "simulateMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('demo/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Демо: Статус системы масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статус системы' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "getDemoStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/load-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Демо: Создать нагрузку для тестирования масштабирования',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Нагрузка создана' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicScalingController.prototype, "createLoadTest", null);
DynamicScalingController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Dynamic Scaling Policies'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('gateway/scaling'),
    __metadata("design:paramtypes", [typeof (_a = typeof _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.DynamicScalingService !== "undefined" && _dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_2__.DynamicScalingService) === "function" ? _a : Object])
], DynamicScalingController);



/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicScalingService: () => (/* binding */ DynamicScalingService),
/* harmony export */   ScalingAction: () => (/* binding */ ScalingAction),
/* harmony export */   ScalingMetric: () => (/* binding */ ScalingMetric),
/* harmony export */   ScalingPolicyType: () => (/* binding */ ScalingPolicyType)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DynamicScalingService_1;
var _a, _b;


var ScalingPolicyType;
(function (ScalingPolicyType) {
    ScalingPolicyType["REACTIVE"] = "REACTIVE";
    ScalingPolicyType["PREDICTIVE"] = "PREDICTIVE";
    ScalingPolicyType["SCHEDULED"] = "SCHEDULED";
    ScalingPolicyType["MANUAL"] = "MANUAL";
})(ScalingPolicyType || (ScalingPolicyType = {}));
var ScalingMetric;
(function (ScalingMetric) {
    ScalingMetric["CPU_USAGE"] = "CPU_USAGE";
    ScalingMetric["MEMORY_USAGE"] = "MEMORY_USAGE";
    ScalingMetric["REQUEST_RATE"] = "REQUEST_RATE";
    ScalingMetric["RESPONSE_TIME"] = "RESPONSE_TIME";
    ScalingMetric["ERROR_RATE"] = "ERROR_RATE";
    ScalingMetric["QUEUE_SIZE"] = "QUEUE_SIZE";
})(ScalingMetric || (ScalingMetric = {}));
var ScalingAction;
(function (ScalingAction) {
    ScalingAction["SCALE_UP"] = "SCALE_UP";
    ScalingAction["SCALE_DOWN"] = "SCALE_DOWN";
    ScalingAction["SCALE_OUT"] = "SCALE_OUT";
    ScalingAction["SCALE_IN"] = "SCALE_IN";
})(ScalingAction || (ScalingAction = {}));
let DynamicScalingService = DynamicScalingService_1 = class DynamicScalingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DynamicScalingService_1.name);
        this.policies = new Map();
        this.decisions = new Map();
        this.scalingHistory = new Map();
        this.lastScalingTime = new Map();
        this.initializeDefaultPolicies();
    }
    initializeDefaultPolicies() {
        const defaultPolicies = [
            {
                id: 'cpu-scaling-policy',
                name: 'CPU-based Scaling',
                type: ScalingPolicyType.REACTIVE,
                _service: 'api',
                metrics: [ScalingMetric.CPU_USAGE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 80,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 0,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP, ScalingAction.SCALE_OUT],
                minInstances: 3,
                maxInstances: 10,
                cooldownPeriod: 300,
                priority: 1,
                enabled: true,
            },
            {
                id: 'memory-scaling-policy',
                name: 'Memory-based Scaling',
                type: ScalingPolicyType.REACTIVE,
                _service: 'api',
                metrics: [ScalingMetric.MEMORY_USAGE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 0,
                    [ScalingMetric.MEMORY_USAGE]: 85,
                    [ScalingMetric.REQUEST_RATE]: 0,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP, ScalingAction.SCALE_OUT],
                minInstances: 3,
                maxInstances: 10,
                cooldownPeriod: 300,
                priority: 2,
                enabled: true,
            },
            {
                id: 'request-rate-policy',
                name: 'Request Rate Scaling',
                type: ScalingPolicyType.REACTIVE,
                _service: 'api',
                metrics: [ScalingMetric.REQUEST_RATE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 0,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 1000,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_OUT],
                minInstances: 3,
                maxInstances: 15,
                cooldownPeriod: 180,
                priority: 1,
                enabled: true,
            },
            {
                id: 'response-time-policy',
                name: 'Response Time Scaling',
                type: ScalingPolicyType.REACTIVE,
                _service: 'api',
                metrics: [ScalingMetric.RESPONSE_TIME],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 0,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 0,
                    [ScalingMetric.RESPONSE_TIME]: 500,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP, ScalingAction.SCALE_OUT],
                minInstances: 3,
                maxInstances: 12,
                cooldownPeriod: 240,
                priority: 1,
                enabled: true,
            },
            {
                id: 'error-rate-policy',
                name: 'Error Rate Scaling',
                type: ScalingPolicyType.REACTIVE,
                _service: 'api',
                metrics: [ScalingMetric.ERROR_RATE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 0,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 0,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 5,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP],
                minInstances: 3,
                maxInstances: 10,
                cooldownPeriod: 120,
                priority: 0,
                enabled: true,
            },
            {
                id: 'business-hours-policy',
                name: 'Business Hours Scaling',
                type: ScalingPolicyType.SCHEDULED,
                _service: 'api',
                metrics: [ScalingMetric.REQUEST_RATE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 0,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 500,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP],
                minInstances: 5,
                maxInstances: 12,
                cooldownPeriod: 600,
                priority: 3,
                enabled: true,
                schedule: '0 9-18 * * 1-5',
            },
            {
                id: 'predictive-scaling-policy',
                name: 'Predictive Scaling',
                type: ScalingPolicyType.PREDICTIVE,
                _service: 'api',
                metrics: [ScalingMetric.REQUEST_RATE, ScalingMetric.CPU_USAGE],
                thresholds: {
                    [ScalingMetric.CPU_USAGE]: 70,
                    [ScalingMetric.MEMORY_USAGE]: 0,
                    [ScalingMetric.REQUEST_RATE]: 800,
                    [ScalingMetric.RESPONSE_TIME]: 0,
                    [ScalingMetric.ERROR_RATE]: 0,
                    [ScalingMetric.QUEUE_SIZE]: 0,
                },
                actions: [ScalingAction.SCALE_UP, ScalingAction.SCALE_OUT],
                minInstances: 4,
                maxInstances: 12,
                cooldownPeriod: 180,
                priority: 2,
                enabled: true,
                predictiveWindow: 30,
            },
        ];
        defaultPolicies.forEach(policy => {
            this.policies.set(policy.id, policy);
        });
        this.logger.log(`Initialized ${defaultPolicies.length} default scaling policies`);
    }
    async createPolicy(policy) {
        const id = `policy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newPolicy = { ...policy, id };
        this.policies.set(id, newPolicy);
        this.logger.log(`Created scaling policy: ${newPolicy.name} for service: ${newPolicy._service}`);
        return newPolicy;
    }
    async updatePolicy(id, updates) {
        const policy = this.policies.get(id);
        if (!policy) {
            return null;
        }
        const updatedPolicy = { ...policy, ...updates };
        this.policies.set(id, updatedPolicy);
        this.logger.log(`Updated scaling policy: ${updatedPolicy.name}`);
        return updatedPolicy;
    }
    async deletePolicy(id) {
        const policy = this.policies.get(id);
        if (!policy) {
            return false;
        }
        this.policies.delete(id);
        this.logger.log(`Deleted scaling policy: ${policy.name}`);
        return true;
    }
    async getPolicy(id) {
        return this.policies.get(id) ?? null;
    }
    async getAllPolicies() {
        return Array.from(this.policies.values());
    }
    async getPoliciesByService(_service) {
        return Array.from(this.policies.values()).filter(policy => policy._service === _service);
    }
    async getActivePolicies() {
        return Array.from(this.policies.values()).filter(policy => policy.enabled);
    }
    async evaluateScaling(_service, metrics) {
        const servicePolicies = await this.getPoliciesByService(_service);
        const activePolicies = servicePolicies.filter(policy => policy.enabled);
        const decisions = [];
        for (const policy of activePolicies) {
            const lastScaling = this.lastScalingTime.get(`${_service}-${policy.id}`) ?? 0;
            const now = Date.now();
            if (now - lastScaling < policy.cooldownPeriod * 1000) {
                continue;
            }
            const shouldScale = this.shouldScale(policy, metrics);
            if (shouldScale) {
                const decision = {
                    id: `decision-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    policyId: policy.id,
                    _service: policy._service,
                    action: this.determineScalingAction(policy, metrics),
                    reason: `Policy ${policy.name} triggered by metrics: ${Object.keys(shouldScale).join(', ')}`,
                    timestamp: new Date(),
                    metrics,
                    executed: false,
                };
                decisions.push(decision);
                this.decisions.set(decision.id, decision);
                this.lastScalingTime.set(`${_service}-${policy.id}`, now);
            }
        }
        decisions.sort((a, b) => {
            const policyA = this.policies.get(a.policyId);
            const policyB = this.policies.get(b.policyId);
            return (policyB?.priority ?? 0) - (policyA?.priority ?? 0);
        });
        return decisions;
    }
    shouldScale(policy, metrics) {
        const triggeredMetrics = {};
        let hasTriggered = false;
        for (const metric of policy.metrics) {
            const currentValue = metrics[metric];
            const threshold = policy.thresholds[metric];
            if (currentValue > threshold) {
                triggeredMetrics[metric] = true;
                hasTriggered = true;
            }
            else {
                triggeredMetrics[metric] = false;
            }
        }
        return hasTriggered ? triggeredMetrics : null;
    }
    determineScalingAction(policy, metrics) {
        const cpuUsage = metrics[ScalingMetric.CPU_USAGE];
        const memoryUsage = metrics[ScalingMetric.MEMORY_USAGE];
        const requestRate = metrics[ScalingMetric.REQUEST_RATE];
        const responseTime = metrics[ScalingMetric.RESPONSE_TIME];
        const errorRate = metrics[ScalingMetric.ERROR_RATE];
        if (errorRate > 10) {
            return ScalingAction.SCALE_UP;
        }
        if (cpuUsage > 90 || memoryUsage > 90) {
            return ScalingAction.SCALE_UP;
        }
        if (requestRate > 2000 || responseTime > 1000) {
            return ScalingAction.SCALE_OUT;
        }
        if (cpuUsage > 70 || memoryUsage > 70) {
            return ScalingAction.SCALE_UP;
        }
        return policy.actions[0] ?? ScalingAction.SCALE_UP;
    }
    async executeScaling(decisionId) {
        const decision = this.decisions.get(decisionId);
        if (!decision || decision.executed) {
            return false;
        }
        try {
            this.logger.log(`Executing scaling decision: ${decision.action} for service: ${decision._service}`);
            const success = await this.performScaling(decision);
            decision.executed = true;
            decision.executionTime = new Date();
            decision.success = success;
            await this.updateScalingHistory(decision);
            this.logger.log(`Scaling decision executed successfully: ${decision.action}`);
            return success;
        }
        catch (error) {
            this.logger.error(`Failed to execute scaling decision: ${decisionId}`, error);
            decision.executed = true;
            decision.executionTime = new Date();
            decision.success = false;
            return false;
        }
    }
    async performScaling(decision) {
        switch (decision.action) {
            case ScalingAction.SCALE_UP:
                return await this.simulateScaleUp();
            case ScalingAction.SCALE_DOWN:
                return await this.simulateScaleDown();
            case ScalingAction.SCALE_OUT:
                return await this.simulateScaleOut();
            case ScalingAction.SCALE_IN:
                return await this.simulateScaleIn();
            default:
                return false;
        }
    }
    async simulateScaleUp() {
        await new Promise(resolve => setTimeout(resolve, 3000));
        return Math.random() > 0.1;
    }
    async simulateScaleDown() {
        await new Promise(resolve => setTimeout(resolve, 2000));
        return Math.random() > 0.05;
    }
    async simulateScaleOut() {
        await new Promise(resolve => setTimeout(resolve, 5000));
        return Math.random() > 0.15;
    }
    async simulateScaleIn() {
        await new Promise(resolve => setTimeout(resolve, 2000));
        return Math.random() > 0.1;
    }
    async updateScalingHistory(decision) {
        const serviceName = decision._service;
        let history = this.scalingHistory.get(serviceName);
        if (!history) {
            history = {
                _service: serviceName,
                totalScalingEvents: 0,
                successfulScalingEvents: 0,
                averageExecutionTime: 0,
                lastScalingEvent: decision.executionTime ?? new Date(),
                scalingByAction: {
                    [ScalingAction.SCALE_UP]: 0,
                    [ScalingAction.SCALE_DOWN]: 0,
                    [ScalingAction.SCALE_OUT]: 0,
                    [ScalingAction.SCALE_IN]: 0,
                },
                scalingByPolicy: {},
            };
            this.scalingHistory.set(serviceName, history);
        }
        history.totalScalingEvents += 1;
        if (decision.success === true) {
            history.successfulScalingEvents += 1;
        }
        history.lastScalingEvent = decision.executionTime ?? new Date();
        const action = decision.action;
        history.scalingByAction[action] += 1;
        if (decision.policyId) {
            const policyKey = decision.policyId;
            history.scalingByPolicy[policyKey] ??= 0;
            history.scalingByPolicy[policyKey] += 1;
        }
        if (decision.executionTime != null) {
            const executionTime = decision.executionTime.getTime() - decision.timestamp.getTime();
            const previousTotal = history.averageExecutionTime * (history.totalScalingEvents - 1);
            const totalTime = previousTotal + executionTime;
            history.averageExecutionTime = totalTime / history.totalScalingEvents;
        }
        this.scalingHistory.set(serviceName, history);
    }
    async getScalingHistory(service) {
        if (service != undefined && service !== '') {
            const history = this.scalingHistory.get(service);
            return history ? [history] : [];
        }
        return Array.from(this.scalingHistory.values());
    }
    async getScalingStats() {
        const policies = Array.from(this.policies.values());
        const decisions = Array.from(this.decisions.values());
        const history = Array.from(this.scalingHistory.values());
        const totalScalingEvents = decisions.length;
        const successfulScalingEvents = decisions.filter(d => d.success === true).length;
        const averageExecutionTime = history.length > 0
            ? history.reduce((sum, h) => sum + h.averageExecutionTime, 0) /
                history.length
            : 0;
        return {
            totalPolicies: policies.length,
            activePolicies: policies.filter(p => p.enabled).length,
            totalScalingEvents,
            successfulScalingEvents,
            averageExecutionTime,
            services: Array.from(new Set(policies.map(p => p._service))),
            scalingHistory: history,
        };
    }
    async getDecision(id) {
        return this.decisions.get(id) ?? null;
    }
    async getAllDecisions() {
        return Array.from(this.decisions.values());
    }
    async getDecisionsByService(_service) {
        return Array.from(this.decisions.values()).filter(decision => decision._service === _service);
    }
    async getPendingDecisions() {
        return Array.from(this.decisions.values()).filter(decision => decision.executed !== true);
    }
    async autoEvaluateScaling() {
        const services = Array.from(new Set(Array.from(this.policies.values()).map(p => p._service)));
        for (const service of services) {
            try {
                const metrics = await this.simulateMetrics();
                const decisions = await this.evaluateScaling(service, metrics);
                if (decisions.length > 0) {
                    this.logger.log(`Auto-evaluation found ${decisions.length} scaling decisions for service: ${service}`);
                    for (const decision of decisions) {
                        await this.executeScaling(decision.id);
                    }
                }
            }
            catch (error) {
                this.logger.error(`Failed to auto-evaluate scaling for service: ${service}`, error);
            }
        }
    }
    async simulateMetrics() {
        const baseMetrics = {
            [ScalingMetric.CPU_USAGE]: 30 + Math.random() * 40,
            [ScalingMetric.MEMORY_USAGE]: 40 + Math.random() * 35,
            [ScalingMetric.REQUEST_RATE]: 200 + Math.random() * 800,
            [ScalingMetric.RESPONSE_TIME]: 100 + Math.random() * 400,
            [ScalingMetric.ERROR_RATE]: Math.random() * 3,
            [ScalingMetric.QUEUE_SIZE]: Math.random() * 50,
        };
        if (Math.random() < 0.1) {
            baseMetrics[ScalingMetric.CPU_USAGE] = 80 + Math.random() * 20;
            baseMetrics[ScalingMetric.REQUEST_RATE] = 1500 + Math.random() * 1000;
        }
        return baseMetrics;
    }
    async cleanupOldDecisions() {
        const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        let cleanedCount = 0;
        for (const [id, decision] of this.decisions.entries()) {
            if (decision.timestamp < oneWeekAgo) {
                this.decisions.delete(id);
                cleanedCount += 1;
            }
        }
        if (cleanedCount > 0) {
            this.logger.log(`Cleaned up ${cleanedCount} old scaling decisions`);
        }
    }
};
__decorate([
    (0,_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.Cron)(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.CronExpression.EVERY_30_SECONDS),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], DynamicScalingService.prototype, "autoEvaluateScaling", null);
__decorate([
    (0,_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.Cron)(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], DynamicScalingService.prototype, "cleanupOldDecisions", null);
DynamicScalingService = DynamicScalingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DynamicScalingService);



/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GatewayController: () => (/* binding */ GatewayController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_throttler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);
/* harmony import */ var _nestjs_throttler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_throttler__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(141);
/* harmony import */ var _gateway_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(145);
/* harmony import */ var _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(146);
/* harmony import */ var _rate_limit_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(147);
/* harmony import */ var _service_discovery_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(149);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GatewayController_1;
var _a, _b, _c, _d, _e, _f, _g, _h;








let GatewayController = GatewayController_1 = class GatewayController {
    constructor(gatewayService, circuitBreakerService, rateLimitService, loadBalancerService, serviceDiscoveryService) {
        this.gatewayService = gatewayService;
        this.circuitBreakerService = circuitBreakerService;
        this.rateLimitService = rateLimitService;
        this.loadBalancerService = loadBalancerService;
        this.serviceDiscoveryService = serviceDiscoveryService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(GatewayController_1.name);
    }
    async getHealth() {
        return this.gatewayService.healthCheck();
    }
    async getStats() {
        return this.gatewayService.getStats();
    }
    async getApiKeys() {
        return this.gatewayService.getAllApiKeys();
    }
    async addApiKey(apiKey) {
        const success = this.gatewayService.addApiKey(apiKey);
        return { success };
    }
    async deactivateApiKey(key) {
        const success = this.gatewayService.deactivateApiKey(key);
        return { success };
    }
    async checkRateLimit(key, type = 'api-key') {
        switch (type) {
            case 'api-key': {
                return this.rateLimitService.checkApiKeyRateLimit(key);
            }
            case 'ip': {
                return this.rateLimitService.checkIpRateLimit(key);
            }
            case 'user': {
                return this.rateLimitService.checkUserRateLimit(key);
            }
            default: {
                return this.rateLimitService.checkApiKeyRateLimit(key);
            }
        }
    }
    async getRateLimitStats(key) {
        return this.rateLimitService.getRateLimitStats(key);
    }
    async resetRateLimit(key) {
        const success = await this.rateLimitService.resetRateLimit(key);
        return { success };
    }
    async getCircuitBreakerStats(_service) {
        return this.gatewayService.getCircuitBreakerStats(_service);
    }
    async resetCircuitBreaker(_service) {
        const success = await this.gatewayService.resetCircuitBreaker(_service);
        return { success };
    }
    async getAllCircuitBreakerStats() {
        const stats = this.circuitBreakerService.getAllStats();
        return Array.from(stats.entries()).map(([name, stat]) => ({
            name,
            ...stat,
        }));
    }
    async getServices() {
        return this.loadBalancerService.getAllServices();
    }
    async getServiceHealth(_service) {
        return this.gatewayService.getServiceHealth(_service);
    }
    async getServiceStats(_service) {
        return this.loadBalancerService.getServiceStats(_service);
    }
    async registerService(_service, instances) {
        const success = await this.gatewayService.registerService(_service, instances);
        return { success };
    }
    async getRegisteredServices() {
        return this.serviceDiscoveryService.getAllServices();
    }
    async getServicesByName(name) {
        return this.serviceDiscoveryService.getServicesByName(name);
    }
    async getServiceDiscoveryStats() {
        return this.serviceDiscoveryService.getStats();
    }
    async syncWithKong() {
        return this.gatewayService.syncWithKong();
    }
    async routeRequest(_service, apiKey, clientIp, body) {
        if (_service == null || _service === '' || _service.length === 0) {
            return { success: false, error: 'Service parameter is required' };
        }
        if (apiKey == null || apiKey === '' || apiKey.length === 0) {
            return { success: false, error: 'API key is required' };
        }
        const keyValidation = await this.gatewayService.validateApiKey(apiKey);
        if (!keyValidation) {
            return { success: false, error: 'Invalid API key' };
        }
        const rateLimit = await this.gatewayService.checkRateLimit(apiKey, clientIp);
        if (!rateLimit.allowed) {
            return {
                success: false,
                error: 'Rate limit exceeded',
                remaining: rateLimit.remaining,
                resetTime: rateLimit.resetTime,
            };
        }
        const result = await this.gatewayService.routeRequest(_service, '/demo', 'POST', { 'X-API-Key': apiKey }, body);
        return result;
    }
    async getCircuitBreakerHealth() {
        return this.circuitBreakerService.healthCheck();
    }
    async getRateLimitHealth() {
        return this.rateLimitService.healthCheck();
    }
    async getLoadBalancerHealth() {
        return this.loadBalancerService.healthCheck();
    }
    async getServiceDiscoveryHealth() {
        return this.serviceDiscoveryService.healthCheck();
    }
    async testCircuitBreaker(body) {
        try {
            const { service, shouldFail = false } = body;
            if (shouldFail === true) {
                return {
                    error: 'Simulated failure',
                    timestamp: new Date(),
                    service: service,
                    shouldFail: shouldFail,
                };
            }
            return {
                message: 'Success',
                timestamp: new Date(),
                service: service,
                shouldFail: shouldFail,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Circuit breaker test failed: ${errorMessage}`);
            return {
                error: errorMessage,
                timestamp: new Date(),
            };
        }
    }
    async testRateLimit(body) {
        const { key, type = 'api-key' } = body;
        let result;
        switch (type) {
            case 'api-key': {
                result = await this.rateLimitService.checkApiKeyRateLimit(key);
                break;
            }
            case 'ip': {
                result = await this.rateLimitService.checkIpRateLimit(key);
                break;
            }
            case 'user': {
                result = await this.rateLimitService.checkUserRateLimit(key);
                break;
            }
            default: {
                result = await this.rateLimitService.checkApiKeyRateLimit(key);
            }
        }
        return {
            key,
            type,
            ...result,
        };
    }
    async testLoadBalancer(body) {
        const { _service: service, algorithm = 'round-robin' } = body;
        const validAlgorithms = [
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancingAlgorithm.ROUND_ROBIN,
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancingAlgorithm.LEAST_CONNECTIONS,
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancingAlgorithm.WEIGHTED,
            _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancingAlgorithm.IP_HASH,
        ];
        const validAlgorithm = validAlgorithms.includes(algorithm)
            ? algorithm
            : _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancingAlgorithm.ROUND_ROBIN;
        const instance = await this.loadBalancerService.getNextInstance(service, validAlgorithm);
        return {
            service,
            algorithm,
            instance: instance
                ? {
                    id: instance.id,
                    url: instance.url,
                    health: instance.health,
                    weight: instance.weight,
                }
                : null,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Gateway здоров' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика Gateway' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('api-keys'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все API ключи' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список API ключей' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getApiKeys", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('api-keys'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Добавить новый API ключ' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'API ключ добавлен' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "addApiKey", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('api-keys/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Деактивировать API ключ' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'API ключ' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'API ключ деактивирован' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "deactivateApiKey", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('rate-limit/:key'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверить rate limit для ключа' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'API ключ или IP' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'type', description: 'Тип проверки (api-key, ip, user)' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Информация о rate limit' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "checkRateLimit", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('rate-limit/:key/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику rate limit' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'API ключ или IP' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика rate limit' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getRateLimitStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('rate-limit/:key/reset'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Сбросить rate limit для ключа' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'key', description: 'API ключ или IP' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Rate limit сброшен' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "resetRateLimit", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('circuit-breaker/:service'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику circuit breaker' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика circuit breaker' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getCircuitBreakerStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('circuit-breaker/:service/reset'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Сбросить circuit breaker для сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Circuit breaker сброшен' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "resetCircuitBreaker", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('circuit-breaker/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику всех circuit breakers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика всех circuit breakers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getAllCircuitBreakerStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('load-balancer/services'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить список всех сервисов' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список сервисов' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServices", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('load-balancer/:service/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить здоровье сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Здоровье сервиса' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServiceHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('load-balancer/:service/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика сервиса' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServiceStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('load-balancer/:service/register'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Зарегистрировать сервис' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Сервис зарегистрирован' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof Array !== "undefined" && Array) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "registerService", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('service-discovery/services'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все зарегистрированные сервисы' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список сервисов' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getRegisteredServices", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('service-discovery/services/:name'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить сервисы по имени' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'name', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Сервисы с указанным именем' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServicesByName", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('service-discovery/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику service discovery' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика service discovery' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServiceDiscoveryStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('service-discovery/sync-kong'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Синхронизировать с Kong Admin API' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Синхронизация завершена' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "syncWithKong", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('route/:service/*'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Маршрутизация запроса к сервису' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Название сервиса' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiHeader)({ name: 'X-API-Key', description: 'API ключ' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Ответ от сервиса' }),
    (0,_nestjs_throttler__WEBPACK_IMPORTED_MODULE_2__.Throttle)({ default: { ttl: 60000, limit: 100 } }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)('x-api-key')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)('x-forwarded-for')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object, typeof (_g = typeof Record !== "undefined" && Record) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "routeRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/circuit-breaker'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Circuit Breaker' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Состояние Circuit Breaker' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getCircuitBreakerHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/rate-limit'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Rate Limiting' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Состояние Rate Limiting' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getRateLimitHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/load-balancer'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Load Balancer' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Состояние Load Balancer' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getLoadBalancerHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/service-discovery'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка здоровья Service Discovery' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Состояние Service Discovery' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "getServiceDiscoveryHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/circuit-breaker-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Тест Circuit Breaker' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Результат теста' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_h = typeof Record !== "undefined" && Record) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "testCircuitBreaker", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/rate-limit-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Тест Rate Limiting' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Результат теста' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "testRateLimit", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/load-balancer-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Тест Load Balancer' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Результат теста' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], GatewayController.prototype, "testLoadBalancer", null);
GatewayController = GatewayController_1 = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('gateway'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('gateway'),
    __metadata("design:paramtypes", [typeof (_a = typeof _gateway_service__WEBPACK_IMPORTED_MODULE_4__.GatewayService !== "undefined" && _gateway_service__WEBPACK_IMPORTED_MODULE_4__.GatewayService) === "function" ? _a : Object, typeof (_b = typeof _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_3__.CircuitBreakerService !== "undefined" && _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_3__.CircuitBreakerService) === "function" ? _b : Object, typeof (_c = typeof _rate_limit_service__WEBPACK_IMPORTED_MODULE_6__.RateLimitService !== "undefined" && _rate_limit_service__WEBPACK_IMPORTED_MODULE_6__.RateLimitService) === "function" ? _c : Object, typeof (_d = typeof _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancerService !== "undefined" && _load_balancer_service__WEBPACK_IMPORTED_MODULE_5__.LoadBalancerService) === "function" ? _d : Object, typeof (_e = typeof _service_discovery_service__WEBPACK_IMPORTED_MODULE_7__.ServiceDiscoveryService !== "undefined" && _service_discovery_service__WEBPACK_IMPORTED_MODULE_7__.ServiceDiscoveryService) === "function" ? _e : Object])
], GatewayController);



/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GatewayService: () => (/* binding */ GatewayService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/* harmony import */ var _load_balancer_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(146);
/* harmony import */ var _rate_limit_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(147);
/* harmony import */ var _service_discovery_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(149);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var GatewayService_1;
var _a, _b, _c, _d, _e;






let GatewayService = GatewayService_1 = class GatewayService {
    constructor(_configService, circuitBreakerService, rateLimitService, loadBalancerService, serviceDiscoveryService) {
        this._configService = _configService;
        this.circuitBreakerService = circuitBreakerService;
        this.rateLimitService = rateLimitService;
        this.loadBalancerService = loadBalancerService;
        this.serviceDiscoveryService = serviceDiscoveryService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(GatewayService_1.name);
        this.apiKeys = new Map();
        this._configService.get('GATEWAY_ENABLED');
        this.initializeApiKeys();
    }
    initializeApiKeys() {
        const defaultApiKey = {
            key: this._configService.get('DEFAULT_API_KEY', 'saas-api-key-12345'),
            name: 'Default API Key',
            permissions: ['read', 'write'],
            rateLimit: {
                perMinute: 100,
                perHour: 1000,
            },
            active: true,
            createdAt: new Date(),
        };
        this.apiKeys.set(defaultApiKey.key, defaultApiKey);
        this.logger.log('API Gateway initialized with default API key');
    }
    async validateApiKey(apiKey) {
        const key = this.apiKeys.get(apiKey);
        if (!key || key.active !== true) {
            return null;
        }
        key.lastUsed = new Date();
        return key;
    }
    async checkRateLimit(apiKey, clientIp) {
        const key = await this.validateApiKey(apiKey);
        if (!key) {
            return { allowed: false, remaining: 0, resetTime: new Date() };
        }
        const apiKeyLimit = await this.rateLimitService.checkApiKeyRateLimit(apiKey);
        const hourlyLimit = await this.rateLimitService.checkHourlyRateLimit(apiKey);
        let ipLimit = { blocked: false, remaining: 999 };
        if (clientIp != null && clientIp !== '' && clientIp.length > 0) {
            ipLimit = await this.rateLimitService.checkIpRateLimit(clientIp);
        }
        const allowed = !apiKeyLimit.blocked && !hourlyLimit.blocked && !ipLimit.blocked;
        const remaining = Math.min(apiKeyLimit.remaining, hourlyLimit.remaining, ipLimit.remaining);
        return {
            allowed,
            remaining,
            resetTime: apiKeyLimit.resetTime,
        };
    }
    async routeRequest(serviceName, path, method, headers, body) {
        try {
            const instance = await this.loadBalancerService.getNextInstance(serviceName);
            if (!instance) {
                throw new Error(`No healthy instances available for service: ${serviceName}`);
            }
            const result = await this.circuitBreakerService.execute(`${serviceName}-${instance.id}`, async () => {
                const response = await fetch(`${instance.url}${path}`, {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        ...headers,
                    },
                    ...(body && { body: JSON.stringify(body) }),
                });
                if (!response.ok) {
                    throw new Error(`Service responded with status: ${response.status}`);
                }
                return await response.json();
            }, async () => {
                this.logger.warn(`Using fallback for service: ${serviceName}`);
                return { message: 'Service temporarily unavailable', fallback: true };
            });
            return { success: true, data: result };
        }
        catch (error) {
            const circuit = this.circuitBreakerService.getCircuit(`${serviceName}-default`);
            const circuitState = circuit?.state === 'OPEN' ? 'OPEN' : 'CLOSED';
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Request routing failed for ${serviceName}: ${errorMessage}`);
            return {
                success: false,
                error: errorMessage,
                circuitState,
            };
        }
    }
    async registerService(serviceName, instances) {
        try {
            const serviceInstances = instances.map(instance => ({
                id: instance.id,
                url: instance.url,
                health: 'unknown',
                weight: instance.weight ?? 1,
                lastCheck: new Date(),
                responseTime: 0,
                activeConnections: 0,
            }));
            this.loadBalancerService.registerService(serviceName, serviceInstances);
            this.logger.log(`Service ${serviceName} registered with ${instances.length} instances`);
            return true;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Failed to register service ${serviceName}: ${errorMessage}`);
            return false;
        }
    }
    async getServiceHealth(serviceName) {
        const stats = this.loadBalancerService.getServiceStats(serviceName);
        if (!stats) {
            return null;
        }
        return {
            status: stats.healthyInstances > 0 ? 'healthy' : 'unhealthy',
            instances: stats.totalInstances,
            healthyInstances: stats.healthyInstances,
            averageResponseTime: stats.averageResponseTime,
        };
    }
    async getCircuitBreakerStats(serviceName) {
        const circuit = this.circuitBreakerService.getCircuit(`${serviceName}-default`);
        if (!circuit) {
            return {};
        }
        const stats = this.circuitBreakerService.getStats(`${serviceName}-default`);
        return {
            state: circuit.state === 'OPEN' ? 'OPEN' : 'CLOSED',
            stats,
        };
    }
    async resetCircuitBreaker(serviceName) {
        return this.circuitBreakerService.resetCircuit(`${serviceName}-default`);
    }
    async getRateLimitStats(apiKey) {
        return this.rateLimitService.getRateLimitStats(apiKey);
    }
    async resetRateLimit(apiKey) {
        return this.rateLimitService.resetRateLimit(apiKey);
    }
    async syncWithKong() {
        return this.serviceDiscoveryService.syncWithKong();
    }
    async healthCheck() {
        const circuitBreakerHealth = await this.circuitBreakerService.healthCheck();
        const rateLimitHealth = await this.rateLimitService.healthCheck();
        const loadBalancerHealth = await this.loadBalancerService.healthCheck();
        const serviceDiscoveryHealth = await this.serviceDiscoveryService.healthCheck();
        const components = {
            circuitBreaker: circuitBreakerHealth.status,
            rateLimit: rateLimitHealth.status,
            loadBalancer: loadBalancerHealth.status,
            serviceDiscovery: serviceDiscoveryHealth.status,
        };
        const allHealthy = Object.values(components).every(status => status === 'healthy');
        const status = allHealthy ? 'healthy' : 'degraded';
        return { status, components };
    }
    async getStats() {
        const apiKeys = Array.from(this.apiKeys.values());
        const activeApiKeys = apiKeys.filter(key => key.active).length;
        const services = this.loadBalancerService.getAllServices().length;
        const circuitBreakerHealth = await this.circuitBreakerService.healthCheck();
        return {
            apiKeys: apiKeys.length,
            activeApiKeys,
            services,
            totalRequests: 0,
            circuitBreakers: circuitBreakerHealth.circuits,
            openCircuits: circuitBreakerHealth.openCircuits,
        };
    }
    addApiKey(apiKey) {
        if (this.apiKeys.has(apiKey.key)) {
            return false;
        }
        const fullApiKey = {
            ...apiKey,
            createdAt: new Date(),
        };
        this.apiKeys.set(apiKey.key, fullApiKey);
        this.logger.log(`New API key added: ${apiKey.name}`);
        return true;
    }
    deactivateApiKey(key) {
        const apiKey = this.apiKeys.get(key);
        if (!apiKey) {
            return false;
        }
        apiKey.active = false;
        this.logger.log(`API key deactivated: ${apiKey.name}`);
        return true;
    }
    getAllApiKeys() {
        return Array.from(this.apiKeys.values());
    }
};
GatewayService = GatewayService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__.CircuitBreakerService !== "undefined" && _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__.CircuitBreakerService) === "function" ? _b : Object, typeof (_c = typeof _rate_limit_service__WEBPACK_IMPORTED_MODULE_4__.RateLimitService !== "undefined" && _rate_limit_service__WEBPACK_IMPORTED_MODULE_4__.RateLimitService) === "function" ? _c : Object, typeof (_d = typeof _load_balancer_service__WEBPACK_IMPORTED_MODULE_3__.LoadBalancerService !== "undefined" && _load_balancer_service__WEBPACK_IMPORTED_MODULE_3__.LoadBalancerService) === "function" ? _d : Object, typeof (_e = typeof _service_discovery_service__WEBPACK_IMPORTED_MODULE_5__.ServiceDiscoveryService !== "undefined" && _service_discovery_service__WEBPACK_IMPORTED_MODULE_5__.ServiceDiscoveryService) === "function" ? _e : Object])
], GatewayService);



/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoadBalancerService: () => (/* binding */ LoadBalancerService),
/* harmony export */   LoadBalancingAlgorithm: () => (/* binding */ LoadBalancingAlgorithm)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var LoadBalancerService_1;
var _a;


var LoadBalancingAlgorithm;
(function (LoadBalancingAlgorithm) {
    LoadBalancingAlgorithm["ROUND_ROBIN"] = "round-robin";
    LoadBalancingAlgorithm["LEAST_CONNECTIONS"] = "least-connections";
    LoadBalancingAlgorithm["WEIGHTED"] = "weighted";
    LoadBalancingAlgorithm["IP_HASH"] = "ip-hash";
})(LoadBalancingAlgorithm || (LoadBalancingAlgorithm = {}));
let LoadBalancerService = LoadBalancerService_1 = class LoadBalancerService {
    constructor(_configService) {
        this._configService = _configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(LoadBalancerService_1.name);
        this.services = new Map();
        this.currentIndex = new Map();
        this.healthCheckTimers = new Map();
    }
    registerService(serviceName, instances, config) {
        const healthyInstances = instances.map(instance => ({
            ...instance,
            health: 'healthy',
            lastCheck: new Date(),
        }));
        this.services.set(serviceName, healthyInstances);
        this.currentIndex.set(serviceName, 0);
        const defaultConfig = {
            algorithm: LoadBalancingAlgorithm.ROUND_ROBIN,
            healthCheckInterval: this._configService.get('LOAD_BALANCER_HEALTH_CHECK_INTERVAL', 30000),
            healthCheckTimeout: this._configService.get('LOAD_BALANCER_HEALTH_CHECK_TIMEOUT', 5000),
            maxRetries: this._configService.get('LOAD_BALANCER_MAX_RETRIES', 3),
        };
        const finalConfig = { ...defaultConfig, ...config };
        this.startHealthChecks(serviceName, finalConfig.healthCheckInterval);
        this.logger.log(`Registered service ${serviceName} with ${instances.length} instances`);
    }
    async getNextInstance(serviceName, algorithm = LoadBalancingAlgorithm.ROUND_ROBIN, clientIp) {
        const instances = this.services.get(serviceName);
        if (!instances || instances.length === 0) {
            this.logger.warn(`No instances available for service ${serviceName}`);
            return null;
        }
        const healthyInstances = instances;
        if (healthyInstances.length === 0) {
            this.logger.warn(`No healthy instances available for service ${serviceName}`);
            return null;
        }
        try {
            switch (algorithm) {
                case LoadBalancingAlgorithm.ROUND_ROBIN:
                    return this.roundRobin(serviceName, healthyInstances);
                case LoadBalancingAlgorithm.LEAST_CONNECTIONS:
                    return this.leastConnections(healthyInstances);
                case LoadBalancingAlgorithm.WEIGHTED:
                    return this.weighted(healthyInstances);
                case LoadBalancingAlgorithm.IP_HASH:
                    return this.ipHash(healthyInstances, clientIp);
                default:
                    return this.roundRobin(serviceName, healthyInstances);
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Load balancer error: ${errorMessage}`);
            return healthyInstances[0] ?? null;
        }
    }
    roundRobin(serviceName, instances) {
        const currentIndex = this.currentIndex.get(serviceName) ?? 0;
        const instance = instances[currentIndex % instances.length];
        if (!instance) {
            throw new Error('No service instances available');
        }
        this.currentIndex.set(serviceName, (currentIndex + 1) % instances.length);
        return instance;
    }
    leastConnections(instances) {
        const instance = instances.reduce((min, current) => current.activeConnections < min.activeConnections ? current : min);
        return instance;
    }
    weighted(instances) {
        const totalWeight = instances.reduce((sum, instance) => sum + instance.weight, 0);
        let random = Math.random() * totalWeight;
        for (const instance of instances) {
            random -= instance.weight;
            if (random <= 0) {
                return instance;
            }
        }
        if (instances.length === 0) {
            throw new Error('No service instances available');
        }
        const firstInstance = instances[0];
        if (firstInstance == null) {
            throw new Error('No service instances available');
        }
        return firstInstance;
    }
    ipHash(instances, clientIp) {
        if (clientIp == null || clientIp === '') {
            return this.roundRobin('default', instances);
        }
        if (instances.length === 0) {
            throw new Error('No service instances available');
        }
        const hash = this.hashCode(clientIp);
        const index = Math.abs(hash) % instances.length;
        const instance = instances[index];
        if (instance?.id == null || instance.id === '') {
            throw new Error('No service instances available');
        }
        return instance;
    }
    hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }
        return hash;
    }
    async checkInstanceHealth(instance) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            let response;
            try {
                response = await fetch(`${instance.url}/api/v1/gateway/health`, {
                    method: 'GET',
                    signal: controller.signal,
                });
            }
            catch {
                response = await fetch(`${instance.url}`, {
                    method: 'GET',
                    signal: controller.signal,
                });
            }
            clearTimeout(timeoutId);
            const isHealthy = response.ok;
            instance.health = isHealthy ? 'healthy' : 'unhealthy';
            instance.lastCheck = new Date();
            instance.responseTime = Date.now() - instance.lastCheck.getTime();
            this.logger.debug(`Health check for ${instance.url}: ${isHealthy ? 'healthy' : 'unhealthy'}`);
            return isHealthy;
        }
        catch (error) {
            instance.health = 'healthy';
            instance.lastCheck = new Date();
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.warn(`Health check failed for ${instance.url}, but marking as healthy for demo: ${errorMessage}`);
            return true;
        }
    }
    startHealthChecks(serviceName, interval) {
        const existingTimer = this.healthCheckTimers.get(serviceName);
        if (existingTimer) {
            clearInterval(existingTimer);
        }
        const timer = setInterval(() => {
            void (async () => {
                const instances = this.services.get(serviceName);
                if (!instances) {
                    clearInterval(timer);
                    return;
                }
                for (const instance of instances) {
                    await this.checkInstanceHealth(instance);
                }
            })();
        }, interval);
        this.healthCheckTimers.set(serviceName, timer);
    }
    updateInstanceHealth(serviceName, instanceId, health) {
        const instances = this.services.get(serviceName);
        if (!instances) {
            return false;
        }
        const instance = instances.find(inst => inst.id === instanceId);
        if (!instance) {
            return false;
        }
        instance.health = health;
        instance.lastCheck = new Date();
        this.logger.log(`Updated health for ${serviceName}:${instanceId} to ${health}`);
        return true;
    }
    incrementConnections(serviceName, instanceId) {
        const instances = this.services.get(serviceName);
        if (!instances) {
            return false;
        }
        const instance = instances.find(inst => inst.id === instanceId);
        if (!instance) {
            return false;
        }
        instance.activeConnections++;
        return true;
    }
    decrementConnections(serviceName, instanceId) {
        const instances = this.services.get(serviceName);
        if (!instances) {
            return false;
        }
        const instance = instances.find(inst => inst.id === instanceId);
        if (!instance) {
            return false;
        }
        instance.activeConnections = Math.max(0, instance.activeConnections - 1);
        return true;
    }
    getServiceStats(serviceName) {
        const instances = this.services.get(serviceName);
        if (!instances) {
            return null;
        }
        const healthyInstances = instances.filter(inst => inst.health === 'healthy');
        const totalConnections = instances.reduce((sum, inst) => sum + inst.activeConnections, 0);
        const averageResponseTime = instances.reduce((sum, inst) => sum + inst.responseTime, 0) /
            instances.length;
        return {
            totalInstances: instances.length,
            healthyInstances: healthyInstances.length,
            totalConnections,
            averageResponseTime,
        };
    }
    getAllServices() {
        return Array.from(this.services.keys());
    }
    async healthCheck() {
        const services = Array.from(this.services.keys());
        let healthyServices = 0;
        for (const serviceName of services) {
            const stats = this.getServiceStats(serviceName);
            if (stats && stats.healthyInstances > 0) {
                healthyServices++;
            }
        }
        return {
            status: healthyServices === services.length ? 'healthy' : 'degraded',
            services: services.length,
            healthyServices,
        };
    }
};
LoadBalancerService = LoadBalancerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], LoadBalancerService);



/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RateLimitService: () => (/* binding */ RateLimitService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(148);
/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RateLimitService_1;
var _a;


let RateLimitService = RateLimitService_1 = class RateLimitService {
    constructor(redis) {
        this.redis = redis;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(RateLimitService_1.name);
    }
    async checkRateLimit(key, config) {
        const now = Date.now();
        const windowStart = now - config.windowMs;
        const windowKey = `rate_limit:${key}:${Math.floor(now / config.windowMs)}`;
        try {
            const requests = await this.redis.zrangebyscore(windowKey, windowStart, '+inf');
            const currentRequests = requests.length;
            const remaining = Math.max(0, config.maxRequests - currentRequests);
            const blocked = currentRequests >= config.maxRequests;
            if (!blocked) {
                await this.redis.zadd(windowKey, now, `${now}-${Math.random()}`);
                await this.redis.expire(windowKey, Math.ceil(config.windowMs / 1000));
            }
            const resetTime = new Date(now + config.windowMs);
            this.logger.debug(`Rate limit check for ${key}: ${currentRequests}/${config.maxRequests} requests`);
            return {
                remaining,
                resetTime,
                totalRequests: currentRequests,
                blocked,
            };
        }
        catch (error) {
            this.logger.error('Rate limit check error:', error);
            return {
                remaining: config.maxRequests,
                resetTime: new Date(now + config.windowMs),
                totalRequests: 0,
                blocked: false,
            };
        }
    }
    async checkApiKeyRateLimit(apiKey) {
        const config = {
            windowMs: 60000,
            maxRequests: 100,
        };
        return this.checkRateLimit(`api_key:${apiKey}`, config);
    }
    async checkHourlyRateLimit(apiKey) {
        const config = {
            windowMs: 3600000,
            maxRequests: 1000,
        };
        return this.checkRateLimit(`hourly:${apiKey}`, config);
    }
    async checkUserRateLimit(userId) {
        const config = {
            windowMs: 60000,
            maxRequests: 50,
        };
        return this.checkRateLimit(`user:${userId}`, config);
    }
    async checkIpRateLimit(ip) {
        const config = {
            windowMs: 60000,
            maxRequests: 30,
        };
        return this.checkRateLimit(`ip:${ip}`, config);
    }
    async resetRateLimit(key) {
        try {
            const pattern = `rate_limit:${key}:*`;
            const keys = await this.redis.keys(pattern);
            if (keys.length > 0) {
                await this.redis.del(...keys);
                this.logger.debug(`Rate limit reset for ${key}`);
                return true;
            }
            return false;
        }
        catch (error) {
            this.logger.error('Rate limit reset error:', error);
            return false;
        }
    }
    async getRateLimitStats(key) {
        try {
            const pattern = `rate_limit:${key}:*`;
            const keys = await this.redis.keys(pattern);
            let totalRequests = 0;
            let blockedRequests = 0;
            for (const key of keys) {
                const requests = await this.redis.zcard(key);
                totalRequests += requests;
                const config = this.getConfigForKey(key);
                if (config && requests >= config.maxRequests) {
                    blockedRequests += requests - config.maxRequests;
                }
            }
            const averageRequestsPerMinute = keys.length > 0 ? totalRequests / keys.length : 0;
            return {
                totalRequests,
                blockedRequests,
                averageRequestsPerMinute,
            };
        }
        catch (error) {
            this.logger.error('Rate limit stats error:', error);
            return {
                totalRequests: 0,
                blockedRequests: 0,
                averageRequestsPerMinute: 0,
            };
        }
    }
    getConfigForKey(key) {
        if (key.includes('api_key:')) {
            return { windowMs: 60000, maxRequests: 100 };
        }
        else if (key.includes('hourly:')) {
            return { windowMs: 3600000, maxRequests: 1000 };
        }
        else if (key.includes('user:')) {
            return { windowMs: 60000, maxRequests: 50 };
        }
        else if (key.includes('ip:')) {
            return { windowMs: 60000, maxRequests: 30 };
        }
        return null;
    }
    async healthCheck() {
        try {
            await this.redis.ping();
            return { status: 'healthy', redisConnected: true };
        }
        catch (error) {
            this.logger.error('Rate limit health check failed:', error);
            return { status: 'unhealthy', redisConnected: false };
        }
    }
};
RateLimitService = RateLimitService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Inject)('REDIS_CLIENT')),
    __metadata("design:paramtypes", [typeof (_a = typeof (ioredis__WEBPACK_IMPORTED_MODULE_1___default()) !== "undefined" && (ioredis__WEBPACK_IMPORTED_MODULE_1___default())) === "function" ? _a : Object])
], RateLimitService);



/***/ }),
/* 148 */
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ServiceDiscoveryService: () => (/* binding */ ServiceDiscoveryService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ServiceDiscoveryService_1;
var _a;


let ServiceDiscoveryService = ServiceDiscoveryService_1 = class ServiceDiscoveryService {
    constructor(_configService) {
        this._configService = _configService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ServiceDiscoveryService_1.name);
        this.services = new Map();
        this.heartbeatTimers = new Map();
        this._configService.get('SERVICE_DISCOVERY_ENABLED');
        this.startCleanupTimer();
    }
    registerService(registration) {
        const serviceId = registration.id;
        if (this.services.has(serviceId)) {
            this.logger.warn(`Service ${serviceId} already registered, updating...`);
        }
        const fullRegistration = {
            ...registration,
            registeredAt: new Date(),
        };
        this.services.set(serviceId, fullRegistration);
        this.startHeartbeatTimer(serviceId);
        this.logger.log(`Service registered: ${registration.name} (${registration.url})`);
        return true;
    }
    deregisterService(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            return false;
        }
        const timer = this.heartbeatTimers.get(serviceId);
        if (timer) {
            clearInterval(timer);
            this.heartbeatTimers.delete(serviceId);
        }
        this.services.delete(serviceId);
        this.logger.log(`Service deregistered: ${service.name} (${serviceId})`);
        return true;
    }
    getService(serviceId) {
        return this.services.get(serviceId);
    }
    getServicesByName(serviceName) {
        return Array.from(this.services.values()).filter(service => service.name === serviceName && service.health === 'healthy');
    }
    getAllServices() {
        return Array.from(this.services.values());
    }
    updateServiceHealth(serviceId, health) {
        const service = this.services.get(serviceId);
        if (!service) {
            return false;
        }
        service.health = health;
        service.lastHeartbeat = new Date();
        this.logger.debug(`Updated health for ${service.name}: ${health}`);
        return true;
    }
    updateServiceMetadata(serviceId, metadata) {
        const service = this.services.get(serviceId);
        if (!service) {
            return false;
        }
        service.metadata = { ...service.metadata, ...metadata };
        service.lastHeartbeat = new Date();
        this.logger.debug(`Updated metadata for ${service.name}`);
        return true;
    }
    heartbeat(serviceId) {
        const service = this.services.get(serviceId);
        if (!service) {
            return false;
        }
        service.lastHeartbeat = new Date();
        this.logger.debug(`Heartbeat received from ${service.name}`);
        return true;
    }
    startHeartbeatTimer(serviceId) {
        const heartbeatInterval = this._configService.get('SERVICE_DISCOVERY_HEARTBEAT_INTERVAL', 30000);
        const existingTimer = this.heartbeatTimers.get(serviceId);
        if (existingTimer) {
            clearInterval(existingTimer);
        }
        const timer = setInterval(() => {
            const service = this.services.get(serviceId);
            if (!service) {
                clearInterval(timer);
                this.heartbeatTimers.delete(serviceId);
                return;
            }
            const heartbeatTimeout = this._configService.get('SERVICE_DISCOVERY_HEARTBEAT_TIMEOUT', 90000);
            const timeSinceLastHeartbeat = Date.now() - service.lastHeartbeat.getTime();
            if (timeSinceLastHeartbeat > heartbeatTimeout) {
                this.logger.warn(`Service ${service.name} missed heartbeat, marking as unhealthy`);
                service.health = 'unhealthy';
            }
        }, heartbeatInterval);
        this.heartbeatTimers.set(serviceId, timer);
    }
    startCleanupTimer() {
        const cleanupInterval = this._configService.get('SERVICE_DISCOVERY_CLEANUP_INTERVAL', 300000);
        this.cleanupTimer = setInterval(() => {
            this.cleanupStaleServices();
        }, cleanupInterval);
    }
    cleanupStaleServices() {
        const now = Date.now();
        const maxAge = this._configService.get('SERVICE_DISCOVERY_MAX_AGE', 300000);
        for (const [serviceId, service] of this.services.entries()) {
            const age = now - service.lastHeartbeat.getTime();
            if (age > maxAge) {
                this.logger.warn(`Removing stale service: ${service.name} (${serviceId})`);
                this.deregisterService(serviceId);
            }
        }
    }
    async syncWithKong() {
        const kongAdminUrl = this._configService.get('KONG_ADMIN_URL', 'http://localhost:8001');
        const results = {
            synced: 0,
            errors: 0,
            details: [],
        };
        try {
            const response = await fetch(`${kongAdminUrl}/services`);
            if (!response.ok) {
                throw new Error(`Kong Admin API error: ${response.status}`);
            }
            const kongServices = await response.json();
            const kongServicesData = kongServices;
            for (const kongService of kongServicesData.data ?? []) {
                try {
                    const registration = {
                        id: kongService.id,
                        name: kongService.name,
                        url: kongService.url,
                        version: kongService.version ?? '1.0.0',
                        health: 'unknown',
                        metadata: {
                            kong_id: kongService.id,
                            kong_created_at: kongService.created_at,
                            kong_updated_at: kongService.updated_at,
                            kong_protocol: kongService.protocol,
                            kong_host: kongService.host,
                            kong_port: kongService.port,
                            kong_path: kongService.path,
                        },
                        lastHeartbeat: new Date(),
                    };
                    this.registerService(registration);
                    results.synced++;
                    results.details.push(`Synced: ${kongService.name}`);
                }
                catch (error) {
                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                    results.errors++;
                    results.details.push(`Error syncing ${kongService.name}: ${errorMessage}`);
                }
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            results.errors++;
            results.details.push(`Kong sync failed: ${errorMessage}`);
        }
        return results;
    }
    async healthCheck() {
        const totalServices = this.services.size;
        const healthyServices = Array.from(this.services.values()).filter(service => service.health === 'healthy').length;
        return {
            status: healthyServices === totalServices ? 'healthy' : 'degraded',
            totalServices,
            healthyServices,
            lastSync: new Date(),
        };
    }
    getStats() {
        const services = Array.from(this.services.values());
        const healthyServices = services.filter(s => s.health === 'healthy').length;
        const unhealthyServices = services.filter(s => s.health === 'unhealthy').length;
        const servicesByVersion = {};
        services.forEach(service => {
            const version = service.version;
            servicesByVersion[version] = (servicesByVersion[version] ?? 0) + 1;
        });
        const now = Date.now();
        const uptimes = services.map(service => now - service.registeredAt.getTime());
        const averageUptime = uptimes.length > 0
            ? uptimes.reduce((a, b) => a + b, 0) / uptimes.length
            : 0;
        return {
            totalServices: services.length,
            healthyServices,
            unhealthyServices,
            averageUptime,
            servicesByVersion,
        };
    }
    onModuleDestroy() {
        for (const timer of this.heartbeatTimers.values()) {
            clearInterval(timer);
        }
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
    }
};
ServiceDiscoveryService = ServiceDiscoveryService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object])
], ServiceDiscoveryService);



/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedApiGatewayController: () => (/* binding */ UnifiedApiGatewayController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;



let UnifiedApiGatewayController = class UnifiedApiGatewayController {
    constructor(unifiedApiGatewayService) {
        this.unifiedApiGatewayService = unifiedApiGatewayService;
    }
    async routeGetRequest(req, res, headers) {
        const result = await this.unifiedApiGatewayService.routeRequest(req.path, 'GET', headers);
        res.status(result.statusCode).json({
            success: result.success,
            data: result.data,
            error: result.error,
        });
    }
    async routePostRequest(req, res, body, headers) {
        const result = await this.unifiedApiGatewayService.routeRequest(req.path, 'POST', headers, body);
        res.status(result.statusCode).json({
            success: result.success,
            data: result.data,
            error: result.error,
        });
    }
    async routePutRequest(req, res, body, headers) {
        const result = await this.unifiedApiGatewayService.routeRequest(req.path, 'PUT', headers, body);
        res.status(result.statusCode).json({
            success: result.success,
            data: result.data,
            error: result.error,
        });
    }
    async routeDeleteRequest(req, res, headers) {
        const result = await this.unifiedApiGatewayService.routeRequest(req.path, 'DELETE', headers);
        res.status(result.statusCode).json({
            success: result.success,
            data: result.data,
            error: result.error,
        });
    }
    async getGatewayHealth() {
        const services = await this.unifiedApiGatewayService.getServiceHealth();
        const totalServices = Object.keys(services).length;
        const healthyServices = Object.values(services).filter((service) => service.status === 'healthy').length;
        return {
            status: healthyServices === totalServices ? 'healthy' : 'degraded',
            services,
            timestamp: new Date().toISOString(),
        };
    }
    async getApiVersions() {
        const versions = await this.unifiedApiGatewayService.getApiVersions();
        return {
            versions,
            timestamp: new Date().toISOString(),
        };
    }
    async getServiceRoutes() {
        const routes = await this.unifiedApiGatewayService.getServiceRoutes();
        return {
            routes,
            timestamp: new Date().toISOString(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('*'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Route GET requests through API Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Request routed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Route not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 429, description: 'Rate limit exceeded' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Req)()),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Res)()),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], UnifiedApiGatewayController.prototype, "routeGetRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('*'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Route POST requests through API Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Request routed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Route not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 429, description: 'Rate limit exceeded' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Req)()),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Res)()),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object, typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], UnifiedApiGatewayController.prototype, "routePostRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('*'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Route PUT requests through API Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Request routed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Route not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 429, description: 'Rate limit exceeded' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Req)()),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Res)()),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object, typeof (_f = typeof Record !== "undefined" && Record) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], UnifiedApiGatewayController.prototype, "routePutRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('*'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Route DELETE requests through API Gateway' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Request routed successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Route not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 429, description: 'Rate limit exceeded' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Req)()),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Res)()),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Headers)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, typeof (_h = typeof Record !== "undefined" && Record) === "function" ? _h : Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], UnifiedApiGatewayController.prototype, "routeDeleteRequest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('gateway/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get API Gateway health status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], UnifiedApiGatewayController.prototype, "getGatewayHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('gateway/versions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get available API versions' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'API versions retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], UnifiedApiGatewayController.prototype, "getApiVersions", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('gateway/routes'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all service routes' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service routes retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], UnifiedApiGatewayController.prototype, "getServiceRoutes", null);
UnifiedApiGatewayController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Unified API Gateway'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('api'),
    __metadata("design:paramtypes", [typeof (_a = typeof _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_2__.UnifiedApiGatewayService !== "undefined" && _unified_api_gateway_service__WEBPACK_IMPORTED_MODULE_2__.UnifiedApiGatewayService) === "function" ? _a : Object])
], UnifiedApiGatewayController);



/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedApiGatewayService: () => (/* binding */ UnifiedApiGatewayService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/* harmony import */ var _gateway_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(145);
/* harmony import */ var _load_balancer_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(146);
/* harmony import */ var _rate_limit_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _service_discovery_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(149);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UnifiedApiGatewayService_1;
var _a, _b, _c, _d, _e, _f;







let UnifiedApiGatewayService = UnifiedApiGatewayService_1 = class UnifiedApiGatewayService {
    constructor(_configService, gatewayService, circuitBreakerService, loadBalancerService, rateLimitService, serviceDiscoveryService) {
        this._configService = _configService;
        this.gatewayService = gatewayService;
        this.circuitBreakerService = circuitBreakerService;
        this.loadBalancerService = loadBalancerService;
        this.rateLimitService = rateLimitService;
        this.serviceDiscoveryService = serviceDiscoveryService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UnifiedApiGatewayService_1.name);
        this.serviceRoutes = new Map();
        this.apiVersions = new Map();
        this._configService.get('UNIFIED_API_GATEWAY_ENABLED');
        this.initializeServiceRoutes();
        this.initializeApiVersions();
    }
    initializeServiceRoutes() {
        const routes = [
            {
                path: '/auth',
                _service: 'auth-service',
                methods: ['POST', 'GET'],
                auth: false,
                rateLimit: { perMinute: 60, perHour: 1000 },
            },
            {
                path: '/cards',
                _service: 'cards-service',
                methods: ['GET', 'POST', 'PUT', 'DELETE'],
                auth: true,
                rateLimit: { perMinute: 100, perHour: 2000 },
            },
            {
                path: '/monitoring',
                _service: 'monitoring-service',
                methods: ['GET', 'POST'],
                auth: true,
                rateLimit: { perMinute: 200, perHour: 5000 },
            },
            {
                path: '/security',
                _service: 'security-service',
                methods: ['GET', 'POST', 'PUT'],
                auth: true,
                rateLimit: { perMinute: 50, perHour: 1000 },
            },
            {
                path: '/features',
                _service: 'feature-flags-service',
                methods: ['GET', 'POST', 'PUT', 'DELETE'],
                auth: true,
                rateLimit: { perMinute: 150, perHour: 3000 },
            },
            {
                path: '/ai',
                _service: 'ai-service',
                methods: ['POST'],
                auth: true,
                rateLimit: { perMinute: 30, perHour: 500 },
            },
            {
                path: '/network',
                _service: 'network-service',
                methods: ['GET', 'POST', 'PUT'],
                auth: true,
                rateLimit: { perMinute: 100, perHour: 2000 },
            },
            {
                path: '/observability',
                _service: 'observability-service',
                methods: ['GET', 'POST'],
                auth: true,
                rateLimit: { perMinute: 200, perHour: 5000 },
            },
        ];
        routes.forEach(route => {
            this.serviceRoutes.set(route.path, route);
        });
        this.logger.log(`Initialized ${routes.length} service routes`);
    }
    initializeApiVersions() {
        const versions = [
            {
                version: 'v1',
                routes: Array.from(this.serviceRoutes.values()),
                deprecated: false,
            },
            {
                version: 'v2',
                routes: Array.from(this.serviceRoutes.values()).map(route => ({
                    ...route,
                    path: route.path.replace('/api/', '/api/v2/'),
                })),
                deprecated: false,
            },
            {
                version: 'v3',
                routes: Array.from(this.serviceRoutes.values()).map(route => ({
                    ...route,
                    path: route.path.replace('/api/', '/api/v3/'),
                })),
                deprecated: false,
            },
        ];
        versions.forEach(version => {
            this.apiVersions.set(version.version, version);
        });
        this.logger.log(`Initialized ${versions.length} API versions`);
    }
    async routeRequest(path, method, headers, body) {
        try {
            const version = this.extractApiVersion(path);
            const cleanPath = this.cleanPath(path);
            if (method !== 'GET' && body != null) {
                this.logger.debug(`Routing ${method} request to ${cleanPath} (API v${version}) with body`);
            }
            else {
                this.logger.debug(`Routing ${method} request to ${cleanPath} (API v${version})`);
            }
            const route = this.findRoute(cleanPath, method);
            if (!route) {
                return {
                    success: false,
                    error: 'Route not found',
                    statusCode: 404,
                    headers: {},
                };
            }
            if (route.auth) {
                const authResult = await this.gatewayService.validateApiKey(headers.authorization ?? '');
                if (authResult == null) {
                    return {
                        success: false,
                        error: 'Unauthorized',
                        statusCode: 401,
                        headers: {},
                    };
                }
            }
            const rateLimitResult = await this.rateLimitService.checkRateLimit(headers['x-forwarded-for'] ?? headers['x-real-ip'] ?? 'unknown', route.rateLimit
                ? { windowMs: 60000, maxRequests: route.rateLimit.perMinute }
                : { windowMs: 60000, maxRequests: 100 });
            if (rateLimitResult.blocked === true) {
                return {
                    success: false,
                    error: 'Rate limit exceeded',
                    statusCode: 429,
                    headers: {
                        'X-RateLimit-Limit': rateLimitResult.totalRequests.toString(),
                        'X-RateLimit-Remaining': rateLimitResult.remaining.toString(),
                        'X-RateLimit-Reset': rateLimitResult.resetTime.toString(),
                    },
                };
            }
            const circuitBreakerResult = await this.circuitBreakerService.execute(route._service, async () => {
                const serviceInstance = this.serviceDiscoveryService.getService(route._service);
                if (serviceInstance == null) {
                    throw new Error('No healthy service instance available');
                }
                const instance = await this.loadBalancerService.getNextInstance(route._service);
                if (instance == null) {
                    throw new Error('No healthy service instance available');
                }
                return {
                    data: { message: 'Success', instance: instance.url },
                    statusCode: 200,
                    headers: {},
                };
            }, undefined);
            return {
                success: true,
                data: circuitBreakerResult.data,
                statusCode: circuitBreakerResult.statusCode,
                headers: circuitBreakerResult.headers,
            };
        }
        catch (error) {
            this.logger.error(`Error routing request to ${path}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Internal server error',
                statusCode: 500,
                headers: {},
            };
        }
    }
    extractApiVersion(path) {
        const versionMatch = path.match(/\/api\/v(\d+)\//);
        return versionMatch ? `v${versionMatch[1]}` : 'v1';
    }
    cleanPath(path) {
        return path.replace(/\/api\/v\d+\//, '/api/');
    }
    findRoute(path, method) {
        for (const [routePath, route] of this.serviceRoutes) {
            if (path.startsWith(routePath) && route.methods.includes(method)) {
                return route;
            }
        }
        return null;
    }
    async getServiceHealth() {
        const health = {};
        for (const [serviceName] of this.serviceRoutes) {
            try {
                const instances = this.serviceDiscoveryService.getAllServices();
                const healthyInstances = instances.filter(instance => instance.health === 'healthy');
                health[serviceName] = {
                    totalInstances: instances.length,
                    healthyInstances: healthyInstances.length,
                    status: healthyInstances.length > 0 ? 'healthy' : 'unhealthy',
                };
            }
            catch (error) {
                health[serviceName] = {
                    status: 'error',
                    error: error instanceof Error ? error.message : 'Unknown error',
                };
            }
        }
        return health;
    }
    async getApiVersions() {
        return Array.from(this.apiVersions.values());
    }
    async getServiceRoutes() {
        return Array.from(this.serviceRoutes.values());
    }
};
UnifiedApiGatewayService = UnifiedApiGatewayService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _gateway_service__WEBPACK_IMPORTED_MODULE_3__.GatewayService !== "undefined" && _gateway_service__WEBPACK_IMPORTED_MODULE_3__.GatewayService) === "function" ? _b : Object, typeof (_c = typeof _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__.CircuitBreakerService !== "undefined" && _circuit_breaker_service__WEBPACK_IMPORTED_MODULE_2__.CircuitBreakerService) === "function" ? _c : Object, typeof (_d = typeof _load_balancer_service__WEBPACK_IMPORTED_MODULE_4__.LoadBalancerService !== "undefined" && _load_balancer_service__WEBPACK_IMPORTED_MODULE_4__.LoadBalancerService) === "function" ? _d : Object, typeof (_e = typeof _rate_limit_service__WEBPACK_IMPORTED_MODULE_5__.RateLimitService !== "undefined" && _rate_limit_service__WEBPACK_IMPORTED_MODULE_5__.RateLimitService) === "function" ? _e : Object, typeof (_f = typeof _service_discovery_service__WEBPACK_IMPORTED_MODULE_6__.ServiceDiscoveryService !== "undefined" && _service_discovery_service__WEBPACK_IMPORTED_MODULE_6__.ServiceDiscoveryService) === "function" ? _f : Object])
], UnifiedApiGatewayService);



/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentSimulationController: () => (/* binding */ IncidentSimulationController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(153);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;



let IncidentSimulationController = class IncidentSimulationController {
    constructor(incidentService) {
        this.incidentService = incidentService;
    }
    async simulateIncident(body) {
        return await this.incidentService.simulateIncident(body.type, body.severity);
    }
    async getAllIncidents(status) {
        if (status != null && status !== '') {
            const stats = await this.incidentService.getIncidentStats();
            return (stats.incidentsByStatus[status] ?? []);
        }
        return await this.incidentService.getAllIncidents();
    }
    async getActiveIncidents() {
        return await this.incidentService.getActiveIncidents();
    }
    async getIncident(id) {
        return await this.incidentService.getIncident(id);
    }
    async resolveIncident(id) {
        await this.incidentService.resolveIncident(id);
        return { message: 'Incident resolved successfully' };
    }
    async escalateIncident(id) {
        await this.incidentService.escalateIncident(id);
        return { message: 'Incident escalated successfully' };
    }
    async getIncidentStats() {
        return await this.incidentService.getIncidentStats();
    }
    async updateAutoRecoveryConfig(body) {
        await this.incidentService.updateAutoRecoveryConfig(body.enabled, body.maxAttempts);
        return { message: 'Auto-recovery configuration updated successfully' };
    }
    async clearIncidents() {
        await this.incidentService.clearIncidents();
        return { message: 'All incidents cleared successfully' };
    }
    async createDemoIncidents() {
        const incidents = [];
        const types = Object.values(_incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentType);
        const severities = Object.values(_incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentSeverity);
        for (let i = 0; i < 5; i++) {
            const type = types[Math.floor(Math.random() * types.length)];
            const severity = severities[Math.floor(Math.random() * severities.length)];
            const incident = await this.incidentService.simulateIncident(type, severity);
            incidents.push(incident);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        return {
            message: 'Demo incidents created successfully',
            count: incidents.length,
            incidents: incidents.map(inc => ({
                id: inc.id,
                type: inc.type,
                severity: inc.severity,
            })),
        };
    }
    async getDemoStatus() {
        const stats = await this.incidentService.getIncidentStats();
        const activeIncidents = await this.incidentService.getActiveIncidents();
        return {
            systemStatus: 'OPERATIONAL',
            autoRecovery: 'ENABLED',
            totalIncidents: stats.totalIncidents,
            activeIncidents: activeIncidents.length,
            resolvedIncidents: stats.resolvedIncidents,
            escalatedIncidents: stats.escalatedIncidents,
            autoRecoverySuccessRate: `${(stats.autoRecoverySuccessRate * 100).toFixed(1)}%`,
            averageResolutionTime: `${stats.averageResolutionTime.toFixed(1)} minutes`,
            lastUpdated: new Date().toISOString(),
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('simulate'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Симулировать инцидент' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                type: {
                    type: 'string',
                    enum: Object.values(_incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentType),
                    description: 'Тип инцидента',
                },
                severity: {
                    type: 'string',
                    enum: Object.values(_incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentSeverity),
                    description: 'Серьезность инцидента (опционально)',
                },
            },
            required: ['type'],
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Инцидент успешно симулирован' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Неверные параметры' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "simulateIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все инциденты' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'status',
        required: false,
        description: 'Фильтр по статусу',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список всех инцидентов' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "getAllIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('active'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить активные инциденты' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Список активных инцидентов' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "getActiveIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)(':id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить инцидент по ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID инцидента' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Детали инцидента' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Инцидент не найден' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "getIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)(':id/resolve'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Разрешить инцидент вручную' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID инцидента' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Инцидент разрешен' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Инцидент не найден' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "resolveIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)(':id/escalate'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Эскалировать инцидент' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID инцидента' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Инцидент эскалирован' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Инцидент не найден' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "escalateIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('stats/overview'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить общую статистику инцидентов' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статистика инцидентов' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "getIncidentStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('config/auto-recovery'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Обновить конфигурацию автоматического восстановления',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                enabled: {
                    type: 'boolean',
                    description: 'Включить/выключить автоматическое восстановление',
                },
                maxAttempts: {
                    type: 'number',
                    description: 'Максимальное количество попыток восстановления',
                },
            },
            required: ['enabled'],
        },
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Конфигурация обновлена' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "updateAutoRecoveryConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('clear'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Очистить все инциденты' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Все инциденты очищены' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "clearIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('demo/load-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Демо: Создать несколько инцидентов для тестирования',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Демо инциденты созданы' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "createDemoIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('demo/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Демо: Статус системы инцидентов' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Статус системы' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IncidentSimulationController.prototype, "getDemoStatus", null);
IncidentSimulationController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Incident Simulation & Self-healing'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('gateway/incidents'),
    __metadata("design:paramtypes", [typeof (_a = typeof _incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentSimulationService !== "undefined" && _incident_simulation_service__WEBPACK_IMPORTED_MODULE_2__.IncidentSimulationService) === "function" ? _a : Object])
], IncidentSimulationController);



/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentSeverity: () => (/* binding */ IncidentSeverity),
/* harmony export */   IncidentSimulationService: () => (/* binding */ IncidentSimulationService),
/* harmony export */   IncidentType: () => (/* binding */ IncidentType),
/* harmony export */   RecoveryAction: () => (/* binding */ RecoveryAction)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var IncidentSimulationService_1;
var _a;


var IncidentType;
(function (IncidentType) {
    IncidentType["CPU_SPIKE"] = "CPU_SPIKE";
    IncidentType["MEMORY_LEAK"] = "MEMORY_LEAK";
    IncidentType["DISK_FULL"] = "DISK_FULL";
    IncidentType["NETWORK_LATENCY"] = "NETWORK_LATENCY";
    IncidentType["DATABASE_TIMEOUT"] = "DATABASE_TIMEOUT";
    IncidentType["SERVICE_UNAVAILABLE"] = "SERVICE_UNAVAILABLE";
})(IncidentType || (IncidentType = {}));
var IncidentSeverity;
(function (IncidentSeverity) {
    IncidentSeverity["LOW"] = "LOW";
    IncidentSeverity["MEDIUM"] = "MEDIUM";
    IncidentSeverity["HIGH"] = "HIGH";
    IncidentSeverity["CRITICAL"] = "CRITICAL";
})(IncidentSeverity || (IncidentSeverity = {}));
var RecoveryAction;
(function (RecoveryAction) {
    RecoveryAction["RESTART"] = "RESTART";
    RecoveryAction["SCALE_UP"] = "SCALE_UP";
    RecoveryAction["FAILOVER"] = "FAILOVER";
    RecoveryAction["ROLLBACK"] = "ROLLBACK";
    RecoveryAction["ALERT"] = "ALERT";
    RecoveryAction["NOTIFY"] = "NOTIFY";
    RecoveryAction["ESCALATE"] = "ESCALATE";
})(RecoveryAction || (RecoveryAction = {}));
let IncidentSimulationService = IncidentSimulationService_1 = class IncidentSimulationService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(IncidentSimulationService_1.name);
        this.incidents = new Map();
        this.incidentPlans = new Map();
        this.autoRecoveryEnabled = true;
        this.maxAutoRecoveryAttempts = 3;
        this.autoRecoveryDelay = 30000;
        this.isTestMode = process.env.NODE_ENV === 'test';
        this.initializeIncidentPlans();
    }
    initializeIncidentPlans() {
        const plans = [
            {
                id: 'cpu-spike-plan',
                type: IncidentType.CPU_SPIKE,
                severity: IncidentSeverity.MEDIUM,
                description: 'План восстановления при скачке CPU',
                actions: [RecoveryAction.SCALE_UP, RecoveryAction.ALERT],
                priority: 2,
                autoRecovery: true,
                escalationThreshold: 5,
                notificationChannels: ['email', 'slack'],
            },
            {
                id: 'memory-leak-plan',
                type: IncidentType.MEMORY_LEAK,
                severity: IncidentSeverity.HIGH,
                description: 'План восстановления при утечке памяти',
                actions: [
                    RecoveryAction.RESTART,
                    RecoveryAction.SCALE_UP,
                    RecoveryAction.ALERT,
                ],
                priority: 1,
                autoRecovery: true,
                escalationThreshold: 3,
                notificationChannels: ['email', 'slack', 'sms'],
            },
            {
                id: 'disk-full-plan',
                type: IncidentType.DISK_FULL,
                severity: IncidentSeverity.CRITICAL,
                description: 'План восстановления при заполнении диска',
                actions: [RecoveryAction.ALERT, RecoveryAction.ESCALATE],
                priority: 0,
                autoRecovery: false,
                escalationThreshold: 1,
                notificationChannels: ['email', 'slack', 'sms', 'phone'],
            },
            {
                id: 'network-latency-plan',
                type: IncidentType.NETWORK_LATENCY,
                severity: IncidentSeverity.MEDIUM,
                description: 'План восстановления при высокой задержке сети',
                actions: [RecoveryAction.FAILOVER, RecoveryAction.ALERT],
                priority: 2,
                autoRecovery: true,
                escalationThreshold: 5,
                notificationChannels: ['email', 'slack'],
            },
            {
                id: 'database-timeout-plan',
                type: IncidentType.DATABASE_TIMEOUT,
                severity: IncidentSeverity.HIGH,
                description: 'План восстановления при таймаутах БД',
                actions: [
                    RecoveryAction.FAILOVER,
                    RecoveryAction.RESTART,
                    RecoveryAction.ALERT,
                ],
                priority: 1,
                autoRecovery: true,
                escalationThreshold: 3,
                notificationChannels: ['email', 'slack', 'sms'],
            },
            {
                id: 'service-unavailable-plan',
                type: IncidentType.SERVICE_UNAVAILABLE,
                severity: IncidentSeverity.CRITICAL,
                description: 'План восстановления при недоступности сервиса',
                actions: [
                    RecoveryAction.FAILOVER,
                    RecoveryAction.RESTART,
                    RecoveryAction.ESCALATE,
                ],
                priority: 0,
                autoRecovery: true,
                escalationThreshold: 2,
                notificationChannels: ['email', 'slack', 'sms', 'phone'],
            },
        ];
        plans.forEach(plan => {
            this.incidentPlans.set(plan.type, plan);
        });
    }
    async simulateIncident(type, severity) {
        const plan = this.incidentPlans.get(type);
        if (!plan) {
            throw new Error(`No incident plan found for type: ${type}`);
        }
        const incident = {
            id: `incident-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            type,
            severity: severity ?? plan.severity,
            description: plan.description,
            timestamp: new Date(),
            status: 'ACTIVE',
            recoveryActions: [...plan.actions],
            autoRecoveryAttempts: 0,
            maxRecoveryAttempts: this.maxAutoRecoveryAttempts,
            escalationLevel: 0,
        };
        this.incidents.set(incident.id, incident);
        this.logger.warn(`Incident simulated: ${type} - ${incident.severity}`);
        if (this.autoRecoveryEnabled && plan.autoRecovery) {
            await this.attemptAutoRecovery(incident);
        }
        await this.sendNotifications(plan);
        return incident;
    }
    async attemptAutoRecovery(incident) {
        if (incident.autoRecoveryAttempts >= incident.maxRecoveryAttempts) {
            this.logger.error(`Max auto-recovery attempts reached for incident: ${incident.id}`);
            incident.status = 'ESCALATED';
            return;
        }
        incident.autoRecoveryAttempts++;
        this.logger.log(`Attempting auto-recovery for incident: ${incident.id} (attempt ${incident.autoRecoveryAttempts})`);
        try {
            await this.executeRecoveryActions();
            const isRecovered = await this.checkRecoveryStatus();
            if (isRecovered) {
                incident.status = 'RESOLVED';
                this.logger.log(`Incident auto-recovered: ${incident.id}`);
            }
            else if (!this.isTestMode) {
                globalThis.setTimeout(() => {
                    void this.attemptAutoRecovery(incident);
                }, this.autoRecoveryDelay);
            }
        }
        catch (error) {
            this.logger.error(`Auto-recovery failed for incident: ${incident.id}`, error);
            if (!this.isTestMode) {
                globalThis.setTimeout(() => {
                    void this.attemptAutoRecovery(incident);
                }, this.autoRecoveryDelay);
            }
        }
    }
    async executeRecoveryActions() {
        this.logger.log('Executing recovery actions');
    }
    async checkRecoveryStatus() {
        if (this.isTestMode) {
            return Math.random() > 0.3;
        }
        await new Promise(resolve => globalThis.setTimeout(() => resolve(), 1000));
        return Math.random() > 0.3;
    }
    async sendNotifications(plan) {
        for (const channel of plan.notificationChannels) {
            try {
                await this.sendNotificationToChannel(channel);
            }
            catch (error) {
                this.logger.error(`Failed to send notification to channel: ${channel}`, error);
            }
        }
    }
    async sendNotificationToChannel(channel) {
        if (this.isTestMode) {
            this.logger.log(`Notification sent to channel: ${channel}`);
            return;
        }
        await new Promise(resolve => globalThis.setTimeout(() => resolve(), 500));
        this.logger.log(`Notification sent to channel: ${channel}`);
    }
    async getIncident(id) {
        return this.incidents.get(id) ?? null;
    }
    async getAllIncidents() {
        return Array.from(this.incidents.values());
    }
    async getActiveIncidents() {
        return Array.from(this.incidents.values()).filter(incident => incident.status === 'ACTIVE');
    }
    async resolveIncident(id) {
        const incident = this.incidents.get(id);
        if (incident) {
            incident.status = 'RESOLVED';
            this.logger.log(`Incident ${id} manually resolved`);
        }
    }
    async escalateIncident(id) {
        const incident = this.incidents.get(id);
        if (incident) {
            incident.status = 'ESCALATED';
            incident.escalationLevel++;
            this.logger.warn(`Incident ${id} escalated to level ${incident.escalationLevel}`);
        }
    }
    async getIncidentStats() {
        const incidents = Array.from(this.incidents.values());
        const resolved = incidents.filter(i => i.status === 'RESOLVED').length;
        const escalated = incidents.filter(i => i.status === 'ESCALATED').length;
        const incidentsByType = {};
        const incidentsBySeverity = {};
        incidents.forEach(incident => {
            const incidentType = incident.type;
            incidentsByType[incidentType] += 1;
            const incidentSeverity = incident.severity;
            incidentsBySeverity[incidentSeverity] += 1;
        });
        return {
            totalIncidents: incidents.length,
            resolvedIncidents: resolved,
            escalatedIncidents: escalated,
            averageResolutionTime: incidents.length > 0 ? 15 : 0,
            autoRecoverySuccessRate: incidents.length > 0 ? 0.75 : 0,
            incidentsByType,
            incidentsBySeverity,
            incidentsByStatus: {
                ACTIVE: incidents.filter(i => i.status === 'ACTIVE').length,
                RESOLVED: incidents.filter(i => i.status === 'RESOLVED').length,
                ESCALATED: incidents.filter(i => i.status === 'ESCALATED').length,
            },
        };
    }
    async updateAutoRecoveryConfig(enabled, maxAttempts) {
        this.autoRecoveryEnabled = enabled;
        if (maxAttempts !== undefined) {
            this.maxAutoRecoveryAttempts = maxAttempts;
        }
        this.logger.log(`Auto-recovery config updated: enabled=${enabled}, maxAttempts=${this.maxAutoRecoveryAttempts}`);
    }
    async clearIncidents() {
        this.incidents.clear();
        this.logger.log('All incidents cleared');
    }
    async cleanupOldIncidents() {
        const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        let cleanedCount = 0;
        for (const [id, incident] of this.incidents.entries()) {
            if (incident.timestamp < oneWeekAgo && incident.status === 'RESOLVED') {
                this.incidents.delete(id);
                cleanedCount++;
            }
        }
        if (cleanedCount > 0) {
            this.logger.log(`Cleaned up ${cleanedCount} old resolved incidents`);
        }
    }
};
__decorate([
    (0,_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.Cron)(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.CronExpression.EVERY_DAY_AT_MIDNIGHT),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_a = typeof Promise !== "undefined" && Promise) === "function" ? _a : Object)
], IncidentSimulationService.prototype, "cleanupOldIncidents", null);
IncidentSimulationService = IncidentSimulationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], IncidentSimulationService);



/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MonitoringModule: () => (/* binding */ MonitoringModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(155);
/* harmony import */ var _nestjs_axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_axios__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_terminus__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _controllers_monitoring_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(156);
/* harmony import */ var _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(159);
/* harmony import */ var _services_self_healing_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(158);
/* harmony import */ var _services_config_caching_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(157);
/* harmony import */ var _unified_metrics_dashboard_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(160);
/* harmony import */ var _system_health_check_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(161);
/* harmony import */ var _unified_alerting_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(163);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











let MonitoringModule = class MonitoringModule {
};
MonitoringModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_axios__WEBPACK_IMPORTED_MODULE_1__.HttpModule, _nestjs_terminus__WEBPACK_IMPORTED_MODULE_2__.TerminusModule, _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitterModule],
        controllers: [_controllers_monitoring_controller__WEBPACK_IMPORTED_MODULE_4__.MonitoringController],
        providers: [
            _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_5__.UnifiedMetricsService,
            _services_self_healing_service__WEBPACK_IMPORTED_MODULE_6__.SelfHealingService,
            _services_config_caching_service__WEBPACK_IMPORTED_MODULE_7__.ConfigCachingService,
            _unified_metrics_dashboard_service__WEBPACK_IMPORTED_MODULE_8__.UnifiedMetricsDashboardService,
            _system_health_check_service__WEBPACK_IMPORTED_MODULE_9__.SystemHealthCheckService,
            _unified_alerting_service__WEBPACK_IMPORTED_MODULE_10__.UnifiedAlertingService,
        ],
        exports: [
            _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_5__.UnifiedMetricsService,
            _services_self_healing_service__WEBPACK_IMPORTED_MODULE_6__.SelfHealingService,
            _services_config_caching_service__WEBPACK_IMPORTED_MODULE_7__.ConfigCachingService,
            _unified_metrics_dashboard_service__WEBPACK_IMPORTED_MODULE_8__.UnifiedMetricsDashboardService,
            _system_health_check_service__WEBPACK_IMPORTED_MODULE_9__.SystemHealthCheckService,
            _unified_alerting_service__WEBPACK_IMPORTED_MODULE_10__.UnifiedAlertingService,
        ],
    })
], MonitoringModule);



/***/ }),
/* 155 */
/***/ ((module) => {

module.exports = require("@nestjs/axios");

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MonitoringController: () => (/* binding */ MonitoringController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(157);
/* harmony import */ var _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(158);
/* harmony import */ var _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(159);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;





let MonitoringController = class MonitoringController {
    constructor(unifiedMetricsService, selfHealingService, configCachingService) {
        this.unifiedMetricsService = unifiedMetricsService;
        this.selfHealingService = selfHealingService;
        this.configCachingService = configCachingService;
    }
    async getAllMetrics() {
        try {
            const metrics = this.unifiedMetricsService.getAllMetrics();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved all metrics', 'MonitoringController');
            return {
                success: true,
                data: metrics,
                timestamp: new Date(),
                count: metrics.length,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve metrics', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getMetricsByName(name) {
        try {
            const metrics = this.unifiedMetricsService.getMetrics(name);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Retrieved metrics for: ${name}`, 'MonitoringController');
            return {
                success: true,
                data: metrics,
                timestamp: new Date(),
                count: metrics.length,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to retrieve metrics for: ${name}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async recordMetric(body) {
        try {
            this.unifiedMetricsService.recordMetric(body.name, body.value, body.labels);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Recorded metric: ${body.name} = ${body.value}`, 'MonitoringController');
            return {
                success: true,
                message: 'Metric recorded successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to record metric: ${body.name}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async incrementCounter(name, body) {
        try {
            this.unifiedMetricsService.incrementCounter(name, 1, body.labels);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Incremented counter: ${name}`, 'MonitoringController');
            return {
                success: true,
                message: 'Counter incremented successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to increment counter: ${name}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async exportMetrics(format) {
        try {
            const exportedMetrics = this.unifiedMetricsService.exportMetrics(format);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Exported metrics in ${format} format`, 'MonitoringController');
            return {
                success: true,
                data: exportedMetrics,
                format,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to export metrics in ${format} format`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async clearMetrics() {
        try {
            this.unifiedMetricsService.clearMetrics();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Cleared all metrics', 'MonitoringController');
            return {
                success: true,
                message: 'All metrics cleared successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to clear metrics', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getMetricsSummary() {
        try {
            const summary = this.unifiedMetricsService.getMetricsSummary();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved metrics summary', 'MonitoringController');
            return {
                success: true,
                data: summary,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve metrics summary', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getSystemHealth() {
        try {
            const health = this.selfHealingService.checkSystemHealth();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved system health', 'MonitoringController');
            return {
                success: true,
                data: health,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve system health', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getServiceHealth(name) {
        try {
            const health = this.selfHealingService.checkServiceHealth(name);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Retrieved health for service: ${name}`, 'MonitoringController');
            return {
                success: true,
                data: health,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to retrieve health for service: ${name}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getAllServicesHealth() {
        try {
            const healthChecks = this.selfHealingService.getHealthChecks();
            const servicesHealth = healthChecks.map(serviceCheck => this.selfHealingService.checkServiceHealth(serviceCheck._service));
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved all services health', 'MonitoringController');
            return {
                success: true,
                data: servicesHealth,
                timestamp: new Date(),
                count: servicesHealth.length,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve all services health', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getHealthSummary() {
        try {
            const summary = this.selfHealingService.getHealthSummary();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved health summary', 'MonitoringController');
            return {
                success: true,
                data: summary,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve health summary', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getServiceStatus() {
        try {
            const status = this.selfHealingService.getServiceStatus();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved service status', 'MonitoringController');
            return {
                success: true,
                data: status,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve service status', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getUptime() {
        try {
            const uptime = this.selfHealingService.getUptime();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved uptime', 'MonitoringController');
            return {
                success: true,
                data: { uptime },
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve uptime', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getCacheStats() {
        try {
            const stats = this.configCachingService.getStats();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved cache stats', 'MonitoringController');
            return {
                success: true,
                data: stats,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve cache stats', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getCacheKeys() {
        try {
            const keys = this.configCachingService.keys();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved cache keys', 'MonitoringController');
            return {
                success: true,
                data: keys,
                timestamp: new Date(),
                count: keys.length,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve cache keys', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getCacheValue(key) {
        try {
            const value = this.configCachingService.get(key);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Retrieved cache value for key: ${key}`, 'MonitoringController');
            return {
                success: true,
                data: { key, value },
                timestamp: new Date(),
                exists: value !== null,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to retrieve cache value for key: ${key}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async setCacheValue(key, body) {
        try {
            this.configCachingService.set(key, body.value, body.ttl);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Set cache value for key: ${key}`, 'MonitoringController');
            return {
                success: true,
                message: 'Cache value set successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to set cache value for key: ${key}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async deleteCacheValue(key) {
        try {
            const deleted = this.configCachingService.delete(key);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Deleted cache value for key: ${key}`, 'MonitoringController');
            return {
                success: true,
                message: deleted
                    ? 'Cache value deleted successfully'
                    : 'Cache key not found',
                deleted,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to delete cache value for key: ${key}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async clearCache() {
        try {
            this.configCachingService.clear();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Cleared all cache', 'MonitoringController');
            return {
                success: true,
                message: 'All cache cleared successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to clear cache', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async invalidateCachePattern(body) {
        try {
            const deletedCount = this.configCachingService.invalidatePattern(body.pattern);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Invalidated cache pattern: ${body.pattern}`, 'MonitoringController');
            return {
                success: true,
                message: 'Cache pattern invalidated successfully',
                deletedCount,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Failed to invalidate cache pattern: ${body.pattern}`, 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getAlertConfig() {
        try {
            const config = this.selfHealingService.getAlertConfig();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved alert config', 'MonitoringController');
            return {
                success: true,
                data: config,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve alert config', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getAlertHistory() {
        try {
            const history = this.selfHealingService.getAlertHistory();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved alert history', 'MonitoringController');
            return {
                success: true,
                data: history,
                timestamp: new Date(),
                count: history.length,
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve alert history', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async clearAlertHistory() {
        try {
            this.selfHealingService.clearAlertHistory();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Cleared alert history', 'MonitoringController');
            return {
                success: true,
                message: 'Alert history cleared successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to clear alert history', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getAlertCount() {
        try {
            const count = this.selfHealingService.getAlertCount();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved alert count', 'MonitoringController');
            return {
                success: true,
                data: { count },
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve alert count', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async resetAlertCount() {
        try {
            this.selfHealingService.resetAlertCount();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Reset alert count', 'MonitoringController');
            return {
                success: true,
                message: 'Alert count reset successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to reset alert count', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getPerformanceMetrics() {
        try {
            const metrics = this.selfHealingService.getPerformanceMetrics();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved performance metrics', 'MonitoringController');
            return {
                success: true,
                data: metrics,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve performance metrics', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getPerformanceBaseline() {
        try {
            const baseline = this.selfHealingService.getPerformanceBaseline();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved performance baseline', 'MonitoringController');
            return {
                success: true,
                data: baseline,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve performance baseline', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async setPerformanceBaseline(body) {
        try {
            this.selfHealingService.setPerformanceBaseline({
                ...body,
                timestamp: new Date(),
            });
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Set performance baseline', 'MonitoringController');
            return {
                success: true,
                message: 'Performance baseline set successfully',
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to set performance baseline', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getSystemMetrics() {
        try {
            const metrics = this.selfHealingService.getSystemMetrics();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved system metrics', 'MonitoringController');
            return {
                success: true,
                data: metrics,
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve system metrics', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getSystemUptime() {
        try {
            const uptime = this.selfHealingService.getUptime();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved system uptime', 'MonitoringController');
            return {
                success: true,
                data: { uptime },
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve system uptime', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
    async getMonitoringOverview() {
        try {
            const [metricsSummary, healthSummary, cacheStats, alertCount, uptime] = await Promise.all([
                this.unifiedMetricsService.getMetricsSummary(),
                this.selfHealingService.getHealthSummary(),
                this.configCachingService.getStats(),
                this.selfHealingService.getAlertCount(),
                this.selfHealingService.getUptime(),
            ]);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Retrieved monitoring overview', 'MonitoringController');
            return {
                success: true,
                data: {
                    metrics: metricsSummary,
                    health: healthSummary,
                    cache: cacheStats,
                    alerts: { count: alertCount },
                    system: { uptime },
                },
                timestamp: new Date(),
            };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to retrieve monitoring overview', 'MonitoringController', error instanceof Error ? error.message : String(error));
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
                timestamp: new Date(),
            };
        }
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getAllMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/:name'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getMetricsByName", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('metrics'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "recordMetric", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('metrics/counter/:name/increment'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "incrementCounter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/export/:format'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('format')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "exportMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('metrics'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "clearMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/summary'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getMetricsSummary", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/system'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getSystemHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/service/:name'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('name')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getServiceHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/services'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getAllServicesHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/summary'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getHealthSummary", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/status'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getServiceStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/uptime'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getUptime", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cache/stats'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getCacheStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cache/keys'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getCacheKeys", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cache/:key'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getCacheValue", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('cache/:key'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "setCacheValue", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('cache/:key'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('key')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "deleteCacheValue", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('cache'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "clearCache", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('cache/invalidate-pattern'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "invalidateCachePattern", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('alerts/config'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getAlertConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('alerts/history'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getAlertHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('alerts/history'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "clearAlertHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('alerts/count'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getAlertCount", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('alerts/count/reset'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "resetAlertCount", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/metrics'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getPerformanceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/baseline'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getPerformanceBaseline", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('performance/baseline'),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "setPerformanceBaseline", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('system/metrics'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getSystemMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('system/uptime'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getSystemUptime", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('overview'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], MonitoringController.prototype, "getMonitoringOverview", null);
MonitoringController = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('monitoring'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__.UnifiedMetricsService !== "undefined" && _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__.UnifiedMetricsService) === "function" ? _a : Object, typeof (_b = typeof _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__.SelfHealingService !== "undefined" && _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__.SelfHealingService) === "function" ? _b : Object, typeof (_c = typeof _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__.ConfigCachingService !== "undefined" && _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__.ConfigCachingService) === "function" ? _c : Object])
], MonitoringController);



/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigCachingService: () => (/* binding */ ConfigCachingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ConfigCachingService = class ConfigCachingService {
    constructor() {
        this.cache = new Map();
        this.hitCount = 0;
        this.missCount = 0;
        this.totalRequests = 0;
        this.accessTimes = [];
        this.config = {
            enabled: process.env.CONFIG_CACHE_ENABLED === 'true',
            ttl: parseInt(process.env.CONFIG_CACHE_TTL ?? '300'),
            maxSize: parseInt(process.env.CONFIG_CACHE_MAX_SIZE ?? '1000'),
            cleanupInterval: parseInt(process.env.CONFIG_CACHE_CLEANUP_INTERVAL ?? '60'),
        };
        if (this.config.enabled) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Config caching service initialized', 'ConfigCachingService', {
                ttl: this.config.ttl,
                maxSize: this.config.maxSize,
                cleanupInterval: this.config.cleanupInterval,
            });
            setInterval(() => this.cleanup(), this.config.cleanupInterval * 1000);
        }
    }
    get(key) {
        if (!this.config.enabled)
            return null;
        const startTime = Date.now();
        this.totalRequests++;
        const item = this.cache.get(key);
        if (item) {
            const ttl = item.customTtl !== undefined ? item.customTtl * 1000 : 1000;
            if (Date.now() - item.timestamp > ttl) {
                this.cache.delete(key);
                this.missCount++;
                this.recordAccessTime(Date.now() - startTime);
                return null;
            }
            item.accessCount++;
            item.lastAccess = Date.now();
            this.hitCount++;
            this.recordAccessTime(Date.now() - startTime);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Cache hit for key: ${key}`, 'ConfigCachingService');
            return item.value;
        }
        this.missCount++;
        this.recordAccessTime(Date.now() - startTime);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Cache miss for key: ${key}`, 'ConfigCachingService');
        return null;
    }
    set(key, value, customTtl) {
        if (!this.config.enabled)
            return;
        if (this.cache.size >= this.config.maxSize) {
            this.evictOldest();
        }
        const item = {
            value,
            timestamp: Date.now(),
            accessCount: 0,
            lastAccess: Date.now(),
            ...(customTtl !== undefined && { customTtl }),
        };
        this.cache.set(key, item);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Value cached for key: ${key}`, 'ConfigCachingService');
    }
    delete(key) {
        if (!this.config.enabled)
            return false;
        const deleted = this.cache.delete(key);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Value deleted from cache for key: ${key}`, 'ConfigCachingService');
        }
        return deleted;
    }
    clear() {
        if (!this.config.enabled)
            return;
        this.cache.clear();
        this.hitCount = 0;
        this.missCount = 0;
        this.totalRequests = 0;
        this.accessTimes = [];
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Cache cleared', 'ConfigCachingService');
    }
    has(key) {
        if (!this.config.enabled)
            return false;
        const item = this.cache.get(key);
        if (!item)
            return false;
        const ttl = item.customTtl !== undefined ? item.customTtl * 1000 : 1000;
        if (Date.now() - item.timestamp > ttl) {
            this.cache.delete(key);
            return false;
        }
        return true;
    }
    getStats() {
        const hitRate = this.totalRequests > 0 ? (this.hitCount / this.totalRequests) * 100 : 0;
        const missRate = this.totalRequests > 0 ? (this.missCount / this.totalRequests) * 100 : 0;
        const averageAccessTime = this.accessTimes.length > 0
            ? this.accessTimes.reduce((sum, time) => sum + time, 0) /
                this.accessTimes.length
            : 0;
        return {
            size: this.cache.size,
            hitCount: this.hitCount,
            missCount: this.missCount,
            hitRate,
            missRate,
            totalRequests: this.totalRequests,
            averageAccessTime,
            maxSize: this.config.maxSize,
            enabled: this.config.enabled,
        };
    }
    invalidatePattern(pattern) {
        if (!this.config.enabled)
            return 0;
        let invalidatedCount = 0;
        const regex = new RegExp(pattern);
        for (const key of this.cache.keys()) {
            if (regex.test(key) === true) {
                this.cache.delete(key);
                invalidatedCount++;
            }
        }
        if (invalidatedCount > 0) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Invalidated ${invalidatedCount} cache entries matching pattern: ${pattern}`, 'ConfigCachingService');
        }
        return invalidatedCount;
    }
    touch(key) {
        if (!this.config.enabled)
            return false;
        const item = this.cache.get(key);
        if (item) {
            item.lastAccess = Date.now();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Cache entry touched for key: ${key}`, 'ConfigCachingService');
            return true;
        }
        return false;
    }
    keys() {
        if (!this.config.enabled)
            return [];
        return Array.from(this.cache.keys());
    }
    size() {
        if (!this.config.enabled)
            return 0;
        return this.cache.size;
    }
    isEnabled() {
        return this.config.enabled;
    }
    getConfig() {
        return { ...this.config };
    }
    cleanup() {
        if (!this.config.enabled)
            return;
        const now = Date.now();
        let cleanedCount = 0;
        for (const [key, item] of this.cache.entries()) {
            const ttl = item.customTtl !== undefined ? item.customTtl * 1000 : 1000;
            const cutoff = now - ttl;
            if (item.timestamp < cutoff) {
                this.cache.delete(key);
                cleanedCount++;
            }
        }
        if (cleanedCount > 0) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Cleaned up ${cleanedCount} expired cache entries`, 'ConfigCachingService');
        }
    }
    evictOldest() {
        if (!this.config.enabled || this.cache.size === 0)
            return;
        let oldestKey = null;
        let oldestTime = Infinity;
        for (const [key, item] of this.cache.entries()) {
            if (item.timestamp < oldestTime) {
                oldestTime = item.timestamp;
                oldestKey = key;
            }
        }
        if (oldestKey != null) {
            this.cache.delete(oldestKey);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Evicted oldest cache entry: ${oldestKey}`, 'ConfigCachingService');
        }
    }
    recordAccessTime(time) {
        this.accessTimes.push(time);
        if (this.accessTimes.length > 1000) {
            this.accessTimes.splice(0, this.accessTimes.length - 1000);
        }
    }
};
ConfigCachingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ConfigCachingService);



/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SelfHealingService: () => (/* binding */ SelfHealingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let SelfHealingService = class SelfHealingService {
    constructor() {
        this.healthChecks = new Map();
        this.healthHistory = new Map();
        this.alertThresholds = {
            cpu: parseInt(process.env.ALERT_CPU_THRESHOLD ?? '80'),
            memory: parseInt(process.env.ALERT_MEMORY_THRESHOLD ?? '85'),
            disk: parseInt(process.env.ALERT_DISK_THRESHOLD ?? '90'),
            responseTime: parseInt(process.env.ALERT_RESPONSE_TIME_THRESHOLD ?? '5000'),
            errorRate: parseInt(process.env.ALERT_ERROR_RATE_THRESHOLD ?? '5'),
        };
        this.alertConfig = {
            enabled: process.env.SELF_HEALING_ENABLED === 'true',
            channels: {
                ...(process.env.TELEGRAM_BOT_TOKEN != null && {
                    telegram: {
                        botToken: process.env.TELEGRAM_BOT_TOKEN,
                        chatId: process.env.TELEGRAM_CHAT_ID ?? '',
                    },
                }),
                ...(process.env.SLACK_WEBHOOK_URL != null && {
                    slack: {
                        webhookUrl: process.env.SLACK_WEBHOOK_URL,
                        channel: process.env.SLACK_CHANNEL ?? '#alerts',
                    },
                }),
                ...(process.env.SMTP_HOST != null && {
                    email: {
                        smtp: process.env.SMTP_HOST,
                        from: process.env.SMTP_FROM ?? 'alerts@example.com',
                        to: (process.env.SMTP_TO ?? '').split(','),
                    },
                }),
            },
            thresholds: this.alertThresholds,
        };
        this.alertHistory = [];
        this.performanceBaseline = null;
        this.startTime = Date.now();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('SelfHealingService initialized', 'SelfHealingService');
        this.setHealthCheck('system', () => this.checkSystemHealth());
        this.setHealthCheck('memory', () => this.checkMemoryHealth());
        this.setHealthCheck('disk', () => this.checkDiskHealth());
    }
    checkSystemHealth() {
        const cpuUsage = Math.random() * 100;
        const memoryUsage = Math.random() * 100;
        const diskUsage = Math.random() * 100;
        let status = 'healthy';
        if (cpuUsage > this.alertThresholds.cpu ||
            memoryUsage > this.alertThresholds.memory ||
            diskUsage > this.alertThresholds.disk) {
            status = 'warning';
        }
        if (cpuUsage > this.alertThresholds.cpu * 1.5 ||
            memoryUsage > this.alertThresholds.memory * 1.5 ||
            diskUsage > this.alertThresholds.disk * 1.5) {
            status = 'critical';
        }
        const health = {
            status,
            timestamp: new Date(),
            metrics: {
                cpu: { usage: cpuUsage, threshold: this.alertThresholds.cpu },
                memory: { usage: memoryUsage, threshold: this.alertThresholds.memory },
                disk: { usage: diskUsage, threshold: this.alertThresholds.disk },
            },
        };
        this.recordHealthHistory('system', health);
        if (status === 'critical') {
            this.sendAlert('system_health', `System health critical: CPU ${cpuUsage}%, Memory ${memoryUsage}%, Disk ${diskUsage}%`, 'critical');
        }
        return health;
    }
    checkServiceHealth(serviceName) {
        const customCheck = this.healthChecks.get(serviceName);
        if (customCheck) {
            const health = customCheck();
            const serviceHealth = {
                _service: serviceName,
                status: health.status,
                timestamp: health.timestamp,
                responseTime: Math.random() * 100 + 50,
                errorRate: Math.random() * 5,
                throughput: Math.random() * 1000 + 500,
                details: health.details ?? {},
            };
            this.recordHealthHistory(serviceName, serviceHealth);
            return serviceHealth;
        }
        const health = {
            _service: serviceName,
            status: 'healthy',
            timestamp: new Date(),
            responseTime: Math.random() * 100 + 50,
            errorRate: Math.random() * 5,
            throughput: Math.random() * 1000 + 500,
            details: { message: 'Basic health check passed' },
        };
        this.recordHealthHistory(serviceName, health);
        return health;
    }
    setHealthCheck(serviceName, checkFunction) {
        this.healthChecks.set(serviceName, checkFunction);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Health check set for service: ${serviceName}`, 'SelfHealingService');
    }
    getHealthChecks() {
        const result = [];
        for (const [service, check] of this.healthChecks.entries()) {
            result.push({ _service: service, check });
        }
        return result;
    }
    getHealthHistory(serviceName) {
        return this.healthHistory.get(serviceName) ?? [];
    }
    getServiceMetrics(serviceName) {
        const history = this.getHealthHistory(serviceName);
        if (history.length === 0)
            return null;
        const lastHealth = history[history.length - 1];
        if (!lastHealth)
            return null;
        const serviceHealth = {
            _service: serviceName,
            status: lastHealth.status,
            timestamp: lastHealth.timestamp,
            responseTime: Math.random() * 100 + 50,
            errorRate: Math.random() * 5,
            throughput: Math.random() * 1000 + 500,
            details: lastHealth.details ?? {},
        };
        return serviceHealth;
    }
    getSystemMetrics() {
        return {
            cpu: this.getCPUUsage(),
            memory: this.getMemoryUsage(),
            disk: this.getDiskUsage(),
            network: Math.random() * 100,
        };
    }
    setAlertThreshold(metric, threshold) {
        if (metric in this.alertThresholds) {
            this.alertThresholds[metric] =
                threshold;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Alert threshold set for ${metric}: ${threshold}`, 'SelfHealingService');
        }
    }
    getAlertThresholds() {
        return { ...this.alertThresholds };
    }
    enableAlerts(channel) {
        if (channel === 'telegram' && !this.alertConfig.channels.telegram) {
            this.alertConfig.channels.telegram = {
                botToken: process.env.TELEGRAM_BOT_TOKEN ?? 'test-token',
                chatId: process.env.TELEGRAM_CHAT_ID ?? 'test-chat-id',
            };
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts enabled for telegram', 'SelfHealingService');
        }
        else if (channel === 'slack' && !this.alertConfig.channels.slack) {
            this.alertConfig.channels.slack = {
                webhookUrl: process.env.SLACK_WEBHOOK_URL ?? 'test-webhook',
                channel: process.env.SLACK_CHANNEL ?? '#alerts',
            };
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts enabled for slack', 'SelfHealingService');
        }
        else if (channel === 'email' && !this.alertConfig.channels.email) {
            this.alertConfig.channels.email = {
                smtp: process.env.SMTP_HOST ?? 'test-smtp',
                from: process.env.SMTP_FROM ?? 'alerts@example.com',
                to: (process.env.SMTP_TO ?? 'test@example.com').split(','),
            };
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts enabled for email', 'SelfHealingService');
        }
    }
    disableAlerts(channel) {
        if (channel === 'telegram') {
            delete this.alertConfig.channels.telegram;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts disabled for telegram', 'SelfHealingService');
        }
        else if (channel === 'slack') {
            delete this.alertConfig.channels.slack;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts disabled for slack', 'SelfHealingService');
        }
        else if (channel === 'email') {
            delete this.alertConfig.channels.email;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alerts disabled for email', 'SelfHealingService');
        }
    }
    getAlertConfig() {
        return { ...this.alertConfig };
    }
    getAlertHistory() {
        return [...this.alertHistory];
    }
    clearAlertHistory() {
        this.alertHistory = [];
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alert history cleared', 'SelfHealingService');
    }
    getServiceStatus() {
        const services = Array.from(this.healthChecks.keys());
        let healthyCount = 0;
        let degradedCount = 0;
        let unhealthyCount = 0;
        for (const service of services) {
            const health = this.checkServiceHealth(service);
            if (health.status === 'healthy') {
                healthyCount++;
            }
            else if (health.status === 'warning') {
                degradedCount++;
            }
            else {
                unhealthyCount++;
            }
        }
        return {
            healthy: healthyCount === services.length,
            total: services.length,
            healthyCount,
            degraded: degradedCount,
            unhealthy: unhealthyCount,
        };
    }
    getUptime() {
        const uptime = Date.now() - this.startTime;
        return Math.max(uptime, 1);
    }
    getLastAlertTime() {
        if (this.alertHistory.length === 0)
            return null;
        const lastAlert = this.alertHistory[this.alertHistory.length - 1];
        return lastAlert?.timestamp ?? null;
    }
    getAlertCount() {
        return this.alertHistory.length;
    }
    resetAlertCount() {
        this.alertHistory = [];
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Alert count reset', 'SelfHealingService');
    }
    getHealthSummary() {
        const services = Array.from(this.healthChecks.keys());
        let healthyCount = 0;
        let warningCount = 0;
        let criticalCount = 0;
        let lastCheck = new Date(0);
        for (const service of services) {
            const health = this.checkServiceHealth(service);
            if (health.status === 'healthy') {
                healthyCount++;
            }
            else if (health.status === 'warning') {
                warningCount++;
            }
            else {
                criticalCount++;
            }
            if (health.timestamp > lastCheck) {
                lastCheck = health.timestamp;
            }
        }
        return {
            totalServices: services.length,
            healthyServices: healthyCount,
            warningServices: warningCount,
            criticalServices: criticalCount,
            degradedServices: warningCount,
            unhealthyServices: criticalCount,
            lastCheck,
        };
    }
    exportHealthData(format) {
        const summary = this.getHealthSummary();
        const allHealth = Array.from(this.healthHistory.entries());
        switch (format) {
            case 'json':
                return JSON.stringify({
                    summary,
                    services: allHealth.map(([service, history]) => ({
                        service,
                        history: history.slice(-10),
                    })),
                }, null, 2);
            case 'csv': {
                let csv = 'Service,Status,Timestamp,Details\n';
                for (const [service, history] of allHealth) {
                    for (const health of history) {
                        csv += `${service},${health.status},${health.timestamp.toISOString()},"${JSON.stringify(health.details)}"\n`;
                    }
                }
                return csv;
            }
            case 'prometheus': {
                let prometheus = '# HELP service_health Service health status\n';
                prometheus += '# TYPE service_health gauge\n';
                for (const [service, history] of allHealth) {
                    const latest = history[history.length - 1];
                    if (latest) {
                        const statusValue = latest.status === 'healthy'
                            ? 1
                            : latest.status === 'warning'
                                ? 0.5
                                : 0;
                        prometheus += `service_health{service="${service}"} ${statusValue}\n`;
                    }
                }
                return prometheus;
            }
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    importHealthData(data) {
        try {
            JSON.parse(data);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Health data imported successfully', 'SelfHealingService');
            return { success: true, message: 'Data imported successfully' };
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to import health data', 'SelfHealingService', error instanceof Error ? error.message : String(error));
            return { success: false, message: 'Import failed' };
        }
    }
    getPerformanceMetrics() {
        const uptime = this.getUptime();
        const alertCount = this.getAlertCount();
        const result = {
            responseTime: uptime > 0 ? Math.random() * 100 + 50 : 0,
            throughput: uptime > 0 ? Math.random() * 1000 + 500 : 0,
            errorRate: uptime > 0 ? (alertCount / (uptime / 1000)) * 100 : 0,
            availability: uptime > 0 ? 99.9 - (alertCount / (uptime / 1000)) * 0.1 : 100,
            uptime,
        };
        if (this.performanceBaseline) {
            result.baseline = this.performanceBaseline;
        }
        return result;
    }
    setPerformanceBaseline(baseline) {
        this.performanceBaseline = { ...baseline };
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Performance baseline set', 'SelfHealingService', {
            baseline,
        });
    }
    getPerformanceBaseline() {
        return this.performanceBaseline ? { ...this.performanceBaseline } : null;
    }
    getCPUUsage() {
        return Math.random() * 100;
    }
    getMemoryUsage() {
        const memUsage = process.memoryUsage();
        return (memUsage.heapUsed / memUsage.heapTotal) * 100;
    }
    getDiskUsage() {
        return Math.random() * 100;
    }
    checkMemoryHealth() {
        const usage = this.getMemoryUsage();
        let status = 'healthy';
        if (usage > this.alertThresholds.memory) {
            status = 'critical';
        }
        else if (usage > this.alertThresholds.memory * 0.8) {
            status = 'warning';
        }
        const health = {
            status,
            timestamp: new Date(),
            details: { memoryUsage: usage },
        };
        this.recordHealthHistory('memory', health);
        return health;
    }
    checkDiskHealth() {
        const usage = this.getDiskUsage();
        let status = 'healthy';
        if (usage > this.alertThresholds.disk) {
            status = 'critical';
        }
        else if (usage > this.alertThresholds.disk * 0.8) {
            status = 'warning';
        }
        const health = {
            status,
            timestamp: new Date(),
            details: { diskUsage: usage },
        };
        this.recordHealthHistory('disk', health);
        return health;
    }
    recordHealthHistory(serviceName, health) {
        if (!this.healthHistory.has(serviceName)) {
            this.healthHistory.set(serviceName, []);
        }
        const history = this.healthHistory.get(serviceName);
        if (history) {
            history.push(health);
            if (history.length > 100) {
                history.splice(0, history.length - 100);
            }
        }
    }
    sendAlert(type, message, severity) {
        if (!this.alertConfig.enabled)
            return;
        const alert = {
            timestamp: new Date(),
            type,
            message,
            severity,
        };
        this.alertHistory.push(alert);
        if (this.alertHistory.length > 1000) {
            this.alertHistory.splice(0, this.alertHistory.length - 1000);
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Alert: ${message}`, 'SelfHealingService', {
            type,
            severity,
        });
    }
};
SelfHealingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SelfHealingService);



/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedMetricsService: () => (/* binding */ UnifiedMetricsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let UnifiedMetricsService = class UnifiedMetricsService {
    constructor() {
        this.metrics = new Map();
        this.counters = new Map();
        this.globalLabels = {};
        this.enabled =
            process.env.METRICS_ENABLED !== 'false' &&
                process.env.METRICS_ENABLED !== undefined;
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('UnifiedMetricsService initialized', 'UnifiedMetricsService');
    }
    recordMetric(name, value, labels) {
        if (!this.enabled)
            return;
        const metric = {
            name,
            value,
            timestamp: new Date(),
            labels: { ...this.globalLabels, ...labels },
        };
        if (!this.metrics.has(name)) {
            this.metrics.set(name, []);
        }
        const metrics = this.metrics.get(name);
        if (metrics) {
            metrics.push(metric);
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Metric recorded: ${name} = ${value}`, 'UnifiedMetricsService', { labels });
    }
    incrementCounter(name, increment = 1, labels) {
        if (!this.enabled)
            return;
        const existingMetrics = this.metrics.get(name);
        const lastValue = existingMetrics && existingMetrics.length > 0
            ? (existingMetrics[existingMetrics.length - 1]?.value ?? 0)
            : 0;
        const newValue = lastValue + increment;
        this.counters.set(name, newValue);
        this.recordMetric(name, newValue, labels);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Counter incremented: ${name} = ${newValue}`, 'UnifiedMetricsService');
    }
    measureExecutionTime(name, fn, labels) {
        if (!this.enabled) {
            return fn();
        }
        const startTime = Date.now();
        try {
            const result = fn();
            if (result instanceof Promise) {
                return result.finally(() => {
                    const executionTime = Date.now() - startTime;
                    this.recordMetric(name, Math.max(executionTime, 1), labels);
                });
            }
            else {
                const executionTime = Date.now() - startTime;
                this.recordMetric(name, Math.max(executionTime, 1), labels);
                return result;
            }
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            this.recordMetric(name, Math.max(executionTime, 1), labels);
            throw error;
        }
    }
    getMetrics(name) {
        if (!this.enabled)
            return [];
        const metrics = this.metrics.get(name);
        if (!metrics)
            return [];
        const lastMetric = metrics[metrics.length - 1];
        return lastMetric ? [lastMetric] : [];
    }
    getAllMetrics() {
        if (!this.enabled)
            return [];
        const allMetrics = [];
        for (const metrics of this.metrics.values()) {
            allMetrics.push(...metrics);
        }
        return allMetrics;
    }
    clearMetrics() {
        if (!this.enabled)
            return;
        this.metrics.clear();
        this.counters.clear();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('All metrics cleared', 'UnifiedMetricsService');
    }
    exportMetrics(format) {
        if (!this.enabled)
            return {};
        switch (format) {
            case 'prometheus':
                return this.exportPrometheusFormat();
            case 'opentelemetry':
                return this.exportOpenTelemetryFormat();
            case 'custom':
                return this.exportCustomFormat();
            default:
                return {};
        }
    }
    exportPrometheusFormat() {
        let output = '# HELP metrics Prometheus metrics\n';
        output += '# TYPE metrics counter\n';
        for (const [name, metrics] of this.metrics.entries()) {
            const latestMetric = metrics[metrics.length - 1];
            if (latestMetric) {
                const labels = latestMetric.labels
                    ? `{${Object.entries(latestMetric.labels)
                        .map(([k, v]) => `${k}="${v}"`)
                        .join(',')}}`
                    : '';
                output += `${name}${labels} ${latestMetric.value}\n`;
            }
        }
        return output;
    }
    exportOpenTelemetryFormat() {
        const otelMetrics = [];
        for (const [name, metrics] of this.metrics.entries()) {
            const latestMetric = metrics[metrics.length - 1];
            if (latestMetric) {
                otelMetrics.push({
                    name,
                    value: latestMetric.value,
                    timestamp: latestMetric.timestamp.toISOString(),
                    labels: latestMetric.labels ?? {},
                });
            }
        }
        return JSON.stringify({
            resourceMetrics: [
                {
                    resource: { attributes: { service: 'monitoring' } },
                    scopeMetrics: [
                        {
                            scope: { name: 'unified-metrics' },
                            metrics: otelMetrics,
                        },
                    ],
                },
            ],
        });
    }
    exportCustomFormat() {
        const customMetrics = {};
        for (const [name, metrics] of this.metrics.entries()) {
            const latestMetric = metrics[metrics.length - 1];
            if (latestMetric) {
                customMetrics[name] = {
                    value: latestMetric.value,
                    timestamp: latestMetric.timestamp.toISOString(),
                    labels: latestMetric.labels ?? {},
                };
            }
        }
        return JSON.stringify(customMetrics);
    }
    getMetricsSummary() {
        const allMetrics = this.getAllMetrics();
        if (allMetrics.length === 0) {
            return {
                totalMetrics: 0,
                metricNames: [],
                totalValue: 0,
                averageValue: 0,
                minValue: 0,
                maxValue: 0,
                lastUpdateTime: new Date(),
            };
        }
        const values = allMetrics.map(m => m.value);
        const totalValue = values.reduce((sum, val) => sum + val, 0);
        const averageValue = totalValue / allMetrics.length;
        const minValue = Math.min(...values);
        const maxValue = Math.max(...values);
        const metricNames = Array.from(this.metrics.keys());
        const lastUpdateTime = allMetrics.length > 0
            ? (allMetrics[allMetrics.length - 1]?.timestamp ?? new Date())
            : new Date();
        return {
            totalMetrics: allMetrics.length,
            metricNames,
            totalValue,
            averageValue,
            minValue,
            maxValue,
            lastUpdateTime,
        };
    }
    setMetricLabels(labels) {
        this.globalLabels = { ...labels };
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Global metric labels set', 'UnifiedMetricsService', {
            labels,
        });
    }
    getMetricHistory(name) {
        return this.metrics.get(name) ?? [];
    }
    deleteMetric(name) {
        const deleted = this.metrics.delete(name);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Metric deleted: ${name}`, 'UnifiedMetricsService');
        }
        return deleted;
    }
    getMetricsByLabel(labelKey, labelValue) {
        const matchingMetrics = [];
        for (const metrics of this.metrics.values()) {
            for (const metric of metrics) {
                if (metric.labels && metric.labels[labelKey] === labelValue) {
                    matchingMetrics.push(metric);
                }
            }
        }
        return matchingMetrics;
    }
};
UnifiedMetricsService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], UnifiedMetricsService);



/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedMetricsDashboardService: () => (/* binding */ UnifiedMetricsDashboardService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(157);
/* harmony import */ var _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(158);
/* harmony import */ var _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(159);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UnifiedMetricsDashboardService_1;
var _a, _b, _c, _d;





let UnifiedMetricsDashboardService = UnifiedMetricsDashboardService_1 = class UnifiedMetricsDashboardService {
    constructor(_configService, unifiedMetricsService, selfHealingService, configCachingService) {
        this._configService = _configService;
        this.unifiedMetricsService = unifiedMetricsService;
        this.selfHealingService = selfHealingService;
        this.configCachingService = configCachingService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UnifiedMetricsDashboardService_1.name);
        this.dashboards = new Map();
        this.metrics = new Map();
        this.initializeDefaultDashboards();
        this.startMetricsCollection();
        this.startHealthMonitoring();
        this._configService.get('DASHBOARD_ENABLED');
        this.selfHealingService.getHealthChecks();
        this.configCachingService.get('dashboard.config');
    }
    initializeDefaultDashboards() {
        const defaultDashboards = [
            {
                id: 'system-overview',
                name: 'System Overview',
                description: 'Overall system health and performance metrics',
                panels: [
                    {
                        id: 'cpu-usage',
                        title: 'CPU Usage',
                        type: 'gauge',
                        metrics: ['system.cpu.usage'],
                        query: 'avg(system_cpu_usage)',
                        refreshInterval: 5000,
                        position: { x: 0, y: 0, width: 6, height: 4 },
                    },
                    {
                        id: 'memory-usage',
                        title: 'Memory Usage',
                        type: 'gauge',
                        metrics: ['system.memory.usage'],
                        query: 'avg(system_memory_usage)',
                        refreshInterval: 5000,
                        position: { x: 6, y: 0, width: 6, height: 4 },
                    },
                    {
                        id: 'request-rate',
                        title: 'Request Rate',
                        type: 'graph',
                        metrics: ['http.requests.rate'],
                        query: 'rate(http_requests_total[5m])',
                        refreshInterval: 10000,
                        position: { x: 0, y: 4, width: 12, height: 4 },
                    },
                ],
                refreshInterval: 10000,
                timeRange: { from: 'now-1h', to: 'now' },
                tags: ['system', 'overview'],
                isPublic: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'api-performance',
                name: 'API Performance',
                description: 'API endpoints performance and response times',
                panels: [
                    {
                        id: 'response-times',
                        title: 'Response Times',
                        type: 'graph',
                        metrics: ['http.response.time'],
                        query: 'histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))',
                        refreshInterval: 10000,
                        position: { x: 0, y: 0, width: 12, height: 4 },
                    },
                    {
                        id: 'error-rate',
                        title: 'Error Rate',
                        type: 'stat',
                        metrics: ['http.errors.rate'],
                        query: 'rate(http_requests_total{status=~"5.."}[5m])',
                        refreshInterval: 10000,
                        position: { x: 0, y: 4, width: 6, height: 4 },
                    },
                    {
                        id: 'throughput',
                        title: 'Throughput',
                        type: 'stat',
                        metrics: ['http.requests.rate'],
                        query: 'rate(http_requests_total[5m])',
                        refreshInterval: 10000,
                        position: { x: 6, y: 4, width: 6, height: 4 },
                    },
                ],
                refreshInterval: 10000,
                timeRange: { from: 'now-1h', to: 'now' },
                tags: ['api', 'performance'],
                isPublic: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'security-events',
                name: 'Security Events',
                description: 'Security monitoring and threat detection',
                panels: [
                    {
                        id: 'failed-logins',
                        title: 'Failed Logins',
                        type: 'graph',
                        metrics: ['auth.failed.logins'],
                        query: 'rate(auth_failed_logins_total[5m])',
                        refreshInterval: 30000,
                        position: { x: 0, y: 0, width: 6, height: 4 },
                    },
                    {
                        id: 'rate-limit-violations',
                        title: 'Rate Limit Violations',
                        type: 'graph',
                        metrics: ['security.rate.limit.violations'],
                        query: 'rate(rate_limit_violations_total[5m])',
                        refreshInterval: 30000,
                        position: { x: 6, y: 0, width: 6, height: 4 },
                    },
                    {
                        id: 'security-alerts',
                        title: 'Security Alerts',
                        type: 'table',
                        metrics: ['security.alerts'],
                        query: 'security_alerts',
                        refreshInterval: 60000,
                        position: { x: 0, y: 4, width: 12, height: 4 },
                    },
                ],
                refreshInterval: 30000,
                timeRange: { from: 'now-6h', to: 'now' },
                tags: ['security', 'monitoring'],
                isPublic: false,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'incident-response',
                name: 'Incident Response',
                description: 'Incident monitoring and response metrics',
                panels: [
                    {
                        id: 'incident-status',
                        title: 'Active Incidents',
                        type: 'stat',
                        metrics: ['incidents.active'],
                        query: 'incidents_active',
                        refreshInterval: 10000,
                        position: { x: 0, y: 0, width: 4, height: 4 },
                    },
                    {
                        id: 'mttr',
                        title: 'Mean Time To Resolution',
                        type: 'stat',
                        metrics: ['incidents.mttr'],
                        query: 'avg(incident_resolution_time)',
                        refreshInterval: 300000,
                        position: { x: 4, y: 0, width: 4, height: 4 },
                    },
                    {
                        id: 'incident-timeline',
                        title: 'Incident Timeline',
                        type: 'graph',
                        metrics: ['incidents.timeline'],
                        query: 'incidents_timeline',
                        refreshInterval: 60000,
                        position: { x: 8, y: 0, width: 4, height: 4 },
                    },
                ],
                refreshInterval: 30000,
                timeRange: { from: 'now-24h', to: 'now' },
                tags: ['incidents', 'response'],
                isPublic: false,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultDashboards.forEach(dashboard => {
            this.dashboards.set(dashboard.id, dashboard);
        });
        this.logger.log(`Initialized ${defaultDashboards.length} default dashboards`);
    }
    startMetricsCollection() {
        setInterval(() => {
            void this.collectMetrics();
        }, 10000);
    }
    startHealthMonitoring() {
        setInterval(() => {
            void this.updateSystemHealth();
        }, 30000);
    }
    async collectMetrics() {
        try {
            const systemMetrics = this.unifiedMetricsService.getMetrics('system');
            const performanceMetrics = this.unifiedMetricsService.getMetrics('performance');
            const securityMetrics = this.unifiedMetricsService.getMetrics('security');
            const allMetrics = [
                ...systemMetrics,
                ...performanceMetrics,
                ...securityMetrics,
            ];
            for (const metric of allMetrics) {
                const metricData = metric;
                const key = `${metricData._service}.${metricData.name}`;
                const existingMetrics = this.metrics.get(key) ?? [];
                existingMetrics.push(metricData);
                if (existingMetrics.length > 1000) {
                    existingMetrics.splice(0, existingMetrics.length - 1000);
                }
                this.metrics.set(key, existingMetrics);
            }
            this.logger.debug(`Collected ${allMetrics.length} metrics`);
        }
        catch (error) {
            this.logger.error('Error collecting metrics:', error);
        }
    }
    async updateSystemHealth() {
        try {
            const services = {};
            const serviceNames = [
                'auth-service',
                'cards-service',
                'monitoring-service',
                'security-service',
            ];
            for (const serviceName of serviceNames) {
                const metrics = this.metrics.get(`${serviceName}.health`) ?? [];
                const latestMetric = metrics[metrics.length - 1];
                let status = 'healthy';
                const serviceMetrics = {};
                if (latestMetric) {
                    serviceMetrics.health = latestMetric.value;
                    if (latestMetric.value < 0.8) {
                        status = 'unhealthy';
                    }
                    else if (latestMetric.value < 0.95) {
                        status = 'degraded';
                    }
                }
                else {
                    status = 'unhealthy';
                }
                services[serviceName] = {
                    status,
                    metrics: serviceMetrics,
                    lastCheck: new Date(),
                };
            }
            const statuses = Object.values(services).map((s) => s.status);
            let overall = 'healthy';
            if (statuses.includes('unhealthy')) {
                overall = 'unhealthy';
            }
            else if (statuses.includes('degraded')) {
                overall = 'degraded';
            }
            this.healthStatus = {
                overall,
                services: services,
                timestamp: new Date(),
            };
            this.logger.debug(`System health updated: ${overall}`);
        }
        catch (error) {
            this.logger.error('Error updating system health:', error);
        }
    }
    async getDashboard(id) {
        return this.dashboards.get(id) ?? null;
    }
    async getAllDashboards() {
        return Array.from(this.dashboards.values());
    }
    async createDashboard(dashboard) {
        const id = `dashboard-${Date.now()}`;
        const newDashboard = {
            ...dashboard,
            id,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.dashboards.set(id, newDashboard);
        this.logger.log(`Created dashboard: ${id}`);
        return newDashboard;
    }
    async updateDashboard(id, updates) {
        const dashboard = this.dashboards.get(id);
        if (!dashboard) {
            return null;
        }
        const updatedDashboard = {
            ...dashboard,
            ...updates,
            id,
            updatedAt: new Date(),
        };
        this.dashboards.set(id, updatedDashboard);
        this.logger.log(`Updated dashboard: ${id}`);
        return updatedDashboard;
    }
    async deleteDashboard(id) {
        const deleted = this.dashboards.delete(id);
        if (deleted) {
            this.logger.log(`Deleted dashboard: ${id}`);
        }
        return deleted;
    }
    async getMetrics(service, metricName, timeRange) {
        let allMetrics = [];
        if (service != null && metricName != null) {
            const key = `${service}.${metricName}`;
            allMetrics = this.metrics.get(key) ?? [];
        }
        else if (service != null) {
            for (const [key, metrics] of this.metrics) {
                if (key.startsWith(`${service}.`)) {
                    allMetrics.push(...metrics);
                }
            }
        }
        else {
            for (const metrics of this.metrics.values()) {
                allMetrics.push(...metrics);
            }
        }
        if (timeRange != null) {
            allMetrics = allMetrics.filter(metric => metric.timestamp >= timeRange.from && metric.timestamp <= timeRange.to);
        }
        return allMetrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getSystemHealth() {
        return this.healthStatus;
    }
    async executeQuery(query, timeRange) {
        const metrics = await this.getMetrics(undefined, undefined, timeRange);
        if (query.includes('avg(')) {
            const metricName = query.match(/avg\(([^)]+)\)/)?.[1];
            if (metricName != null) {
                const relevantMetrics = metrics.filter(m => m.name === metricName);
                const sum = relevantMetrics.reduce((acc, m) => acc + m.value, 0);
                return relevantMetrics.length > 0 ? sum / relevantMetrics.length : 0;
            }
        }
        if (query.includes('sum(')) {
            const metricName = query.match(/sum\(([^)]+)\)/)?.[1];
            if (metricName != null) {
                const relevantMetrics = metrics.filter(m => m.name === metricName);
                return relevantMetrics.reduce((acc, m) => acc + m.value, 0);
            }
        }
        if (query.includes('max(')) {
            const metricName = query.match(/max\(([^)]+)\)/)?.[1];
            if (metricName != null) {
                const relevantMetrics = metrics.filter(m => m.name === metricName);
                return relevantMetrics.length > 0
                    ? Math.max(...relevantMetrics.map(m => m.value))
                    : 0;
            }
        }
        if (query.includes('min(')) {
            const metricName = query.match(/min\(([^)]+)\)/)?.[1];
            if (metricName != null) {
                const relevantMetrics = metrics.filter(m => m.name === metricName);
                return relevantMetrics.length > 0
                    ? Math.min(...relevantMetrics.map(m => m.value))
                    : 0;
            }
        }
        return 0;
    }
    async getDashboardData(dashboardId) {
        const dashboard = await this.getDashboard(dashboardId);
        if (!dashboard) {
            throw new Error(`Dashboard ${dashboardId} not found`);
        }
        const data = {};
        for (const panel of dashboard.panels) {
            try {
                const result = await this.executeQuery(panel.query, {
                    from: new Date(Date.now() - 3600000),
                    to: new Date(),
                });
                data[panel.id] = {
                    title: panel.title,
                    type: panel.type,
                    data: result,
                    timestamp: new Date(),
                };
            }
            catch (error) {
                this.logger.error(`Error executing query for panel ${panel.id}:`, error);
                data[panel.id] = {
                    title: panel.title,
                    type: panel.type,
                    data: null,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    timestamp: new Date(),
                };
            }
        }
        return data;
    }
};
UnifiedMetricsDashboardService = UnifiedMetricsDashboardService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__.UnifiedMetricsService !== "undefined" && _services_unified_metrics_service__WEBPACK_IMPORTED_MODULE_4__.UnifiedMetricsService) === "function" ? _b : Object, typeof (_c = typeof _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__.SelfHealingService !== "undefined" && _services_self_healing_service__WEBPACK_IMPORTED_MODULE_3__.SelfHealingService) === "function" ? _c : Object, typeof (_d = typeof _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__.ConfigCachingService !== "undefined" && _services_config_caching_service__WEBPACK_IMPORTED_MODULE_2__.ConfigCachingService) === "function" ? _d : Object])
], UnifiedMetricsDashboardService);



/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SystemHealthCheckService: () => (/* binding */ SystemHealthCheckService)
/* harmony export */ });
/* harmony import */ var _nestjs_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155);
/* harmony import */ var _nestjs_axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(139);
/* harmony import */ var _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(162);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_4__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SystemHealthCheckService_1;
var _a, _b, _c, _d;





let SystemHealthCheckService = SystemHealthCheckService_1 = class SystemHealthCheckService {
    constructor(_configService, healthCheckService, httpService) {
        this._configService = _configService;
        this.healthCheckService = healthCheckService;
        this.httpService = httpService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Logger(SystemHealthCheckService_1.name);
        this.services = [];
        this.startTime = Date.now();
        this._configService.get('HEALTH_CHECK_ENABLED');
        this.initializeServices();
        this.startPeriodicHealthChecks();
    }
    initializeServices() {
        this.services = [
            {
                name: 'database',
                status: 'healthy',
                responseTime: 0,
                lastCheck: new Date(),
                details: {},
            },
            {
                name: 'redis',
                status: 'healthy',
                responseTime: 0,
                lastCheck: new Date(),
                details: {},
            },
            {
                name: 'supabase',
                status: 'healthy',
                responseTime: 0,
                lastCheck: new Date(),
                details: {},
            },
            {
                name: 'external-apis',
                status: 'healthy',
                responseTime: 0,
                lastCheck: new Date(),
                details: {},
            },
        ];
    }
    startPeriodicHealthChecks() {
        setInterval(() => {
            void this.performHealthChecks();
        }, 30000);
        setTimeout(() => {
            void this.performHealthChecks();
        }, 5000);
    }
    async performHealthChecks() {
        this.logger.debug('Performing health checks...');
        for (const service of this.services) {
            try {
                await this.checkServiceHealth(service);
            }
            catch (error) {
                this.logger.error(`Health check failed for ${service.name}:`, error);
                service.status = 'unhealthy';
                service.error =
                    error instanceof Error ? error.message : 'Unknown error';
                service.lastCheck = new Date();
            }
        }
    }
    async checkServiceHealth(service) {
        const startTime = Date.now();
        switch (service.name) {
            case 'database':
                await this.checkDatabaseHealth(service);
                break;
            case 'redis':
                await this.checkRedisHealth(service);
                break;
            case 'supabase':
                await this.checkSupabaseHealth(service);
                break;
            case 'external-apis':
                await this.checkExternalApisHealth(service);
                break;
            default:
                service.status = 'healthy';
                service.error = 'Unknown service';
        }
        service.responseTime = Date.now() - startTime;
        service.lastCheck = new Date();
    }
    async checkDatabaseHealth(service) {
        try {
            const dbUrl = this._configService.get('DATABASE_URL');
            if (dbUrl == null) {
                service.status = 'unhealthy';
                service.error = 'Database URL not configured';
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
            service.status = 'healthy';
            service.details = {
                url: dbUrl.replace(/\/\/.*@/, '//***:***@'),
                poolSize: 10,
                activeConnections: 3,
            };
        }
        catch (error) {
            service.status = 'unhealthy';
            service.error =
                error instanceof Error ? error.message : 'Database check failed';
        }
    }
    async checkRedisHealth(service) {
        try {
            const redisUrl = this._configService.get('REDIS_URL');
            if (redisUrl == null) {
                service.status = 'unhealthy';
                service.error = 'Redis URL not configured';
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 50));
            service.status = 'healthy';
            service.details = {
                url: redisUrl.replace(/\/\/.*@/, '//***:***@'),
                memoryUsage: '45MB',
                connectedClients: 2,
            };
        }
        catch (error) {
            service.status = 'unhealthy';
            service.error =
                error instanceof Error ? error.message : 'Redis check failed';
        }
    }
    async checkSupabaseHealth(service) {
        try {
            const supabaseUrl = this._configService.get('SUPABASE_URL');
            if (supabaseUrl == null) {
                service.status = 'unhealthy';
                service.error = 'Supabase URL not configured';
                return;
            }
            const response = await (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.firstValueFrom)(this.httpService.get(`${supabaseUrl}/rest/v1/`, {
                timeout: 5000,
                headers: {
                    apikey: this._configService.get('SUPABASE_ANON_KEY', ''),
                    Authorization: `Bearer ${this._configService.get('SUPABASE_ANON_KEY', '')}`,
                },
            }));
            if (response.status === 200) {
                service.status = 'healthy';
                service.details = {
                    url: supabaseUrl,
                    version: response.headers['x-supabase-version'] ?? 'unknown',
                    responseTime: response.headers['x-response-time'] ?? 'unknown',
                };
            }
            else {
                service.status = 'degraded';
                service.error = `Unexpected status: ${response.status}`;
            }
        }
        catch (error) {
            service.status = 'unhealthy';
            service.error =
                error instanceof Error ? error.message : 'Supabase check failed';
        }
    }
    async checkExternalApisHealth(service) {
        try {
            const externalApis = [
                { name: 'Sentry', url: this._configService.get('SENTRY_DSN') },
                {
                    name: 'BetterStack',
                    url: this._configService.get('BETTERSTACK_TOKEN'),
                },
            ];
            const results = {};
            let healthyCount = 0;
            for (const api of externalApis) {
                if (api.url != null) {
                    try {
                        await new Promise(resolve => setTimeout(resolve, 200));
                        results[api.name] = { status: 'healthy', responseTime: 200 };
                        healthyCount++;
                    }
                    catch (error) {
                        results[api.name] = {
                            status: 'unhealthy',
                            error: error instanceof Error ? error.message : 'Check failed',
                        };
                    }
                }
                else {
                    results[api.name] = { status: 'not_configured' };
                }
            }
            if (healthyCount === externalApis.length) {
                service.status = 'healthy';
            }
            else if (healthyCount > 0) {
                service.status = 'degraded';
            }
            else {
                service.status = 'unhealthy';
            }
            service.details = results;
        }
        catch (error) {
            service.status = 'unhealthy';
            service.error =
                error instanceof Error ? error.message : 'External APIs check failed';
        }
    }
    async getSystemHealth() {
        const healthyServices = this.services.filter(s => s.status === 'healthy').length;
        const totalServices = this.services.length;
        let overall;
        if (healthyServices === totalServices) {
            overall = 'healthy';
        }
        else if (healthyServices > totalServices / 2) {
            overall = 'degraded';
        }
        else {
            overall = 'unhealthy';
        }
        return {
            overall,
            services: [...this.services],
            timestamp: new Date(),
            uptime: Date.now() - this.startTime,
            version: this._configService.get('APP_VERSION', '1.0.0'),
        };
    }
    async getServiceHealth(serviceName) {
        return this.services.find(s => s.name === serviceName) ?? null;
    }
    async getAllServicesHealth() {
        return [...this.services];
    }
    async performImmediateHealthCheck() {
        await this.performHealthChecks();
        return this.getSystemHealth();
    }
    async check() {
        const systemHealth = await this.getSystemHealth();
        const healthChecks = {};
        for (const service of systemHealth.services) {
            healthChecks[service.name] = async () => {
                if (service.status === 'healthy') {
                    return { [service.name]: { status: 'up', ...service.details } };
                }
                else {
                    throw new Error(`${service.name} is ${service.status}: ${service.error ?? 'Unknown error'}`);
                }
            };
        }
        return this.healthCheckService.check(Object.values(healthChecks));
    }
    async getHealthMetrics() {
        const systemHealth = await this.getSystemHealth();
        return {
            overall_status: systemHealth.overall,
            healthy_services: systemHealth.services.filter(s => s.status === 'healthy').length,
            total_services: systemHealth.services.length,
            uptime_seconds: Math.floor(systemHealth.uptime / 1000),
            last_check: systemHealth.timestamp,
            services: systemHealth.services.reduce((acc, service) => {
                acc[service.name] = {
                    status: service.status,
                    response_time_ms: service.responseTime,
                    last_check: service.lastCheck,
                };
                return acc;
            }, {}),
        };
    }
};
__decorate([
    (0,_nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__.HealthCheck)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], SystemHealthCheckService.prototype, "check", null);
SystemHealthCheckService = SystemHealthCheckService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_1__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_2__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__.HealthCheckService !== "undefined" && _nestjs_terminus__WEBPACK_IMPORTED_MODULE_3__.HealthCheckService) === "function" ? _b : Object, typeof (_c = typeof _nestjs_axios__WEBPACK_IMPORTED_MODULE_0__.HttpService !== "undefined" && _nestjs_axios__WEBPACK_IMPORTED_MODULE_0__.HttpService) === "function" ? _c : Object])
], SystemHealthCheckService);



/***/ }),
/* 162 */
/***/ ((module) => {

module.exports = require("rxjs");

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedAlertingService: () => (/* binding */ UnifiedAlertingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UnifiedAlertingService_1;
var _a, _b;



let UnifiedAlertingService = UnifiedAlertingService_1 = class UnifiedAlertingService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UnifiedAlertingService_1.name);
        this.alertRules = new Map();
        this.activeAlerts = new Map();
        this.notificationChannels = new Map();
        this.notifications = new Map();
        this.lastTriggered = new Map();
        this.initializeDefaultRules();
        this.initializeDefaultChannels();
        this.startAlertEvaluation();
        this._configService.get('ALERTING_ENABLED');
    }
    initializeDefaultRules() {
        const defaultRules = [
            {
                id: 'high-cpu-usage',
                name: 'High CPU Usage',
                description: 'Alert when CPU usage exceeds 80%',
                condition: 'system.cpu.usage',
                threshold: 80,
                operator: 'gt',
                severity: 'high',
                enabled: true,
                cooldown: 300,
                channels: ['email-alerts', 'slack-devops'],
                tags: ['system', 'performance'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-memory-usage',
                name: 'High Memory Usage',
                description: 'Alert when memory usage exceeds 85%',
                condition: 'system.memory.usage',
                threshold: 85,
                operator: 'gt',
                severity: 'high',
                enabled: true,
                cooldown: 300,
                channels: ['email-alerts', 'slack-devops'],
                tags: ['system', 'performance'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-error-rate',
                name: 'High Error Rate',
                description: 'Alert when error rate exceeds 5%',
                condition: 'http.errors.rate',
                threshold: 5,
                operator: 'gt',
                severity: 'critical',
                enabled: true,
                cooldown: 60,
                channels: ['email-alerts', 'slack-devops', 'telegram-admin'],
                tags: ['api', 'errors'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'low-disk-space',
                name: 'Low Disk Space',
                description: 'Alert when disk space is below 10%',
                condition: 'system.disk.usage',
                threshold: 90,
                operator: 'gt',
                severity: 'medium',
                enabled: true,
                cooldown: 600,
                channels: ['email-alerts'],
                tags: ['system', 'storage'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'service-down',
                name: 'Service Down',
                description: 'Alert when a service is not responding',
                condition: 'service.health',
                threshold: 0,
                operator: 'eq',
                severity: 'critical',
                enabled: true,
                cooldown: 30,
                channels: [
                    'email-alerts',
                    'slack-devops',
                    'telegram-admin',
                    'sms-alerts',
                ],
                tags: ['service', 'availability'],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultRules.forEach(rule => {
            this.alertRules.set(rule.id, rule);
        });
        this.logger.log(`Initialized ${defaultRules.length} default alert rules`);
    }
    initializeDefaultChannels() {
        const defaultChannels = [
            {
                id: 'email-alerts',
                name: 'Email Alerts',
                type: 'email',
                config: {
                    smtp: {
                        host: this._configService.get('SMTP_HOST', 'localhost'),
                        port: this._configService.get('SMTP_PORT', 587),
                        secure: false,
                        auth: {
                            user: this._configService.get('SMTP_USER', ''),
                            pass: this._configService.get('SMTP_PASS', ''),
                        },
                    },
                    from: this._configService.get('ALERT_EMAIL_FROM', 'alerts@example.com'),
                    to: this._configService
                        .get('ALERT_EMAIL_TO', 'admin@example.com')
                        .split(','),
                },
                enabled: true,
                rateLimit: { maxPerHour: 20, maxPerDay: 100 },
                filters: {
                    severities: ['medium', 'high', 'critical'],
                    tags: [],
                },
            },
            {
                id: 'slack-devops',
                name: 'Slack DevOps',
                type: 'slack',
                config: {
                    webhookUrl: this._configService.get('SLACK_WEBHOOK_URL', ''),
                    channel: '#devops-alerts',
                    username: 'AlertBot',
                    iconEmoji: ':warning:',
                },
                enabled: true,
                rateLimit: { maxPerHour: 50, maxPerDay: 200 },
                filters: {
                    severities: ['high', 'critical'],
                    tags: ['system', 'api', 'service'],
                },
            },
            {
                id: 'telegram-admin',
                name: 'Telegram Admin',
                type: 'telegram',
                config: {
                    botToken: this._configService.get('TELEGRAM_BOT_TOKEN', ''),
                    chatId: this._configService.get('TELEGRAM_CHAT_ID', ''),
                    parseMode: 'HTML',
                },
                enabled: true,
                rateLimit: { maxPerHour: 30, maxPerDay: 150 },
                filters: {
                    severities: ['critical'],
                    tags: [],
                },
            },
            {
                id: 'sms-alerts',
                name: 'SMS Alerts',
                type: 'sms',
                config: {
                    provider: 'twilio',
                    accountSid: this._configService.get('TWILIO_ACCOUNT_SID', ''),
                    authToken: this._configService.get('TWILIO_AUTH_TOKEN', ''),
                    from: this._configService.get('TWILIO_FROM_NUMBER', ''),
                    to: this._configService.get('TWILIO_TO_NUMBER', ''),
                },
                enabled: false,
                rateLimit: { maxPerHour: 5, maxPerDay: 20 },
                filters: {
                    severities: ['critical'],
                    tags: ['service', 'availability'],
                },
            },
        ];
        defaultChannels.forEach(channel => {
            this.notificationChannels.set(channel.id, channel);
        });
        this.logger.log(`Initialized ${defaultChannels.length} default notification channels`);
    }
    startAlertEvaluation() {
        setInterval(() => {
            void this.evaluateAlerts();
        }, 30000);
    }
    async evaluateAlerts() {
        for (const [ruleId, rule] of this.alertRules) {
            if (!rule.enabled) {
                continue;
            }
            try {
                await this.evaluateRule(rule);
            }
            catch (error) {
                this.logger.error(`Error evaluating rule ${ruleId}:`, error);
            }
        }
    }
    async evaluateRule(rule) {
        const currentValue = this.getMockMetricValue(rule.condition);
        const shouldTrigger = this.evaluateCondition(currentValue, rule.operator, rule.threshold);
        const isInCooldown = this.isInCooldown(rule.id, rule.cooldown);
        if (shouldTrigger && !isInCooldown) {
            await this.triggerAlert(rule, currentValue);
        }
        else if (!shouldTrigger) {
            await this.resolveAlert(rule.id);
        }
    }
    getMockMetricValue(condition) {
        const mockValues = {
            'system.cpu.usage': Math.random() * 100,
            'system.memory.usage': Math.random() * 100,
            'http.errors.rate': Math.random() * 10,
            'system.disk.usage': Math.random() * 100,
            'service.health': Math.random() > 0.1 ? 1 : 0,
        };
        return mockValues[condition] ?? 0;
    }
    evaluateCondition(value, operator, threshold) {
        switch (operator) {
            case 'gt':
                return value > threshold;
            case 'lt':
                return value < threshold;
            case 'eq':
                return value === threshold;
            case 'gte':
                return value >= threshold;
            case 'lte':
                return value <= threshold;
            default:
                return false;
        }
    }
    isInCooldown(ruleId, cooldown) {
        const lastTriggered = this.lastTriggered.get(ruleId);
        if (lastTriggered == null) {
            return false;
        }
        const now = new Date();
        const timeDiff = (now.getTime() - lastTriggered.getTime()) / 1000;
        return timeDiff < cooldown;
    }
    async triggerAlert(rule, value) {
        const alertId = `${rule.id}-${Date.now()}`;
        const alert = {
            id: alertId,
            ruleId: rule.id,
            title: rule.name,
            message: `${rule.description}. Current value: ${value.toFixed(2)}`,
            severity: rule.severity,
            status: 'firing',
            value,
            threshold: rule.threshold,
            labels: {
                rule: rule.id,
                severity: rule.severity,
            },
            annotations: {
                description: rule.description,
                summary: rule.name,
            },
            startsAt: new Date(),
        };
        this.activeAlerts.set(alertId, alert);
        this.lastTriggered.set(rule.id, new Date());
        await this.sendNotifications(alert, rule.channels);
        this.eventEmitter.emit('alert.fired', alert);
        this.logger.warn(`Alert fired: ${rule.name} (${rule.severity})`);
    }
    async resolveAlert(ruleId) {
        const activeAlert = Array.from(this.activeAlerts.values()).find(alert => alert.ruleId === ruleId && alert.status === 'firing');
        if (activeAlert) {
            activeAlert.status = 'resolved';
            activeAlert.endsAt = new Date();
            activeAlert.resolvedAt = new Date();
            activeAlert.resolvedBy = 'system';
            this.eventEmitter.emit('alert.resolved', activeAlert);
            this.logger.log(`Alert resolved: ${activeAlert.title}`);
        }
    }
    async sendNotifications(alert, channelIds) {
        for (const channelId of channelIds) {
            const channel = this.notificationChannels.get(channelId);
            if (channel?.enabled !== true) {
                continue;
            }
            if (!this.shouldSendNotification(alert, channel)) {
                continue;
            }
            if (!this.checkRateLimit(channelId, channel.rateLimit)) {
                this.logger.warn(`Rate limit exceeded for channel ${channelId}`);
                continue;
            }
            try {
                await this.sendNotification(alert, channel);
            }
            catch (error) {
                this.logger.error(`Failed to send notification to ${channelId}:`, error);
            }
        }
    }
    shouldSendNotification(alert, channel) {
        if (!channel.filters.severities.includes(alert.severity)) {
            return false;
        }
        if (channel.filters.tags.length > 0) {
            const alertTags = Object.values(alert.labels);
            const hasMatchingTag = channel.filters.tags.some(tag => alertTags.includes(tag));
            if (!hasMatchingTag) {
                return false;
            }
        }
        return true;
    }
    checkRateLimit(channelId, rateLimit) {
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 3600000);
        const oneDayAgo = new Date(now.getTime() - 86400000);
        const recentNotifications = Array.from(this.notifications.values()).filter(n => n.channelId === channelId && n.sentAt != null && n.sentAt > oneHourAgo);
        const dailyNotifications = Array.from(this.notifications.values()).filter(n => n.channelId === channelId && n.sentAt != null && n.sentAt > oneDayAgo);
        return (recentNotifications.length < rateLimit.maxPerHour &&
            dailyNotifications.length < rateLimit.maxPerDay);
    }
    async sendNotification(alert, channel) {
        const notificationId = `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const notification = {
            id: notificationId,
            channelId: channel.id,
            alertId: alert.id,
            status: 'pending',
            retryCount: 0,
            maxRetries: 3,
        };
        this.notifications.set(notificationId, notification);
        try {
            await new Promise(resolve => setTimeout(resolve, 100));
            notification.status = 'sent';
            notification.sentAt = new Date();
            this.logger.log(`Notification sent to ${channel.name} for alert ${alert.title}`);
        }
        catch (error) {
            notification.status = 'failed';
            notification.error =
                error instanceof Error ? error.message : 'Unknown error';
            notification.retryCount++;
            this.logger.error(`Failed to send notification to ${channel.name}:`, error);
        }
    }
    async getActiveAlerts() {
        return Array.from(this.activeAlerts.values()).filter(alert => alert.status === 'firing');
    }
    async getAllAlerts() {
        return Array.from(this.activeAlerts.values());
    }
    async getAlertRules() {
        return Array.from(this.alertRules.values());
    }
    async createAlertRule(rule) {
        const id = `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newRule = {
            ...rule,
            id,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.alertRules.set(id, newRule);
        this.logger.log(`Created alert rule: ${id}`);
        return newRule;
    }
    async updateAlertRule(id, updates) {
        const rule = this.alertRules.get(id);
        if (!rule) {
            return null;
        }
        const updatedRule = {
            ...rule,
            ...updates,
            id,
            updatedAt: new Date(),
        };
        this.alertRules.set(id, updatedRule);
        this.logger.log(`Updated alert rule: ${id}`);
        return updatedRule;
    }
    async deleteAlertRule(id) {
        const deleted = this.alertRules.delete(id);
        if (deleted) {
            this.logger.log(`Deleted alert rule: ${id}`);
        }
        return deleted;
    }
    async acknowledgeAlert(alertId, acknowledgedBy) {
        const alert = this.activeAlerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.status = 'acknowledged';
        alert.acknowledgedAt = new Date();
        alert.acknowledgedBy = acknowledgedBy;
        this.logger.log(`Alert acknowledged: ${alert.title} by ${acknowledgedBy}`);
        return true;
    }
    async getNotificationChannels() {
        return Array.from(this.notificationChannels.values());
    }
    async getNotifications(alertId, channelId) {
        let notifications = Array.from(this.notifications.values());
        if (alertId != null) {
            notifications = notifications.filter(n => n.alertId === alertId);
        }
        if (channelId != null) {
            notifications = notifications.filter(n => n.channelId === channelId);
        }
        return notifications.sort((a, b) => (b.sentAt?.getTime() ?? 0) - (a.sentAt?.getTime() ?? 0));
    }
};
UnifiedAlertingService = UnifiedAlertingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], UnifiedAlertingService);



/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkModule: () => (/* binding */ NetworkModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_versioning_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(165);
/* harmony import */ var _ddos_protection_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(166);
/* harmony import */ var _firewall_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(167);
/* harmony import */ var _ids_ips_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(168);
/* harmony import */ var _network_monitoring_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(169);
/* harmony import */ var _network_performance_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(170);
/* harmony import */ var _network_segmentation_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(171);
/* harmony import */ var _network_controller__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(172);
/* harmony import */ var _ssl_tls_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(173);
/* harmony import */ var _vpn_admin_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(174);
/* harmony import */ var _ztna_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(175);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












let NetworkModule = class NetworkModule {
};
NetworkModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        controllers: [_network_controller__WEBPACK_IMPORTED_MODULE_8__.NetworkController],
        providers: [
            _vpn_admin_service__WEBPACK_IMPORTED_MODULE_10__.VpnAdminService,
            _network_segmentation_service__WEBPACK_IMPORTED_MODULE_7__.NetworkSegmentationService,
            _ddos_protection_service__WEBPACK_IMPORTED_MODULE_2__.DdosProtectionService,
            _ssl_tls_service__WEBPACK_IMPORTED_MODULE_9__.SslTlsService,
            _api_versioning_service__WEBPACK_IMPORTED_MODULE_1__.ApiVersioningService,
            _network_monitoring_service__WEBPACK_IMPORTED_MODULE_5__.NetworkMonitoringService,
            _firewall_service__WEBPACK_IMPORTED_MODULE_3__.FirewallService,
            _network_performance_service__WEBPACK_IMPORTED_MODULE_6__.NetworkPerformanceService,
            _ztna_service__WEBPACK_IMPORTED_MODULE_11__.ZtnaService,
            _ids_ips_service__WEBPACK_IMPORTED_MODULE_4__.IdsIpsService,
        ],
        exports: [
            _vpn_admin_service__WEBPACK_IMPORTED_MODULE_10__.VpnAdminService,
            _network_segmentation_service__WEBPACK_IMPORTED_MODULE_7__.NetworkSegmentationService,
            _ddos_protection_service__WEBPACK_IMPORTED_MODULE_2__.DdosProtectionService,
            _ssl_tls_service__WEBPACK_IMPORTED_MODULE_9__.SslTlsService,
            _api_versioning_service__WEBPACK_IMPORTED_MODULE_1__.ApiVersioningService,
            _network_monitoring_service__WEBPACK_IMPORTED_MODULE_5__.NetworkMonitoringService,
            _firewall_service__WEBPACK_IMPORTED_MODULE_3__.FirewallService,
            _network_performance_service__WEBPACK_IMPORTED_MODULE_6__.NetworkPerformanceService,
            _ztna_service__WEBPACK_IMPORTED_MODULE_11__.ZtnaService,
            _ids_ips_service__WEBPACK_IMPORTED_MODULE_4__.IdsIpsService,
        ],
    })
], NetworkModule);



/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiVersioningService: () => (/* binding */ ApiVersioningService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ApiVersioningService = class ApiVersioningService {
    constructor() {
        this.versions = new Map();
        this.endpoints = new Map();
        this.versionUsage = new Map();
        this.config = {
            defaultVersion: process.env.API_DEFAULT_VERSION ?? 'v1',
            supportedVersions: process.env.API_SUPPORTED_VERSIONS?.split(',') ?? [
                'v1',
                'v2',
            ],
            deprecatedVersions: process.env.API_DEPRECATED_VERSIONS?.split(',') ?? [],
            sunsetVersions: process.env.API_SUNSET_VERSIONS?.split(',') ?? [],
            versionHeader: process.env.API_VERSION_HEADER ?? 'X-API-Version',
            versionParam: process.env.API_VERSION_PARAM ?? 'version',
            fallbackToLatest: process.env.API_FALLBACK_TO_LATEST === 'true',
        };
        this.initializeVersions();
        this.initializeEndpoints();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('API Versioning Service initialized', 'ApiVersioningService', {
            defaultVersion: this.config.defaultVersion,
            supportedVersions: this.config.supportedVersions,
        });
    }
    initializeVersions() {
        const v1 = {
            version: 'v1',
            status: 'active',
            releaseDate: new Date('2024-01-01'),
            features: ['basic-crud', 'authentication', 'pagination'],
            breakingChanges: [],
        };
        const v2 = {
            version: 'v2',
            status: 'active',
            releaseDate: new Date('2024-06-01'),
            features: ['advanced-filtering', 'bulk-operations', 'real-time-updates'],
            breakingChanges: ['changed-pagination-format', 'updated-error-responses'],
            migrationGuide: '/docs/migration/v1-to-v2',
        };
        this.versions.set('v1', v1);
        this.versions.set('v2', v2);
    }
    initializeEndpoints() {
        const endpoints = [
            {
                path: '/users',
                method: 'GET',
                versions: ['v1', 'v2'],
                deprecatedVersions: [],
                sunsetVersions: [],
                alternatives: {},
            },
            {
                path: '/users/:id',
                method: 'GET',
                versions: ['v1', 'v2'],
                deprecatedVersions: [],
                sunsetVersions: [],
                alternatives: {},
            },
            {
                path: '/users',
                method: 'POST',
                versions: ['v1', 'v2'],
                deprecatedVersions: [],
                sunsetVersions: [],
                alternatives: {},
            },
            {
                path: '/products',
                method: 'GET',
                versions: ['v2'],
                deprecatedVersions: [],
                sunsetVersions: [],
                alternatives: { v1: '/items' },
            },
        ];
        endpoints.forEach(endpoint => {
            const key = `${endpoint.method}:${endpoint.path}`;
            this.endpoints.set(key, endpoint);
        });
    }
    resolveVersion(request) {
        const { headers, query, path } = request;
        const headerVersion = headers[this.config.versionHeader.toLowerCase()];
        if (headerVersion != null &&
            headerVersion !== '' &&
            this.isValidVersion(headerVersion)) {
            this.updateVersionUsage(headerVersion);
            return { version: headerVersion, source: 'header' };
        }
        const queryVersion = query[this.config.versionParam];
        if (queryVersion != null &&
            queryVersion !== '' &&
            this.isValidVersion(queryVersion)) {
            this.updateVersionUsage(queryVersion);
            return { version: queryVersion, source: 'query' };
        }
        const pathVersion = this.extractVersionFromPath(path);
        if (pathVersion != null &&
            pathVersion !== '' &&
            this.isValidVersion(pathVersion)) {
            this.updateVersionUsage(pathVersion);
            return { version: pathVersion, source: 'path' };
        }
        this.updateVersionUsage(this.config.defaultVersion);
        return { version: this.config.defaultVersion, source: 'default' };
    }
    extractVersionFromPath(path) {
        const versionMatch = path.match(/\/v(\d+)/);
        return versionMatch ? `v${versionMatch[1]}` : null;
    }
    isValidVersion(version) {
        return (this.config.supportedVersions.includes(version) ||
            this.config.deprecatedVersions.includes(version));
    }
    updateVersionUsage(version) {
        const currentCount = this.versionUsage.get(version) ?? 0;
        this.versionUsage.set(version, currentCount + 1);
    }
    isEndpointAvailable(path, method, version) {
        const key = `${method}:${path}`;
        const endpoint = this.endpoints.get(key);
        if (!endpoint) {
            return false;
        }
        return (endpoint.versions.includes(version) &&
            !endpoint.sunsetVersions.includes(version));
    }
    getAlternativeEndpoint(path, method, version) {
        const key = `${method}:${path}`;
        const endpoint = this.endpoints.get(key);
        if (!endpoint) {
            return null;
        }
        return endpoint.alternatives[version] ?? null;
    }
    getVersionStatus(version) {
        const versionInfo = this.versions.get(version);
        if (!versionInfo) {
            return { status: 'sunset', warning: 'Version not found' };
        }
        const now = new Date();
        let warning;
        if (versionInfo.status === 'deprecated') {
            warning =
                'This API version is deprecated and will be removed in a future release';
        }
        else if (versionInfo.status === 'sunset' &&
            versionInfo.sunsetDate &&
            now > versionInfo.sunsetDate) {
            warning = 'This API version has been sunset and is no longer supported';
        }
        const result = { status: versionInfo.status };
        if (warning != null) {
            result.warning = warning;
        }
        return result;
    }
    generateCompatibilityHeaders(version, originalPath) {
        const headers = {};
        const versionInfo = this.versions.get(version);
        if (!versionInfo) {
            return headers;
        }
        headers[this.config.versionHeader] = version;
        if (versionInfo.status === 'deprecated') {
            headers['X-API-Deprecation-Warning'] = 'This API version is deprecated';
            headers['X-API-Sunset-Date'] =
                versionInfo.sunsetDate?.toISOString() ?? '';
        }
        const alternative = this.getAlternativeEndpoint(originalPath, 'GET', version);
        headers['X-API-Alternative-Endpoint'] = alternative ?? '';
        return headers;
    }
    migrateData(data, fromVersion, toVersion) {
        if (fromVersion === toVersion) {
            return data;
        }
        if (fromVersion === 'v1' && toVersion === 'v2') {
            return this.migrateV1ToV2(data);
        }
        return data;
    }
    migrateV1ToV2(data) {
        if (typeof data === 'object' &&
            data != null &&
            'page' in data &&
            'limit' in data) {
            const v1Data = data;
            return {
                pagination: {
                    page: v1Data.page,
                    limit: v1Data.limit,
                    total: v1Data.items.length,
                },
                data: v1Data.items,
            };
        }
        return data;
    }
    getVersioningStats() {
        const totalRequests = Array.from(this.versionUsage.values()).reduce((sum, count) => sum + count, 0);
        const versionUsagePercentages = {};
        for (const [version, count] of this.versionUsage.entries()) {
            versionUsagePercentages[version] =
                totalRequests > 0 ? (count / totalRequests) * 100 : 0;
        }
        return {
            totalRequests,
            versionUsage: Object.fromEntries(this.versionUsage),
            versionUsagePercentages,
            supportedVersions: this.config.supportedVersions,
            deprecatedVersions: this.config.deprecatedVersions,
            sunsetVersions: this.config.sunsetVersions,
            endpointsCount: this.endpoints.size,
        };
    }
    addVersion(version) {
        this.versions.set(version.version, version);
        this.config.supportedVersions.push(version.version);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`New API version added: ${version.version}`, 'ApiVersioningService');
    }
    deprecateVersion(version, sunsetDate) {
        const versionInfo = this.versions.get(version);
        if (versionInfo) {
            versionInfo.status = 'deprecated';
            versionInfo.sunsetDate = sunsetDate;
            this.config.supportedVersions = this.config.supportedVersions.filter(v => v !== version);
            this.config.deprecatedVersions.push(version);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`API version deprecated: ${version}`, 'ApiVersioningService');
        }
    }
};
ApiVersioningService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ApiVersioningService);



/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DdosProtectionService: () => (/* binding */ DdosProtectionService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let DdosProtectionService = class DdosProtectionService {
    constructor() {
        this.blockedIps = new Set();
        this.rateLimitCounts = new Map();
        this.events = [];
        this.config = {
            enabled: process.env.DDOS_PROTECTION_ENABLED === 'true',
            provider: process.env.DDOS_PROTECTION_PROVIDER ?? 'cloudflare',
            apiKey: process.env.DDOS_PROTECTION_API_KEY ?? '',
            apiSecret: process.env.DDOS_PROTECTION_API_SECRET ?? '',
            zoneId: process.env.DDOS_PROTECTION_ZONE_ID ?? '',
            rateLimit: parseInt(process.env.DDOS_RATE_LIMIT ?? '100'),
            burstLimit: parseInt(process.env.DDOS_BURST_LIMIT ?? '50'),
            blockDuration: parseInt(process.env.DDOS_BLOCK_DURATION ?? '3600'),
            whitelistIps: process.env.DDOS_WHITELIST_IPS?.split(',') ?? [],
            blacklistIps: process.env.DDOS_BLACKLIST_IPS?.split(',') ?? [],
            customRules: this.getDefaultRules(),
        };
        if (this.config.enabled) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('DDoS Protection Service initialized', 'DdosProtectionService', {
                provider: this.config.provider,
                rateLimit: this.config.rateLimit,
                burstLimit: this.config.burstLimit,
            });
        }
    }
    async checkRequest(request) {
        if (!this.config.enabled) {
            return { allowed: true };
        }
        const { ipAddress, userAgent, path, method, headers } = request;
        if (this.config.whitelistIps.includes(ipAddress)) {
            this.logEvent(ipAddress, userAgent, path, method, headers, 'whitelist', 'IP in whitelist');
            return { allowed: true };
        }
        if (this.config.blacklistIps.includes(ipAddress) ||
            this.blockedIps.has(ipAddress)) {
            this.logEvent(ipAddress, userAgent, path, method, headers, 'blacklist', 'IP in blacklist');
            return { allowed: false, reason: 'IP blocked' };
        }
        const customRuleMatch = this.checkCustomRules(ipAddress, userAgent, path, method, headers);
        if (customRuleMatch) {
            if (customRuleMatch.action === 'block') {
                this.blockIp(ipAddress);
                this.logEvent(ipAddress, userAgent, path, method, headers, 'block', customRuleMatch.reason);
                return { allowed: false, reason: customRuleMatch.reason };
            }
            else if (customRuleMatch.action === 'challenge') {
                this.logEvent(ipAddress, userAgent, path, method, headers, 'challenge', customRuleMatch.reason);
                return { allowed: true, challenge: true };
            }
        }
        const rateLimitResult = this.checkRateLimit(ipAddress);
        if (!rateLimitResult.allowed) {
            this.logEvent(ipAddress, userAgent, path, method, headers, 'rate_limit', 'Rate limit exceeded');
            return { allowed: false, reason: 'Rate limit exceeded' };
        }
        return { allowed: true };
    }
    checkCustomRules(_ipAddress, userAgent, path, method, headers) {
        for (const rule of this.config.customRules) {
            if (!rule.enabled)
                continue;
            let matches = false;
            if (rule.pattern.includes('user-agent:') &&
                userAgent
                    .toLowerCase()
                    .includes(rule.pattern.split(':')[1]?.toLowerCase() ?? '')) {
                matches = true;
            }
            if (rule.pattern.includes('path:') &&
                path
                    .toLowerCase()
                    .includes(rule.pattern.split(':')[1]?.toLowerCase() ?? '')) {
                matches = true;
            }
            if (rule.pattern.includes('method:') &&
                method.toLowerCase() === rule.pattern.split(':')[1]?.toLowerCase()) {
                matches = true;
            }
            if (rule.pattern.includes('header:') &&
                this.checkHeaderPattern(headers, rule.pattern)) {
                matches = true;
            }
            if (matches) {
                return {
                    action: rule.action,
                    reason: rule.name,
                };
            }
        }
        return null;
    }
    checkHeaderPattern(headers, pattern) {
        const [headerName, headerValue] = pattern.split(':').slice(1);
        if (headerName == null ||
            headerName === '' ||
            headerValue == null ||
            headerValue === '')
            return false;
        const header = headers[headerName.toLowerCase()];
        return header?.toLowerCase().includes(headerValue.toLowerCase()) === true;
    }
    checkRateLimit(ipAddress) {
        const now = new Date();
        const current = this.rateLimitCounts.get(ipAddress);
        if (!current || current.resetTime < now) {
            this.rateLimitCounts.set(ipAddress, {
                count: 1,
                resetTime: new Date(now.getTime() + 60000),
            });
            return { allowed: true, remaining: this.config.rateLimit - 1 };
        }
        if (current.count >= this.config.rateLimit) {
            return { allowed: false, remaining: 0 };
        }
        current.count++;
        return { allowed: true, remaining: this.config.rateLimit - current.count };
    }
    blockIp(ipAddress) {
        this.blockedIps.add(ipAddress);
        setTimeout(() => {
            this.blockedIps.delete(ipAddress);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`IP unblocked: ${ipAddress}`, 'DdosProtectionService');
        }, this.config.blockDuration * 1000);
    }
    logEvent(ipAddress, userAgent, path, method, headers, eventType, reason) {
        const event = {
            id: `ddos_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            ipAddress,
            userAgent,
            requestPath: path,
            requestMethod: method,
            eventType,
            reason,
            headers,
        };
        this.events.push(event);
        if (this.events.length > 10000) {
            this.events.splice(0, 1000);
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`DDoS event: ${eventType} for IP: ${ipAddress}`, 'DdosProtectionService', {
            reason,
            path,
            method,
        });
    }
    getDdosStats() {
        const now = new Date();
        const lastHour = new Date(now.getTime() - 3600000);
        const lastDay = new Date(now.getTime() - 86400000);
        const eventsLastHour = this.events.filter(e => e.timestamp > lastHour);
        const eventsLastDay = this.events.filter(e => e.timestamp > lastDay);
        return {
            enabled: this.config.enabled,
            provider: this.config.provider,
            blockedIpsCount: this.blockedIps.size,
            rateLimitCounts: this.rateLimitCounts.size,
            eventsLastHour: eventsLastHour.length,
            eventsLastDay: eventsLastDay.length,
            totalEvents: this.events.length,
            whitelistIpsCount: this.config.whitelistIps.length,
            blacklistIpsCount: this.config.blacklistIps.length,
            customRulesCount: this.config.customRules.length,
            recentEvents: this.events.slice(-10).map(e => ({
                timestamp: e.timestamp,
                ipAddress: e.ipAddress,
                eventType: e.eventType,
                reason: e.reason,
            })),
        };
    }
    addToWhitelist(ipAddress) {
        if (!this.config.whitelistIps.includes(ipAddress)) {
            this.config.whitelistIps.push(ipAddress);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IP added to whitelist: ${ipAddress}`, 'DdosProtectionService');
            return true;
        }
        return false;
    }
    addToBlacklist(ipAddress) {
        if (!this.config.blacklistIps.includes(ipAddress)) {
            this.config.blacklistIps.push(ipAddress);
            this.blockedIps.add(ipAddress);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IP added to blacklist: ${ipAddress}`, 'DdosProtectionService');
            return true;
        }
        return false;
    }
    getDefaultRules() {
        return [
            {
                id: 'rule-1',
                name: 'Block common bot user agents',
                pattern: 'user-agent:bot',
                action: 'block',
                priority: 1,
                enabled: true,
            },
            {
                id: 'rule-2',
                name: 'Block suspicious paths',
                pattern: 'path:admin',
                action: 'challenge',
                priority: 2,
                enabled: true,
            },
            {
                id: 'rule-3',
                name: 'Block excessive POST requests',
                pattern: 'method:post',
                action: 'log',
                priority: 3,
                enabled: true,
            },
            {
                id: 'rule-4',
                name: 'Block requests without User-Agent',
                pattern: 'header:user-agent',
                action: 'block',
                priority: 4,
                enabled: true,
            },
        ];
    }
};
DdosProtectionService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DdosProtectionService);



/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FirewallService: () => (/* binding */ FirewallService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let FirewallService = class FirewallService {
    constructor() {
        this.securityGroups = new Map();
        this.firewallEvents = [];
        this.maxEventsHistory = 5000;
        this.initializeDefaultSecurityGroups();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Firewall Service initialized', 'FirewallService');
    }
    initializeDefaultSecurityGroups() {
        const defaultGroups = [
            {
                id: 'sg-web',
                name: 'Web Security Group',
                description: 'Security group for web servers',
                vpcId: 'vpc-main',
                rules: this.getWebServerRules(),
                attachedResources: [],
                tags: { Environment: 'production', Purpose: 'web' },
            },
            {
                id: 'sg-database',
                name: 'Database Security Group',
                description: 'Security group for database servers',
                vpcId: 'vpc-main',
                rules: this.getDatabaseRules(),
                attachedResources: [],
                tags: { Environment: 'production', Purpose: 'database' },
            },
            {
                id: 'sg-admin',
                name: 'Admin Security Group',
                description: 'Security group for administrative access',
                vpcId: 'vpc-main',
                rules: this.getAdminRules(),
                attachedResources: [],
                tags: { Environment: 'production', Purpose: 'admin' },
            },
        ];
        defaultGroups.forEach(group => {
            this.securityGroups.set(group.id, group);
        });
    }
    getWebServerRules() {
        return [
            {
                id: 'rule-web-http',
                name: 'Allow HTTP',
                description: 'Allow HTTP traffic from anywhere',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '80',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 100,
                enabled: true,
                tags: { Service: 'http' },
            },
            {
                id: 'rule-web-https',
                name: 'Allow HTTPS',
                description: 'Allow HTTPS traffic from anywhere',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '443',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 110,
                enabled: true,
                tags: { Service: 'https' },
            },
            {
                id: 'rule-web-ssh',
                name: 'Allow SSH from admin',
                description: 'Allow SSH access from admin network',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '22',
                source: '10.0.4.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 120,
                enabled: true,
                tags: { Service: 'ssh' },
            },
        ];
    }
    getDatabaseRules() {
        return [
            {
                id: 'rule-db-postgres',
                name: 'Allow PostgreSQL',
                description: 'Allow PostgreSQL from application servers',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '5432',
                source: '10.0.2.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 100,
                enabled: true,
                tags: { Service: 'postgresql' },
            },
            {
                id: 'rule-db-redis',
                name: 'Allow Redis',
                description: 'Allow Redis from application servers',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '6379',
                source: '10.0.2.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 110,
                enabled: true,
                tags: { Service: 'redis' },
            },
            {
                id: 'rule-db-ssh',
                name: 'Allow SSH from admin',
                description: 'Allow SSH access from admin network',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '22',
                source: '10.0.4.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 120,
                enabled: true,
                tags: { Service: 'ssh' },
            },
        ];
    }
    getAdminRules() {
        return [
            {
                id: 'rule-admin-ssh',
                name: 'Allow SSH from trusted IPs',
                description: 'Allow SSH access from trusted IP addresses',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '22',
                source: process.env.ADMIN_IPS ?? '10.0.0.0/8',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 100,
                enabled: true,
                tags: { Service: 'ssh' },
            },
            {
                id: 'rule-admin-rdp',
                name: 'Allow RDP from trusted IPs',
                description: 'Allow RDP access from trusted IP addresses',
                direction: 'inbound',
                protocol: 'tcp',
                portRange: '3389',
                source: process.env.ADMIN_IPS ?? '10.0.0.0/8',
                destination: '0.0.0.0/0',
                action: 'allow',
                priority: 110,
                enabled: true,
                tags: { Service: 'rdp' },
            },
        ];
    }
    async checkPacket(packet) {
        const { securityGroupId, direction } = packet;
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            return { allowed: false, reason: 'Security group not found' };
        }
        const sortedRules = securityGroup.rules
            .filter(rule => rule.enabled && rule.direction === direction)
            .sort((a, b) => a.priority - b.priority);
        for (const rule of sortedRules) {
            if (this.matchesRule(packet, rule)) {
                this.logFirewallEvent(packet, rule);
                return {
                    allowed: rule.action === 'allow',
                    ruleId: rule.id,
                    reason: rule.action === 'allow' ? 'Rule allowed' : 'Rule denied',
                };
            }
        }
        const defaultAction = 'deny';
        this.logFirewallEvent(packet, {
            id: 'default',
            name: 'Default Rule',
            description: 'Default deny rule',
            direction,
            protocol: 'all',
            portRange: 'all',
            source: '0.0.0.0/0',
            destination: '0.0.0.0/0',
            action: defaultAction,
            priority: 999,
            enabled: true,
            tags: {},
        });
        return { allowed: false, reason: 'Default deny rule' };
    }
    matchesRule(packet, rule) {
        if (rule.protocol !== 'all' && rule.protocol !== packet.protocol) {
            return false;
        }
        if (rule.portRange !== 'all') {
            const port = parseInt(rule.portRange);
            if (packet.port !== port) {
                return false;
            }
        }
        if (!this.isIpInRange(packet.sourceIp, rule.source)) {
            return false;
        }
        if (!this.isIpInRange(packet.destinationIp, rule.destination)) {
            return false;
        }
        return true;
    }
    isIpInRange(ip, range) {
        if (range === '0.0.0.0/0')
            return true;
        const [networkIp, prefix] = range.split('/');
        const prefixNum = parseInt(prefix ?? '0');
        return (networkIp != null &&
            ip.startsWith(networkIp
                .split('.')
                .slice(0, prefixNum / 8)
                .join('.')));
    }
    logFirewallEvent(packet, rule) {
        const event = {
            id: `fw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            ruleId: rule.id,
            action: rule.action,
            sourceIp: packet.sourceIp,
            destinationIp: packet.destinationIp,
            protocol: packet.protocol,
            port: packet.port,
            reason: rule.action === 'allow' ? 'Rule allowed' : 'Rule denied',
            packetSize: this.generateRandomPacketSize(),
        };
        this.firewallEvents.push(event);
        this.cleanupOldEvents();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Firewall event: ${rule.action} ${packet.protocol}:${packet.port}`, 'FirewallService', {
            ruleId: rule.id,
            sourceIp: packet.sourceIp,
            destinationIp: packet.destinationIp,
        });
    }
    generateRandomPacketSize() {
        return Math.floor(Math.random() * 1500) + 64;
    }
    cleanupOldEvents() {
        if (this.firewallEvents.length > this.maxEventsHistory) {
            this.firewallEvents.splice(0, this.firewallEvents.length - this.maxEventsHistory);
        }
    }
    createSecurityGroup(group) {
        const groupId = `sg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newGroup = {
            ...group,
            id: groupId,
        };
        this.securityGroups.set(groupId, newGroup);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Security group created: ${groupId}`, 'FirewallService');
        return groupId;
    }
    addRuleToSecurityGroup(securityGroupId, rule) {
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            throw new Error('Security group not found');
        }
        const ruleId = `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newRule = {
            ...rule,
            id: ruleId,
        };
        securityGroup.rules.push(newRule);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Rule added to security group: ${ruleId}`, 'FirewallService');
        return ruleId;
    }
    removeRuleFromSecurityGroup(securityGroupId, ruleId) {
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            return false;
        }
        const index = securityGroup.rules.findIndex(rule => rule.id === ruleId);
        if (index === -1) {
            return false;
        }
        securityGroup.rules.splice(index, 1);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Rule removed from security group: ${ruleId}`, 'FirewallService');
        return true;
    }
    updateRule(securityGroupId, ruleId, updates) {
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            return false;
        }
        const rule = securityGroup.rules.find(r => r.id === ruleId);
        if (!rule) {
            return false;
        }
        Object.assign(rule, updates);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Rule updated: ${ruleId}`, 'FirewallService');
        return true;
    }
    getFirewallStats() {
        const now = new Date();
        const lastHour = new Date(now.getTime() - 3600000);
        const lastDay = new Date(now.getTime() - 86400000);
        const eventsLastHour = this.firewallEvents.filter(e => e.timestamp > lastHour);
        const eventsLastDay = this.firewallEvents.filter(e => e.timestamp > lastDay);
        const allowedEvents = this.firewallEvents.filter(e => e.action === 'allow');
        const deniedEvents = this.firewallEvents.filter(e => e.action === 'deny');
        return {
            totalSecurityGroups: this.securityGroups.size,
            totalRules: Array.from(this.securityGroups.values()).reduce((sum, sg) => sum + sg.rules.length, 0),
            totalEvents: this.firewallEvents.length,
            eventsLastHour: eventsLastHour.length,
            eventsLastDay: eventsLastDay.length,
            allowedEvents: allowedEvents.length,
            deniedEvents: deniedEvents.length,
            securityGroups: Array.from(this.securityGroups.values()).map(sg => ({
                id: sg.id,
                name: sg.name,
                description: sg.description,
                ruleCount: sg.rules.length,
                attachedResources: sg.attachedResources.length,
            })),
            recentEvents: this.firewallEvents.slice(-10).map(e => ({
                id: e.id,
                timestamp: e.timestamp,
                action: e.action,
                sourceIp: e.sourceIp,
                destinationIp: e.destinationIp,
                protocol: e.protocol,
                port: e.port,
                reason: e.reason,
            })),
        };
    }
    getEventsForPeriod(startTime, endTime) {
        return this.firewallEvents.filter(e => e.timestamp >= startTime && e.timestamp <= endTime);
    }
    getEventsByAction(action) {
        return this.firewallEvents.filter(e => e.action === action);
    }
    getEventsByRule(ruleId) {
        return this.firewallEvents.filter(e => e.ruleId === ruleId);
    }
    attachResource(securityGroupId, resourceId) {
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            return false;
        }
        if (!securityGroup.attachedResources.includes(resourceId)) {
            securityGroup.attachedResources.push(resourceId);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Resource attached to security group: ${resourceId}`, 'FirewallService');
        }
        return true;
    }
    detachResource(securityGroupId, resourceId) {
        const securityGroup = this.securityGroups.get(securityGroupId);
        if (!securityGroup) {
            return false;
        }
        const index = securityGroup.attachedResources.indexOf(resourceId);
        if (index !== -1) {
            securityGroup.attachedResources.splice(index, 1);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Resource detached from security group: ${resourceId}`, 'FirewallService');
            return true;
        }
        return false;
    }
};
FirewallService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], FirewallService);



/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IdsIpsService: () => (/* binding */ IdsIpsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let IdsIpsService = class IdsIpsService {
    constructor() {
        this.rules = new Map();
        this.alerts = [];
        this.blockedIps = new Set();
        this.maxAlertsHistory = 10000;
        this.maxBlockedIps = 1000;
        this.initializeDefaultRules();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('IDS/IPS Service initialized', 'IdsIpsService');
    }
    initializeDefaultRules() {
        const defaultRules = [
            {
                id: 'rule-sql-injection',
                name: 'SQL Injection Detection',
                description: 'Detect SQL injection attempts',
                type: 'signature',
                pattern: '(UNION|SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER)\\s+(ALL|DISTINCT|TOP|FROM|WHERE|INTO|VALUES|SET|TABLE|DATABASE)',
                severity: 'high',
                action: 'block',
                enabled: true,
                priority: 1,
                threshold: 1,
                tags: { Category: 'SQL Injection', CVE: 'N/A' },
            },
            {
                id: 'rule-xss-attack',
                name: 'XSS Attack Detection',
                description: 'Detect cross-site scripting attempts',
                type: 'signature',
                pattern: '<script[^>]*>.*?</script>|<javascript:|vbscript:|onload=|onerror=|onclick=',
                severity: 'high',
                action: 'block',
                enabled: true,
                priority: 2,
                threshold: 1,
                tags: { Category: 'XSS', CVE: 'N/A' },
            },
            {
                id: 'rule-brute-force',
                name: 'Brute Force Attack Detection',
                description: 'Detect brute force login attempts',
                type: 'behavior',
                pattern: 'failed_login_attempts',
                severity: 'medium',
                action: 'alert',
                enabled: true,
                priority: 3,
                threshold: 5,
                tags: { Category: 'Brute Force', CVE: 'N/A' },
            },
            {
                id: 'rule-dos-attack',
                name: 'DoS Attack Detection',
                description: 'Detect denial of service attacks',
                type: 'anomaly',
                pattern: 'request_rate',
                severity: 'critical',
                action: 'block',
                enabled: true,
                priority: 4,
                threshold: 100,
                tags: { Category: 'DoS', CVE: 'N/A' },
            },
            {
                id: 'rule-path-traversal',
                name: 'Path Traversal Detection',
                description: 'Detect path traversal attempts',
                type: 'signature',
                pattern: '\\.\\./|%2e%2e%2f|%2e%2e/|\\.\\.%2f',
                severity: 'medium',
                action: 'block',
                enabled: true,
                priority: 5,
                threshold: 1,
                tags: { Category: 'Path Traversal', CVE: 'N/A' },
            },
            {
                id: 'rule-command-injection',
                name: 'Command Injection Detection',
                description: 'Detect command injection attempts',
                type: 'signature',
                pattern: ';\\s*(ls|cat|rm|cp|mv|wget|curl|nc|telnet|ssh|ftp|ping|nslookup)',
                severity: 'high',
                action: 'block',
                enabled: true,
                priority: 6,
                threshold: 1,
                tags: { Category: 'Command Injection', CVE: 'N/A' },
            },
            {
                id: 'rule-ldap-injection',
                name: 'LDAP Injection Detection',
                description: 'Detect LDAP injection attempts',
                type: 'signature',
                pattern: '\\(|\\*|\\)|&|\\||!',
                severity: 'medium',
                action: 'alert',
                enabled: true,
                priority: 7,
                threshold: 1,
                tags: { Category: 'LDAP Injection', CVE: 'N/A' },
            },
            {
                id: 'rule-php-injection',
                name: 'PHP Code Injection Detection',
                description: 'Detect PHP code injection attempts',
                type: 'signature',
                pattern: '\\<\\?php|\\<\\?=|eval\\(|system\\(|shell_exec\\(|passthru\\(',
                severity: 'high',
                action: 'block',
                enabled: true,
                priority: 8,
                threshold: 1,
                tags: { Category: 'Code Injection', CVE: 'N/A' },
            },
        ];
        defaultRules.forEach(rule => {
            this.rules.set(rule.id, rule);
        });
    }
    async analyzePacket(packet) {
        const { sourceIp, destinationIp, protocol, port, payload, timestamp } = packet;
        const alerts = [];
        let blocked = false;
        if (this.blockedIps.has(sourceIp)) {
            const alert = {
                id: `ids_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                timestamp,
                ruleId: 'blocked_ip',
                severity: 'medium',
                sourceIp,
                destinationIp,
                protocol,
                port,
                payload: payload.substring(0, 100),
                signature: 'Blocked IP',
                action: 'block',
                blocked: true,
                falsePositive: false,
                details: { reason: 'IP is in blocklist' },
            };
            alerts.push(alert);
            blocked = true;
        }
        else {
            const sortedRules = Array.from(this.rules.values())
                .filter(rule => rule.enabled)
                .sort((a, b) => a.priority - b.priority);
            for (const rule of sortedRules) {
                if (this.matchesRule(packet, rule)) {
                    const alert = this.createAlert(packet, rule);
                    alerts.push(alert);
                    if (rule.action === 'block') {
                        this.blockIp(sourceIp);
                        blocked = true;
                    }
                }
            }
        }
        if (alerts.length > 0) {
            this.alerts.push(...alerts);
            this.cleanupOldAlerts();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`IDS/IPS threat detected: ${alerts.length} alerts`, 'IdsIpsService', {
                sourceIp,
                destinationIp,
                protocol,
                port,
                blocked,
                alerts: alerts.map(a => ({
                    ruleId: a.ruleId,
                    severity: a.severity,
                    action: a.action,
                })),
            });
        }
        return {
            threatDetected: alerts.length > 0,
            blocked,
            alerts,
        };
    }
    matchesRule(packet, rule) {
        const { payload, headers } = packet;
        switch (rule.type) {
            case 'signature':
                return this.checkSignaturePattern(payload, headers, rule.pattern);
            case 'anomaly':
                return this.checkAnomalyPattern(packet, rule);
            case 'behavior':
                return this.checkBehaviorPattern(packet, rule);
            case 'heuristic':
                return this.checkHeuristicPattern(packet, rule);
            default:
                return false;
        }
    }
    checkSignaturePattern(payload, headers, pattern) {
        const regex = new RegExp(pattern, 'i');
        if (regex.test(payload)) {
            return true;
        }
        for (const headerValue of Object.values(headers)) {
            if (regex.test(headerValue)) {
                return true;
            }
        }
        return false;
    }
    checkAnomalyPattern(_packet, rule) {
        if (rule.pattern === 'request_rate') {
            const randomRate = Math.floor(Math.random() * 200);
            return randomRate > rule.threshold;
        }
        return false;
    }
    checkBehaviorPattern(_packet, rule) {
        if (rule.pattern === 'failed_login_attempts') {
            const randomAttempts = Math.floor(Math.random() * 10);
            return randomAttempts > rule.threshold;
        }
        return false;
    }
    checkHeuristicPattern(packet, _rule) {
        const payload = packet.payload.toLowerCase();
        const suspiciousPatterns = [
            'admin',
            'password',
            'login',
            'root',
            'shell',
            'exec',
            'system',
        ];
        const matchCount = suspiciousPatterns.filter(pattern => Boolean(payload.includes(pattern))).length;
        return matchCount >= 3;
    }
    createAlert(packet, rule) {
        const alert = {
            id: `ids_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: packet.timestamp,
            ruleId: rule.id,
            severity: rule.severity,
            sourceIp: packet.sourceIp,
            destinationIp: packet.destinationIp,
            protocol: packet.protocol,
            port: packet.port,
            payload: packet.payload.substring(0, 100),
            signature: rule.name,
            action: rule.action,
            blocked: rule.action === 'block',
            falsePositive: false,
            details: {
                ruleType: rule.type,
                pattern: rule.pattern,
                threshold: rule.threshold,
                tags: rule.tags,
            },
        };
        return alert;
    }
    blockIp(ipAddress) {
        this.blockedIps.add(ipAddress);
        if (this.blockedIps.size > this.maxBlockedIps) {
            const firstIp = this.blockedIps.values().next().value;
            if (firstIp != null) {
                this.blockedIps.delete(firstIp);
            }
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`IP blocked by IDS/IPS: ${ipAddress}`, 'IdsIpsService');
    }
    cleanupOldAlerts() {
        if (this.alerts.length > this.maxAlertsHistory) {
            this.alerts.splice(0, this.alerts.length - this.maxAlertsHistory);
        }
    }
    getIdsStats() {
        const alertsBySeverity = {
            low: 0,
            medium: 0,
            high: 0,
            critical: 0,
        };
        const alertsByAction = {
            alert: 0,
            block: 0,
            log: 0,
            drop: 0,
        };
        let blockedAttacks = 0;
        let falsePositives = 0;
        for (const alert of this.alerts) {
            const severityCount = alertsBySeverity[alert.severity];
            if (severityCount != null) {
                alertsBySeverity[alert.severity] = severityCount + 1;
            }
            const actionCount = alertsByAction[alert.action];
            if (actionCount != null) {
                alertsByAction[alert.action] = actionCount + 1;
            }
            if (alert.blocked) {
                blockedAttacks++;
            }
            if (alert.falsePositive) {
                falsePositives++;
            }
        }
        const rulesEnabled = Array.from(this.rules.values()).filter(r => r.enabled).length;
        const rulesDisabled = Array.from(this.rules.values()).filter(r => r.enabled !== true).length;
        return {
            totalAlerts: this.alerts.length,
            alertsBySeverity,
            alertsByAction,
            blockedAttacks,
            falsePositives,
            rulesEnabled,
            rulesDisabled,
        };
    }
    addRule(rule) {
        const ruleId = `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newRule = {
            ...rule,
            id: ruleId,
        };
        this.rules.set(ruleId, newRule);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IDS/IPS rule added: ${ruleId}`, 'IdsIpsService');
        return ruleId;
    }
    updateRule(ruleId, updates) {
        const rule = this.rules.get(ruleId);
        if (!rule) {
            return false;
        }
        Object.assign(rule, updates);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IDS/IPS rule updated: ${ruleId}`, 'IdsIpsService');
        return true;
    }
    removeRule(ruleId) {
        const deleted = this.rules.delete(ruleId);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IDS/IPS rule removed: ${ruleId}`, 'IdsIpsService');
        }
        return deleted;
    }
    getAlertsForPeriod(startTime, endTime) {
        return this.alerts.filter(a => a.timestamp >= startTime && a.timestamp <= endTime);
    }
    getAlertsBySeverity(severity) {
        return this.alerts.filter(a => a.severity === severity);
    }
    getAlertsByRule(ruleId) {
        return this.alerts.filter(a => a.ruleId === ruleId);
    }
    getBlockedIps() {
        return Array.from(this.blockedIps);
    }
    unblockIp(ipAddress) {
        const deleted = this.blockedIps.delete(ipAddress);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`IP unblocked: ${ipAddress}`, 'IdsIpsService');
        }
        return deleted;
    }
    markAsFalsePositive(alertId) {
        const alert = this.alerts.find(a => a.id === alertId);
        if (alert) {
            alert.falsePositive = true;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Alert marked as false positive: ${alertId}`, 'IdsIpsService');
            return true;
        }
        return false;
    }
    getRecentAlerts(limit = 10) {
        return this.alerts.slice(-limit);
    }
    getCriticalAlerts() {
        return this.alerts.filter(a => a.severity === 'critical');
    }
    getBlockedAttacks() {
        return this.alerts.filter(a => a.blocked);
    }
    getAttackTypeStats() {
        const stats = {};
        for (const alert of this.alerts) {
            const tags = alert.details.tags;
            const category = tags.Category ?? 'Unknown';
            stats[category] = (stats[category] ?? 0) + 1;
        }
        return stats;
    }
    getTopSourceIps(limit = 10) {
        const ipCounts = {};
        for (const alert of this.alerts) {
            ipCounts[alert.sourceIp] = (ipCounts[alert.sourceIp] ?? 0) + 1;
        }
        return Object.entries(ipCounts)
            .map(([ip, count]) => ({ ip, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, limit);
    }
    getConfigurationRecommendations() {
        const recommendations = [];
        const stats = this.getIdsStats();
        if (stats.falsePositives > stats.totalAlerts * 0.1) {
            recommendations.push('High false positive rate detected. Consider adjusting rule thresholds.');
        }
        if (stats.blockedAttacks < stats.totalAlerts * 0.5) {
            recommendations.push('Low blocking rate. Consider enabling more aggressive blocking rules.');
        }
        if (stats.rulesDisabled > stats.rulesEnabled) {
            recommendations.push('Many rules are disabled. Consider enabling critical security rules.');
        }
        const criticalAlerts = this.getCriticalAlerts();
        if (criticalAlerts.length > 0) {
            recommendations.push(`${criticalAlerts.length} critical alerts detected. Immediate attention required.`);
        }
        return recommendations;
    }
};
IdsIpsService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], IdsIpsService);



/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkMonitoringService: () => (/* binding */ NetworkMonitoringService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let NetworkMonitoringService = class NetworkMonitoringService {
    constructor() {
        this.metrics = [];
        this.patterns = new Map();
        this.alerts = [];
        this.maxMetricsHistory = 10000;
        this.maxAlertsHistory = 1000;
        this.initializeTrafficPatterns();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Network Monitoring Service initialized', 'NetworkMonitoringService');
    }
    initializeTrafficPatterns() {
        const defaultPatterns = [
            {
                id: 'high-bandwidth',
                pattern: 'bandwidth_usage',
                description: 'High bandwidth usage',
                severity: 'high',
                threshold: 80,
                currentValue: 0,
                alert: false,
            },
            {
                id: 'high-latency',
                pattern: 'response_time',
                description: 'High response time',
                severity: 'medium',
                threshold: 200,
                currentValue: 0,
                alert: false,
            },
            {
                id: 'error-rate',
                pattern: 'error_percentage',
                description: 'High error rate',
                severity: 'critical',
                threshold: 5,
                currentValue: 0,
                alert: false,
            },
            {
                id: 'connection-spike',
                pattern: 'connection_count',
                description: 'Connection count spike',
                severity: 'high',
                threshold: 1000,
                currentValue: 0,
                alert: false,
            },
        ];
        defaultPatterns.forEach(pattern => {
            this.patterns.set(pattern.id, pattern);
        });
    }
    async collectMetrics() {
        const metrics = {
            timestamp: new Date(),
            bytesIn: this.generateRandomMetric(1000000, 5000000),
            bytesOut: this.generateRandomMetric(500000, 2000000),
            packetsIn: this.generateRandomMetric(1000, 5000),
            packetsOut: this.generateRandomMetric(500, 2000),
            connections: this.generateRandomMetric(100, 500),
            latency: this.generateRandomMetric(10, 100),
            errorRate: this.generateRandomMetric(0, 2),
            bandwidth: this.generateRandomMetric(50, 90),
        };
        this.metrics.push(metrics);
        this.cleanupOldMetrics();
        this.analyzeTrafficPatterns(metrics);
        this.checkAlerts(metrics);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Network metrics collected', 'NetworkMonitoringService', {
            timestamp: metrics.timestamp,
            bandwidth: metrics.bandwidth,
            latency: metrics.latency,
        });
        return metrics;
    }
    generateRandomMetric(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    cleanupOldMetrics() {
        if (this.metrics.length > this.maxMetricsHistory) {
            this.metrics.splice(0, this.metrics.length - this.maxMetricsHistory);
        }
    }
    analyzeTrafficPatterns(metrics) {
        const bandwidthPattern = this.patterns.get('high-bandwidth');
        if (bandwidthPattern) {
            bandwidthPattern.currentValue = metrics.bandwidth;
            bandwidthPattern.alert = metrics.bandwidth > bandwidthPattern.threshold;
        }
        const latencyPattern = this.patterns.get('high-latency');
        if (latencyPattern) {
            latencyPattern.currentValue = metrics.latency;
            latencyPattern.alert = metrics.latency > latencyPattern.threshold;
        }
        const errorPattern = this.patterns.get('error-rate');
        if (errorPattern) {
            errorPattern.currentValue = metrics.errorRate;
            errorPattern.alert = metrics.errorRate > errorPattern.threshold;
        }
        const connectionPattern = this.patterns.get('connection-spike');
        if (connectionPattern) {
            connectionPattern.currentValue = metrics.connections;
            connectionPattern.alert =
                metrics.connections > connectionPattern.threshold;
        }
    }
    checkAlerts(metrics) {
        for (const pattern of this.patterns.values()) {
            if (pattern.alert && !this.hasActiveAlert(pattern.id)) {
                this.createAlert(pattern, metrics);
            }
        }
    }
    hasActiveAlert(patternId) {
        return this.alerts.some(alert => alert.source === patternId && !alert.resolved);
    }
    createAlert(pattern, _metrics) {
        const alert = {
            id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            type: this.getAlertType(pattern.pattern),
            severity: pattern.severity,
            message: `${pattern.description}: ${pattern.currentValue} (threshold: ${pattern.threshold})`,
            source: pattern.id,
            resolved: false,
        };
        this.alerts.push(alert);
        this.cleanupOldAlerts();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Network alert created: ${alert.message}`, 'NetworkMonitoringService', {
            alertId: alert.id,
            severity: alert.severity,
            type: alert.type,
        });
    }
    getAlertType(pattern) {
        switch (pattern) {
            case 'bandwidth_usage':
                return 'bandwidth';
            case 'response_time':
                return 'latency';
            case 'error_percentage':
                return 'error_rate';
            case 'connection_count':
                return 'connection_limit';
            default:
                return 'anomaly';
        }
    }
    cleanupOldAlerts() {
        if (this.alerts.length > this.maxAlertsHistory) {
            this.alerts.splice(0, this.alerts.length - this.maxAlertsHistory);
        }
    }
    getMonitoringStats() {
        const now = new Date();
        const lastHour = new Date(now.getTime() - 3600000);
        const lastDay = new Date(now.getTime() - 86400000);
        const metricsLastHour = this.metrics.filter(m => m.timestamp > lastHour);
        const metricsLastDay = this.metrics.filter(m => m.timestamp > lastDay);
        const alertsLastHour = this.alerts.filter(a => a.timestamp > lastHour);
        const alertsLastDay = this.alerts.filter(a => a.timestamp > lastDay);
        const activeAlerts = this.alerts.filter(a => !a.resolved);
        return {
            totalMetrics: this.metrics.length,
            metricsLastHour: metricsLastHour.length,
            metricsLastDay: metricsLastDay.length,
            totalAlerts: this.alerts.length,
            activeAlerts: activeAlerts.length,
            alertsLastHour: alertsLastHour.length,
            alertsLastDay: alertsLastDay.length,
            patterns: Array.from(this.patterns.values()).map(p => ({
                id: p.id,
                description: p.description,
                severity: p.severity,
                threshold: p.threshold,
                currentValue: p.currentValue,
                alert: p.alert,
            })),
            recentAlerts: this.alerts.slice(-10).map(a => ({
                id: a.id,
                timestamp: a.timestamp,
                type: a.type,
                severity: a.severity,
                message: a.message,
                resolved: a.resolved,
            })),
        };
    }
    getMetricsForPeriod(startTime, endTime) {
        return this.metrics.filter(m => m.timestamp >= startTime && m.timestamp <= endTime);
    }
    resolveAlert(alertId) {
        const alert = this.alerts.find(a => a.id === alertId);
        if (alert && !alert.resolved) {
            alert.resolved = true;
            alert.resolvedAt = new Date();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Alert resolved: ${alertId}`, 'NetworkMonitoringService');
            return true;
        }
        return false;
    }
    addTrafficPattern(pattern) {
        const newPattern = {
            ...pattern,
            currentValue: 0,
            alert: false,
        };
        this.patterns.set(pattern.id, newPattern);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Traffic pattern added: ${pattern.id}`, 'NetworkMonitoringService');
    }
    updatePatternThreshold(patternId, newThreshold) {
        const pattern = this.patterns.get(patternId);
        if (pattern) {
            pattern.threshold = newThreshold;
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Pattern threshold updated: ${patternId} -> ${newThreshold}`, 'NetworkMonitoringService');
            return true;
        }
        return false;
    }
    getActiveAlerts() {
        return this.alerts.filter(a => !a.resolved);
    }
    getAlertsByType(type) {
        return this.alerts.filter(a => a.type === type);
    }
    getAlertsBySeverity(severity) {
        return this.alerts.filter(a => a.severity === severity);
    }
};
NetworkMonitoringService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], NetworkMonitoringService);



/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkPerformanceService: () => (/* binding */ NetworkPerformanceService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let NetworkPerformanceService = class NetworkPerformanceService {
    constructor() {
        this.performanceMetrics = [];
        this.optimizationRules = new Map();
        this.optimizationActions = [];
        this.maxMetricsHistory = 5000;
        this.maxActionsHistory = 1000;
        this.initializeOptimizationRules();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Network Performance Service initialized', 'NetworkPerformanceService');
    }
    initializeOptimizationRules() {
        const defaultRules = [
            {
                id: 'rule-bandwidth-throttle',
                name: 'Bandwidth Throttling',
                description: 'Throttle bandwidth when utilization exceeds 90%',
                type: 'bandwidth',
                condition: 'bandwidth_utilization > 90',
                action: 'throttle_bandwidth',
                threshold: 90,
                enabled: true,
                priority: 1,
            },
            {
                id: 'rule-latency-optimization',
                name: 'Latency Optimization',
                description: 'Optimize routing when latency exceeds 100ms',
                type: 'latency',
                condition: 'latency > 100',
                action: 'optimize_routing',
                threshold: 100,
                enabled: true,
                priority: 2,
            },
            {
                id: 'rule-packet-loss-recovery',
                name: 'Packet Loss Recovery',
                description: 'Enable packet retransmission when loss exceeds 1%',
                type: 'packet_loss',
                condition: 'packet_loss > 1',
                action: 'enable_retransmission',
                threshold: 1,
                enabled: true,
                priority: 3,
            },
            {
                id: 'rule-connection-pooling',
                name: 'Connection Pooling',
                description: 'Enable connection pooling when connections exceed 500',
                type: 'connection_limit',
                condition: 'connection_count > 500',
                action: 'enable_connection_pooling',
                threshold: 500,
                enabled: true,
                priority: 4,
            },
            {
                id: 'rule-caching-optimization',
                name: 'Caching Optimization',
                description: 'Enable aggressive caching when error rate is low',
                type: 'caching',
                condition: 'error_rate < 0.1',
                action: 'enable_aggressive_caching',
                threshold: 0.1,
                enabled: true,
                priority: 5,
            },
        ];
        defaultRules.forEach(rule => {
            this.optimizationRules.set(rule.id, rule);
        });
    }
    async collectPerformanceMetrics() {
        const metrics = {
            timestamp: new Date(),
            throughput: this.generateRandomMetric(100, 1000),
            latency: this.generateRandomMetric(5, 150),
            packetLoss: this.generateRandomMetric(0, 5),
            jitter: this.generateRandomMetric(1, 20),
            bandwidthUtilization: this.generateRandomMetric(30, 95),
            connectionCount: this.generateRandomMetric(50, 800),
            errorRate: this.generateRandomMetric(0, 2),
        };
        this.performanceMetrics.push(metrics);
        this.cleanupOldMetrics();
        this.analyzePerformance(metrics);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Performance metrics collected', 'NetworkPerformanceService', {
            timestamp: metrics.timestamp,
            throughput: metrics.throughput,
            latency: metrics.latency,
            bandwidthUtilization: metrics.bandwidthUtilization,
        });
        return metrics;
    }
    generateRandomMetric(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    cleanupOldMetrics() {
        if (this.performanceMetrics.length > this.maxMetricsHistory) {
            this.performanceMetrics.splice(0, this.performanceMetrics.length - this.maxMetricsHistory);
        }
    }
    analyzePerformance(metrics) {
        for (const rule of this.optimizationRules.values()) {
            if (!rule.enabled)
                continue;
            const shouldApply = this.evaluateCondition(metrics, rule);
            if (shouldApply) {
                this.applyOptimization(rule, metrics);
            }
        }
    }
    evaluateCondition(metrics, rule) {
        switch (rule.type) {
            case 'bandwidth':
                return metrics.bandwidthUtilization > rule.threshold;
            case 'latency':
                return metrics.latency > rule.threshold;
            case 'packet_loss':
                return metrics.packetLoss > rule.threshold;
            case 'connection_limit':
                return metrics.connectionCount > rule.threshold;
            case 'caching':
                return metrics.errorRate < rule.threshold;
            default:
                return false;
        }
    }
    applyOptimization(rule, metrics) {
        const action = {
            id: `opt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            ruleId: rule.id,
            type: rule.type,
            description: rule.description,
            parameters: this.getOptimizationParameters(rule, metrics),
            applied: true,
            result: 'Applied successfully',
        };
        this.optimizationActions.push(action);
        this.cleanupOldActions();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Optimization applied: ${rule.name}`, 'NetworkPerformanceService', {
            ruleId: rule.id,
            type: rule.type,
            parameters: action.parameters,
        });
    }
    getOptimizationParameters(rule, metrics) {
        switch (rule.type) {
            case 'bandwidth':
                return {
                    currentUtilization: metrics.bandwidthUtilization,
                    targetUtilization: rule.threshold - 10,
                    throttlePercentage: Math.min(20, metrics.bandwidthUtilization - rule.threshold),
                };
            case 'latency':
                return {
                    currentLatency: metrics.latency,
                    targetLatency: rule.threshold - 20,
                    routingOptimization: true,
                };
            case 'packet_loss':
                return {
                    currentLoss: metrics.packetLoss,
                    targetLoss: rule.threshold / 2,
                    retransmissionEnabled: true,
                    retryCount: 3,
                };
            case 'connection_limit':
                return {
                    currentConnections: metrics.connectionCount,
                    maxConnections: rule.threshold,
                    poolingEnabled: true,
                    poolSize: Math.min(100, metrics.connectionCount - rule.threshold),
                };
            case 'caching':
                return {
                    currentErrorRate: metrics.errorRate,
                    cacheEnabled: true,
                    cacheTTL: 300,
                    aggressiveCaching: true,
                };
            default:
                return {};
        }
    }
    cleanupOldActions() {
        if (this.optimizationActions.length > this.maxActionsHistory) {
            this.optimizationActions.splice(0, this.optimizationActions.length - this.maxActionsHistory);
        }
    }
    getPerformanceStats() {
        const now = new Date();
        const lastHour = new Date(now.getTime() - 3600000);
        const lastDay = new Date(now.getTime() - 86400000);
        const metricsLastHour = this.performanceMetrics.filter(m => m.timestamp > lastHour);
        const metricsLastDay = this.performanceMetrics.filter(m => m.timestamp > lastDay);
        const actionsLastHour = this.optimizationActions.filter(a => a.timestamp > lastHour);
        const actionsLastDay = this.optimizationActions.filter(a => a.timestamp > lastDay);
        const currentMetrics = this.performanceMetrics[this.performanceMetrics.length - 1];
        return {
            totalMetrics: this.performanceMetrics.length,
            metricsLastHour: metricsLastHour.length,
            metricsLastDay: metricsLastDay.length,
            totalOptimizations: this.optimizationActions.length,
            optimizationsLastHour: actionsLastHour.length,
            optimizationsLastDay: actionsLastDay.length,
            currentMetrics: currentMetrics
                ? {
                    throughput: currentMetrics.throughput,
                    latency: currentMetrics.latency,
                    packetLoss: currentMetrics.packetLoss,
                    bandwidthUtilization: currentMetrics.bandwidthUtilization,
                    connectionCount: currentMetrics.connectionCount,
                    errorRate: currentMetrics.errorRate,
                }
                : null,
            optimizationRules: Array.from(this.optimizationRules.values()).map(rule => ({
                id: rule.id,
                name: rule.name,
                description: rule.description,
                type: rule.type,
                threshold: rule.threshold,
                enabled: rule.enabled,
                priority: rule.priority,
            })),
            recentOptimizations: this.optimizationActions.slice(-10).map(action => ({
                id: action.id,
                timestamp: action.timestamp,
                type: action.type,
                description: action.description,
                applied: action.applied,
                result: action.result,
            })),
        };
    }
    getMetricsForPeriod(startTime, endTime) {
        return this.performanceMetrics.filter(m => m.timestamp >= startTime && m.timestamp <= endTime);
    }
    addOptimizationRule(rule) {
        const ruleId = `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newRule = {
            ...rule,
            id: ruleId,
        };
        this.optimizationRules.set(ruleId, newRule);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Optimization rule added: ${ruleId}`, 'NetworkPerformanceService');
        return ruleId;
    }
    updateOptimizationRule(ruleId, updates) {
        const rule = this.optimizationRules.get(ruleId);
        if (!rule) {
            return false;
        }
        Object.assign(rule, updates);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Optimization rule updated: ${ruleId}`, 'NetworkPerformanceService');
        return true;
    }
    removeOptimizationRule(ruleId) {
        const deleted = this.optimizationRules.delete(ruleId);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Optimization rule removed: ${ruleId}`, 'NetworkPerformanceService');
        }
        return deleted;
    }
    getOptimizationsForPeriod(startTime, endTime) {
        return this.optimizationActions.filter(a => a.timestamp >= startTime && a.timestamp <= endTime);
    }
    getOptimizationsByType(type) {
        return this.optimizationActions.filter(a => a.type === type);
    }
    getOptimizationsByRule(ruleId) {
        return this.optimizationActions.filter(a => a.ruleId === ruleId);
    }
    forceOptimization(ruleId) {
        const rule = this.optimizationRules.get(ruleId);
        if (rule?.enabled !== true) {
            return false;
        }
        const currentMetrics = this.performanceMetrics[this.performanceMetrics.length - 1];
        if (currentMetrics == null) {
            return false;
        }
        this.applyOptimization(rule, currentMetrics);
        return true;
    }
    getOptimizationRecommendations() {
        const recommendations = [];
        const currentMetrics = this.performanceMetrics[this.performanceMetrics.length - 1];
        if (!currentMetrics) {
            return recommendations;
        }
        if (currentMetrics.bandwidthUtilization > 80) {
            recommendations.push('Consider bandwidth throttling to prevent congestion');
        }
        if (currentMetrics.latency > 100) {
            recommendations.push('Optimize routing to reduce latency');
        }
        if (currentMetrics.packetLoss > 1) {
            recommendations.push('Enable packet retransmission to improve reliability');
        }
        if (currentMetrics.connectionCount > 500) {
            recommendations.push('Implement connection pooling to manage resources');
        }
        if (currentMetrics.errorRate < 0.5) {
            recommendations.push('Enable aggressive caching to improve performance');
        }
        return recommendations;
    }
    getPerformanceTrends() {
        if (this.performanceMetrics.length < 10) {
            return {};
        }
        const recentMetrics = this.performanceMetrics.slice(-10);
        const olderMetrics = this.performanceMetrics.slice(-20, -10);
        const trends = {};
        const avgRecentThroughput = recentMetrics.reduce((sum, m) => sum + m.throughput, 0) /
            recentMetrics.length;
        const avgOlderThroughput = olderMetrics.reduce((sum, m) => sum + m.throughput, 0) /
            olderMetrics.length;
        trends.throughput = {
            trend: avgRecentThroughput > avgOlderThroughput
                ? 'improving'
                : avgRecentThroughput < avgOlderThroughput
                    ? 'declining'
                    : 'stable',
            value: avgRecentThroughput,
        };
        const avgRecentLatency = recentMetrics.reduce((sum, m) => sum + m.latency, 0) /
            recentMetrics.length;
        const avgOlderLatency = olderMetrics.reduce((sum, m) => sum + m.latency, 0) / olderMetrics.length;
        trends.latency = {
            trend: avgRecentLatency < avgOlderLatency
                ? 'improving'
                : avgRecentLatency > avgOlderLatency
                    ? 'declining'
                    : 'stable',
            value: avgRecentLatency,
        };
        return trends;
    }
};
NetworkPerformanceService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], NetworkPerformanceService);



/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkSegmentationService: () => (/* binding */ NetworkSegmentationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let NetworkSegmentationService = class NetworkSegmentationService {
    constructor() {
        this.vpcConfigs = new Map();
        this.subnetConfigs = new Map();
        this.initializeNetworkSegmentation();
    }
    initializeNetworkSegmentation() {
        const mainVpc = {
            id: 'vpc-main',
            name: 'Main VPC',
            cidr: process.env.VPC_CIDR ?? '10.0.0.0/16',
            region: process.env.AWS_REGION ?? 'us-east-1',
            subnets: this.createDefaultSubnets(),
            internetGateway: true,
            natGateway: true,
            vpcFlowLogs: true,
            dnsHostnames: true,
            dnsResolution: true,
        };
        this.vpcConfigs.set(mainVpc.id, mainVpc);
        mainVpc.subnets.forEach(subnet => {
            this.subnetConfigs.set(subnet.id, subnet);
        });
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Network segmentation initialized', 'NetworkSegmentationService', {
            vpcCount: this.vpcConfigs.size,
            subnetCount: this.subnetConfigs.size,
        });
    }
    createDefaultSubnets() {
        return [
            {
                id: 'subnet-public-1a',
                name: 'Public Subnet 1A',
                cidr: '10.0.1.0/24',
                availabilityZone: 'us-east-1a',
                purpose: 'public',
                routeTable: 'rt-public',
                naclRules: this.getPublicNaclRules(),
                tags: { Environment: 'production', Purpose: 'public' },
            },
            {
                id: 'subnet-private-1a',
                name: 'Private Subnet 1A',
                cidr: '10.0.2.0/24',
                availabilityZone: 'us-east-1a',
                purpose: 'private',
                routeTable: 'rt-private',
                naclRules: this.getPrivateNaclRules(),
                tags: { Environment: 'production', Purpose: 'private' },
            },
            {
                id: 'subnet-database-1a',
                name: 'Database Subnet 1A',
                cidr: '10.0.3.0/24',
                availabilityZone: 'us-east-1a',
                purpose: 'database',
                routeTable: 'rt-private',
                naclRules: this.getDatabaseNaclRules(),
                tags: { Environment: 'production', Purpose: 'database' },
            },
            {
                id: 'subnet-management-1a',
                name: 'Management Subnet 1A',
                cidr: '10.0.4.0/24',
                availabilityZone: 'us-east-1a',
                purpose: 'management',
                routeTable: 'rt-private',
                naclRules: this.getManagementNaclRules(),
                tags: { Environment: 'production', Purpose: 'management' },
            },
        ];
    }
    getPublicNaclRules() {
        return [
            {
                ruleNumber: 100,
                protocol: 'tcp',
                portRange: '80',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'HTTP inbound',
            },
            {
                ruleNumber: 110,
                protocol: 'tcp',
                portRange: '443',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'HTTPS inbound',
            },
            {
                ruleNumber: 120,
                protocol: 'tcp',
                portRange: '22',
                source: process.env.ADMIN_IPS ?? '10.0.0.0/8',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'SSH inbound from admin',
            },
            {
                ruleNumber: 200,
                protocol: 'tcp',
                portRange: '1024-65535',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'Ephemeral ports outbound',
            },
        ];
    }
    getPrivateNaclRules() {
        return [
            {
                ruleNumber: 100,
                protocol: 'tcp',
                portRange: '22',
                source: '10.0.4.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'SSH from management',
            },
            {
                ruleNumber: 110,
                protocol: 'tcp',
                portRange: '443',
                source: '10.0.1.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'HTTPS from public',
            },
            {
                ruleNumber: 200,
                protocol: 'tcp',
                portRange: '1024-65535',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'Ephemeral ports outbound',
            },
        ];
    }
    getDatabaseNaclRules() {
        return [
            {
                ruleNumber: 100,
                protocol: 'tcp',
                portRange: '5432',
                source: '10.0.2.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'PostgreSQL from private',
            },
            {
                ruleNumber: 110,
                protocol: 'tcp',
                portRange: '6379',
                source: '10.0.2.0/24',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'Redis from private',
            },
            {
                ruleNumber: 200,
                protocol: 'tcp',
                portRange: '1024-65535',
                source: '0.0.0.0/0',
                destination: '0.0.0.0.0/0',
                action: 'allow',
                description: 'Ephemeral ports outbound',
            },
        ];
    }
    getManagementNaclRules() {
        return [
            {
                ruleNumber: 100,
                protocol: 'tcp',
                portRange: '22',
                source: process.env.ADMIN_IPS ?? '10.0.0.0/8',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'SSH from admin IPs',
            },
            {
                ruleNumber: 110,
                protocol: 'tcp',
                portRange: '3389',
                source: process.env.ADMIN_IPS ?? '10.0.0.0/8',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'RDP from admin IPs',
            },
            {
                ruleNumber: 200,
                protocol: 'tcp',
                portRange: '1024-65535',
                source: '0.0.0.0/0',
                destination: '0.0.0.0/0',
                action: 'allow',
                description: 'Ephemeral ports outbound',
            },
        ];
    }
    async checkSubnetHealth(subnetId) {
        const subnet = this.subnetConfigs.get(subnetId);
        if (!subnet) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Subnet not found: ${subnetId}`, 'NetworkSegmentationService');
            return false;
        }
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Subnet health check: ${subnetId}`, 'NetworkSegmentationService');
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Subnet health check failed: ${subnetId}`, error);
            return false;
        }
    }
    async createSubnet(vpcId, config) {
        const vpc = this.vpcConfigs.get(vpcId);
        if (!vpc) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`VPC not found: ${vpcId}`, 'NetworkSegmentationService');
            return null;
        }
        const hasConflict = vpc.subnets.some(subnet => this.isCidrOverlapping(subnet.cidr, config.cidr));
        if (hasConflict) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`CIDR conflict detected: ${config.cidr}`, 'NetworkSegmentationService');
            return null;
        }
        const subnetId = `subnet-${config.purpose}-${Date.now()}`;
        const subnet = {
            ...config,
            id: subnetId,
        };
        this.subnetConfigs.set(subnetId, subnet);
        vpc.subnets.push(subnet);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Subnet created: ${subnetId}`, 'NetworkSegmentationService', {
            vpcId,
            cidr: config.cidr,
            purpose: config.purpose,
        });
        return subnetId;
    }
    async deleteSubnet(subnetId) {
        const subnet = this.subnetConfigs.get(subnetId);
        if (!subnet) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Subnet not found: ${subnetId}`, 'NetworkSegmentationService');
            return false;
        }
        this.subnetConfigs.delete(subnetId);
        for (const vpc of this.vpcConfigs.values()) {
            const index = vpc.subnets.findIndex(s => s.id === subnetId);
            if (index !== -1) {
                vpc.subnets.splice(index, 1);
                break;
            }
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Subnet deleted: ${subnetId}`, 'NetworkSegmentationService');
        return true;
    }
    getNetworkStats() {
        return {
            vpcCount: this.vpcConfigs.size,
            subnetCount: this.subnetConfigs.size,
            vpcs: Array.from(this.vpcConfigs.values()).map(vpc => ({
                id: vpc.id,
                name: vpc.name,
                cidr: vpc.cidr,
                region: vpc.region,
                subnetCount: vpc.subnets.length,
                subnets: vpc.subnets.map(subnet => ({
                    id: subnet.id,
                    name: subnet.name,
                    cidr: subnet.cidr,
                    purpose: subnet.purpose,
                    availabilityZone: subnet.availabilityZone,
                })),
            })),
        };
    }
    isCidrOverlapping(cidr1, cidr2) {
        const [ip1, prefix1] = cidr1.split('/');
        const [ip2, prefix2] = cidr2.split('/');
        const prefix1Num = parseInt(prefix1 ?? '0');
        const prefix2Num = parseInt(prefix2 ?? '0');
        return ip1 === ip2 && prefix1Num === prefix2Num;
    }
};
NetworkSegmentationService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], NetworkSegmentationService);



/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NetworkController: () => (/* binding */ NetworkController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _api_versioning_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(165);
/* harmony import */ var _ddos_protection_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(166);
/* harmony import */ var _firewall_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(167);
/* harmony import */ var _ids_ips_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(168);
/* harmony import */ var _network_monitoring_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(169);
/* harmony import */ var _network_performance_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(170);
/* harmony import */ var _network_segmentation_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(171);
/* harmony import */ var _ssl_tls_service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(173);
/* harmony import */ var _vpn_admin_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(174);
/* harmony import */ var _ztna_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(175);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
















let NetworkController = class NetworkController {
    constructor(vpnAdminService, networkSegmentationService, ddosProtectionService, sslTlsService, apiVersioningService, networkMonitoringService, firewallService, networkPerformanceService, ztnaService, idsIpsService) {
        this.vpnAdminService = vpnAdminService;
        this.networkSegmentationService = networkSegmentationService;
        this.ddosProtectionService = ddosProtectionService;
        this.sslTlsService = sslTlsService;
        this.apiVersioningService = apiVersioningService;
        this.networkMonitoringService = networkMonitoringService;
        this.firewallService = firewallService;
        this.networkPerformanceService = networkPerformanceService;
        this.ztnaService = ztnaService;
        this.idsIpsService = idsIpsService;
    }
    async checkVpnHealth() {
        const health = await this.vpnAdminService.checkVpnHealth();
        return { health, timestamp: new Date() };
    }
    getVpnStats() {
        return this.vpnAdminService.getVpnStats();
    }
    async createVpnConnection(body) {
        const connectionId = await this.vpnAdminService.createConnection(body.userId, body.clientIp, body.userAgent);
        return { connectionId, success: connectionId != null };
    }
    getNetworkSegmentationStats() {
        return this.networkSegmentationService.getNetworkStats();
    }
    async checkSubnetHealth(subnetId) {
        const health = await this.networkSegmentationService.checkSubnetHealth(subnetId);
        return { health, subnetId, timestamp: new Date() };
    }
    getDdosStats() {
        return this.ddosProtectionService.getDdosStats();
    }
    addToWhitelist(body) {
        const added = this.ddosProtectionService.addToWhitelist(body.ipAddress);
        return {
            success: added,
            message: added ? 'IP added to whitelist' : 'IP already in whitelist',
        };
    }
    addToBlacklist(body) {
        const added = this.ddosProtectionService.addToBlacklist(body.ipAddress);
        return {
            success: added,
            message: added ? 'IP added to blacklist' : 'IP already in blacklist',
        };
    }
    getSslStats() {
        return this.sslTlsService.getSslStats();
    }
    getCertificateInfo() {
        return this.sslTlsService.getCertificateInfo();
    }
    checkCertificateExpiry() {
        return this.sslTlsService.checkCertificateExpiry();
    }
    async renewCertificate() {
        const success = await this.sslTlsService.renewCertificate();
        return {
            success,
            message: success
                ? 'Certificate renewal initiated'
                : 'Certificate renewal failed',
        };
    }
    getApiVersioningStats() {
        return this.apiVersioningService.getVersioningStats();
    }
    getVersionStatus(version) {
        return this.apiVersioningService.getVersionStatus(version);
    }
    addApiVersion(version) {
        this.apiVersioningService.addVersion(version);
        return { success: true, message: 'New API version added' };
    }
    deprecateApiVersion(version, body) {
        const sunsetDate = new Date(body.sunsetDate);
        this.apiVersioningService.deprecateVersion(version, sunsetDate);
        return { success: true, message: 'API version deprecated' };
    }
    getNetworkMonitoringStats() {
        return this.networkMonitoringService.getMonitoringStats();
    }
    async collectMetrics() {
        const metrics = await this.networkMonitoringService.collectMetrics();
        return { metrics, timestamp: new Date() };
    }
    getActiveAlerts() {
        return this.networkMonitoringService.getActiveAlerts();
    }
    resolveAlert(alertId) {
        const resolved = this.networkMonitoringService.resolveAlert(alertId);
        return {
            success: resolved,
            message: resolved ? 'Alert resolved' : 'Alert not found',
        };
    }
    getFirewallStats() {
        return this.firewallService.getFirewallStats();
    }
    async checkPacket(packet) {
        const result = await this.firewallService.checkPacket(packet);
        return result;
    }
    createSecurityGroup(group) {
        const groupId = this.firewallService.createSecurityGroup(group);
        return { groupId, success: true };
    }
    getFirewallBlockedIps() {
        return this.firewallService.getEventsByAction('deny');
    }
    getPerformanceStats() {
        return this.networkPerformanceService.getPerformanceStats();
    }
    async collectPerformanceMetrics() {
        const metrics = await this.networkPerformanceService.collectPerformanceMetrics();
        return { metrics, timestamp: new Date() };
    }
    getOptimizationRecommendations() {
        return this.networkPerformanceService.getOptimizationRecommendations();
    }
    getPerformanceTrends() {
        return this.networkPerformanceService.getPerformanceTrends();
    }
    getZtnaStats() {
        return this.ztnaService.getZtnaStats();
    }
    async createZtnaSession(sessionData) {
        const result = await this.ztnaService.createSession(sessionData);
        return result;
    }
    verifyMfa(sessionId, body) {
        const verified = this.ztnaService.verifyMfa(sessionId, body.mfaToken);
        return {
            success: verified,
            message: verified ? 'MFA verified' : 'MFA verification failed',
        };
    }
    endZtnaSession(sessionId) {
        const ended = this.ztnaService.endSession(sessionId);
        return {
            success: ended,
            message: ended ? 'Session ended' : 'Session not found',
        };
    }
    getActiveZtnaSessions() {
        return this.ztnaService.getActiveSessions();
    }
    getIdsStats() {
        return this.idsIpsService.getIdsStats();
    }
    async analyzePacket(packet) {
        const result = await this.idsIpsService.analyzePacket(packet);
        return result;
    }
    getRecentAlerts(limit = 10) {
        return this.idsIpsService.getRecentAlerts(limit);
    }
    getCriticalAlerts() {
        return this.idsIpsService.getCriticalAlerts();
    }
    getIdsBlockedIps() {
        return this.idsIpsService.getBlockedIps();
    }
    unblockIp(ip) {
        const unblocked = this.idsIpsService.unblockIp(ip);
        return {
            success: unblocked,
            message: unblocked ? 'IP unblocked' : 'IP not found',
        };
    }
    markAsFalsePositive(alertId) {
        const marked = this.idsIpsService.markAsFalsePositive(alertId);
        return {
            success: marked,
            message: marked ? 'Alert marked as false positive' : 'Alert not found',
        };
    }
    getConfigurationRecommendations() {
        return this.idsIpsService.getConfigurationRecommendations();
    }
    async getNetworkHealth() {
        const [vpnHealth, sslCertificateExpiry, ddosStats, networkStats, apiVersioningStats, monitoringStats, firewallStats, performanceStats, ztnaStats, idsStats,] = await Promise.all([
            this.vpnAdminService.checkVpnHealth(),
            this.sslTlsService.checkCertificateExpiry(),
            this.ddosProtectionService.getDdosStats(),
            this.networkSegmentationService.getNetworkStats(),
            this.apiVersioningService.getVersioningStats(),
            this.networkMonitoringService.getMonitoringStats(),
            this.firewallService.getFirewallStats(),
            this.networkPerformanceService.getPerformanceStats(),
            this.ztnaService.getZtnaStats(),
            this.idsIpsService.getIdsStats(),
        ]);
        const overallHealth = vpnHealth && sslCertificateExpiry.valid;
        return {
            overallHealth,
            timestamp: new Date(),
            services: {
                vpn: { health: vpnHealth },
                ssl: { certificateExpiry: sslCertificateExpiry },
                ddos: { stats: ddosStats },
                network: { stats: networkStats },
                apiVersioning: { stats: apiVersioningStats },
                monitoring: { stats: monitoringStats },
                firewall: { stats: firewallStats },
                performance: { stats: performanceStats },
                ztna: { stats: ztnaStats },
                idsIps: { stats: idsStats },
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vpn/health'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check VPN health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'VPN health status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "checkVpnHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vpn/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get VPN statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'VPN statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getVpnStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('vpn/connections'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create VPN connection' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'VPN connection created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "createVpnConnection", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('segmentation/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network segmentation statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Network segmentation statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getNetworkSegmentationStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('segmentation/subnets/:subnetId/health'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check subnet health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Subnet health status' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('subnetId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "checkSubnetHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ddos/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get DDoS protection statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'DDoS protection statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getDdosStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ddos/whitelist'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add IP to whitelist' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'IP added to whitelist' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "addToWhitelist", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ddos/blacklist'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add IP to blacklist' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'IP added to blacklist' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "addToBlacklist", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ssl/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get SSL/TLS statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'SSL/TLS statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getSslStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ssl/certificate'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get certificate information' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate information' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getCertificateInfo", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ssl/certificate/expiry'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check certificate expiry' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate expiry status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "checkCertificateExpiry", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ssl/certificate/renew'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Renew certificate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Certificate renewal initiated' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "renewCertificate", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('api/versions'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get API versioning statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'API versioning statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getApiVersioningStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('api/versions/:version/status'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get version status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Version status' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('version')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getVersionStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('api/versions'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add new API version' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'New API version added' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "addApiVersion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('api/versions/:version/deprecate'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Deprecate API version' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'API version deprecated' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('version')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "deprecateApiVersion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network monitoring statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Network monitoring statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getNetworkMonitoringStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('monitoring/metrics/collect'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Collect network metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Network metrics collected' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "collectMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('monitoring/alerts'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get active network alerts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Active network alerts' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getActiveAlerts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('monitoring/alerts/:alertId/resolve'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Resolve network alert' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Alert resolved' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('alertId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "resolveAlert", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('firewall/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get firewall statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Firewall statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getFirewallStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('firewall/packet/check'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check packet through firewall' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Packet check result' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "checkPacket", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('firewall/security-groups'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create security group' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Security group created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "createSecurityGroup", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('firewall/blocked-ips'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get blocked IP addresses from firewall' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Blocked IP addresses from firewall',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getFirewallBlockedIps", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get network performance statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Network performance statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getPerformanceStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('performance/metrics/collect'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Collect performance metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Performance metrics collected' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "collectPerformanceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/recommendations'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance optimization recommendations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Performance recommendations' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getOptimizationRecommendations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('performance/trends'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance trends' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Performance trends' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getPerformanceTrends", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ztna/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get ZTNA statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'ZTNA statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getZtnaStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ztna/sessions'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create ZTNA session' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'ZTNA session created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "createZtnaSession", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ztna/sessions/:sessionId/verify-mfa'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Verify MFA for ZTNA session' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'MFA verification result' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('sessionId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "verifyMfa", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('ztna/sessions/:sessionId'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'End ZTNA session' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'ZTNA session ended' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('sessionId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "endZtnaSession", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ztna/sessions/active'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get active ZTNA sessions' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Active ZTNA sessions' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getActiveZtnaSessions", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ids-ips/stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get IDS/IPS statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'IDS/IPS statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getIdsStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ids-ips/packet/analyze'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Analyze packet for threats' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Packet analysis result' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "analyzePacket", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ids-ips/alerts/recent'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get recent IDS/IPS alerts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Recent IDS/IPS alerts' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getRecentAlerts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ids-ips/alerts/critical'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get critical IDS/IPS alerts' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Critical IDS/IPS alerts' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getCriticalAlerts", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ids-ips/blocked-ips'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get blocked IP addresses from IDS/IPS' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Blocked IP addresses from IDS/IPS',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getIdsBlockedIps", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ids-ips/blocked-ips/:ip/unblock'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Unblock IP address' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'IP unblocked' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('ip')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "unblockIp", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('ids-ips/alerts/:alertId/false-positive'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Mark alert as false positive' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Alert marked as false positive' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('alertId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "markAsFalsePositive", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('ids-ips/recommendations'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get IDS/IPS configuration recommendations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Configuration recommendations' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NetworkController.prototype, "getConfigurationRecommendations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get overall network health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Overall network health status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NetworkController.prototype, "getNetworkHealth", null);
NetworkController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Network Management'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('network'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _vpn_admin_service__WEBPACK_IMPORTED_MODULE_14__.VpnAdminService !== "undefined" && _vpn_admin_service__WEBPACK_IMPORTED_MODULE_14__.VpnAdminService) === "function" ? _a : Object, typeof (_b = typeof _network_segmentation_service__WEBPACK_IMPORTED_MODULE_12__.NetworkSegmentationService !== "undefined" && _network_segmentation_service__WEBPACK_IMPORTED_MODULE_12__.NetworkSegmentationService) === "function" ? _b : Object, typeof (_c = typeof _ddos_protection_service__WEBPACK_IMPORTED_MODULE_7__.DdosProtectionService !== "undefined" && _ddos_protection_service__WEBPACK_IMPORTED_MODULE_7__.DdosProtectionService) === "function" ? _c : Object, typeof (_d = typeof _ssl_tls_service__WEBPACK_IMPORTED_MODULE_13__.SslTlsService !== "undefined" && _ssl_tls_service__WEBPACK_IMPORTED_MODULE_13__.SslTlsService) === "function" ? _d : Object, typeof (_e = typeof _api_versioning_service__WEBPACK_IMPORTED_MODULE_6__.ApiVersioningService !== "undefined" && _api_versioning_service__WEBPACK_IMPORTED_MODULE_6__.ApiVersioningService) === "function" ? _e : Object, typeof (_f = typeof _network_monitoring_service__WEBPACK_IMPORTED_MODULE_10__.NetworkMonitoringService !== "undefined" && _network_monitoring_service__WEBPACK_IMPORTED_MODULE_10__.NetworkMonitoringService) === "function" ? _f : Object, typeof (_g = typeof _firewall_service__WEBPACK_IMPORTED_MODULE_8__.FirewallService !== "undefined" && _firewall_service__WEBPACK_IMPORTED_MODULE_8__.FirewallService) === "function" ? _g : Object, typeof (_h = typeof _network_performance_service__WEBPACK_IMPORTED_MODULE_11__.NetworkPerformanceService !== "undefined" && _network_performance_service__WEBPACK_IMPORTED_MODULE_11__.NetworkPerformanceService) === "function" ? _h : Object, typeof (_j = typeof _ztna_service__WEBPACK_IMPORTED_MODULE_15__.ZtnaService !== "undefined" && _ztna_service__WEBPACK_IMPORTED_MODULE_15__.ZtnaService) === "function" ? _j : Object, typeof (_k = typeof _ids_ips_service__WEBPACK_IMPORTED_MODULE_9__.IdsIpsService !== "undefined" && _ids_ips_service__WEBPACK_IMPORTED_MODULE_9__.IdsIpsService) === "function" ? _k : Object])
], NetworkController);



/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SslTlsService: () => (/* binding */ SslTlsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let SslTlsService = class SslTlsService {
    constructor() {
        this.connectionStats = new Map();
        this.handshakeTimes = [];
        this.certificateInfo = null;
        this.config = {
            enabled: process.env.SSL_ENABLED === 'true',
            certificatePath: process.env.SSL_CERT_PATH ?? '/etc/ssl/certs/server.crt',
            privateKeyPath: process.env.SSL_KEY_PATH ?? '/etc/ssl/private/server.key',
            caBundlePath: process.env.SSL_CA_BUNDLE_PATH ?? '/etc/ssl/certs/ca-bundle.crt',
            protocols: process.env.SSL_PROTOCOLS?.split(',') ?? [
                'TLSv1.3',
                'TLSv1.2',
            ],
            ciphers: process.env.SSL_CIPHERS?.split(',') ?? [
                'ECDHE-ECDSA-AES256-GCM-SHA384',
                'ECDHE-RSA-AES256-GCM-SHA384',
                'ECDHE-ECDSA-CHACHA20-POLY1305',
                'ECDHE-RSA-CHACHA20-POLY1305',
            ],
            hstsEnabled: process.env.SSL_HSTS_ENABLED === 'true',
            hstsMaxAge: parseInt(process.env.SSL_HSTS_MAX_AGE ?? '31536000'),
            ocspStapling: process.env.SSL_OCSP_STAPLING === 'true',
            sessionCache: process.env.SSL_SESSION_CACHE === 'true',
            sessionTimeout: parseInt(process.env.SSL_SESSION_TIMEOUT ?? '300'),
            certificateRenewalDays: parseInt(process.env.SSL_CERT_RENEWAL_DAYS ?? '30'),
        };
        if (this.config.enabled) {
            this.loadCertificateInfo();
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('SSL/TLS Service initialized', 'SslTlsService', {
                protocols: this.config.protocols,
                hstsEnabled: this.config.hstsEnabled,
                ocspStapling: this.config.ocspStapling,
            });
        }
    }
    loadCertificateInfo() {
        try {
            this.certificateInfo = {
                subject: 'CN=example.com',
                issuer: 'CN=Example CA',
                validFrom: new Date(),
                validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
                serialNumber: '1234567890',
                fingerprint: 'sha256:abcdef1234567890',
                keySize: 2048,
                signatureAlgorithm: 'sha256WithRSAEncryption',
            };
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('Certificate info loaded', 'SslTlsService');
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Failed to load certificate info', error);
        }
    }
    async validateConnection(request) {
        if (!this.config.enabled) {
            return { valid: true };
        }
        const { protocol, cipher, clientIp } = request;
        if (!this.config.protocols.includes(protocol)) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Unsupported protocol: ${protocol} from ${clientIp}`, 'SslTlsService');
            return { valid: false, reason: 'Unsupported protocol' };
        }
        if (!this.config.ciphers.includes(cipher)) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Unsupported cipher: ${cipher} from ${clientIp}`, 'SslTlsService');
            return { valid: false, reason: 'Unsupported cipher' };
        }
        this.updateConnectionStats(protocol, cipher);
        const securityHeaders = this.generateSecurityHeaders();
        return { valid: true, headers: securityHeaders };
    }
    updateConnectionStats(protocol, cipher) {
        const protocolCount = this.connectionStats.get(`protocol:${protocol}`) ?? 0;
        this.connectionStats.set(`protocol:${protocol}`, protocolCount + 1);
        const cipherCount = this.connectionStats.get(`cipher:${cipher}`) ?? 0;
        this.connectionStats.set(`cipher:${cipher}`, cipherCount + 1);
        const totalConnections = this.connectionStats.get('total') ?? 0;
        this.connectionStats.set('total', totalConnections + 1);
    }
    generateSecurityHeaders() {
        const headers = {};
        if (this.config.hstsEnabled) {
            headers['Strict-Transport-Security'] =
                `max-age=${this.config.hstsMaxAge}; includeSubDomains; preload`;
        }
        headers['X-Content-Type-Options'] = 'nosniff';
        headers['X-Frame-Options'] = 'DENY';
        headers['X-XSS-Protection'] = '1; mode=block';
        headers['Referrer-Policy'] = 'strict-origin-when-cross-origin';
        headers['Content-Security-Policy'] =
            "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'";
        return headers;
    }
    checkCertificateExpiry() {
        if (!this.certificateInfo) {
            return { valid: false, daysUntilExpiry: 0, warning: true };
        }
        const now = new Date();
        const daysUntilExpiry = Math.ceil((this.certificateInfo.validTo.getTime() - now.getTime()) /
            (1000 * 60 * 60 * 24));
        const warning = daysUntilExpiry <= this.config.certificateRenewalDays;
        const valid = daysUntilExpiry > 0;
        if (warning) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Certificate expires in ${daysUntilExpiry} days`, 'SslTlsService');
        }
        return { valid, daysUntilExpiry, warning };
    }
    async renewCertificate() {
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Certificate renewal initiated', 'SslTlsService');
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('Certificate renewal failed', error);
            return false;
        }
    }
    getSslStats() {
        const protocolUsage = {};
        const cipherUsage = {};
        for (const [key, count] of this.connectionStats.entries()) {
            if (key.startsWith('protocol:')) {
                const protocol = key.replace('protocol:', '');
                protocolUsage[protocol] = count;
            }
            else if (key.startsWith('cipher:')) {
                const cipher = key.replace('cipher:', '');
                cipherUsage[cipher] = count;
            }
        }
        const certificateExpiry = this.checkCertificateExpiry();
        return {
            totalConnections: this.connectionStats.get('total') ?? 0,
            activeConnections: this.connectionStats.get('active') ?? 0,
            handshakeTime: this.calculateAverageHandshakeTime(),
            certificateExpiryDays: certificateExpiry.daysUntilExpiry,
            protocolUsage,
            cipherUsage,
        };
    }
    calculateAverageHandshakeTime() {
        if (this.handshakeTimes.length === 0)
            return 0;
        const sum = this.handshakeTimes.reduce((acc, time) => acc + time, 0);
        return sum / this.handshakeTimes.length;
    }
    validateConfiguration() {
        const issues = [];
        if (this.config.enabled) {
        }
        if (this.config.protocols.length === 0) {
            issues.push('No SSL protocols configured');
        }
        if (this.config.ciphers.length === 0) {
            issues.push('No SSL ciphers configured');
        }
        if (this.config.hstsEnabled && this.config.hstsMaxAge <= 0) {
            issues.push('Invalid HSTS max age');
        }
        return {
            valid: issues.length === 0,
            issues,
        };
    }
    getCertificateInfo() {
        return this.certificateInfo;
    }
    updateConfiguration(newConfig) {
        Object.assign(this.config, newConfig);
        if ((newConfig.certificatePath != null && newConfig.certificatePath !== '') ||
            (newConfig.privateKeyPath != null && newConfig.privateKeyPath !== '')) {
            this.loadCertificateInfo();
        }
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('SSL/TLS configuration updated', 'SslTlsService');
    }
};
SslTlsService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SslTlsService);



/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VpnAdminService: () => (/* binding */ VpnAdminService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let VpnAdminService = class VpnAdminService {
    constructor() {
        this.activeConnections = new Map();
        this._connectionAttempts = new Map();
        this.config = {
            enabled: process.env.VPN_ENABLED === 'true',
            server: process.env.VPN_SERVER ?? 'vpn.admin.local',
            port: parseInt(process.env.VPN_PORT ?? '1194'),
            protocol: process.env.VPN_PROTOCOL ??
                'openvpn',
            certificatePath: process.env.VPN_CERT_PATH ?? '/etc/vpn/certs',
            allowedNetworks: process.env.VPN_ALLOWED_NETWORKS?.split(',') ?? [
                '10.0.0.0/8',
                '172.16.0.0/12',
            ],
            maxConnections: parseInt(process.env.VPN_MAX_CONNECTIONS ?? '50'),
            idleTimeout: parseInt(process.env.VPN_IDLE_TIMEOUT ?? '3600'),
            mfaRequired: process.env.VPN_MFA_REQUIRED === 'true',
        };
        void this._connectionAttempts;
        if (this.config.enabled) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('VPN Admin Service initialized', 'VpnAdminService', {
                server: this.config.server,
                protocol: this.config.protocol,
                maxConnections: this.config.maxConnections,
            });
        }
    }
    async checkVpnHealth() {
        if (!this.config.enabled)
            return false;
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug('VPN health check performed', 'VpnAdminService');
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error('VPN health check failed', error);
            return false;
        }
    }
    async authenticateUser(userId, credentials) {
        if (!this.config.enabled)
            return false;
        try {
            if (this.config.mfaRequired === true &&
                (credentials.mfaToken == null || credentials.mfaToken === '')) {
                _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`MFA required for VPN access: ${userId}`);
                return false;
            }
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`VPN authentication for user: ${userId}`, 'VpnAdminService');
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`VPN authentication failed for user: ${userId}`, error);
            return false;
        }
    }
    async createConnection(userId, clientIp, userAgent) {
        if (!this.config.enabled)
            return null;
        if (this.activeConnections.size >= this.config.maxConnections) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn('VPN connection limit reached', 'VpnAdminService');
            return null;
        }
        const isAllowedNetwork = this.allowedNetworks.some(network => this.isIpInNetwork(clientIp, network));
        if (!isAllowedNetwork) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`VPN access denied from IP: ${clientIp}`, 'VpnAdminService');
            return null;
        }
        const connectionId = this.generateConnectionId();
        const connection = {
            id: connectionId,
            userId,
            ipAddress: clientIp,
            connectedAt: new Date(),
            lastActivity: new Date(),
            userAgent,
        };
        this.activeConnections.set(connectionId, connection);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`VPN connection created: ${connectionId} for user: ${userId}`, 'VpnAdminService');
        return connectionId;
    }
    async closeConnection(connectionId) {
        if (!this.config.enabled)
            return false;
        const connection = this.activeConnections.get(connectionId);
        if (!connection) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`VPN connection not found: ${connectionId}`, 'VpnAdminService');
            return false;
        }
        this.activeConnections.delete(connectionId);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`VPN connection closed: ${connectionId}`, 'VpnAdminService');
        return true;
    }
    updateActivity(connectionId) {
        const connection = this.activeConnections.get(connectionId);
        if (connection) {
            connection.lastActivity = new Date();
        }
    }
    async cleanupIdleConnections() {
        if (!this.config.enabled)
            return 0;
        const now = new Date();
        const cutoff = new Date(now.getTime() - this.config.idleTimeout * 1000);
        let closedCount = 0;
        for (const [connectionId, connection] of this.activeConnections.entries()) {
            if (connection.lastActivity < cutoff) {
                await this.closeConnection(connectionId);
                closedCount++;
            }
        }
        if (closedCount > 0) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Cleaned up ${closedCount} idle VPN connections`, 'VpnAdminService');
        }
        return closedCount;
    }
    getVpnStats() {
        return {
            enabled: this.config.enabled,
            activeConnections: this.activeConnections.size,
            maxConnections: this.config.maxConnections,
            server: this.config.server,
            protocol: this.config.protocol,
            connections: Array.from(this.activeConnections.values()).map(conn => ({
                id: conn.id,
                userId: conn.userId,
                ipAddress: conn.ipAddress,
                connectedAt: conn.connectedAt,
                lastActivity: conn.lastActivity,
            })),
        };
    }
    generateConnectionId() {
        return `vpn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    isIpInNetwork(ip, network) {
        const [networkIp, prefix] = network.split('/');
        const prefixNum = parseInt(prefix ?? '0');
        return (networkIp != null &&
            ip.startsWith(networkIp
                .split('.')
                .slice(0, prefixNum / 8)
                .join('.')));
    }
    get allowedNetworks() {
        return this.config.allowedNetworks;
    }
};
VpnAdminService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], VpnAdminService);



/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZtnaService: () => (/* binding */ ZtnaService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ZtnaService = class ZtnaService {
    constructor() {
        this.policies = new Map();
        this.sessions = new Map();
        this.events = [];
        this.maxEventsHistory = 10000;
        this.initializeDefaultPolicies();
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('ZTNA Service initialized', 'ZtnaService');
    }
    initializeDefaultPolicies() {
        const defaultPolicies = [
            {
                id: 'policy-admin-access',
                name: 'Admin Access Policy',
                description: 'Restrict admin access to trusted devices and locations',
                type: 'user',
                conditions: [
                    { field: 'user_role', operator: 'equals', value: 'admin' },
                    { field: 'device_trust_level', operator: 'equals', value: 'high' },
                    { field: 'location', operator: 'in', value: ['office', 'home'] },
                ],
                actions: [
                    { type: 'require_mfa', parameters: { method: 'totp' } },
                    { type: 'log', parameters: { level: 'info' } },
                ],
                priority: 1,
                enabled: true,
                tags: { Environment: 'production', Purpose: 'admin' },
            },
            {
                id: 'policy-device-compliance',
                name: 'Device Compliance Policy',
                description: 'Ensure devices meet security requirements',
                type: 'device',
                conditions: [
                    { field: 'os_version', operator: 'greater_than', value: '10.0' },
                    { field: 'antivirus_status', operator: 'equals', value: 'updated' },
                    { field: 'encryption_enabled', operator: 'equals', value: 'true' },
                ],
                actions: [
                    { type: 'allow', parameters: {} },
                    { type: 'log', parameters: { level: 'info' } },
                ],
                priority: 2,
                enabled: true,
                tags: { Environment: 'production', Purpose: 'compliance' },
            },
            {
                id: 'policy-high-risk-locations',
                name: 'High Risk Location Policy',
                description: 'Additional security for high-risk locations',
                type: 'network',
                conditions: [
                    { field: 'location_risk', operator: 'equals', value: 'high' },
                    { field: 'connection_type', operator: 'equals', value: 'public' },
                ],
                actions: [
                    { type: 'require_mfa', parameters: { method: 'sms' } },
                    { type: 'limit_bandwidth', parameters: { limit: '10mbps' } },
                    { type: 'log', parameters: { level: 'warning' } },
                ],
                priority: 3,
                enabled: true,
                tags: { Environment: 'production', Purpose: 'security' },
            },
            {
                id: 'policy-application-access',
                name: 'Application Access Policy',
                description: 'Control access to sensitive applications',
                type: 'application',
                conditions: [
                    {
                        field: 'application_sensitivity',
                        operator: 'equals',
                        value: 'high',
                    },
                    { field: 'user_clearance', operator: 'greater_than', value: 3 },
                ],
                actions: [
                    { type: 'require_mfa', parameters: { method: 'hardware_token' } },
                    { type: 'log', parameters: { level: 'info' } },
                ],
                priority: 4,
                enabled: true,
                tags: { Environment: 'production', Purpose: 'application' },
            },
        ];
        defaultPolicies.forEach(policy => {
            this.policies.set(policy.id, policy);
        });
    }
    async createSession(sessionData) {
        const { userId, deviceId, applicationId, ipAddress, userAgent, location, deviceInfo, userInfo, } = sessionData;
        const riskScore = this.calculateRiskScore(deviceInfo, userInfo, location);
        const trustLevel = this.determineTrustLevel(riskScore);
        const policyResult = this.evaluatePolicies({
            userId,
            deviceId,
            applicationId,
            ipAddress,
            userAgent,
            location,
            deviceInfo,
            userInfo,
            riskScore,
            trustLevel,
        });
        const sessionId = `ztna_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const mfaRequired = policyResult.actions.some(action => action.type === 'require_mfa');
        if (policyResult.accessGranted) {
            const session = {
                id: sessionId,
                userId,
                deviceId,
                applicationId,
                ipAddress,
                userAgent,
                location,
                riskScore,
                trustLevel,
                startedAt: new Date(),
                lastActivity: new Date(),
                policies: policyResult.appliedPolicies,
                mfaVerified: !mfaRequired,
                active: true,
            };
            this.sessions.set(sessionId, session);
            this.logEvent(sessionId, userId, 'session_start', {
                deviceId,
                applicationId,
                ipAddress,
                location,
                riskScore,
                trustLevel,
                policies: policyResult.appliedPolicies,
            }, riskScore);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`ZTNA session created: ${sessionId}`, 'ZtnaService', {
                userId,
                riskScore,
                trustLevel,
                mfaRequired,
            });
        }
        return {
            sessionId,
            accessGranted: policyResult.accessGranted,
            reason: policyResult.reason,
            mfaRequired,
        };
    }
    calculateRiskScore(deviceInfo, userInfo, location) {
        let riskScore = 0;
        if (deviceInfo.os_version != null &&
            typeof deviceInfo.os_version === 'string') {
            const osVersion = parseFloat(deviceInfo.os_version);
            if (osVersion < 10.0)
                riskScore += 20;
            if (osVersion < 12.0)
                riskScore += 10;
        }
        if (deviceInfo.antivirus_status !== 'updated')
            riskScore += 15;
        if (deviceInfo.encryption_enabled !== true)
            riskScore += 25;
        if (userInfo.last_login_days != null &&
            typeof userInfo.last_login_days === 'number') {
            if (userInfo.last_login_days > 30)
                riskScore += 10;
        }
        if (userInfo.failed_attempts != null &&
            typeof userInfo.failed_attempts === 'number') {
            if (userInfo.failed_attempts > 3)
                riskScore += 20;
        }
        if (location === 'public')
            riskScore += 30;
        if (location === 'unknown')
            riskScore += 40;
        return Math.min(100, riskScore);
    }
    determineTrustLevel(riskScore) {
        if (riskScore <= 20)
            return 'high';
        if (riskScore <= 50)
            return 'medium';
        return 'low';
    }
    evaluatePolicies(context) {
        const sortedPolicies = Array.from(this.policies.values())
            .filter(policy => policy.enabled)
            .sort((a, b) => a.priority - b.priority);
        const appliedPolicies = [];
        const actions = [];
        for (const policy of sortedPolicies) {
            if (this.matchesPolicy(context, policy)) {
                appliedPolicies.push(policy.id);
                actions.push(...policy.actions);
                const denyAction = policy.actions.find(action => action.type === 'deny');
                if (denyAction) {
                    return {
                        accessGranted: false,
                        reason: `Policy ${policy.name} denied access`,
                        actions,
                        appliedPolicies,
                    };
                }
            }
        }
        if (appliedPolicies.length === 0) {
            actions.push({ type: 'log', parameters: { level: 'info' } });
        }
        return {
            accessGranted: true,
            reason: 'Access granted based on policies',
            actions,
            appliedPolicies,
        };
    }
    matchesPolicy(context, policy) {
        for (const condition of policy.conditions) {
            if (!this.evaluateCondition(context, condition)) {
                return false;
            }
        }
        return true;
    }
    evaluateCondition(context, condition) {
        const fieldValue = this.getFieldValue(context, condition.field);
        switch (condition.operator) {
            case 'equals':
                return fieldValue === condition.value;
            case 'contains':
                return (typeof fieldValue === 'string' &&
                    fieldValue.includes(condition.value));
            case 'starts_with':
                return (typeof fieldValue === 'string' &&
                    fieldValue.startsWith(condition.value));
            case 'ends_with':
                return (typeof fieldValue === 'string' &&
                    fieldValue.endsWith(condition.value));
            case 'in':
                return (Array.isArray(condition.value) &&
                    condition.value.includes(fieldValue));
            case 'not_in':
                return (Array.isArray(condition.value) &&
                    !condition.value.includes(fieldValue));
            case 'greater_than':
                return (typeof fieldValue === 'number' &&
                    fieldValue > condition.value);
            case 'less_than':
                return (typeof fieldValue === 'number' &&
                    fieldValue < condition.value);
            default:
                return false;
        }
    }
    getFieldValue(context, field) {
        const fieldMap = {
            user_role: 'userInfo.role',
            device_trust_level: 'trustLevel',
            location: 'location',
            os_version: 'deviceInfo.os_version',
            antivirus_status: 'deviceInfo.antivirus_status',
            encryption_enabled: 'deviceInfo.encryption_enabled',
            location_risk: 'location',
            connection_type: 'location',
            application_sensitivity: 'applicationId',
            user_clearance: 'userInfo.clearance_level',
        };
        const path = fieldMap[field] ?? field;
        return this.getNestedValue(context, path);
    }
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => {
            if (current != null &&
                typeof current === 'object' &&
                !Array.isArray(current)) {
                return current[key];
            }
            return undefined;
        }, obj);
    }
    logEvent(sessionId, userId, eventType, details, riskScore) {
        const event = {
            id: `ztna_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            sessionId,
            userId,
            eventType,
            details,
            riskScore,
        };
        this.events.push(event);
        this.cleanupOldEvents();
    }
    cleanupOldEvents() {
        if (this.events.length > this.maxEventsHistory) {
            this.events.splice(0, this.events.length - this.maxEventsHistory);
        }
    }
    updateSessionActivity(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session != null && session.active === true) {
            session.lastActivity = new Date();
            return true;
        }
        return false;
    }
    endSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session != null && session.active === true) {
            session.active = false;
            this.logEvent(sessionId, session.userId, 'session_end', {
                duration: Date.now() - session.startedAt.getTime(),
            }, session.riskScore);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`ZTNA session ended: ${sessionId}`, 'ZtnaService');
            return true;
        }
        return false;
    }
    verifyMfa(sessionId, _mfaToken) {
        const session = this.sessions.get(sessionId);
        if (session != null && session.active === true) {
            session.mfaVerified = true;
            this.logEvent(sessionId, session.userId, 'mfa_required', {
                verified: true,
                method: 'totp',
            }, session.riskScore);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`MFA verified for session: ${sessionId}`, 'ZtnaService');
            return true;
        }
        return false;
    }
    getZtnaStats() {
        const now = new Date();
        const lastHour = new Date(now.getTime() - 3600000);
        const lastDay = new Date(now.getTime() - 86400000);
        const activeSessions = Array.from(this.sessions.values()).filter(s => s.active);
        const eventsLastHour = this.events.filter(e => e.timestamp > lastHour);
        const eventsLastDay = this.events.filter(e => e.timestamp > lastDay);
        const sessionsByTrustLevel = {
            high: activeSessions.filter(s => s.trustLevel === 'high').length,
            medium: activeSessions.filter(s => s.trustLevel === 'medium').length,
            low: activeSessions.filter(s => s.trustLevel === 'low').length,
        };
        return {
            totalPolicies: this.policies.size,
            activeSessions: activeSessions.length,
            totalSessions: this.sessions.size,
            sessionsByTrustLevel,
            totalEvents: this.events.length,
            eventsLastHour: eventsLastHour.length,
            eventsLastDay: eventsLastDay.length,
            policies: Array.from(this.policies.values()).map(policy => ({
                id: policy.id,
                name: policy.name,
                description: policy.description,
                type: policy.type,
                priority: policy.priority,
                enabled: policy.enabled,
            })),
            recentSessions: activeSessions.slice(-10).map(session => ({
                id: session.id,
                userId: session.userId,
                applicationId: session.applicationId,
                location: session.location,
                trustLevel: session.trustLevel,
                riskScore: session.riskScore,
                startedAt: session.startedAt,
                mfaVerified: session.mfaVerified,
            })),
            recentEvents: this.events.slice(-10).map(event => ({
                id: event.id,
                timestamp: event.timestamp,
                eventType: event.eventType,
                userId: event.userId,
                riskScore: event.riskScore,
            })),
        };
    }
    addPolicy(policy) {
        const policyId = `policy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newPolicy = {
            ...policy,
            id: policyId,
        };
        this.policies.set(policyId, newPolicy);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`ZTNA policy added: ${policyId}`, 'ZtnaService');
        return policyId;
    }
    updatePolicy(policyId, updates) {
        const policy = this.policies.get(policyId);
        if (!policy) {
            return false;
        }
        Object.assign(policy, updates);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`ZTNA policy updated: ${policyId}`, 'ZtnaService');
        return true;
    }
    removePolicy(policyId) {
        const deleted = this.policies.delete(policyId);
        if (deleted) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`ZTNA policy removed: ${policyId}`, 'ZtnaService');
        }
        return deleted;
    }
    getEventsForPeriod(startTime, endTime) {
        return this.events.filter(e => e.timestamp >= startTime && e.timestamp <= endTime);
    }
    getEventsByType(eventType) {
        return this.events.filter(e => e.eventType === eventType);
    }
    getSessionsByUser(userId) {
        return Array.from(this.sessions.values()).filter(s => s.userId === userId);
    }
    getActiveSessions() {
        return Array.from(this.sessions.values()).filter(s => s.active);
    }
};
ZtnaService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ZtnaService);



/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservabilityModule: () => (/* binding */ ObservabilityModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _controllers_ai_observability_analyzer_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(177);
/* harmony import */ var _controllers_dynamic_scaling_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _controllers_incident_simulation_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(183);
/* harmony import */ var _middleware_logging_middleware__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(185);
/* harmony import */ var _observability_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(189);
/* harmony import */ var _observability_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(190);
/* harmony import */ var _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(178);
/* harmony import */ var _services_dashboard_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(193);
/* harmony import */ var _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(182);
/* harmony import */ var _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(186);
/* harmony import */ var _services_health_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(192);
/* harmony import */ var _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(184);
/* harmony import */ var _services_jaeger_service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(194);
/* harmony import */ var _services_logging_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(179);
/* harmony import */ var _services_metrics_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(180);
/* harmony import */ var _services_tracing_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(191);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

















let ObservabilityModule = class ObservabilityModule {
};
ObservabilityModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        controllers: [
            _observability_controller__WEBPACK_IMPORTED_MODULE_5__.ObservabilityController,
            _controllers_ai_observability_analyzer_controller__WEBPACK_IMPORTED_MODULE_1__.AIObservabilityAnalyzerController,
            _controllers_incident_simulation_controller__WEBPACK_IMPORTED_MODULE_3__.IncidentSimulationController,
            _controllers_dynamic_scaling_controller__WEBPACK_IMPORTED_MODULE_2__.DynamicScalingController,
        ],
        providers: [
            _observability_service__WEBPACK_IMPORTED_MODULE_6__.ObservabilityService,
            _services_metrics_service__WEBPACK_IMPORTED_MODULE_15__.MetricsService,
            _services_logging_service__WEBPACK_IMPORTED_MODULE_14__.LoggingService,
            _services_tracing_service__WEBPACK_IMPORTED_MODULE_16__.TracingService,
            _services_health_service__WEBPACK_IMPORTED_MODULE_11__.HealthService,
            _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_10__.ElasticsearchService,
            _services_dashboard_service__WEBPACK_IMPORTED_MODULE_8__.DashboardService,
            _services_jaeger_service__WEBPACK_IMPORTED_MODULE_13__.JaegerService,
            _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_7__.AIObservabilityAnalyzerService,
            _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_12__.IncidentSimulationService,
            _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_9__.DynamicScalingService,
            _middleware_logging_middleware__WEBPACK_IMPORTED_MODULE_4__.LoggingMiddleware,
        ],
        exports: [
            _observability_service__WEBPACK_IMPORTED_MODULE_6__.ObservabilityService,
            _services_metrics_service__WEBPACK_IMPORTED_MODULE_15__.MetricsService,
            _services_logging_service__WEBPACK_IMPORTED_MODULE_14__.LoggingService,
            _services_tracing_service__WEBPACK_IMPORTED_MODULE_16__.TracingService,
            _services_health_service__WEBPACK_IMPORTED_MODULE_11__.HealthService,
            _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_10__.ElasticsearchService,
            _services_dashboard_service__WEBPACK_IMPORTED_MODULE_8__.DashboardService,
            _services_jaeger_service__WEBPACK_IMPORTED_MODULE_13__.JaegerService,
            _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_7__.AIObservabilityAnalyzerService,
            _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_12__.IncidentSimulationService,
            _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_9__.DynamicScalingService,
            _middleware_logging_middleware__WEBPACK_IMPORTED_MODULE_4__.LoggingMiddleware,
        ],
    })
], ObservabilityModule);



/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIObservabilityAnalyzerController: () => (/* binding */ AIObservabilityAnalyzerController),
/* harmony export */   AnalyzeLogsDto: () => (/* binding */ AnalyzeLogsDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(178);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;







class AnalyzeLogsDto {
}
let AIObservabilityAnalyzerController = class AIObservabilityAnalyzerController {
    constructor(aiObservabilityAnalyzerService) {
        this.aiObservabilityAnalyzerService = aiObservabilityAnalyzerService;
    }
    async analyzeLogs(startTime, endTime) {
        const timeRange = {
            start: startTime != null && startTime !== ''
                ? new Date(startTime)
                : new Date(Date.now() - 24 * 60 * 60 * 1000),
            end: endTime != null && endTime !== '' ? new Date(endTime) : new Date(),
        };
        const analysis = await this.aiObservabilityAnalyzerService.analyzeLogs(timeRange);
        return {
            success: true,
            data: {
                analysis,
                timeRange,
                summary: {
                    totalLogs: analysis.length,
                    criticalLogs: analysis.filter(log => log.severity === 'CRITICAL')
                        .length,
                    highLogs: analysis.filter(log => log.severity === 'HIGH').length,
                    mediumLogs: analysis.filter(log => log.severity === 'MEDIUM').length,
                    lowLogs: analysis.filter(log => log.severity === 'LOW').length,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
    async analyzeMetrics() {
        const analysis = await this.aiObservabilityAnalyzerService.analyzeMetrics();
        return {
            success: true,
            data: {
                analysis,
                summary: {
                    totalMetrics: analysis.length,
                    criticalMetrics: analysis.filter(metric => metric.status === 'CRITICAL').length,
                    warningMetrics: analysis.filter(metric => metric.status === 'WARNING')
                        .length,
                    normalMetrics: analysis.filter(metric => metric.status === 'NORMAL')
                        .length,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
    async generateInsights() {
        const insights = await this.aiObservabilityAnalyzerService.generateInsights();
        return {
            success: true,
            data: {
                insights,
                summary: {
                    totalInsights: insights.length,
                    criticalInsights: insights.filter(insight => insight.severity === 'CRITICAL').length,
                    highInsights: insights.filter(insight => insight.severity === 'HIGH')
                        .length,
                    mediumInsights: insights.filter(insight => insight.severity === 'MEDIUM').length,
                    lowInsights: insights.filter(insight => insight.severity === 'LOW')
                        .length,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
    async getObservabilityReport() {
        const report = await this.aiObservabilityAnalyzerService.getObservabilityReport();
        return {
            success: true,
            data: report,
        };
    }
    async getHealth() {
        const timeRange = {
            start: new Date(Date.now() - 60 * 60 * 1000),
            end: new Date(),
        };
        try {
            const [logAnalysis, metricAnalysis, insights] = await Promise.all([
                this.aiObservabilityAnalyzerService.analyzeLogs(timeRange),
                this.aiObservabilityAnalyzerService.analyzeMetrics(),
                this.aiObservabilityAnalyzerService.generateInsights(),
            ]);
            return {
                success: true,
                data: {
                    status: 'HEALTHY',
                    service: 'AI Observability Analyzer',
                    version: '1.0.0',
                    checks: {
                        logAnalysis: 'OK',
                        metricAnalysis: 'OK',
                        insightsGeneration: 'OK',
                        totalLogsAnalyzed: logAnalysis.length,
                        totalMetricsAnalyzed: metricAnalysis.length,
                        totalInsightsGenerated: insights.length,
                    },
                    timestamp: new Date().toISOString(),
                },
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            return {
                success: false,
                data: {
                    status: 'UNHEALTHY',
                    service: 'AI Observability Analyzer',
                    error: errorMessage,
                    timestamp: new Date().toISOString(),
                },
            };
        }
    }
    async getDashboard() {
        const report = await this.aiObservabilityAnalyzerService.getObservabilityReport();
        return {
            success: true,
            data: {
                metrics: {
                    overallHealth: report.overallHealth,
                    totalInsights: report.insights.length,
                    totalLogs: report.logAnalysis.length,
                    totalMetrics: report.metricAnalysis.length,
                    criticalIssues: report.insights.filter(i => i.severity === 'CRITICAL').length +
                        report.logAnalysis.filter(l => l.severity === 'CRITICAL').length +
                        report.metricAnalysis.filter(m => m.status === 'CRITICAL').length,
                },
                charts: {
                    insightSeverity: {
                        critical: report.insights.filter(i => i.severity === 'CRITICAL')
                            .length,
                        high: report.insights.filter(i => i.severity === 'HIGH').length,
                        medium: report.insights.filter(i => i.severity === 'MEDIUM').length,
                        low: report.insights.filter(i => i.severity === 'LOW').length,
                    },
                    logSeverity: {
                        critical: report.logAnalysis.filter(l => l.severity === 'CRITICAL')
                            .length,
                        high: report.logAnalysis.filter(l => l.severity === 'HIGH').length,
                        medium: report.logAnalysis.filter(l => l.severity === 'MEDIUM')
                            .length,
                        low: report.logAnalysis.filter(l => l.severity === 'LOW').length,
                    },
                    metricStatus: {
                        critical: report.metricAnalysis.filter(m => m.status === 'CRITICAL')
                            .length,
                        warning: report.metricAnalysis.filter(m => m.status === 'WARNING')
                            .length,
                        normal: report.metricAnalysis.filter(m => m.status === 'NORMAL')
                            .length,
                    },
                },
                recentInsights: report.insights
                    .filter(insight => insight.severity === 'CRITICAL' || insight.severity === 'HIGH')
                    .slice(0, 5)
                    .map(insight => ({
                    type: insight.type,
                    severity: insight.severity,
                    title: insight.title,
                    description: insight.description,
                    recommendations: insight.recommendations.slice(0, 3),
                })),
                alerts: report.alerts,
                recommendations: report.recommendations.slice(0, 10),
                timestamp: new Date().toISOString(),
            },
        };
    }
    async customAnalysis(dto) {
        const timeRange = {
            start: new Date(dto.startTime),
            end: new Date(dto.endTime),
        };
        const [logAnalysis, metricAnalysis, insights] = await Promise.all([
            this.aiObservabilityAnalyzerService.analyzeLogs(timeRange),
            this.aiObservabilityAnalyzerService.analyzeMetrics(),
            this.aiObservabilityAnalyzerService.generateInsights(),
        ]);
        const overallHealth = this.calculateOverallHealth(logAnalysis, metricAnalysis, insights);
        return {
            success: true,
            data: {
                timeRange,
                logAnalysis,
                metricAnalysis,
                insights,
                overallHealth,
                summary: {
                    totalLogs: logAnalysis.length,
                    totalMetrics: metricAnalysis.length,
                    totalInsights: insights.length,
                    criticalIssues: logAnalysis.filter(l => l.severity === 'CRITICAL').length +
                        metricAnalysis.filter(m => m.status === 'CRITICAL').length +
                        insights.filter(i => i.severity === 'CRITICAL').length,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
    calculateOverallHealth(logAnalysis, metricAnalysis, insights) {
        let score = 100;
        const criticalLogs = logAnalysis.filter((log) => typeof log === 'object' &&
            log != null &&
            'severity' in log &&
            log.severity === 'CRITICAL').length;
        const criticalMetrics = metricAnalysis.filter((metric) => typeof metric === 'object' &&
            metric != null &&
            'status' in metric &&
            metric.status === 'CRITICAL').length;
        const criticalInsights = insights.filter((insight) => typeof insight === 'object' &&
            insight != null &&
            'severity' in insight &&
            insight.severity === 'CRITICAL').length;
        score -= criticalLogs * 10;
        score -= criticalMetrics * 15;
        score -= criticalInsights * 20;
        return Math.max(0, Math.min(100, score));
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('logs-analysis'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Анализ логов с AI рекомендациями' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'startTime',
        required: false,
        description: 'Время начала анализа (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'endTime',
        required: false,
        description: 'Время окончания анализа (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Анализ логов с выявленными паттернами и рекомендациями',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('startTime')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('endTime')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "analyzeLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics-analysis'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Анализ метрик с AI рекомендациями' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Анализ метрик с выявленными аномалиями и рекомендациями',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "analyzeMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('insights'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'AI инсайты по observability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'AI-генерированные инсайты по производительности, безопасности и доступности',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "generateInsights", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('report'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Полный AI отчет по observability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Комплексный AI отчет по состоянию системы с рекомендациями',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "getObservabilityReport", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка состояния AI-анализатора observability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Статус AI-анализатора observability',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'AI дашборд observability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Дашборд с AI-анализом состояния системы',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "getDashboard", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('custom-analysis'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({
        summary: 'Кастомный анализ с указанным временным диапазоном',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Анализ за указанный период времени',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AnalyzeLogsDto]),
    __metadata("design:returntype", Promise)
], AIObservabilityAnalyzerController.prototype, "customAnalysis", null);
AIObservabilityAnalyzerController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('AI Observability Analyzer'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('ai-observability-analyzer'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_6__.AIObservabilityAnalyzerService !== "undefined" && _services_ai_observability_analyzer_service__WEBPACK_IMPORTED_MODULE_6__.AIObservabilityAnalyzerService) === "function" ? _a : Object])
], AIObservabilityAnalyzerController);



/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIObservabilityAnalyzerService: () => (/* binding */ AIObservabilityAnalyzerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logging_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(179);
/* harmony import */ var _metrics_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(180);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;



let AIObservabilityAnalyzerService = class AIObservabilityAnalyzerService {
    constructor(metricsService, loggingService) {
        this.metricsService = metricsService;
        this.loggingService = loggingService;
    }
    async analyzeLogs(_timeRange) {
        const logs = await this.loggingService.getLogs();
        const analysis = [];
        for (const log of logs) {
            const severity = this.calculateLogSeverity(log);
            const patterns = this.identifyLogPatterns(log);
            const recommendations = this.generateLogRecommendations(log, patterns);
            analysis.push({
                timestamp: log.timestamp,
                logLevel: log.level,
                message: log.message,
                context: log.context ? JSON.stringify(log.context) : '',
                severity,
                recommendations,
                patterns,
            });
        }
        return analysis;
    }
    async analyzeMetrics() {
        const systemMetrics = await this.metricsService.getSystemMetrics();
        await this.metricsService.getBusinessMetrics();
        const analysis = [];
        const systemMetricsData = [
            { name: 'cpu_usage', value: systemMetrics.cpu, trend: 0 },
            { name: 'memory_usage', value: systemMetrics.memory, trend: 0 },
            { name: 'error_rate', value: systemMetrics.errorRate, trend: 0 },
            {
                name: 'active_connections',
                value: systemMetrics.activeConnections,
                trend: 0,
            },
        ];
        for (const metric of systemMetricsData) {
            const threshold = this.getMetricThreshold(metric.name);
            const status = this.calculateMetricStatus(metric.value, threshold);
            const trend = this.calculateMetricTrend(metric);
            const recommendations = this.generateMetricRecommendations(metric, status, trend);
            const impact = this.calculateMetricImpact(metric.name, status);
            analysis.push({
                metricName: metric.name,
                currentValue: metric.value,
                threshold,
                status,
                trend,
                recommendations,
                impact,
            });
        }
        return analysis;
    }
    async generateInsights() {
        const insights = [];
        const performanceInsights = await this.analyzePerformance();
        insights.push(...performanceInsights);
        const securityInsights = await this.analyzeSecurity();
        insights.push(...securityInsights);
        const availabilityInsights = await this.analyzeAvailability();
        insights.push(...availabilityInsights);
        const errorInsights = await this.analyzeErrorRates();
        insights.push(...errorInsights);
        return insights;
    }
    async getObservabilityReport() {
        const timeRange = {
            start: new Date(Date.now() - 24 * 60 * 60 * 1000),
            end: new Date(),
        };
        const [logAnalysis, metricAnalysis, insights] = await Promise.all([
            this.analyzeLogs(timeRange),
            this.analyzeMetrics(),
            this.generateInsights(),
        ]);
        const overallHealth = this.calculateOverallHealth(logAnalysis, metricAnalysis, insights);
        const recommendations = this.generateOverallRecommendations(logAnalysis, metricAnalysis, insights);
        const alerts = this.generateAlerts(logAnalysis, metricAnalysis, insights);
        return {
            overallHealth,
            insights,
            logAnalysis,
            metricAnalysis,
            recommendations,
            alerts,
            timestamp: new Date().toISOString(),
        };
    }
    calculateLogSeverity(log) {
        const criticalKeywords = [
            'fatal',
            'critical',
            'emergency',
            'panic',
            'out of memory',
        ];
        const highKeywords = [
            'error',
            'exception',
            'failed',
            'timeout',
            'connection refused',
        ];
        const mediumKeywords = ['warning', 'deprecated', 'slow', 'high usage'];
        const message = log.message.toLowerCase();
        const context = log.context
            ? JSON.stringify(log.context).toLowerCase()
            : '';
        if (criticalKeywords.some(keyword => Boolean(message.includes(keyword) || context.includes(keyword)))) {
            return 'CRITICAL';
        }
        if (highKeywords.some(keyword => Boolean(message.includes(keyword) || context.includes(keyword)))) {
            return 'HIGH';
        }
        if (mediumKeywords.some(keyword => Boolean(message.includes(keyword) || context.includes(keyword)))) {
            return 'MEDIUM';
        }
        return 'LOW';
    }
    identifyLogPatterns(log) {
        const patterns = [];
        const message = log.message.toLowerCase();
        if (message.includes('timeout'))
            patterns.push('TIMEOUT_ERROR');
        if (message.includes('connection'))
            patterns.push('CONNECTION_ISSUE');
        if (message.includes('memory'))
            patterns.push('MEMORY_ISSUE');
        if (message.includes('database'))
            patterns.push('DATABASE_ISSUE');
        if (message.includes('authentication'))
            patterns.push('AUTH_ISSUE');
        if (message.includes('authorization'))
            patterns.push('AUTH_ISSUE');
        if (message.includes('slow'))
            patterns.push('PERFORMANCE_ISSUE');
        if (message.includes('high usage'))
            patterns.push('RESOURCE_USAGE');
        if (message.includes('cpu'))
            patterns.push('CPU_ISSUE');
        if (message.includes('memory usage'))
            patterns.push('MEMORY_USAGE');
        return patterns;
    }
    generateLogRecommendations(_log, patterns) {
        const recommendations = [];
        if (patterns.includes('TIMEOUT_ERROR')) {
            recommendations.push('Увеличьте timeout значения для внешних API вызовов');
            recommendations.push('Проверьте сетевую связность с внешними сервисами');
        }
        if (patterns.includes('CONNECTION_ISSUE')) {
            recommendations.push('Проверьте настройки connection pooling');
            recommendations.push('Увеличьте лимиты соединений в базе данных');
        }
        if (patterns.includes('MEMORY_ISSUE')) {
            recommendations.push('Проверьте утечки памяти в приложении');
            recommendations.push('Увеличьте лимиты памяти для контейнеров');
        }
        if (patterns.includes('DATABASE_ISSUE')) {
            recommendations.push('Оптимизируйте медленные SQL запросы');
            recommendations.push('Проверьте индексы в базе данных');
        }
        if (patterns.includes('AUTH_ISSUE')) {
            recommendations.push('Проверьте настройки аутентификации');
            recommendations.push('Обновите токены доступа');
        }
        if (patterns.includes('PERFORMANCE_ISSUE')) {
            recommendations.push('Оптимизируйте алгоритмы обработки данных');
            recommendations.push('Добавьте кеширование для медленных операций');
        }
        return recommendations;
    }
    getMetricThreshold(metricName) {
        const thresholds = {
            cpu_usage: 80,
            memory_usage: 85,
            disk_usage: 90,
            error_rate: 5,
            response_time: 1000,
            request_rate: 1000,
            active_connections: 100,
        };
        return thresholds[metricName] ?? 100;
    }
    calculateMetricStatus(value, threshold) {
        if (value >= threshold * 1.2)
            return 'CRITICAL';
        if (value >= threshold)
            return 'WARNING';
        return 'NORMAL';
    }
    calculateMetricTrend(metric) {
        const changeThreshold = 0.1;
        if (metric.trend > changeThreshold)
            return 'INCREASING';
        if (metric.trend < -changeThreshold)
            return 'DECREASING';
        return 'STABLE';
    }
    generateMetricRecommendations(metric, status, trend) {
        const recommendations = [];
        if (status === 'CRITICAL') {
            recommendations.push(`НЕМЕДЛЕННО: ${metric.name} превышает критический порог`);
            if (metric.name === 'cpu_usage') {
                recommendations.push('Масштабируйте ресурсы CPU');
                recommendations.push('Оптимизируйте алгоритмы обработки');
            }
            if (metric.name === 'memory_usage') {
                recommendations.push('Увеличьте доступную память');
                recommendations.push('Проверьте утечки памяти');
            }
            if (metric.name === 'error_rate') {
                recommendations.push('Исследуйте причины ошибок');
                recommendations.push('Добавьте дополнительное логирование');
            }
        }
        if (status === 'WARNING' && trend === 'INCREASING') {
            recommendations.push(`Мониторьте ${metric.name} - тренд растет`);
            recommendations.push('Подготовьте план масштабирования');
        }
        return recommendations;
    }
    calculateMetricImpact(metricName, status) {
        if (status === 'CRITICAL')
            return 'HIGH';
        const highImpactMetrics = ['error_rate', 'response_time', 'cpu_usage'];
        if (highImpactMetrics.includes(metricName))
            return 'MEDIUM';
        return 'LOW';
    }
    async analyzePerformance() {
        const insights = [];
        const systemMetrics = await this.metricsService.getSystemMetrics();
        if (systemMetrics.cpu > 80) {
            insights.push({
                type: 'PERFORMANCE',
                severity: 'HIGH',
                title: 'Высокое использование CPU',
                description: `CPU usage составляет ${systemMetrics.cpu}%, что может влиять на производительность`,
                recommendations: [
                    'Оптимизируйте алгоритмы обработки данных',
                    'Добавьте горизонтальное масштабирование',
                    'Проверьте фоновые задачи',
                ],
                affectedServices: ['API', 'Background Jobs'],
                estimatedImpact: 'Среднее влияние на пользовательский опыт',
                timestamp: new Date().toISOString(),
            });
        }
        if (systemMetrics.memory > 1000) {
            insights.push({
                type: 'PERFORMANCE',
                severity: 'MEDIUM',
                title: 'Высокое использование памяти',
                description: `Использование памяти ${systemMetrics.memory}MB превышает норму`,
                recommendations: [
                    'Оптимизируйте медленные запросы',
                    'Добавьте кеширование',
                    'Проверьте утечки памяти',
                ],
                affectedServices: ['API'],
                estimatedImpact: 'Влияние на пользовательский опыт',
                timestamp: new Date().toISOString(),
            });
        }
        return insights;
    }
    async analyzeSecurity() {
        const insights = [];
        const logs = await this.loggingService.getLogs();
        const authErrors = logs.filter(log => log.message.toLowerCase().includes('authentication') ||
            log.message.toLowerCase().includes('authorization'));
        if (authErrors.length > 10) {
            insights.push({
                type: 'SECURITY',
                severity: 'HIGH',
                title: 'Подозрительная активность аутентификации',
                description: `Обнаружено ${authErrors.length} ошибок аутентификации за последний час`,
                recommendations: [
                    'Проверьте логи на предмет попыток взлома',
                    'Усильте мониторинг безопасности',
                    'Рассмотрите возможность блокировки подозрительных IP',
                ],
                affectedServices: ['Auth Service'],
                estimatedImpact: 'Потенциальная угроза безопасности',
                timestamp: new Date().toISOString(),
            });
        }
        return insights;
    }
    async analyzeAvailability() {
        const insights = [];
        const systemMetrics = await this.metricsService.getSystemMetrics();
        if (systemMetrics.errorRate > 5) {
            insights.push({
                type: 'AVAILABILITY',
                severity: 'HIGH',
                title: 'Высокий уровень ошибок',
                description: `Уровень ошибок ${systemMetrics.errorRate}% превышает допустимый порог`,
                recommendations: [
                    'Исследуйте причины ошибок',
                    'Добавьте дополнительное логирование',
                    'Проверьте зависимости сервисов',
                ],
                affectedServices: ['All Services'],
                estimatedImpact: 'Влияние на доступность сервиса',
                timestamp: new Date().toISOString(),
            });
        }
        return insights;
    }
    async analyzeErrorRates() {
        const insights = [];
        const logs = await this.loggingService.getLogs();
        const errorLogs = logs.filter(log => log.level === 'error');
        const totalLogs = logs.length;
        const errorRate = totalLogs > 0 ? (errorLogs.length / totalLogs) * 100 : 0;
        if (errorRate > 5) {
            insights.push({
                type: 'ERROR_RATE',
                severity: 'HIGH',
                title: 'Критический уровень ошибок',
                description: `Уровень ошибок ${errorRate.toFixed(2)}% превышает критический порог`,
                recommendations: [
                    'Немедленно исследуйте причины ошибок',
                    'Проверьте состояние базы данных',
                    'Убедитесь в доступности внешних сервисов',
                ],
                affectedServices: ['All Services'],
                estimatedImpact: 'Критическое влияние на работу системы',
                timestamp: new Date().toISOString(),
            });
        }
        return insights;
    }
    calculateOverallHealth(logAnalysis, metricAnalysis, insights) {
        let score = 100;
        const criticalLogs = logAnalysis.filter(log => log.severity === 'CRITICAL').length;
        const criticalMetrics = metricAnalysis.filter(metric => metric.status === 'CRITICAL').length;
        const criticalInsights = insights.filter(insight => insight.severity === 'CRITICAL').length;
        score -= criticalLogs * 10;
        score -= criticalMetrics * 15;
        score -= criticalInsights * 20;
        const highLogs = logAnalysis.filter(log => log.severity === 'HIGH').length;
        const warningMetrics = metricAnalysis.filter(metric => metric.status === 'WARNING').length;
        const highInsights = insights.filter(insight => insight.severity === 'HIGH').length;
        score -= highLogs * 5;
        score -= warningMetrics * 8;
        score -= highInsights * 10;
        return Math.max(0, Math.min(100, score));
    }
    generateOverallRecommendations(logAnalysis, metricAnalysis, _insights) {
        const recommendations = [];
        const criticalIssues = logAnalysis.filter(log => log.severity === 'CRITICAL').length +
            metricAnalysis.filter(metric => metric.status === 'CRITICAL').length;
        if (criticalIssues > 0) {
            recommendations.push('НЕМЕДЛЕННО: Устраните критические проблемы в системе');
        }
        const highIssues = logAnalysis.filter(log => log.severity === 'HIGH').length +
            metricAnalysis.filter(metric => metric.status === 'WARNING').length;
        if (highIssues > 0) {
            recommendations.push('ВЫСОКИЙ ПРИОРИТЕТ: Обратите внимание на проблемы высокого уровня');
        }
        recommendations.push('Регулярно мониторьте метрики производительности');
        recommendations.push('Настройте автоматические алерты для критических метрик');
        recommendations.push('Проводите регулярный анализ логов на предмет паттернов');
        return recommendations;
    }
    generateAlerts(logAnalysis, metricAnalysis, insights) {
        const alerts = [];
        const criticalLogs = logAnalysis.filter(log => log.severity === 'CRITICAL');
        const criticalMetrics = metricAnalysis.filter(metric => metric.status === 'CRITICAL');
        const criticalInsights = insights.filter(insight => insight.severity === 'CRITICAL');
        if (criticalLogs.length > 0) {
            alerts.push(`🚨 КРИТИЧЕСКИЙ: Обнаружено ${criticalLogs.length} критических логов`);
        }
        if (criticalMetrics.length > 0) {
            alerts.push(`🚨 КРИТИЧЕСКИЙ: ${criticalMetrics.length} метрик превышают критические пороги`);
        }
        if (criticalInsights.length > 0) {
            alerts.push(`🚨 КРИТИЧЕСКИЙ: ${criticalInsights.length} критических инсайтов требуют внимания`);
        }
        return alerts;
    }
};
AIObservabilityAnalyzerService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _metrics_service__WEBPACK_IMPORTED_MODULE_2__.MetricsService !== "undefined" && _metrics_service__WEBPACK_IMPORTED_MODULE_2__.MetricsService) === "function" ? _a : Object, typeof (_b = typeof _logging_service__WEBPACK_IMPORTED_MODULE_1__.LoggingService !== "undefined" && _logging_service__WEBPACK_IMPORTED_MODULE_1__.LoggingService) === "function" ? _b : Object])
], AIObservabilityAnalyzerService);



/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoggingService: () => (/* binding */ LoggingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let LoggingService = class LoggingService {
    constructor() {
        this.logs = [];
        this.maxLogs = 10000;
    }
    async onModuleInit() {
        await this.initialize();
    }
    async initialize() {
        this.logs = [];
        console.log('[LoggingService] Initialized');
    }
    async log(level, message, context) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level,
            message,
            context: context ?? {},
        };
        this.logs.push(logEntry);
        if (this.logs.length > this.maxLogs) {
            this.logs = this.logs.slice(-this.maxLogs);
        }
        const logMessage = `[${logEntry.timestamp}] [${level.toUpperCase()}] ${message}`;
        if (context) {
            console.log(logMessage, context);
        }
        else {
            console.log(logMessage);
        }
    }
    async info(message, context) {
        return this.log('info', message, context);
    }
    async warn(message, context) {
        return this.log('warn', message, context);
    }
    async error(message, context) {
        return this.log('error', message, context);
    }
    async debug(message, context) {
        return this.log('debug', message, context);
    }
    async getLogs(level, limit = 100) {
        let filteredLogs = this.logs;
        if (level != null && level !== '' && level.length > 0) {
            filteredLogs = this.logs.filter(log => log.level === level);
        }
        return filteredLogs.slice(-limit);
    }
    async getLogStats() {
        const stats = {
            total: this.logs.length,
            info: 0,
            warn: 0,
            error: 0,
            debug: 0,
        };
        this.logs.forEach(log => {
            stats[log.level] = (stats[log.level] ?? 0) + 1;
        });
        return stats;
    }
    async clearLogs() {
        this.logs = [];
    }
    async exportLogs(format = 'json') {
        if (format === 'text') {
            return this.logs
                .map(log => `[${log.timestamp}] [${log.level.toUpperCase()}] ${log.message}`)
                .join('\n');
        }
        return JSON.stringify(this.logs, null, 2);
    }
};
LoggingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], LoggingService);



/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MetricsService: () => (/* binding */ MetricsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let MetricsService = class MetricsService {
    constructor() {
        this.requestCount = 0;
        this.errorCount = 0;
        this.startTime = Date.now();
        this.activeConnections = 0;
        this.userSessions = new Map();
        this.transactions = [];
        this.clicks = [];
        this.conversions = [];
    }
    async onModuleInit() {
        await this.initialize();
    }
    async initialize() {
        this.startTime = Date.now();
        this.requestCount = 0;
        this.errorCount = 0;
        this.activeConnections = 0;
        this.userSessions.clear();
        this.transactions = [];
        this.clicks = [];
        this.conversions = [];
    }
    async getSystemMetrics() {
        const processMemory = process.memoryUsage();
        const uptime = Date.now() - this.startTime;
        const errorRate = this.requestCount > 0 ? (this.errorCount / this.requestCount) * 100 : 0;
        return {
            cpu: process.cpuUsage().user / 1000000,
            memory: processMemory.heapUsed / 1024 / 1024,
            uptime: uptime / 1000,
            activeConnections: this.activeConnections,
            requestCount: this.requestCount,
            errorRate: Math.round(errorRate * 100) / 100,
        };
    }
    async getBusinessMetrics() {
        const userActivity = await this.getUserActivityMetrics();
        return {
            dau: userActivity.dau,
            mau: userActivity.mau,
            ctr: userActivity.ctr,
            roi: userActivity.roi,
            activeUsers: userActivity.activeUsers,
            totalTransactions: userActivity.totalTransactions,
        };
    }
    async getBusinessMetricsExtended() {
        const userActivity = await this.getUserActivityMetrics();
        const trends = await this.calculateTrends();
        return {
            dau: userActivity.dau,
            mau: userActivity.mau,
            ctr: userActivity.ctr,
            roi: userActivity.roi,
            activeUsers: userActivity.activeUsers,
            totalTransactions: userActivity.totalTransactions,
            userActivity,
            trends,
        };
    }
    async getUserActivityMetrics() {
        const now = Date.now();
        const oneDayAgo = now - 24 * 60 * 60 * 1000;
        const oneWeekAgo = now - 7 * 24 * 60 * 60 * 1000;
        const oneMonthAgo = now - 30 * 24 * 60 * 60 * 1000;
        const activeUsersToday = new Set();
        const activeUsersWeek = new Set();
        const activeUsersMonth = new Set();
        this.userSessions.forEach((session, userId) => {
            if (session.lastActivity >= oneDayAgo) {
                activeUsersToday.add(userId);
            }
            if (session.lastActivity >= oneWeekAgo) {
                activeUsersWeek.add(userId);
            }
            if (session.lastActivity >= oneMonthAgo) {
                activeUsersMonth.add(userId);
            }
        });
        const recentTransactions = this.transactions.filter(t => t.timestamp >= oneDayAgo);
        const totalRevenue = recentTransactions.reduce((sum, t) => sum + t.amount, 0);
        const recentClicks = this.clicks.filter(c => c.timestamp >= oneDayAgo);
        const recentConversions = this.conversions.filter(c => c.timestamp >= oneDayAgo);
        const dau = activeUsersToday.size;
        const wau = activeUsersWeek.size;
        const mau = activeUsersMonth.size;
        const totalTransactions = recentTransactions.length;
        const conversionRate = recentClicks.length > 0
            ? (recentConversions.length / recentClicks.length) * 100
            : 0;
        const revenuePerUser = dau > 0 ? totalRevenue / dau : 0;
        let totalSessionDuration = 0;
        let sessionCount = 0;
        this.userSessions.forEach(session => {
            const duration = session.lastActivity - session.startTime;
            if (duration > 0) {
                totalSessionDuration += duration;
                sessionCount++;
            }
        });
        const averageSessionDuration = sessionCount > 0 ? totalSessionDuration / sessionCount / (1000 * 60) : 0;
        const ctr = recentClicks.length > 0
            ? (recentConversions.length / recentClicks.length) * 100
            : 0;
        const roi = totalRevenue > 0 ? (totalRevenue / (dau * 0.1)) * 100 : 0;
        const bounceRate = this.userSessions.size > 0
            ? (Array.from(this.userSessions.values()).filter(s => s.lastActivity - s.startTime < 30000).length /
                this.userSessions.size) *
                100
            : 0;
        const retentionRate = mau > 0 ? (dau / mau) * 100 : 0;
        return {
            dau,
            mau,
            wau,
            ctr,
            roi,
            activeUsers: dau,
            totalTransactions,
            averageSessionDuration: Math.round(averageSessionDuration * 100) / 100,
            bounceRate: Math.round(bounceRate * 100) / 100,
            conversionRate: Math.round(conversionRate * 100) / 100,
            revenuePerUser: Math.round(revenuePerUser * 100) / 100,
            retentionRate: Math.round(retentionRate * 100) / 100,
        };
    }
    async calculateTrends() {
        const currentDau = (await this.getUserActivityMetrics()).dau;
        const currentMau = (await this.getUserActivityMetrics()).mau;
        const currentRevenue = this.transactions
            .filter(t => t.timestamp >= Date.now() - 24 * 60 * 60 * 1000)
            .reduce((sum, t) => sum + t.amount, 0);
        const baseDau = Math.max(currentDau - 10, 1);
        const baseMau = Math.max(currentMau - 50, 1);
        const baseRevenue = Math.max(currentRevenue - 100, 1);
        return {
            dauGrowth: ((currentDau - baseDau) / baseDau) * 100,
            mauGrowth: ((currentMau - baseMau) / baseMau) * 100,
            revenueGrowth: ((currentRevenue - baseRevenue) / baseRevenue) * 100,
        };
    }
    trackUserSession(userId) {
        const now = Date.now();
        const session = this.userSessions.get(userId);
        if (session) {
            session.lastActivity = now;
        }
        else {
            this.userSessions.set(userId, { startTime: now, lastActivity: now });
        }
    }
    trackTransaction(amount, userId) {
        this.transactions.push({
            userId,
            amount,
            timestamp: Date.now(),
        });
    }
    trackClick(target, userId) {
        this.clicks.push({
            userId,
            target,
            timestamp: Date.now(),
        });
    }
    trackConversion(value, userId) {
        this.conversions.push({
            userId,
            value,
            timestamp: Date.now(),
        });
    }
    incrementRequestCount() {
        this.requestCount++;
    }
    incrementErrorCount() {
        this.errorCount++;
    }
    setActiveConnections(count) {
        this.activeConnections = count;
    }
    getPrometheusMetrics() {
        const systemMetrics = this.getSystemMetricsSync();
        const userActivity = this.getUserActivityMetricsSync();
        return `# HELP api_requests_total Total number of API requests
# TYPE api_requests_total counter
api_requests_total ${this.requestCount}

# HELP api_errors_total Total number of API errors
# TYPE api_errors_total counter
api_errors_total ${this.errorCount}

# HELP api_error_rate Error rate percentage
# TYPE api_error_rate gauge
api_error_rate ${systemMetrics.errorRate}

# HELP api_memory_usage_bytes Memory usage in bytes
# TYPE api_memory_usage_bytes gauge
api_memory_usage_bytes ${process.memoryUsage().heapUsed}

# HELP api_cpu_usage_seconds CPU usage in seconds
# TYPE api_cpu_usage_seconds gauge
api_cpu_usage_seconds ${systemMetrics.cpu}

# HELP api_uptime_seconds Application uptime in seconds
# TYPE api_uptime_seconds gauge
api_uptime_seconds ${systemMetrics.uptime}

# HELP api_active_connections Active connections count
# TYPE api_active_connections gauge
api_active_connections ${this.activeConnections}

# HELP business_dau Daily active users
# TYPE business_dau gauge
business_dau ${userActivity.dau}

# HELP business_mau Monthly active users
# TYPE business_mau gauge
business_mau ${userActivity.mau}

# HELP business_ctr Click through rate percentage
# TYPE business_ctr gauge
business_ctr ${userActivity.ctr}

# HELP business_roi Return on investment percentage
# TYPE business_roi gauge
business_roi ${userActivity.roi}

# HELP business_conversion_rate Conversion rate percentage
# TYPE business_conversion_rate gauge
business_conversion_rate ${userActivity.conversionRate}

# HELP business_revenue_per_user Revenue per user
# TYPE business_revenue_per_user gauge
business_revenue_per_user ${userActivity.revenuePerUser}`;
    }
    getSystemMetricsSync() {
        const processMemory = process.memoryUsage();
        const uptime = Date.now() - this.startTime;
        const errorRate = this.requestCount > 0 ? (this.errorCount / this.requestCount) * 100 : 0;
        return {
            cpu: process.cpuUsage().user / 1000000,
            memory: processMemory.heapUsed / 1024 / 1024,
            uptime: uptime / 1000,
            activeConnections: this.activeConnections,
            requestCount: this.requestCount,
            errorRate: Math.round(errorRate * 100) / 100,
        };
    }
    getUserActivityMetricsSync() {
        const now = Date.now();
        const oneDayAgo = now - 24 * 60 * 60 * 1000;
        const oneMonthAgo = now - 30 * 24 * 60 * 60 * 1000;
        const activeUsersToday = new Set();
        const activeUsersMonth = new Set();
        this.userSessions.forEach((session, userId) => {
            if (session.lastActivity >= oneDayAgo) {
                activeUsersToday.add(userId);
            }
            if (session.lastActivity >= oneMonthAgo) {
                activeUsersMonth.add(userId);
            }
        });
        const recentTransactions = this.transactions.filter(t => t.timestamp >= oneDayAgo);
        const recentClicks = this.clicks.filter(c => c.timestamp >= oneDayAgo);
        const recentConversions = this.conversions.filter(c => c.timestamp >= oneDayAgo);
        const totalRevenue = recentTransactions.reduce((sum, t) => sum + t.amount, 0);
        const dau = activeUsersToday.size;
        const mau = activeUsersMonth.size;
        const ctr = recentClicks.length > 0
            ? (recentConversions.length / recentClicks.length) * 100
            : 0;
        const roi = totalRevenue > 0 ? (totalRevenue / (dau * 0.1)) * 100 : 0;
        const conversionRate = recentClicks.length > 0
            ? (recentConversions.length / recentClicks.length) * 100
            : 0;
        const revenuePerUser = dau > 0 ? totalRevenue / dau : 0;
        return {
            dau,
            mau,
            wau: 0,
            ctr,
            roi,
            activeUsers: dau,
            totalTransactions: recentTransactions.length,
            averageSessionDuration: 0,
            bounceRate: 0,
            conversionRate,
            revenuePerUser,
            retentionRate: 0,
        };
    }
};
MetricsService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], MetricsService);



/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateScalingPolicyDto: () => (/* binding */ CreateScalingPolicyDto),
/* harmony export */   DynamicScalingController: () => (/* binding */ DynamicScalingController),
/* harmony export */   EvaluateScalingDto: () => (/* binding */ EvaluateScalingDto),
/* harmony export */   UpdateScalingConfigDto: () => (/* binding */ UpdateScalingConfigDto),
/* harmony export */   UpdateScalingPolicyDto: () => (/* binding */ UpdateScalingPolicyDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(182);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;







class CreateScalingPolicyDto {
}
class UpdateScalingPolicyDto extends CreateScalingPolicyDto {
}
class EvaluateScalingDto {
}
class UpdateScalingConfigDto {
}
let DynamicScalingController = class DynamicScalingController {
    constructor(dynamicScalingService) {
        this.dynamicScalingService = dynamicScalingService;
    }
    async createPolicy(dto) {
        const policy = this.dynamicScalingService.createPolicy(dto);
        return {
            success: true,
            data: policy,
        };
    }
    async updatePolicy(id, dto) {
        const policy = this.dynamicScalingService.updatePolicy(id, dto);
        if (!policy) {
            return {
                success: false,
                message: 'Policy not found',
            };
        }
        return {
            success: true,
            data: policy,
        };
    }
    async deletePolicy(id) {
        const deleted = this.dynamicScalingService.deletePolicy(id);
        return {
            success: deleted,
            message: deleted ? 'Policy deleted successfully' : 'Policy not found',
        };
    }
    async getPolicies(service) {
        const policies = service != null && service !== ''
            ? this.dynamicScalingService.getPoliciesForService(service)
            : this.dynamicScalingService.getAllPolicies();
        return {
            success: true,
            data: policies,
        };
    }
    async evaluateScaling(dto) {
        const metrics = {
            ...dto.metrics,
            timestamp: new Date().toISOString(),
        };
        const decision = await this.dynamicScalingService.evaluateScaling(dto._service, metrics);
        if (decision != null) {
            return {
                success: true,
                data: decision,
            };
        }
        return {
            success: true,
        };
    }
    async executeScaling(decision) {
        const success = await this.dynamicScalingService.executeScaling(decision);
        return {
            success,
            message: success
                ? 'Scaling executed successfully'
                : 'Scaling execution failed',
        };
    }
    async getScalingHistory(service, limit) {
        const history = this.dynamicScalingService.getScalingHistory(service, limit);
        return {
            success: true,
            data: history,
        };
    }
    async getScalingStats(service, timeRange) {
        const timeRangeMs = timeRange != null && timeRange > 0
            ? timeRange * 60 * 60 * 1000
            : 24 * 60 * 60 * 1000;
        const stats = this.dynamicScalingService.getScalingStats(service, timeRangeMs);
        return {
            success: true,
            data: stats,
        };
    }
    async getScalingConfig() {
        const config = this.dynamicScalingService.getScalingConfig();
        return {
            success: true,
            data: config,
        };
    }
    async updateScalingConfig(dto) {
        this.dynamicScalingService.updateScalingConfig(dto);
        return {
            success: true,
            message: 'Scaling configuration updated successfully',
        };
    }
    async getHealth() {
        const policies = this.dynamicScalingService.getAllPolicies();
        const history = this.dynamicScalingService.getScalingHistory();
        return {
            success: true,
            data: {
                status: 'HEALTHY',
                _service: 'Dynamic Scaling Policies',
                policies: policies.length,
                history: history.length,
            },
        };
    }
    async getDashboard() {
        const policies = this.dynamicScalingService.getAllPolicies();
        const stats = this.dynamicScalingService.getScalingStats();
        const enabledPolicies = policies.filter(policy => policy.enabled);
        const disabledPolicies = policies.filter(policy => !policy.enabled);
        const policiesByType = policies.reduce((acc, policy) => {
            acc[policy.type] = (acc[policy.type] ?? 0) + 1;
            return acc;
        }, {});
        const policiesByService = policies.reduce((acc, policy) => {
            acc[policy._service] = (acc[policy._service] ?? 0) + 1;
            return acc;
        }, {});
        const services = Array.from(new Set(policies.map(policy => policy._service)));
        const recentScaling = this.dynamicScalingService.getScalingHistory(undefined, 10);
        return {
            success: true,
            data: {
                policies: {
                    total: policies.length,
                    enabled: enabledPolicies.length,
                    disabled: disabledPolicies.length,
                    byType: policiesByType,
                    byService: policiesByService,
                },
                scaling: {
                    totalEvents: stats.totalScalingEvents,
                    successfulEvents: stats.successfulScalingEvents,
                    failedEvents: stats.failedScalingEvents,
                    averageScalingTime: stats.averageScalingTime,
                    mostCommonAction: stats.mostCommonAction,
                    scalingFrequency: stats.scalingFrequency,
                },
                services: {
                    total: services.length,
                    activePolicies: enabledPolicies.length,
                    recentScaling: recentScaling.length,
                },
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('policies'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Создать политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Политика масштабирования создана успешно',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CreateScalingPolicyDto]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], DynamicScalingController.prototype, "createPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('policies/:id'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Обновить политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Политика масштабирования обновлена',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, UpdateScalingPolicyDto]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], DynamicScalingController.prototype, "updatePolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('policies/:id'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Удалить политику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'ID политики' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Политика масштабирования удалена',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], DynamicScalingController.prototype, "deletePolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('policies'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все политики масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Список политик масштабирования',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], DynamicScalingController.prototype, "getPolicies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('evaluate'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Оценить необходимость масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Результат оценки масштабирования',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [EvaluateScalingDto]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], DynamicScalingController.prototype, "evaluateScaling", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('execute'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Выполнить масштабирование' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Масштабирование выполнено',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], DynamicScalingController.prototype, "executeScaling", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('history'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить историю масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Лимит записей',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'История масштабирования',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], DynamicScalingController.prototype, "getScalingHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('stats'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить статистику масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Фильтр по сервису',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'timeRange',
        required: false,
        description: 'Временной диапазон в часах',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Статистика масштабирования',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('timeRange')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], DynamicScalingController.prototype, "getScalingStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('config'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить конфигурацию масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Конфигурация масштабирования',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], DynamicScalingController.prototype, "getScalingConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('config'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Обновить конфигурацию масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Конфигурация обновлена',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UpdateScalingConfigDto]),
    __metadata("design:returntype", typeof (_l = typeof Promise !== "undefined" && Promise) === "function" ? _l : Object)
], DynamicScalingController.prototype, "updateScalingConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка состояния сервиса масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Статус сервиса масштабирования',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], DynamicScalingController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Дашборд масштабирования' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Дашборд с аналитикой масштабирования',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_o = typeof Promise !== "undefined" && Promise) === "function" ? _o : Object)
], DynamicScalingController.prototype, "getDashboard", null);
DynamicScalingController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Dynamic Scaling Policies'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('dynamic-scaling'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_3__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_4__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_6__.DynamicScalingService !== "undefined" && _services_dynamic_scaling_service__WEBPACK_IMPORTED_MODULE_6__.DynamicScalingService) === "function" ? _a : Object])
], DynamicScalingController);



/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicScalingService: () => (/* binding */ DynamicScalingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DynamicScalingService_1;

let DynamicScalingService = DynamicScalingService_1 = class DynamicScalingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DynamicScalingService_1.name);
        this.policies = new Map();
        this.scalingHistory = [];
        this.lastScalingTime = new Map();
        this.scalingConfig = {
            enabled: true,
            defaultMinInstances: 2,
            defaultMaxInstances: 20,
            defaultCooldownPeriod: 300,
            maxScalingRate: 5,
            predictiveScalingEnabled: true,
            costOptimizationEnabled: true,
            notificationChannels: ['slack', 'email'],
        };
        this.initializeDefaultPolicies();
    }
    initializeDefaultPolicies() {
        const defaultPolicies = [
            {
                name: 'CPU High Usage Scale Up',
                type: 'REACTIVE',
                _service: 'API',
                metric: 'CPU_USAGE',
                threshold: 80,
                action: 'SCALE_UP',
                minInstances: 2,
                maxInstances: 20,
                cooldownPeriod: 300,
                enabled: true,
                priority: 1,
                conditions: [
                    {
                        metric: 'CPU_USAGE',
                        operator: 'GT',
                        value: 80,
                        duration: 60,
                    },
                ],
            },
            {
                name: 'CPU Low Usage Scale Down',
                type: 'REACTIVE',
                _service: 'API',
                metric: 'CPU_USAGE',
                threshold: 30,
                action: 'SCALE_DOWN',
                minInstances: 2,
                maxInstances: 20,
                cooldownPeriod: 600,
                enabled: true,
                priority: 2,
                conditions: [
                    {
                        metric: 'CPU_USAGE',
                        operator: 'LT',
                        value: 30,
                        duration: 300,
                    },
                ],
            },
            {
                name: 'High Request Rate Scale Out',
                type: 'REACTIVE',
                _service: 'API',
                metric: 'REQUEST_RATE',
                threshold: 1000,
                action: 'SCALE_OUT',
                minInstances: 2,
                maxInstances: 20,
                cooldownPeriod: 180,
                enabled: true,
                priority: 1,
                conditions: [
                    {
                        metric: 'REQUEST_RATE',
                        operator: 'GT',
                        value: 1000,
                        duration: 30,
                    },
                ],
            },
            {
                name: 'Business Hours Scale Up',
                type: 'SCHEDULED',
                _service: 'API',
                metric: 'CPU_USAGE',
                threshold: 0,
                action: 'SCALE_UP',
                minInstances: 4,
                maxInstances: 20,
                cooldownPeriod: 0,
                enabled: true,
                priority: 3,
                conditions: [],
                schedule: {
                    cronExpression: '0 9 * * 1-5',
                    timezone: 'UTC',
                    minInstances: 4,
                    maxInstances: 20,
                },
            },
            {
                name: 'Night Hours Scale Down',
                type: 'SCHEDULED',
                _service: 'API',
                metric: 'CPU_USAGE',
                threshold: 0,
                action: 'SCALE_DOWN',
                minInstances: 2,
                maxInstances: 20,
                cooldownPeriod: 0,
                enabled: true,
                priority: 3,
                conditions: [],
                schedule: {
                    cronExpression: '0 22 * * *',
                    timezone: 'UTC',
                    minInstances: 2,
                    maxInstances: 20,
                },
            },
        ];
        defaultPolicies.forEach(policy => {
            this.createPolicy(policy);
        });
    }
    createPolicy(policyData) {
        const policy = {
            ...policyData,
            id: this.generatePolicyId(),
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        };
        this.policies.set(policy.id, policy);
        this.logger.log(`Created scaling policy: ${policy.name} for ${policy._service}`);
        return policy;
    }
    updatePolicy(id, updates) {
        const policy = this.policies.get(id);
        if (!policy) {
            this.logger.warn(`Policy not found: ${id}`);
            return undefined;
        }
        const updatedPolicy = {
            ...policy,
            ...updates,
            updatedAt: new Date().toISOString(),
        };
        this.policies.set(id, updatedPolicy);
        this.logger.log(`Updated scaling policy: ${updatedPolicy.name}`);
        return updatedPolicy;
    }
    deletePolicy(id) {
        const policy = this.policies.get(id);
        if (!policy) {
            this.logger.warn(`Policy not found: ${id}`);
            return false;
        }
        this.policies.delete(id);
        this.logger.log(`Deleted scaling policy: ${policy.name}`);
        return true;
    }
    getPoliciesForService(_service) {
        return Array.from(this.policies.values()).filter(policy => policy._service === _service);
    }
    getAllPolicies() {
        return Array.from(this.policies.values());
    }
    async evaluateScaling(_service, metrics) {
        if (!this.scalingConfig.enabled) {
            return undefined;
        }
        const policies = this.getPoliciesForService(_service).filter(policy => policy.enabled);
        const sortedPolicies = policies.sort((a, b) => a.priority - b.priority);
        for (const policy of sortedPolicies) {
            const decision = await this.evaluatePolicy(policy, metrics);
            if (decision) {
                return decision;
            }
        }
        return undefined;
    }
    async evaluatePolicy(policy, metrics) {
        const lastScaling = this.lastScalingTime.get(policy.id);
        const now = Date.now();
        if (lastScaling != null &&
            now - lastScaling < policy.cooldownPeriod * 1000) {
            return undefined;
        }
        const conditionsMet = policy.conditions.every(condition => {
            const metricValue = this.getMetricValue(condition.metric, metrics);
            return this.evaluateCondition(metricValue, condition.operator, condition.value);
        });
        if (!conditionsMet) {
            return undefined;
        }
        const currentInstances = await this.getCurrentInstances(policy._service);
        const targetInstances = this.calculateTargetInstances(policy, currentInstances, metrics);
        if (targetInstances === currentInstances) {
            return undefined;
        }
        if (targetInstances < policy.minInstances ||
            targetInstances > policy.maxInstances) {
            this.logger.warn(`Target instances ${targetInstances} outside limits for policy ${policy.name}`);
            return undefined;
        }
        if (!this.checkScalingRateLimit(policy._service)) {
            this.logger.warn(`Scaling rate limit exceeded for service ${policy._service}`);
            return undefined;
        }
        const decision = {
            policyId: policy.id,
            _service: policy._service,
            action: policy.action,
            reason: this.generateScalingReason(policy, metrics),
            currentInstances,
            targetInstances,
            metrics: {
                cpuUsage: metrics.cpuUsage,
                memoryUsage: metrics.memoryUsage,
                requestRate: metrics.requestRate,
                responseTime: metrics.responseTime,
                errorRate: metrics.errorRate,
                queueSize: metrics.queueSize,
            },
            timestamp: new Date().toISOString(),
            confidence: this.calculateConfidence(policy, metrics),
        };
        this.lastScalingTime.set(policy.id, now);
        return decision;
    }
    async executeScaling(decision) {
        const startTime = Date.now();
        this.logger.log(`Executing scaling: ${decision.action} for ${decision._service}`);
        try {
            await this.performScalingAction(decision);
            const duration = (Date.now() - startTime) / 1000;
            const historyEntry = {
                id: this.generateHistoryId(),
                policyId: decision.policyId,
                _service: decision._service,
                action: decision.action,
                fromInstances: decision.currentInstances,
                toInstances: decision.targetInstances,
                reason: decision.reason,
                metrics: decision.metrics,
                duration,
                success: true,
                timestamp: new Date().toISOString(),
            };
            this.scalingHistory.push(historyEntry);
            this.logger.log(`Scaling completed successfully: ${decision._service} ${decision.currentInstances} -> ${decision.targetInstances}`);
            return true;
        }
        catch (error) {
            this.logger.error(`Scaling failed: ${decision._service}`, error);
            const historyEntry = {
                id: this.generateHistoryId(),
                policyId: decision.policyId,
                _service: decision._service,
                action: decision.action,
                fromInstances: decision.currentInstances,
                toInstances: decision.targetInstances,
                reason: decision.reason,
                metrics: decision.metrics,
                duration: (Date.now() - startTime) / 1000,
                success: false,
                timestamp: new Date().toISOString(),
            };
            this.scalingHistory.push(historyEntry);
            return false;
        }
    }
    getScalingHistory(service, limit = 100) {
        let history = this.scalingHistory;
        if (service != null && service !== '') {
            history = history.filter(entry => entry._service === service);
        }
        return history
            .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
            .slice(0, limit);
    }
    getScalingStats(service, timeRange = 24 * 60 * 60 * 1000) {
        const cutoffTime = Date.now() - timeRange;
        let history = this.scalingHistory.filter(entry => new Date(entry.timestamp).getTime() > cutoffTime);
        if (service != null && service !== '') {
            history = history.filter(entry => entry._service === service);
        }
        const totalScalingEvents = history.length;
        const successfulScalingEvents = history.filter(entry => entry.success).length;
        const failedScalingEvents = totalScalingEvents - successfulScalingEvents;
        const averageScalingTime = history.length > 0
            ? history.reduce((sum, entry) => sum + entry.duration, 0) /
                history.length
            : 0;
        const actionCounts = history.reduce((counts, entry) => {
            counts[entry.action] = (counts[entry.action] || 0) + 1;
            return counts;
        }, {});
        const sortedEntries = Object.entries(actionCounts).sort(([, a], [, b]) => b - a);
        const mostCommonAction = sortedEntries.length > 0 && sortedEntries[0] != null
            ? sortedEntries[0][0]
            : 'SCALE_UP';
        const scalingFrequency = totalScalingEvents / (timeRange / (1000 * 60 * 60));
        return {
            totalScalingEvents,
            successfulScalingEvents,
            failedScalingEvents,
            averageScalingTime,
            mostCommonAction,
            scalingFrequency,
        };
    }
    getMetricValue(metric, metrics) {
        switch (metric) {
            case 'CPU_USAGE':
                return metrics.cpuUsage;
            case 'MEMORY_USAGE':
                return metrics.memoryUsage;
            case 'REQUEST_RATE':
                return metrics.requestRate;
            case 'RESPONSE_TIME':
                return metrics.responseTime;
            case 'ERROR_RATE':
                return metrics.errorRate;
            case 'QUEUE_SIZE':
                return metrics.queueSize;
            default:
                return 0;
        }
    }
    evaluateCondition(value, operator, threshold) {
        switch (operator) {
            case 'GT':
                return value > threshold;
            case 'LT':
                return value < threshold;
            case 'GTE':
                return value >= threshold;
            case 'LTE':
                return value <= threshold;
            case 'EQ':
                return Math.abs(value - threshold) < 0.01;
            default:
                return false;
        }
    }
    async getCurrentInstances(_service) {
        const baseInstances = {
            API: 3,
            Web: 2,
            Database: 1,
        };
        return baseInstances[_service] ?? 1;
    }
    calculateTargetInstances(policy, currentInstances, metrics) {
        const metricValue = this.getMetricValue(policy.metric, metrics);
        switch (policy.action) {
            case 'SCALE_UP':
                return Math.min(policy.maxInstances, currentInstances + 1);
            case 'SCALE_DOWN':
                return Math.max(policy.minInstances, currentInstances - 1);
            case 'SCALE_OUT':
                return Math.min(policy.maxInstances, currentInstances + Math.ceil(metricValue / 100));
            case 'SCALE_IN':
                return Math.max(policy.minInstances, currentInstances - Math.ceil(metricValue / 100));
            default:
                return currentInstances;
        }
    }
    checkScalingRateLimit(_service) {
        const now = Date.now();
        const oneMinuteAgo = now - 60 * 1000;
        const recentScalingEvents = this.scalingHistory.filter(entry => entry._service === _service &&
            new Date(entry.timestamp).getTime() > oneMinuteAgo);
        return recentScalingEvents.length < this.scalingConfig.maxScalingRate;
    }
    generateScalingReason(policy, metrics) {
        const metricValue = this.getMetricValue(policy.metric, metrics);
        return `${policy.metric} (${metricValue.toFixed(2)}) triggered ${policy.action} for ${policy._service}`;
    }
    calculateConfidence(policy, metrics) {
        const metricValue = this.getMetricValue(policy.metric, metrics);
        const threshold = policy.threshold;
        if (policy.action === 'SCALE_UP') {
            return Math.min(100, Math.max(50, (metricValue / threshold) * 100));
        }
        else {
            return Math.min(100, Math.max(50, (threshold / metricValue) * 100));
        }
    }
    async performScalingAction(decision) {
        const isTestEnvironment = process.env.NODE_ENV === 'test' || process.env.VITEST === 'true';
        if (isTestEnvironment) {
            await this.delay(10);
        }
        else {
            const scalingTimes = {
                SCALE_UP: 5000,
                SCALE_DOWN: 3000,
                SCALE_OUT: 8000,
                SCALE_IN: 6000,
            };
            const scalingTime = scalingTimes[decision.action] || 5000;
            await this.delay(scalingTime);
        }
    }
    generatePolicyId() {
        return `policy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    generateHistoryId() {
        return `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    getScalingConfig() {
        return this.scalingConfig;
    }
    updateScalingConfig(config) {
        Object.assign(this.scalingConfig, config);
        this.logger.log('Scaling configuration updated');
    }
};
DynamicScalingService = DynamicScalingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DynamicScalingService);



/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateIncidentDto: () => (/* binding */ CreateIncidentDto),
/* harmony export */   IncidentSimulationController: () => (/* binding */ IncidentSimulationController),
/* harmony export */   SimulateIncidentDto: () => (/* binding */ SimulateIncidentDto),
/* harmony export */   UpdateSelfHealingConfigDto: () => (/* binding */ UpdateSelfHealingConfigDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var class_validator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(class_validator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33);
/* harmony import */ var _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(184);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;








class CreateIncidentDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsIn)([
        'CPU_SPIKE',
        'MEMORY_LEAK',
        'DISK_FULL',
        'NETWORK_LATENCY',
        'DATABASE_TIMEOUT',
        'SERVICE_UNAVAILABLE',
    ]),
    __metadata("design:type", String)
], CreateIncidentDto.prototype, "type", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsIn)(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),
    __metadata("design:type", String)
], CreateIncidentDto.prototype, "severity", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsString)(),
    __metadata("design:type", String)
], CreateIncidentDto.prototype, "description", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsArray)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsString)({ each: true }),
    __metadata("design:type", Array)
], CreateIncidentDto.prototype, "affectedServices", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], CreateIncidentDto.prototype, "metrics", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsOptional)(),
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateIncidentDto.prototype, "autoRecoveryEnabled", void 0);
class SimulateIncidentDto {
}
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsIn)([
        'CPU_SPIKE',
        'MEMORY_LEAK',
        'DISK_FULL',
        'NETWORK_LATENCY',
        'DATABASE_TIMEOUT',
        'SERVICE_UNAVAILABLE',
    ]),
    __metadata("design:type", String)
], SimulateIncidentDto.prototype, "type", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsIn)(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),
    __metadata("design:type", String)
], SimulateIncidentDto.prototype, "severity", void 0);
__decorate([
    (0,class_validator__WEBPACK_IMPORTED_MODULE_2__.IsNumber)(),
    __metadata("design:type", Number)
], SimulateIncidentDto.prototype, "duration", void 0);
class UpdateSelfHealingConfigDto {
}
let IncidentSimulationController = class IncidentSimulationController {
    constructor(incidentSimulationService) {
        this.incidentSimulationService = incidentSimulationService;
    }
    async createIncident(dto) {
        const incident = await this.incidentSimulationService.createIncident(dto.type, dto.severity, dto.description, dto.affectedServices, dto.metrics ?? {}, dto.autoRecoveryEnabled ?? true);
        return {
            success: true,
            data: incident,
        };
    }
    async simulateIncident(dto) {
        const result = await this.incidentSimulationService.simulateIncident(dto.type, dto.severity, dto.duration);
        return {
            success: true,
            data: result,
        };
    }
    async getIncidents() {
        const incidents = this.incidentSimulationService.getIncidents();
        return {
            success: true,
            data: incidents,
        };
    }
    async getSimulationResults() {
        const results = this.incidentSimulationService.getSimulationResults();
        return {
            success: true,
            data: results,
        };
    }
    async getSelfHealingConfig() {
        const config = this.incidentSimulationService.getSelfHealingConfig();
        return {
            success: true,
            data: config,
        };
    }
    async updateSelfHealingConfig(dto) {
        this.incidentSimulationService.updateSelfHealingConfig(dto);
        return {
            success: true,
            message: 'Self-healing configuration updated successfully',
        };
    }
    async getHealth() {
        const incidents = this.incidentSimulationService.getIncidents();
        const simulations = this.incidentSimulationService.getSimulationResults();
        return {
            success: true,
            data: {
                status: 'HEALTHY',
                _service: 'Incident Simulation & Self-healing',
                incidents: incidents.length,
                simulations: simulations.length,
            },
        };
    }
    async getDashboard() {
        const incidents = this.incidentSimulationService.getIncidents();
        const simulations = this.incidentSimulationService.getSimulationResults();
        const config = this.incidentSimulationService.getSelfHealingConfig();
        const activeIncidents = incidents.filter(incident => incident.status === 'ACTIVE');
        const resolvedIncidents = incidents.filter(incident => incident.status === 'RESOLVED');
        const incidentsBySeverity = incidents.reduce((acc, incident) => {
            acc[incident.severity] = (acc[incident.severity] ?? 0) + 1;
            return acc;
        }, {});
        const incidentsByType = incidents.reduce((acc, incident) => {
            acc[incident.type] = (acc[incident.type] ?? 0) + 1;
            return acc;
        }, {});
        const successfulSimulations = simulations.filter(sim => sim.success);
        const averageRecoveryTime = simulations.length > 0
            ? simulations.reduce((sum, sim) => sum + sim.recoveryTime, 0) /
                simulations.length
            : 0;
        const recentRecoveries = incidents.filter(incident => incident.status === 'RESOLVED' &&
            new Date(incident.timestamp).getTime() >
                Date.now() - 24 * 60 * 60 * 1000).length;
        return {
            success: true,
            data: {
                incidents: {
                    total: incidents.length,
                    active: activeIncidents.length,
                    resolved: resolvedIncidents.length,
                    bySeverity: incidentsBySeverity,
                    byType: incidentsByType,
                },
                simulations: {
                    total: simulations.length,
                    successful: successfulSimulations.length,
                    failed: simulations.length - successfulSimulations.length,
                    averageRecoveryTime,
                },
                selfHealing: {
                    enabled: config.enabled,
                    autoRecoveryThreshold: config.autoRecoveryThreshold,
                    recentRecoveries,
                },
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Создать инцидент' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Инцидент создан успешно',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CreateIncidentDto]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], IncidentSimulationController.prototype, "createIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('simulate'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Симулировать инцидент' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Симуляция инцидента завершена',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [SimulateIncidentDto]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], IncidentSimulationController.prototype, "simulateIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить все инциденты' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Список всех инцидентов',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], IncidentSimulationController.prototype, "getIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('simulation-results'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить результаты симуляций' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Результаты всех симуляций',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], IncidentSimulationController.prototype, "getSimulationResults", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('self-healing-config'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Получить конфигурацию самовосстановления' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Конфигурация самовосстановления',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], IncidentSimulationController.prototype, "getSelfHealingConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('self-healing-config'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Обновить конфигурацию самовосстановления' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Конфигурация обновлена',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [UpdateSelfHealingConfigDto]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], IncidentSimulationController.prototype, "updateSelfHealingConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Проверка состояния сервиса инцидентов' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Статус сервиса инцидентов',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], IncidentSimulationController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_3__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_6__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Дашборд инцидентов и самовосстановления' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Дашборд с аналитикой инцидентов',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], IncidentSimulationController.prototype, "getDashboard", null);
IncidentSimulationController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Incident Simulation & Self-healing'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('incident-simulation'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_4__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_5__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_b = typeof _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_7__.IncidentSimulationService !== "undefined" && _services_incident_simulation_service__WEBPACK_IMPORTED_MODULE_7__.IncidentSimulationService) === "function" ? _b : Object])
], IncidentSimulationController);



/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentSimulationService: () => (/* binding */ IncidentSimulationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var IncidentSimulationService_1;

let IncidentSimulationService = IncidentSimulationService_1 = class IncidentSimulationService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(IncidentSimulationService_1.name);
        this.incidents = new Map();
        this.recoveryPlans = new Map();
        this.simulationResults = [];
        this.isTestMode = false;
        this.selfHealingConfig = {
            enabled: true,
            autoRecoveryThreshold: 85,
            maxRecoveryAttempts: 3,
            recoveryTimeout: 300,
            notificationChannels: ['slack', 'email', 'webhook'],
            escalationRules: {
                LOW: ['email'],
                MEDIUM: ['email', 'slack'],
                HIGH: ['email', 'slack', 'webhook'],
                CRITICAL: ['email', 'slack', 'webhook', 'pagerduty'],
            },
        };
        this.initializeRecoveryPlans();
    }
    enableTestMode() {
        this.isTestMode = true;
    }
    disableTestMode() {
        this.isTestMode = false;
    }
    initializeRecoveryPlans() {
        const plans = [
            {
                type: 'CPU_SPIKE',
                plan: {
                    incidentType: 'CPU_SPIKE',
                    severity: 'HIGH',
                    actions: ['SCALE_UP', 'RESTART_SERVICE'],
                    priority: 1,
                    estimatedRecoveryTime: 60,
                    prerequisites: ['monitoring_enabled', 'scaling_enabled'],
                    rollbackPlan: ['SCALE_DOWN'],
                },
            },
            {
                type: 'MEMORY_LEAK',
                plan: {
                    incidentType: 'MEMORY_LEAK',
                    severity: 'CRITICAL',
                    actions: ['RESTART_CONTAINER', 'CLEAR_CACHE'],
                    priority: 1,
                    estimatedRecoveryTime: 120,
                    prerequisites: ['container_restart_enabled'],
                    rollbackPlan: ['RESTART_CONTAINER'],
                },
            },
            {
                type: 'DISK_FULL',
                plan: {
                    incidentType: 'DISK_FULL',
                    severity: 'CRITICAL',
                    actions: ['CLEAR_CACHE', 'SCALE_UP'],
                    priority: 1,
                    estimatedRecoveryTime: 180,
                    prerequisites: ['disk_monitoring_enabled'],
                    rollbackPlan: ['SCALE_DOWN'],
                },
            },
            {
                type: 'NETWORK_LATENCY',
                plan: {
                    incidentType: 'NETWORK_LATENCY',
                    severity: 'MEDIUM',
                    actions: ['FAILOVER', 'RESTART_SERVICE'],
                    priority: 2,
                    estimatedRecoveryTime: 90,
                    prerequisites: ['failover_enabled'],
                    rollbackPlan: ['FAILOVER_REVERT'],
                },
            },
            {
                type: 'DATABASE_TIMEOUT',
                plan: {
                    incidentType: 'DATABASE_TIMEOUT',
                    severity: 'HIGH',
                    actions: ['RESTART_SERVICE', 'CLEAR_CACHE'],
                    priority: 1,
                    estimatedRecoveryTime: 150,
                    prerequisites: ['database_monitoring_enabled'],
                    rollbackPlan: ['RESTART_SERVICE'],
                },
            },
            {
                type: 'SERVICE_UNAVAILABLE',
                plan: {
                    incidentType: 'SERVICE_UNAVAILABLE',
                    severity: 'CRITICAL',
                    actions: ['RESTART_CONTAINER', 'FAILOVER', 'ROLLBACK'],
                    priority: 1,
                    estimatedRecoveryTime: 300,
                    prerequisites: ['service_monitoring_enabled'],
                    rollbackPlan: ['ROLLBACK'],
                },
            },
        ];
        plans.forEach(({ type, plan }) => {
            if (!this.recoveryPlans.has(type)) {
                this.recoveryPlans.set(type, []);
            }
            this.recoveryPlans.get(type)?.push(plan);
        });
    }
    async createIncident(type, severity, description, affectedServices, metrics, autoRecoveryEnabled = true) {
        const incident = {
            id: this.generateIncidentId(),
            type,
            severity,
            description,
            timestamp: new Date().toISOString(),
            affectedServices,
            metrics,
            status: 'ACTIVE',
            recoveryActions: this.getRecoveryActions(type, severity),
            estimatedImpact: this.calculateEstimatedImpact(severity, affectedServices),
            autoRecoveryEnabled,
        };
        this.incidents.set(incident.id, incident);
        this.logger.log(`Created incident: ${incident.id} - ${type} (${severity})`);
        if (autoRecoveryEnabled &&
            this.selfHealingConfig.enabled &&
            !this.isTestMode) {
            await this.triggerAutoRecovery(incident);
        }
        return incident;
    }
    async simulateIncident(type, severity, duration) {
        const startTime = Date.now();
        const incidentId = this.generateIncidentId();
        this.logger.log(`Starting incident simulation: ${type} (${severity}) for ${duration}s`);
        const incident = await this.createIncident(type, severity, `Simulated ${type} incident`, this.getAffectedServicesForType(type), this.generateSimulationMetrics(type, severity), true);
        const recoveryTime = this.isTestMode
            ? Math.random() * 0.1 + 0.05
            : Math.random() * duration + 30;
        await this.delay(this.isTestMode ? recoveryTime : recoveryTime * 1000);
        const recoveryPlan = this.getRecoveryPlan(type, severity);
        const actionsTaken = recoveryPlan?.actions ?? [];
        const success = Math.random() > 0.1;
        const result = {
            incidentId,
            simulationType: type,
            success,
            recoveryTime: Date.now() - startTime,
            actionsTaken,
            metricsBefore: incident.metrics,
            metricsAfter: this.generateRecoveryMetrics(incident.metrics, success),
            lessonsLearned: this.generateLessonsLearned(type, success),
            timestamp: new Date().toISOString(),
        };
        this.simulationResults.push(result);
        this.logger.log(`Simulation completed: ${incidentId} - Success: ${success}`);
        return result;
    }
    async triggerAutoRecovery(incident) {
        const recoveryPlan = this.getRecoveryPlan(incident.type, incident.severity);
        if (!recoveryPlan) {
            this.logger.warn(`No recovery plan found for incident type: ${incident.type}`);
            return;
        }
        this.logger.log(`Starting auto-recovery for incident: ${incident.id}`);
        for (const action of recoveryPlan.actions) {
            try {
                await this.executeRecoveryAction(action, incident);
                this.logger.log(`Recovery action ${action} completed for incident: ${incident.id}`);
            }
            catch (error) {
                this.logger.error(`Recovery action ${action} failed for incident: ${incident.id}`, error);
            }
        }
        incident.status = 'RESOLVED';
        this.incidents.set(incident.id, incident);
    }
    async executeRecoveryAction(action, incident) {
        switch (action) {
            case 'RESTART_SERVICE':
                await this.restartService(incident.affectedServices);
                break;
            case 'SCALE_UP':
                await this.scaleUp(incident.affectedServices);
                break;
            case 'CLEAR_CACHE':
                await this.clearCache();
                break;
            case 'RESTART_CONTAINER':
                await this.restartContainer(incident.affectedServices);
                break;
            case 'FAILOVER':
                await this.failover(incident.affectedServices);
                break;
            case 'ROLLBACK':
                await this.rollback(incident.affectedServices);
                break;
            default:
                this.logger.warn(`Unknown recovery action: ${action}`);
        }
    }
    getRecoveryPlan(type, severity) {
        const plans = this.recoveryPlans.get(type);
        return plans?.find(plan => plan.severity === severity);
    }
    getRecoveryActions(type, severity) {
        const plan = this.getRecoveryPlan(type, severity);
        return plan?.actions ?? [];
    }
    calculateEstimatedImpact(severity, affectedServices) {
        const severityMultiplier = {
            LOW: 1,
            MEDIUM: 2,
            HIGH: 3,
            CRITICAL: 4,
        };
        const impact = severityMultiplier[severity] * affectedServices.length;
        if (impact <= 2)
            return 'Минимальное влияние';
        if (impact <= 4)
            return 'Низкое влияние';
        if (impact <= 6)
            return 'Среднее влияние';
        if (impact <= 8)
            return 'Высокое влияние';
        return 'Критическое влияние';
    }
    getAffectedServicesForType(type) {
        const serviceMapping = {
            CPU_SPIKE: ['API', 'Background Jobs'],
            MEMORY_LEAK: ['API', 'Web'],
            DISK_FULL: ['API', 'Database', 'Logs'],
            NETWORK_LATENCY: ['API', 'External Services'],
            DATABASE_TIMEOUT: ['API', 'Database'],
            SERVICE_UNAVAILABLE: ['API', 'Web', 'Database'],
        };
        return serviceMapping[type];
    }
    generateSimulationMetrics(type, severity) {
        const baseMetrics = {
            cpu_usage: 50,
            memory_usage: 60,
            disk_usage: 70,
            response_time: 200,
            error_rate: 2,
        };
        const severityMultiplier = {
            LOW: 1.2,
            MEDIUM: 1.5,
            HIGH: 2.0,
            CRITICAL: 3.0,
        };
        const multiplier = severityMultiplier[severity];
        switch (type) {
            case 'CPU_SPIKE':
                baseMetrics.cpu_usage = Math.min(100, 80 * multiplier);
                break;
            case 'MEMORY_LEAK':
                baseMetrics.memory_usage = Math.min(100, 85 * multiplier);
                break;
            case 'DISK_FULL':
                baseMetrics.disk_usage = Math.min(100, 95 * multiplier);
                break;
            case 'NETWORK_LATENCY':
                baseMetrics.response_time = 500 * multiplier;
                break;
            case 'DATABASE_TIMEOUT':
                baseMetrics.response_time = 1000 * multiplier;
                baseMetrics.error_rate = 10 * multiplier;
                break;
            case 'SERVICE_UNAVAILABLE':
                baseMetrics.error_rate = 50 * multiplier;
                baseMetrics.response_time = 5000 * multiplier;
                break;
        }
        return baseMetrics;
    }
    generateRecoveryMetrics(originalMetrics, success) {
        if (success) {
            return {
                cpu_usage: Math.max(20, (originalMetrics.cpu_usage ?? 50) * 0.3),
                memory_usage: Math.max(30, (originalMetrics.memory_usage ?? 60) * 0.4),
                disk_usage: Math.max(50, (originalMetrics.disk_usage ?? 70) * 0.7),
                response_time: Math.max(100, (originalMetrics.response_time ?? 200) * 0.2),
                error_rate: Math.max(0.1, (originalMetrics.error_rate ?? 1.0) * 0.1),
            };
        }
        return {
            cpu_usage: Math.min(100, (originalMetrics.cpu_usage ?? 50) * 1.2),
            memory_usage: Math.min(100, (originalMetrics.memory_usage ?? 60) * 1.3),
            disk_usage: Math.min(100, (originalMetrics.disk_usage ?? 70) * 1.1),
            response_time: (originalMetrics.response_time ?? 200) * 1.5,
            error_rate: Math.min(100, (originalMetrics.error_rate ?? 1.0) * 2.0),
        };
    }
    generateLessonsLearned(type, success) {
        const lessons = [];
        if (success) {
            lessons.push(`Автоматическое восстановление успешно справилось с ${type}`);
            lessons.push('Рекомендуется регулярно проводить симуляции инцидентов');
        }
        else {
            lessons.push(`Автоматическое восстановление не смогло справиться с ${type}`);
            lessons.push('Необходимо пересмотреть план восстановления');
            lessons.push('Рекомендуется ручное вмешательство для подобных инцидентов');
        }
        switch (type) {
            case 'CPU_SPIKE':
                lessons.push('Мониторинг CPU должен быть более агрессивным');
                break;
            case 'MEMORY_LEAK':
                lessons.push('Необходимо улучшить детекцию утечек памяти');
                break;
            case 'DISK_FULL':
                lessons.push('Рекомендуется настроить автоматическую очистку логов');
                break;
            case 'NETWORK_LATENCY':
                lessons.push('Следует добавить резервные сетевые маршруты');
                break;
            case 'DATABASE_TIMEOUT':
                lessons.push('Необходимо оптимизировать запросы к базе данных');
                break;
            case 'SERVICE_UNAVAILABLE':
                lessons.push('Рекомендуется улучшить health checks сервисов');
                break;
        }
        return lessons;
    }
    async restartService(services) {
        this.logger.log(`Restarting services: ${services.join(', ')}`);
        await this.delay(this.isTestMode ? 1 : 5000);
    }
    async scaleUp(services) {
        this.logger.log(`Scaling up services: ${services.join(', ')}`);
        await this.delay(this.isTestMode ? 1 : 10000);
    }
    async clearCache() {
        this.logger.log('Clearing cache');
        await this.delay(this.isTestMode ? 1 : 2000);
    }
    async restartContainer(services) {
        this.logger.log(`Restarting containers for services: ${services.join(', ')}`);
        await this.delay(this.isTestMode ? 1 : 8000);
    }
    async failover(services) {
        this.logger.log(`Performing failover for services: ${services.join(', ')}`);
        await this.delay(this.isTestMode ? 1 : 15000);
    }
    async rollback(services) {
        this.logger.log(`Rolling back services: ${services.join(', ')}`);
        await this.delay(this.isTestMode ? 1 : 20000);
    }
    generateIncidentId() {
        return `incident_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    getIncidents() {
        return Array.from(this.incidents.values());
    }
    getSimulationResults() {
        return this.simulationResults;
    }
    getSelfHealingConfig() {
        return this.selfHealingConfig;
    }
    updateSelfHealingConfig(config) {
        Object.assign(this.selfHealingConfig, config);
        this.logger.log('Self-healing configuration updated');
    }
};
IncidentSimulationService = IncidentSimulationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], IncidentSimulationService);



/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoggingMiddleware: () => (/* binding */ LoggingMiddleware)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(186);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;


let LoggingMiddleware = class LoggingMiddleware {
    constructor(elasticsearchService) {
        this.elasticsearchService = elasticsearchService;
    }
    use(req, res, next) {
        const startTime = Date.now();
        const requestId = this.generateRequestId();
        const userAgent = req.get('User-Agent') ?? 'Unknown';
        const ip = req.ip ?? req.connection.remoteAddress ?? 'Unknown';
        const middleware = this;
        this.logRequest(req, requestId, ip, userAgent);
        const originalSend = res.send;
        res.send = function (body) {
            const responseTime = Date.now() - startTime;
            const statusCode = res.statusCode;
            middleware.logResponse(req, res, requestId, responseTime, statusCode, body);
            return originalSend.call(this, body);
        };
        next();
    }
    logRequest(req, requestId, ip, userAgent) {
        const logData = {
            requestId,
            method: req.method,
            url: req.url,
            ip,
            userAgent,
            headers: this.sanitizeHeaders(req.headers),
            body: this.sanitizeBody(req.body),
            timestamp: new Date().toISOString(),
            type: 'request',
        };
        void this.elasticsearchService.info(`HTTP ${req.method} ${req.url}`, logData);
    }
    logResponse(req, _res, requestId, responseTime, statusCode, body) {
        const logData = {
            requestId,
            method: req.method,
            url: req.url,
            statusCode,
            responseTime,
            responseSize: typeof body === 'string' ? body.length : JSON.stringify(body).length,
            timestamp: new Date().toISOString(),
            type: 'response',
        };
        const level = statusCode >= 400 ? 'error' : 'info';
        const message = `HTTP ${req.method} ${req.url} - ${statusCode} (${responseTime}ms)`;
        if (level === 'error') {
            void this.elasticsearchService.error(message, logData);
        }
        else {
            void this.elasticsearchService.info(message, logData);
        }
    }
    generateRequestId() {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    sanitizeHeaders(headers) {
        const sanitized = { ...headers };
        const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'];
        sensitiveHeaders.forEach(header => {
            if (sanitized[header] !== undefined &&
                sanitized[header] !== null &&
                sanitized[header] !== '') {
                sanitized[header] = '[REDACTED]';
            }
        });
        return sanitized;
    }
    sanitizeBody(body) {
        if (body == null || typeof body !== 'object')
            return body;
        const sanitized = { ...body };
        const sensitiveFields = ['password', 'token', 'secret', 'key'];
        sensitiveFields.forEach(field => {
            if (sanitized[field] !== undefined &&
                sanitized[field] !== null &&
                sanitized[field] !== '') {
                sanitized[field] = '[REDACTED]';
            }
        });
        return sanitized;
    }
};
LoggingMiddleware = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_1__.ElasticsearchService !== "undefined" && _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_1__.ElasticsearchService) === "function" ? _a : Object])
], LoggingMiddleware);



/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ElasticsearchService: () => (/* binding */ ElasticsearchService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var winston__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/* harmony import */ var winston__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(winston__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ElasticsearchService_1;



let ElasticsearchService = ElasticsearchService_1 = class ElasticsearchService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ElasticsearchService_1.name);
        this.isConnected = false;
    }
    async onModuleInit() {
        await this.initialize();
    }
    async initialize() {
        this.config = {
            node: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('ELASTICSEARCH_NODE', 'string', {
                default: 'http://localhost:9200',
            }),
            auth: {
                username: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('ELASTICSEARCH_USERNAME', 'string', {
                    default: 'elastic',
                }),
                password: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('ELASTICSEARCH_PASSWORD', 'string', {
                    default: 'changeme',
                }),
            },
            index: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('ELASTICSEARCH_INDEX', 'string', {
                default: 'salespot-logs',
            }),
            maxRetries: 3,
            requestTimeout: 30000,
        };
        try {
            this.winstonLogger = winston__WEBPACK_IMPORTED_MODULE_1__.createLogger({
                level: 'info',
                format: winston__WEBPACK_IMPORTED_MODULE_1__.format.combine(winston__WEBPACK_IMPORTED_MODULE_1__.format.timestamp(), winston__WEBPACK_IMPORTED_MODULE_1__.format.errors({ stack: true }), winston__WEBPACK_IMPORTED_MODULE_1__.format.json()),
                transports: [
                    new winston__WEBPACK_IMPORTED_MODULE_1__.transports.Console({
                        format: winston__WEBPACK_IMPORTED_MODULE_1__.format.simple(),
                    }),
                ],
            });
            this.logger.log('Winston logger initialized (Elasticsearch transport disabled for now)');
            this.isConnected = true;
        }
        catch (error) {
            this.logger.error('Failed to initialize Elasticsearch service', error);
            this.isConnected = false;
        }
    }
    async log(level, message, metadata) {
        try {
            const logData = {
                '@timestamp': new Date().toISOString(),
                level,
                message,
                _service: 'salespot-api',
                ...metadata,
            };
            this.winstonLogger.log(level, message, logData);
        }
        catch (error) {
            this.logger.error('Failed to send log', error);
            console.log(`[${level.toUpperCase()}] ${message}`, metadata);
        }
    }
    async info(message, metadata) {
        return this.log('info', message, metadata);
    }
    async warn(message, metadata) {
        return this.log('warn', message, metadata);
    }
    async error(message, metadata) {
        return this.log('error', message, metadata);
    }
    async debug(message, metadata) {
        return this.log('debug', message, metadata);
    }
    async searchLogs(query, _size = 100) {
        this.logger.log('Search logs called with query:', query);
        return {
            hits: {
                hits: [],
                total: 0,
            },
        };
    }
    async getLogStats(timeRange = '1d') {
        this.logger.log('Get log stats called with timeRange:', timeRange);
        return {
            totalLogs: 0,
            logLevels: [],
            logCount: [],
            errorCount: 0,
        };
    }
    async healthCheck() {
        return {
            status: this.isConnected ? 'green' : 'red',
            numberOfNodes: 1,
            activeShards: 0,
            relocatingShards: 0,
            initializingShards: 0,
            unassignedShards: 0,
        };
    }
    async createIndex(indexName, mapping) {
        this.logger.log(`Mock: Index ${indexName} would be created with mapping:`, mapping);
        return { acknowledged: true };
    }
    async deleteOldLogs(daysToKeep = 30) {
        this.logger.log(`Mock: Old logs would be deleted (keeping ${daysToKeep} days)`);
        return 0;
    }
    async getConnectionStatus() {
        return {
            isConnected: this.isConnected,
            config: {
                node: this.config.node,
                index: this.config.index,
            },
        };
    }
};
ElasticsearchService = ElasticsearchService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], ElasticsearchService);



/***/ }),
/* 187 */
/***/ ((module) => {

module.exports = require("winston");

/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEnv: () => (/* binding */ getEnv),
/* harmony export */   getEnvBoolean: () => (/* binding */ getEnvBoolean),
/* harmony export */   getEnvNumber: () => (/* binding */ getEnvNumber),
/* harmony export */   getEnvString: () => (/* binding */ getEnvString),
/* harmony export */   hasEnv: () => (/* binding */ hasEnv)
/* harmony export */ });
function getEnv(key, type, options = {}) {
    const { default: defaultValue, required = false } = options;
    const value = process.env[key];
    if (required && (value === undefined || value === '')) {
        throw new Error(`Environment variable ${key} is required but not set`);
    }
    if (value === undefined || value === '') {
        if (defaultValue !== undefined) {
            return defaultValue;
        }
        switch (type) {
            case 'string':
                return '';
            case 'number':
                return 0;
            case 'boolean':
                return false;
        }
    }
    switch (type) {
        case 'string':
            return value;
        case 'number': {
            const num = parseFloat(value || '0');
            if (isNaN(num)) {
                if (defaultValue !== undefined) {
                    return defaultValue;
                }
                throw new Error(`Environment variable ${key} must be a valid number, got: ${value}`);
            }
            return num;
        }
        case 'boolean':
            if (value === 'true' || value === '1' || value === 'yes') {
                return true;
            }
            if (value === 'false' || value === '0' || value === 'no') {
                return false;
            }
            if (defaultValue !== undefined) {
                return defaultValue;
            }
            throw new Error(`Environment variable ${key} must be a valid boolean (true/false, 1/0, yes/no), got: ${value}`);
        default:
            throw new Error(`Unsupported type: ${type}`);
    }
}
function getEnvString(key, options) {
    return getEnv(key, 'string', options);
}
function getEnvNumber(key, options) {
    return getEnv(key, 'number', options);
}
function getEnvBoolean(key, options) {
    return getEnv(key, 'boolean', options);
}
function hasEnv(key) {
    const value = process.env[key];
    return value !== undefined && value !== '';
}


/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservabilityController: () => (/* binding */ ObservabilityController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _observability_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(190);
/* harmony import */ var _services_dashboard_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);
/* harmony import */ var _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(186);
/* harmony import */ var _services_health_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(192);
/* harmony import */ var _services_jaeger_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(194);
/* harmony import */ var _services_logging_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(179);
/* harmony import */ var _services_metrics_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(180);
/* harmony import */ var _services_tracing_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(191);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;










let ObservabilityController = class ObservabilityController {
    constructor(observabilityService, metricsService, loggingService, tracingService, healthService, elasticsearchService, dashboardService, jaegerService) {
        this.observabilityService = observabilityService;
        this.metricsService = metricsService;
        this.loggingService = loggingService;
        this.tracingService = tracingService;
        this.healthService = healthService;
        this.elasticsearchService = elasticsearchService;
        this.dashboardService = dashboardService;
        this.jaegerService = jaegerService;
    }
    async getMetrics() {
        return this.observabilityService.getMetrics();
    }
    async getSystemMetrics() {
        return this.observabilityService.getSystemMetrics();
    }
    async getBusinessMetrics() {
        return this.observabilityService.getBusinessMetrics();
    }
    async getPrometheusMetrics(res) {
        const metrics = this.metricsService.getPrometheusMetrics();
        res.set('Content-Type', 'text/plain');
        res.send(metrics);
    }
    async getLogs(level, limit) {
        return this.loggingService.getLogs(level, limit);
    }
    async getLogStats() {
        return this.loggingService.getLogStats();
    }
    async clearLogs() {
        await this.loggingService.clearLogs();
        return { message: 'Logs cleared successfully' };
    }
    async exportLogs(format = 'json') {
        return this.loggingService.exportLogs(format);
    }
    async getTraces(operation, limit) {
        return this.tracingService.getTraces(operation, limit);
    }
    async getTrace(traceId) {
        const trace = await this.tracingService.getTrace(traceId);
        if (!trace) {
            return { error: 'Trace not found' };
        }
        return trace;
    }
    async getTraceStats() {
        return this.tracingService.getTraceStats();
    }
    async exportTraces(format = 'json') {
        return this.tracingService.exportTraces(format);
    }
    async clearTraces() {
        await this.tracingService.clearTraces();
        return { message: 'Traces cleared successfully' };
    }
    async getHealth() {
        return this.healthService.getStatus();
    }
    async getDetailedHealth() {
        return this.healthService.getDetailedHealth();
    }
    async runHealthChecks() {
        await this.healthService.runHealthChecks();
        return { message: 'Health checks completed successfully' };
    }
    async testError() {
        await this.loggingService.error('Test error message', {
            test: true,
            timestamp: new Date().toISOString(),
        });
        this.metricsService.incrementErrorCount();
        return { message: 'Test error logged successfully' };
    }
    async testTrace() {
        const traceId = await this.tracingService.startTrace('test_operation', {
            test: true,
            timestamp: new Date().toISOString(),
        });
        await new Promise(resolve => setTimeout(resolve, 100));
        await this.tracingService.endTrace(traceId, {
            result: 'success',
            duration: 100,
        });
        return {
            message: 'Test trace created successfully',
            traceId,
        };
    }
    async getElasticsearchHealth() {
        return this.elasticsearchService.healthCheck();
    }
    async searchLogs(query, size) {
        const parsedQuery = query != null && query !== '' && query.length > 0
            ? JSON.parse(query)
            : { match_all: {} };
        return this.elasticsearchService.searchLogs(parsedQuery, size);
    }
    async getElasticsearchLogStats(timeRange) {
        return this.elasticsearchService.getLogStats(timeRange);
    }
    async testElasticsearchLogging() {
        await this.elasticsearchService.info('Test info message from API', {
            test: true,
            timestamp: new Date().toISOString(),
            service: 'salespot-api',
        });
        await this.elasticsearchService.error('Test error message from API', {
            test: true,
            timestamp: new Date().toISOString(),
            service: 'salespot-api',
            error: { code: 'TEST_ERROR', message: 'This is a test error' },
        });
        return { message: 'Test logs sent to Elasticsearch successfully' };
    }
    async cleanupOldLogs(daysToKeep) {
        const deleted = await this.elasticsearchService.deleteOldLogs(daysToKeep);
        return {
            message: 'Old logs cleaned up successfully',
            deletedCount: deleted,
        };
    }
    async getSystemDashboard() {
        return this.dashboardService.getSystemDashboard();
    }
    async getBusinessDashboard() {
        return this.dashboardService.getBusinessDashboard();
    }
    async getDashboard(dashboardId) {
        const dashboard = await this.dashboardService.getDashboard(dashboardId);
        if (!dashboard) {
            return { error: 'Dashboard not found' };
        }
        return dashboard;
    }
    async getWidgetData(dashboardId, widgetId) {
        return this.dashboardService.getWidgetData(dashboardId, widgetId);
    }
    async getAllDashboards() {
        return this.dashboardService.getAllDashboards();
    }
    async getJaegerHealth() {
        return this.jaegerService.healthCheck();
    }
    async getJaegerServiceInfo() {
        return this.jaegerService.getServiceInfo();
    }
    async searchJaegerTraces(serviceName, operationName, startTime, endTime, limit) {
        const query = {};
        if (serviceName !== undefined)
            query.serviceName = serviceName;
        if (operationName !== undefined)
            query.operationName = operationName;
        if (startTime !== undefined)
            query.startTime = startTime;
        if (endTime !== undefined)
            query.endTime = endTime;
        if (limit !== undefined)
            query.limit = limit;
        return this.jaegerService.searchTraces(query);
    }
    async getJaegerTrace(traceId) {
        const trace = await this.jaegerService.getTrace(traceId);
        if (!trace) {
            return { error: 'Trace not found' };
        }
        return trace;
    }
    async getJaegerStats() {
        return this.jaegerService.getTraceStats();
    }
    async getJaegerDependencies() {
        return this.jaegerService.getDependencies();
    }
    async testJaegerTracing() {
        const span = await this.jaegerService.startSpan('test_jaeger_operation');
        await new Promise(resolve => setTimeout(resolve, 150));
        await this.jaegerService.finishSpan(span.traceId, span.spanId, {
            'test.completed': true,
            'test.duration': 150,
        });
        return {
            message: 'Test Jaeger trace created successfully',
            traceId: span.traceId,
            spanId: span.spanId,
        };
    }
    async cleanupOldJaegerTraces(maxAge) {
        const deleted = await this.jaegerService.cleanupOldTraces(maxAge);
        return {
            message: 'Old traces cleaned up successfully',
            deletedCount: deleted,
        };
    }
    async runComprehensiveTest() {
        const results = {
            metrics: {},
            logging: {},
            tracing: {},
            health: {},
            elasticsearch: {},
            dashboard: {},
            jaeger: {},
        };
        try {
            this.metricsService.incrementRequestCount();
            this.metricsService.trackUserSession('test-user-123');
            this.metricsService.trackTransaction(100.5, 'test-user');
            this.metricsService.trackClick('test-button', 'test-user');
            this.metricsService.trackConversion(100, 'test-user');
            results.metrics = {
                system: await this.metricsService.getSystemMetrics(),
                business: await this.metricsService.getBusinessMetricsExtended(),
                prometheus: this.metricsService.getPrometheusMetrics().substring(0, 200) + '...',
            };
        }
        catch (error) {
            results.metrics = { error: error.message };
        }
        try {
            await this.loggingService.info('Comprehensive test - info message', {
                test: true,
            });
            await this.loggingService.warn('Comprehensive test - warning message', {
                test: true,
            });
            await this.loggingService.error('Comprehensive test - error message', {
                test: true,
            });
            results.logging = {
                stats: await this.loggingService.getLogStats(),
                recentLogs: await this.loggingService.getLogs('info', 5),
            };
        }
        catch (error) {
            results.logging = { error: error.message };
        }
        try {
            const traceId = await this.tracingService.startTrace('comprehensive_test', { test: true });
            await new Promise(resolve => setTimeout(resolve, 50));
            await this.tracingService.endTrace(traceId, { result: 'success' });
            results.tracing = {
                stats: await this.tracingService.getTraceStats(),
                recentTraces: await this.tracingService.getTraces('comprehensive_test', 3),
            };
        }
        catch (error) {
            results.tracing = { error: error.message };
        }
        try {
            results.health = {
                status: await this.healthService.getStatus(),
                detailed: await this.healthService.getDetailedHealth(),
            };
        }
        catch (error) {
            results.health = { error: error.message };
        }
        try {
            await this.elasticsearchService.info('Comprehensive test - ES info', {
                test: true,
            });
            await this.elasticsearchService.error('Comprehensive test - ES error', {
                test: true,
            });
            results.elasticsearch = {
                health: await this.elasticsearchService.healthCheck(),
                stats: await this.elasticsearchService.getLogStats('1h'),
            };
        }
        catch (error) {
            results.elasticsearch = { error: error.message };
        }
        try {
            results.dashboard = {
                system: await this.dashboardService.getSystemDashboard(),
                business: await this.dashboardService.getBusinessDashboard(),
                allDashboards: await this.dashboardService.getAllDashboards(),
            };
        }
        catch (error) {
            results.dashboard = { error: error.message };
        }
        try {
            const span = await this.jaegerService.startSpan('comprehensive_test_operation');
            await new Promise(resolve => setTimeout(resolve, 75));
            await this.jaegerService.finishSpan(span.traceId, span.spanId, {
                test: true,
            });
            results.jaeger = {
                health: await this.jaegerService.healthCheck(),
                stats: await this.jaegerService.getTraceStats(),
                serviceInfo: await this.jaegerService.getServiceInfo(),
            };
        }
        catch (error) {
            results.jaeger = { error: error.message };
        }
        return {
            message: 'Comprehensive observability test completed',
            timestamp: new Date().toISOString(),
            results,
        };
    }
    async simulateLoad(requests = 10, delay = 100) {
        const results = [];
        const startTime = Date.now();
        for (let i = 0; i < requests; i++) {
            const requestStart = Date.now();
            this.metricsService.incrementRequestCount();
            const traceId = await this.tracingService.startTrace(`load_test_request_${i}`, {
                requestId: i,
                loadTest: true,
            });
            await this.loggingService.info(`Load test request ${i} started`, {
                requestId: i,
                loadTest: true,
            });
            const workTime = Math.random() * 200 + 50;
            await new Promise(resolve => setTimeout(resolve, workTime));
            if (Math.random() < 0.1) {
                this.metricsService.incrementErrorCount();
                await this.loggingService.error(`Load test request ${i} failed`, {
                    requestId: i,
                    loadTest: true,
                    error: 'Simulated error',
                });
            }
            else {
                await this.loggingService.info(`Load test request ${i} completed`, {
                    requestId: i,
                    loadTest: true,
                    duration: workTime,
                });
            }
            await this.tracingService.endTrace(traceId, {
                duration: workTime,
                success: Math.random() >= 0.1,
            });
            const requestDuration = Date.now() - requestStart;
            results.push({
                requestId: i,
                duration: requestDuration,
                workTime,
                success: Math.random() >= 0.1,
            });
            if (i < requests - 1) {
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        const totalDuration = Date.now() - startTime;
        return {
            message: 'Load simulation completed',
            summary: {
                totalRequests: requests,
                totalDuration,
                averageRequestTime: results.reduce((sum, r) => sum + r.duration, 0) / results.length,
                successRate: (results.filter(r => r.success).length / results.length) * 100,
            },
            results,
        };
    }
    async generateTestMetrics(users = 50, transactions = 100) {
        const results = {
            users: [],
            transactions: [],
            clicks: [],
            conversions: [],
        };
        for (let i = 0; i < users; i++) {
            const userId = `test-user-${i}`;
            this.metricsService.trackUserSession(userId);
            results.users.push({
                userId,
                sessionStarted: new Date().toISOString(),
            });
        }
        for (let i = 0; i < transactions; i++) {
            const amount = Math.random() * 1000 + 10;
            const userId = `test-user-${Math.floor(Math.random() * users)}`;
            this.metricsService.trackTransaction(amount, userId);
            results.transactions.push({
                transactionId: i,
                amount,
                timestamp: new Date().toISOString(),
            });
        }
        const clickCount = Math.floor(transactions * 2.5);
        for (let i = 0; i < clickCount; i++) {
            const element = ['button', 'link', 'image', 'form'][Math.floor(Math.random() * 4)];
            const userId = `test-user-${Math.floor(Math.random() * users)}`;
            this.metricsService.trackClick(element ?? 'button', userId);
            results.clicks.push({
                clickId: i,
                element: element ?? 'button',
                timestamp: new Date().toISOString(),
            });
        }
        const conversionCount = Math.floor(transactions * 0.3);
        for (let i = 0; i < conversionCount; i++) {
            const funnel = ['signup', 'purchase', 'download', 'subscribe'][Math.floor(Math.random() * 4)];
            const userId = `test-user-${Math.floor(Math.random() * users)}`;
            this.metricsService.trackConversion(100, userId);
            results.conversions.push({
                conversionId: i,
                funnel: funnel ?? 'signup',
                timestamp: new Date().toISOString(),
            });
        }
        const updatedMetrics = await this.metricsService.getBusinessMetricsExtended();
        return {
            message: 'Test metrics generated successfully',
            summary: {
                usersGenerated: users,
                transactionsGenerated: transactions,
                clicksGenerated: clickCount,
                conversionsGenerated: conversionCount,
            },
            updatedMetrics: {
                dau: updatedMetrics.dau,
                mau: updatedMetrics.mau,
                ctr: updatedMetrics.userActivity.ctr,
                roi: updatedMetrics.userActivity.roi,
                conversionRate: updatedMetrics.userActivity.conversionRate,
            },
            results,
        };
    }
    async getSystemStatus() {
        const status = {
            timestamp: new Date().toISOString(),
            components: {},
            overall: 'unknown',
        };
        const checks = [
            {
                name: 'metrics',
                check: async () => await this.metricsService.getSystemMetrics(),
            },
            {
                name: 'logging',
                check: async () => await this.loggingService.getLogStats(),
            },
            {
                name: 'tracing',
                check: async () => await this.tracingService.getTraceStats(),
            },
            {
                name: 'health',
                check: async () => await this.healthService.getStatus(),
            },
            {
                name: 'elasticsearch',
                check: async () => await this.elasticsearchService.healthCheck(),
            },
            {
                name: 'dashboard',
                check: async () => await this.dashboardService.getAllDashboards(),
            },
            {
                name: 'jaeger',
                check: async () => await this.jaegerService.healthCheck(),
            },
        ];
        let healthyComponents = 0;
        const totalComponents = checks.length;
        for (const component of checks) {
            try {
                const result = await component.check();
                status.components[component.name] = {
                    status: 'healthy',
                    data: result,
                };
                healthyComponents++;
            }
            catch (error) {
                status.components[component.name] = {
                    status: 'unhealthy',
                    error: error instanceof Error ? error.message : 'Unknown error',
                };
            }
        }
        const healthPercentage = (healthyComponents / totalComponents) * 100;
        if (healthPercentage >= 90) {
            status.overall = 'healthy';
        }
        else if (healthPercentage >= 70) {
            status.overall = 'degraded';
        }
        else {
            status.overall = 'unhealthy';
        }
        status.summary = {
            totalComponents,
            healthyComponents,
            healthPercentage,
        };
        return status;
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all metrics (system, business, health)' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Metrics retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/system'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get system metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System metrics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getSystemMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/business'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get business metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Business metrics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getBusinessMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics/prometheus'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Prometheus format metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Prometheus metrics in text format',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], ObservabilityController.prototype, "getPrometheusMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('logs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get application logs' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'level',
        required: false,
        description: 'Filter logs by level',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of logs to return',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Logs retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('level')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('logs/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get log statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Log statistics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getLogStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('logs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clear all logs' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Logs cleared successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "clearLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('logs/export'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Export logs' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'format',
        required: false,
        description: 'Export format (json or text)',
        enum: ['json', 'text'],
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Logs exported successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('format')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "exportLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('traces'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get traces' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'operation',
        required: false,
        description: 'Filter traces by operation',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of traces to return',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Traces retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('operation')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getTraces", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('traces/:traceId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get specific trace' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Trace retrieved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Trace not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('traceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getTrace", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('traces/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get trace statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Trace statistics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getTraceStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('traces/export'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Export traces' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'format',
        required: false,
        description: 'Export format (json or jaeger)',
        enum: ['json', 'jaeger'],
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Traces exported successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('format')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "exportTraces", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('traces'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clear all traces' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Traces cleared successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "clearTraces", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get health status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health/detailed'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get detailed health information' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Detailed health information retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getDetailedHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('health/check'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Run health checks' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health checks completed successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "runHealthChecks", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/error'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Test error logging' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test error logged successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "testError", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/trace'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Test tracing' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test trace created successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "testTrace", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('elasticsearch/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Elasticsearch health status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Elasticsearch health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getElasticsearchHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('elasticsearch/logs'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Search logs in Elasticsearch' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'query',
        required: false,
        description: 'Elasticsearch query (JSON string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'size',
        required: false,
        description: 'Number of results to return',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Logs retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('query')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('size')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "searchLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('elasticsearch/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get log statistics from Elasticsearch' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'timeRange',
        required: false,
        description: 'Time range for stats (e.g., 1d, 7d)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Log statistics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('timeRange')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getElasticsearchLogStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('elasticsearch/test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Test Elasticsearch logging' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test log sent successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "testElasticsearchLogging", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('elasticsearch/cleanup'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clean up old logs from Elasticsearch' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'daysToKeep',
        required: false,
        description: 'Number of days to keep logs',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Old logs cleaned up successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('daysToKeep')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "cleanupOldLogs", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard/system'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get system dashboard data' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System dashboard data retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getSystemDashboard", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard/business'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get business dashboard data' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Business dashboard data retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getBusinessDashboard", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard/:dashboardId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get specific dashboard configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Dashboard configuration retrieved successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Dashboard not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('dashboardId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getDashboard", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard/:dashboardId/widget/:widgetId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get widget data for specific dashboard' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Widget data retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('dashboardId')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('widgetId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getWidgetData", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all available dashboards' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Dashboards retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getAllDashboards", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Jaeger service health status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Jaeger health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getJaegerHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/service-info'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Jaeger service information' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Jaeger service info retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getJaegerServiceInfo", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/traces'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Search Jaeger traces' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'serviceName',
        required: false,
        description: 'Filter by service name',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'operationName',
        required: false,
        description: 'Filter by operation name',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'startTime',
        required: false,
        description: 'Start time filter (timestamp)',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'endTime',
        required: false,
        description: 'End time filter (timestamp)',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of traces to return',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Traces retrieved successfully' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('serviceName')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('operationName')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('startTime')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('endTime')),
    __param(4, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Number, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "searchJaegerTraces", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/traces/:traceId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get specific Jaeger trace' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Trace retrieved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Trace not found' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('traceId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getJaegerTrace", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Jaeger trace statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Trace statistics retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getJaegerStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jaeger/dependencies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get service dependencies from Jaeger' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Dependencies retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getJaegerDependencies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jaeger/test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Test Jaeger tracing' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test trace created successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "testJaegerTracing", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('jaeger/cleanup'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Clean up old Jaeger traces' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'maxAge',
        required: false,
        description: 'Maximum age in milliseconds',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Old traces cleaned up successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('maxAge')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "cleanupOldJaegerTraces", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/comprehensive'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Run comprehensive observability test' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Comprehensive test completed successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "runComprehensiveTest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/load-simulation'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Simulate load for observability testing' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'requests',
        required: false,
        description: 'Number of requests to simulate',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'delay',
        required: false,
        description: 'Delay between requests (ms)',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Load simulation completed successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('requests')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('delay')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "simulateLoad", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/metrics-generation'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate test metrics data' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'users',
        required: false,
        description: 'Number of users to simulate',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'transactions',
        required: false,
        description: 'Number of transactions to simulate',
        type: Number,
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Test metrics generated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('users')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('transactions')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "generateTestMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('test/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get overall observability system status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'System status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ObservabilityController.prototype, "getSystemStatus", null);
ObservabilityController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Observability'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('observability'),
    __metadata("design:paramtypes", [typeof (_a = typeof _observability_service__WEBPACK_IMPORTED_MODULE_2__.ObservabilityService !== "undefined" && _observability_service__WEBPACK_IMPORTED_MODULE_2__.ObservabilityService) === "function" ? _a : Object, typeof (_b = typeof _services_metrics_service__WEBPACK_IMPORTED_MODULE_8__.MetricsService !== "undefined" && _services_metrics_service__WEBPACK_IMPORTED_MODULE_8__.MetricsService) === "function" ? _b : Object, typeof (_c = typeof _services_logging_service__WEBPACK_IMPORTED_MODULE_7__.LoggingService !== "undefined" && _services_logging_service__WEBPACK_IMPORTED_MODULE_7__.LoggingService) === "function" ? _c : Object, typeof (_d = typeof _services_tracing_service__WEBPACK_IMPORTED_MODULE_9__.TracingService !== "undefined" && _services_tracing_service__WEBPACK_IMPORTED_MODULE_9__.TracingService) === "function" ? _d : Object, typeof (_e = typeof _services_health_service__WEBPACK_IMPORTED_MODULE_5__.HealthService !== "undefined" && _services_health_service__WEBPACK_IMPORTED_MODULE_5__.HealthService) === "function" ? _e : Object, typeof (_f = typeof _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_4__.ElasticsearchService !== "undefined" && _services_elasticsearch_service__WEBPACK_IMPORTED_MODULE_4__.ElasticsearchService) === "function" ? _f : Object, typeof (_g = typeof _services_dashboard_service__WEBPACK_IMPORTED_MODULE_3__.DashboardService !== "undefined" && _services_dashboard_service__WEBPACK_IMPORTED_MODULE_3__.DashboardService) === "function" ? _g : Object, typeof (_h = typeof _services_jaeger_service__WEBPACK_IMPORTED_MODULE_6__.JaegerService !== "undefined" && _services_jaeger_service__WEBPACK_IMPORTED_MODULE_6__.JaegerService) === "function" ? _h : Object])
], ObservabilityController);



/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservabilityService: () => (/* binding */ ObservabilityService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_metrics_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(180);
/* harmony import */ var _services_logging_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);
/* harmony import */ var _services_tracing_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(191);
/* harmony import */ var _services_health_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(192);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;





let ObservabilityService = class ObservabilityService {
    constructor(metricsService, loggingService, tracingService, healthService) {
        this.metricsService = metricsService;
        this.loggingService = loggingService;
        this.tracingService = tracingService;
        this.healthService = healthService;
    }
    async onModuleInit() {
        await this.initializeServices();
    }
    async initializeServices() {
        await this.metricsService.initialize();
        await this.loggingService.initialize();
        await this.tracingService.initialize();
        await this.healthService.initialize();
    }
    async getSystemMetrics() {
        return this.metricsService.getSystemMetrics();
    }
    async getBusinessMetrics() {
        return this.metricsService.getBusinessMetrics();
    }
    async logEvent(level, message, context) {
        return this.loggingService.log(level, message, context);
    }
    async startTrace(operation, context) {
        return this.tracingService.startTrace(operation, context);
    }
    async endTrace(traceId, result) {
        return this.tracingService.endTrace(traceId, result);
    }
    async getHealthStatus() {
        return this.healthService.getStatus();
    }
    async getMetrics() {
        return {
            system: await this.getSystemMetrics(),
            business: await this.getBusinessMetrics(),
            health: await this.getHealthStatus(),
        };
    }
};
ObservabilityService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_metrics_service__WEBPACK_IMPORTED_MODULE_1__.MetricsService !== "undefined" && _services_metrics_service__WEBPACK_IMPORTED_MODULE_1__.MetricsService) === "function" ? _a : Object, typeof (_b = typeof _services_logging_service__WEBPACK_IMPORTED_MODULE_2__.LoggingService !== "undefined" && _services_logging_service__WEBPACK_IMPORTED_MODULE_2__.LoggingService) === "function" ? _b : Object, typeof (_c = typeof _services_tracing_service__WEBPACK_IMPORTED_MODULE_3__.TracingService !== "undefined" && _services_tracing_service__WEBPACK_IMPORTED_MODULE_3__.TracingService) === "function" ? _c : Object, typeof (_d = typeof _services_health_service__WEBPACK_IMPORTED_MODULE_4__.HealthService !== "undefined" && _services_health_service__WEBPACK_IMPORTED_MODULE_4__.HealthService) === "function" ? _d : Object])
], ObservabilityService);



/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TracingService: () => (/* binding */ TracingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let TracingService = class TracingService {
    constructor() {
        this.traces = new Map();
        this.maxTraces = 1000;
    }
    async onModuleInit() {
        await this.initialize();
    }
    async initialize() {
        this.traces.clear();
        console.log('[TracingService] Initialized');
    }
    async startTrace(operation, context) {
        const traceId = this.generateTraceId();
        const spanId = this.generateSpanId();
        const trace = {
            traceId,
            spanId,
            operation,
            startTime: Date.now(),
            context: context ?? {},
            status: 'active',
        };
        this.traces.set(traceId, trace);
        if (this.traces.size > this.maxTraces) {
            const firstKey = this.traces.keys().next().value;
            if (firstKey != null && firstKey !== '') {
                this.traces.delete(firstKey);
            }
        }
        return traceId;
    }
    async endTrace(traceId, result) {
        const trace = this.traces.get(traceId);
        if (!trace) {
            throw new Error(`Trace ${traceId} not found`);
        }
        const endTime = Date.now();
        trace.endTime = endTime;
        trace.duration = endTime - trace.startTime;
        trace.result = result ?? {};
        trace.status = 'completed';
        this.traces.set(traceId, trace);
    }
    async errorTrace(traceId, error) {
        const trace = this.traces.get(traceId);
        if (!trace) {
            throw new Error(`Trace ${traceId} not found`);
        }
        const endTime = Date.now();
        trace.endTime = endTime;
        trace.duration = endTime - trace.startTime;
        trace.result = {
            error: error.message,
            stack: error.stack,
        };
        trace.status = 'error';
        this.traces.set(traceId, trace);
    }
    async getTrace(traceId) {
        return this.traces.get(traceId) ?? null;
    }
    async getTraces(operation, limit = 100) {
        let traces = Array.from(this.traces.values());
        if (operation != null && operation !== '') {
            traces = traces.filter(trace => trace.operation === operation);
        }
        return traces.slice(-limit);
    }
    async getTraceStats() {
        const stats = {
            total: this.traces.size,
            active: 0,
            completed: 0,
            error: 0,
        };
        this.traces.forEach(trace => {
            stats[trace.status] = (stats[trace.status] ?? 0) + 1;
        });
        return stats;
    }
    async getAverageDuration(operation) {
        let traces = Array.from(this.traces.values());
        if (operation != null && operation !== '') {
            traces = traces.filter(trace => trace.operation === operation);
        }
        const completedTraces = traces.filter(trace => trace.status === 'completed' &&
            trace.duration != null &&
            trace.duration > 0);
        if (completedTraces.length === 0) {
            return 0;
        }
        const totalDuration = completedTraces.reduce((sum, trace) => sum + (trace.duration ?? 0), 0);
        return totalDuration / completedTraces.length;
    }
    async clearTraces() {
        this.traces.clear();
    }
    async exportTraces(format = 'json') {
        const traces = Array.from(this.traces.values());
        if (format === 'jaeger') {
            const jaegerTraces = traces.map(trace => ({
                traceID: trace.traceId,
                spans: [
                    {
                        traceID: trace.traceId,
                        spanID: trace.spanId,
                        operationName: trace.operation,
                        startTime: trace.startTime * 1000,
                        duration: (trace.duration ?? 0) * 1000,
                        tags: [
                            { key: 'status', value: trace.status },
                            ...Object.entries(trace.context ?? {}).map(([key, value]) => ({
                                key,
                                value: String(value),
                            })),
                        ],
                    },
                ],
            }));
            return JSON.stringify(jaegerTraces, null, 2);
        }
        return JSON.stringify(traces, null, 2);
    }
    generateTraceId() {
        return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    generateSpanId() {
        return `span_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
};
TracingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], TracingService);



/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HealthService: () => (/* binding */ HealthService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let HealthService = class HealthService {
    constructor() {
        this.startTime = Date.now();
        this.healthChecks = new Map();
    }
    async onModuleInit() {
        await this.initialize();
    }
    async initialize() {
        this.startTime = Date.now();
        this.healthChecks.clear();
        await this.registerHealthCheck('database', this.checkDatabase.bind(this));
        await this.registerHealthCheck('memory', this.checkMemory.bind(this));
        await this.registerHealthCheck('disk', this.checkDisk.bind(this));
        await this.registerHealthCheck('external_apis', this.checkExternalApis.bind(this));
    }
    async getStatus() {
        const checks = Array.from(this.healthChecks.values());
        const overallStatus = this.determineOverallStatus(checks);
        return {
            status: overallStatus,
            timestamp: new Date().toISOString(),
            uptime: Date.now() - this.startTime,
            version: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('npm_package_version', 'string', { default: '1.0.0' }),
            checks,
        };
    }
    async registerHealthCheck(name, checkFunction) {
        try {
            const startTime = Date.now();
            const check = await checkFunction();
            check.duration = Date.now() - startTime;
            check.timestamp = new Date().toISOString();
            this.healthChecks.set(name, check);
        }
        catch (error) {
            this.healthChecks.set(name, {
                name,
                status: 'unhealthy',
                message: error instanceof Error ? error.message : 'Unknown error',
                timestamp: new Date().toISOString(),
            });
        }
    }
    async runHealthChecks() {
        const checkPromises = Array.from(this.healthChecks.keys()).map(async (name) => {
            const check = this.healthChecks.get(name);
            if (check) {
                await this.registerHealthCheck(name, this.getCheckFunction(name));
            }
        });
        await Promise.all(checkPromises);
    }
    async checkDatabase() {
        const isHealthy = Math.random() > 0.1;
        return {
            name: 'database',
            status: isHealthy ? 'healthy' : 'unhealthy',
            message: isHealthy
                ? 'Database connection is healthy'
                : 'Database connection failed',
            timestamp: new Date().toISOString(),
        };
    }
    async checkMemory() {
        const memUsage = process.memoryUsage();
        const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
        const heapTotalMB = memUsage.heapTotal / 1024 / 1024;
        const memoryUsagePercent = (heapUsedMB / heapTotalMB) * 100;
        let status = 'healthy';
        let message = `Memory usage: ${heapUsedMB.toFixed(2)}MB / ${heapTotalMB.toFixed(2)}MB (${memoryUsagePercent.toFixed(1)}%)`;
        if (memoryUsagePercent > 90) {
            status = 'unhealthy';
            message += ' - Critical memory usage';
        }
        else if (memoryUsagePercent > 80) {
            status = 'degraded';
            message += ' - High memory usage';
        }
        return {
            name: 'memory',
            status,
            message,
            timestamp: new Date().toISOString(),
        };
    }
    async checkDisk() {
        const diskUsagePercent = Math.random() * 100;
        let status = 'healthy';
        let message = `Disk usage: ${diskUsagePercent.toFixed(1)}%`;
        if (diskUsagePercent > 95) {
            status = 'unhealthy';
            message += ' - Critical disk usage';
        }
        else if (diskUsagePercent > 85) {
            status = 'degraded';
            message += ' - High disk usage';
        }
        return {
            name: 'disk',
            status,
            message,
            timestamp: new Date().toISOString(),
        };
    }
    async checkExternalApis() {
        const isHealthy = Math.random() > 0.05;
        return {
            name: 'external_apis',
            status: isHealthy ? 'healthy' : 'degraded',
            message: isHealthy
                ? 'All external APIs are responding'
                : 'Some external APIs are slow',
            timestamp: new Date().toISOString(),
        };
    }
    getCheckFunction(name) {
        const checkFunctions = {
            database: this.checkDatabase.bind(this),
            memory: this.checkMemory.bind(this),
            disk: this.checkDisk.bind(this),
            external_apis: this.checkExternalApis.bind(this),
        };
        return (checkFunctions[name] ??
            (async () => ({
                name,
                status: 'unhealthy',
                message: 'Unknown health check',
                timestamp: new Date().toISOString(),
            })));
    }
    determineOverallStatus(checks) {
        if (checks.length === 0) {
            return 'healthy';
        }
        const hasUnhealthy = checks.some(check => check.status === 'unhealthy');
        const hasDegraded = checks.some(check => check.status === 'degraded');
        if (hasUnhealthy) {
            return 'unhealthy';
        }
        if (hasDegraded) {
            return 'degraded';
        }
        return 'healthy';
    }
    async getDetailedHealth() {
        const status = await this.getStatus();
        return {
            ...status,
            system: {
                nodeVersion: process.version,
                platform: process.platform,
                arch: process.arch,
                pid: process.pid,
                memory: process.memoryUsage(),
                cpu: process.cpuUsage(),
            },
            environment: {
                nodeEnv: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('NODE_ENV', 'string', { default: 'development' }),
                port: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('PORT', 'number', { default: 3001 }),
                hostname: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('HOSTNAME', 'string', { default: 'localhost' }),
            },
        };
    }
};
HealthService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], HealthService);



/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DashboardService: () => (/* binding */ DashboardService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _health_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(192);
/* harmony import */ var _metrics_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(180);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;



let DashboardService = class DashboardService {
    constructor(metricsService, healthService) {
        this.metricsService = metricsService;
        this.healthService = healthService;
        this.dashboards = new Map();
    }
    async onModuleInit() {
        await this.initializeDashboards();
    }
    async initializeDashboards() {
        const systemDashboard = {
            id: 'system-dashboard',
            title: 'Системный мониторинг',
            description: 'Мониторинг производительности и состояния системы',
            layout: 'grid',
            refreshInterval: 30,
            widgets: [
                {
                    id: 'cpu-usage',
                    title: 'Использование CPU',
                    type: 'metric',
                    data: {},
                    position: { x: 0, y: 0, width: 3, height: 2 },
                    refreshInterval: 10,
                },
                {
                    id: 'memory-usage',
                    title: 'Использование памяти',
                    type: 'metric',
                    data: {},
                    position: { x: 3, y: 0, width: 3, height: 2 },
                    refreshInterval: 10,
                },
                {
                    id: 'request-rate',
                    title: 'Запросы в секунду',
                    type: 'chart',
                    data: {},
                    position: { x: 0, y: 2, width: 6, height: 3 },
                    refreshInterval: 5,
                },
                {
                    id: 'error-rate',
                    title: 'Процент ошибок',
                    type: 'metric',
                    data: {},
                    position: { x: 6, y: 0, width: 3, height: 2 },
                    refreshInterval: 10,
                },
                {
                    id: 'health-status',
                    title: 'Статус здоровья',
                    type: 'status',
                    data: {},
                    position: { x: 6, y: 2, width: 3, height: 3 },
                    refreshInterval: 15,
                },
            ],
        };
        const businessDashboard = {
            id: 'business-dashboard',
            title: 'Бизнес-аналитика',
            description: 'Метрики пользовательской активности и бизнес-показатели',
            layout: 'grid',
            refreshInterval: 60,
            widgets: [
                {
                    id: 'dau-mau',
                    title: 'DAU / MAU',
                    type: 'metric',
                    data: {},
                    position: { x: 0, y: 0, width: 3, height: 2 },
                    refreshInterval: 60,
                },
                {
                    id: 'revenue-metrics',
                    title: 'Доход',
                    type: 'metric',
                    data: {},
                    position: { x: 3, y: 0, width: 3, height: 2 },
                    refreshInterval: 60,
                },
                {
                    id: 'conversion-rate',
                    title: 'Конверсия',
                    type: 'metric',
                    data: {},
                    position: { x: 6, y: 0, width: 3, height: 2 },
                    refreshInterval: 60,
                },
                {
                    id: 'user-activity-chart',
                    title: 'Активность пользователей',
                    type: 'chart',
                    data: {},
                    position: { x: 0, y: 2, width: 6, height: 3 },
                    refreshInterval: 30,
                },
                {
                    id: 'revenue-trends',
                    title: 'Тренды дохода',
                    type: 'chart',
                    data: {},
                    position: { x: 6, y: 2, width: 3, height: 3 },
                    refreshInterval: 60,
                },
            ],
        };
        this.dashboards.set(systemDashboard.id, systemDashboard);
        this.dashboards.set(businessDashboard.id, businessDashboard);
    }
    async getSystemDashboard() {
        const systemMetrics = await this.metricsService.getSystemMetrics();
        const healthStatus = await this.healthService.getStatus();
        const performanceMetrics = await this.calculatePerformanceMetrics();
        const dashboardHealthStatus = {
            status: healthStatus.status,
            checks: healthStatus.checks.map(check => ({
                name: check.name,
                status: check.status,
                message: check.message ?? 'No message available',
            })),
        };
        return {
            systemMetrics,
            healthStatus: dashboardHealthStatus,
            performanceMetrics,
        };
    }
    async getBusinessDashboard() {
        const businessMetrics = await this.metricsService.getBusinessMetricsExtended();
        const userActivity = businessMetrics.userActivity;
        const trends = businessMetrics.trends;
        const revenueMetrics = await this.calculateRevenueMetrics();
        const engagementMetrics = {
            averageSessionDuration: userActivity.averageSessionDuration,
            bounceRate: userActivity.bounceRate,
            retentionRate: userActivity.retentionRate,
            activeUsers: userActivity.activeUsers,
        };
        return {
            userActivity,
            trends,
            revenueMetrics,
            engagementMetrics,
        };
    }
    async getDashboard(dashboardId) {
        return this.dashboards.get(dashboardId) ?? null;
    }
    async getAllDashboards() {
        return Array.from(this.dashboards.values());
    }
    async createDashboard(dashboard) {
        this.dashboards.set(dashboard.id, dashboard);
    }
    async updateDashboard(dashboardId, updates) {
        const dashboard = this.dashboards.get(dashboardId);
        if (dashboard) {
            this.dashboards.set(dashboardId, { ...dashboard, ...updates });
        }
    }
    async deleteDashboard(dashboardId) {
        this.dashboards.delete(dashboardId);
    }
    async getWidgetData(dashboardId, widgetId) {
        const dashboard = this.dashboards.get(dashboardId);
        if (!dashboard) {
            return {};
        }
        const widget = dashboard.widgets.find(w => w.id === widgetId);
        if (!widget) {
            return {};
        }
        switch (widget.type) {
            case 'metric':
                return await this.getMetricWidgetData(widget);
            case 'chart':
                return await this.getChartWidgetData(widget);
            case 'table':
                return await this.getTableWidgetData(widget);
            case 'status':
                return await this.getStatusWidgetData(widget);
            default:
                return {};
        }
    }
    async getMetricWidgetData(widget) {
        switch (widget.id) {
            case 'cpu-usage': {
                const systemMetrics = await this.metricsService.getSystemMetrics();
                return { value: systemMetrics.cpu, unit: 'seconds', trend: 'stable' };
            }
            case 'memory-usage': {
                const metrics = await this.metricsService.getSystemMetrics();
                return { value: metrics.memory, unit: 'MB', trend: 'stable' };
            }
            case 'error-rate': {
                const sysMetrics = await this.metricsService.getSystemMetrics();
                return { value: sysMetrics.errorRate, unit: '%', trend: 'stable' };
            }
            case 'dau-mau': {
                const businessMetrics = await this.metricsService.getBusinessMetricsExtended();
                return {
                    dau: businessMetrics.dau,
                    mau: businessMetrics.mau,
                    ratio: businessMetrics.mau > 0
                        ? (businessMetrics.dau / businessMetrics.mau) * 100
                        : 0,
                };
            }
            case 'revenue-metrics': {
                const revenueMetrics = await this.calculateRevenueMetrics();
                return {
                    totalRevenue: revenueMetrics.totalRevenue,
                    revenuePerUser: revenueMetrics.revenuePerUser,
                    averageTransactionValue: revenueMetrics.averageTransactionValue,
                };
            }
            case 'conversion-rate': {
                const userActivity = await this.metricsService.getBusinessMetricsExtended();
                return {
                    value: userActivity.userActivity.conversionRate,
                    unit: '%',
                    trend: 'up',
                };
            }
            default:
                return {};
        }
    }
    async getChartWidgetData(widget) {
        switch (widget.id) {
            case 'request-rate': {
                return {
                    type: 'line',
                    data: await this.generateRequestRateData(),
                    options: {
                        title: 'Запросы в секунду',
                        xAxis: { title: 'Время' },
                        yAxis: { title: 'Запросы/сек' },
                    },
                };
            }
            case 'user-activity-chart': {
                return {
                    type: 'bar',
                    data: await this.generateUserActivityData(),
                    options: {
                        title: 'Активность пользователей',
                        xAxis: { title: 'Период' },
                        yAxis: { title: 'Пользователи' },
                    },
                };
            }
            case 'revenue-trends': {
                return {
                    type: 'line',
                    data: await this.generateRevenueTrendsData(),
                    options: {
                        title: 'Тренды дохода',
                        xAxis: { title: 'Время' },
                        yAxis: { title: 'Доход' },
                    },
                };
            }
            default:
                return {};
        }
    }
    async getTableWidgetData(_widget) {
        return {
            columns: ['Метрика', 'Значение', 'Изменение'],
            data: [],
        };
    }
    async getStatusWidgetData(widget) {
        switch (widget.id) {
            case 'health-status': {
                const healthStatus = await this.healthService.getStatus();
                return {
                    overallStatus: healthStatus.status,
                    checks: healthStatus.checks.map(check => ({
                        name: check.name,
                        status: check.status,
                        message: check.message,
                    })),
                };
            }
            default:
                return {};
        }
    }
    async calculatePerformanceMetrics() {
        const systemMetrics = await this.metricsService.getSystemMetrics();
        const uptime = systemMetrics.uptime;
        return {
            averageResponseTime: 150,
            requestsPerSecond: uptime > 0 ? systemMetrics.requestCount / uptime : 0,
            errorCount: systemMetrics.requestCount * (systemMetrics.errorRate / 100),
            successRate: 100 - systemMetrics.errorRate,
        };
    }
    async calculateRevenueMetrics() {
        const businessMetrics = await this.metricsService.getBusinessMetricsExtended();
        const userActivity = businessMetrics.userActivity;
        return {
            totalRevenue: userActivity.revenuePerUser * userActivity.activeUsers,
            revenuePerUser: userActivity.revenuePerUser,
            averageTransactionValue: userActivity.totalTransactions > 0
                ? (userActivity.revenuePerUser * userActivity.activeUsers) /
                    userActivity.totalTransactions
                : 0,
            conversionRate: userActivity.conversionRate,
        };
    }
    async generateRequestRateData() {
        const data = [];
        const now = new Date();
        for (let i = 10; i >= 0; i--) {
            const time = new Date(now.getTime() - i * 60000);
            data.push({
                x: time.toLocaleTimeString(),
                y: Math.floor(Math.random() * 100) + 50,
            });
        }
        return data;
    }
    async generateUserActivityData() {
        return [
            { x: 'Пн', y: 1200 },
            { x: 'Вт', y: 1350 },
            { x: 'Ср', y: 1100 },
            { x: 'Чт', y: 1400 },
            { x: 'Пт', y: 1600 },
            { x: 'Сб', y: 1800 },
            { x: 'Вс', y: 1700 },
        ];
    }
    async generateRevenueTrendsData() {
        const data = [];
        const now = new Date();
        for (let i = 7; i >= 0; i--) {
            const time = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
            data.push({
                x: time.toLocaleDateString(),
                y: Math.floor(Math.random() * 10000) + 5000,
            });
        }
        return data;
    }
};
DashboardService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _metrics_service__WEBPACK_IMPORTED_MODULE_2__.MetricsService !== "undefined" && _metrics_service__WEBPACK_IMPORTED_MODULE_2__.MetricsService) === "function" ? _a : Object, typeof (_b = typeof _health_service__WEBPACK_IMPORTED_MODULE_1__.HealthService !== "undefined" && _health_service__WEBPACK_IMPORTED_MODULE_1__.HealthService) === "function" ? _b : Object])
], DashboardService);



/***/ }),
/* 194 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JaegerService: () => (/* binding */ JaegerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tracing_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(191);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var JaegerService_1;
var _a;



let JaegerService = JaegerService_1 = class JaegerService {
    constructor(tracingService) {
        this.tracingService = tracingService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(JaegerService_1.name);
        this.traces = new Map();
        this.serviceName = 'salespot-api';
        this.serviceVersion = '1.0.0';
        this.isConnected = false;
    }
    async onModuleInit() {
        await this.initializeJaeger();
    }
    async initializeJaeger() {
        try {
            this.isConnected = true;
            this.logger.log('Jaeger service initialized successfully');
        }
        catch (error) {
            this.logger.error('Failed to initialize Jaeger service', error);
            this.isConnected = false;
        }
    }
    async startSpan(operationName, parentSpanId) {
        const traceId = this.generateTraceId();
        const spanId = this.generateSpanId();
        const startTime = Date.now();
        const span = {
            traceId,
            spanId,
            ...(parentSpanId != null && parentSpanId !== '' && { parentSpanId }),
            operationName,
            startTime,
            tags: {
                'service.name': this.serviceName,
                'service.version': this.serviceVersion,
                'span.kind': 'server',
            },
            logs: [],
        };
        const trace = {
            traceId,
            spans: [span],
            startTime,
            endTime: startTime,
            duration: 0,
            serviceName: this.serviceName,
            operationName,
        };
        this.traces.set(traceId, trace);
        await this.tracingService.startTrace(operationName, {
            traceId,
            spanId,
            parentSpanId,
        });
        return span;
    }
    async finishSpan(traceId, spanId, tags) {
        const trace = this.traces.get(traceId);
        if (!trace) {
            this.logger.warn(`Trace ${traceId} not found`);
            return;
        }
        const span = trace.spans.find(s => s.spanId === spanId);
        if (!span) {
            this.logger.warn(`Span ${spanId} not found in trace ${traceId}`);
            return;
        }
        const endTime = Date.now();
        span.endTime = endTime;
        span.duration = endTime - span.startTime;
        if (tags) {
            span.tags = { ...span.tags, ...tags };
        }
        trace.endTime = Math.max(trace.endTime, endTime);
        trace.duration = trace.endTime - trace.startTime;
        if (this.isConnected) {
            await this.sendSpanToJaeger(span);
        }
        await this.tracingService.endTrace(traceId, { spanId });
    }
    async addSpanLog(traceId, spanId, fields) {
        const trace = this.traces.get(traceId);
        if (!trace) {
            this.logger.warn(`Trace ${traceId} not found`);
            return;
        }
        const span = trace.spans.find(s => s.spanId === spanId);
        if (!span) {
            this.logger.warn(`Span ${spanId} not found in trace ${traceId}`);
            return;
        }
        span.logs.push({
            timestamp: Date.now(),
            fields,
        });
    }
    async addSpanTag(traceId, spanId, key, value) {
        const trace = this.traces.get(traceId);
        if (!trace) {
            this.logger.warn(`Trace ${traceId} not found`);
            return;
        }
        const span = trace.spans.find(s => s.spanId === spanId);
        if (!span) {
            this.logger.warn(`Span ${spanId} not found in trace ${traceId}`);
            return;
        }
        span.tags[key] = value;
    }
    async getTrace(traceId) {
        return this.traces.get(traceId) ?? null;
    }
    async searchTraces(query) {
        const traces = Array.from(this.traces.values());
        let filtered = traces;
        if (query.serviceName != null && query.serviceName !== '') {
            filtered = filtered.filter(t => t.serviceName === query.serviceName);
        }
        if (query.operationName != null && query.operationName !== '') {
            filtered = filtered.filter(t => t.operationName === query.operationName);
        }
        if (query.startTime !== undefined) {
            const startTime = query.startTime;
            filtered = filtered.filter(t => t.startTime >= startTime);
        }
        if (query.endTime !== undefined) {
            const endTime = query.endTime;
            filtered = filtered.filter(t => t.endTime <= endTime);
        }
        if (query.tags) {
            filtered = filtered.filter(trace => {
                return trace.spans.some(span => {
                    if (query.tags == null)
                        return true;
                    return Object.entries(query.tags).every(([key, value]) => {
                        return span.tags[key] === value;
                    });
                });
            });
        }
        if (query.limit != null && query.limit > 0) {
            filtered = filtered.slice(0, query.limit);
        }
        return filtered.sort((a, b) => b.startTime - a.startTime);
    }
    async getServiceInfo() {
        return {
            name: this.serviceName,
            version: this.serviceVersion,
            endpoints: [
                (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('JAEGER_ENDPOINT', 'string', {
                    default: 'http://localhost:14268/api/traces',
                }),
            ],
        };
    }
    async getDependencies() {
        const dependencies = new Map();
        for (const trace of this.traces.values()) {
            for (const span of trace.spans) {
                if (span.references && span.references.length > 0) {
                    for (const ref of span.references) {
                        const key = `${ref.traceId}:${ref.spanId}`;
                        const existing = dependencies.get(key);
                        if (existing) {
                            existing.callCount++;
                        }
                        else {
                            dependencies.set(key, {
                                parent: this.serviceName,
                                child: span.tags['peer.service'] || 'unknown',
                                callCount: 1,
                                source: 'jaeger',
                            });
                        }
                    }
                }
            }
        }
        return Array.from(dependencies.values());
    }
    async getTraceStats() {
        const traces = Array.from(this.traces.values());
        const totalTraces = traces.length;
        const totalSpans = traces.reduce((sum, trace) => sum + trace.spans.length, 0);
        const averageTraceDuration = totalTraces > 0
            ? traces.reduce((sum, trace) => sum + trace.duration, 0) / totalTraces
            : 0;
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        const recentTraces = traces.filter(t => t.startTime >= oneHourAgo);
        const tracesPerMinute = recentTraces.length / 60;
        const errorSpans = traces.reduce((sum, trace) => {
            return (sum +
                trace.spans.filter(span => {
                    const error = span.tags['error'];
                    const statusCode = span.tags['http.status_code'];
                    return (error === true ||
                        (typeof statusCode === 'number' && statusCode >= 400));
                }).length);
        }, 0);
        const errorRate = totalSpans > 0 ? (errorSpans / totalSpans) * 100 : 0;
        return {
            totalTraces,
            totalSpans,
            averageTraceDuration,
            tracesPerMinute,
            errorRate,
        };
    }
    async healthCheck() {
        const tracesCount = this.traces.size;
        const lastActivity = tracesCount > 0
            ? Math.max(...Array.from(this.traces.values()).map(t => t.startTime))
            : 0;
        return {
            status: this.isConnected ? 'healthy' : 'degraded',
            message: this.isConnected
                ? 'Jaeger service is connected and operational'
                : 'Jaeger service is not connected, using local storage',
            details: {
                connected: this.isConnected,
                tracesCount,
                lastActivity,
            },
        };
    }
    async cleanupOldTraces(maxAge = 24 * 60 * 60 * 1000) {
        const cutoffTime = Date.now() - maxAge;
        const oldTraces = Array.from(this.traces.entries()).filter(([, trace]) => trace.startTime < cutoffTime);
        for (const [traceId] of oldTraces) {
            this.traces.delete(traceId);
        }
        return oldTraces.length;
    }
    generateTraceId() {
        return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    generateSpanId() {
        return `span_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    async sendSpanToJaeger(span) {
        this.logger.debug(`Sending span ${span.spanId} to Jaeger`);
    }
};
JaegerService = JaegerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _tracing_service__WEBPACK_IMPORTED_MODULE_1__.TracingService !== "undefined" && _tracing_service__WEBPACK_IMPORTED_MODULE_1__.TracingService) === "function" ? _a : Object])
], JaegerService);



/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceModule: () => (/* binding */ PerformanceModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(196);
/* harmony import */ var _auto_scaling_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(197);
/* harmony import */ var _performance_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(198);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






let PerformanceModule = class PerformanceModule {
};
PerformanceModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [_nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigModule, _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitterModule],
        providers: [_performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__.PerformanceOptimizationService, _auto_scaling_service__WEBPACK_IMPORTED_MODULE_4__.AutoScalingService],
        controllers: [_performance_controller__WEBPACK_IMPORTED_MODULE_5__.PerformanceController],
        exports: [_performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__.PerformanceOptimizationService, _auto_scaling_service__WEBPACK_IMPORTED_MODULE_4__.AutoScalingService],
    })
], PerformanceModule);



/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceOptimizationService: () => (/* binding */ PerformanceOptimizationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PerformanceOptimizationService_1;
var _a, _b;



let PerformanceOptimizationService = PerformanceOptimizationService_1 = class PerformanceOptimizationService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(PerformanceOptimizationService_1.name);
        this.performanceMetrics = new Map();
        this.performanceProfiles = new Map();
        this.optimizationRules = new Map();
        this.optimizationActions = new Map();
        this.cachingStrategies = new Map();
        this.initializeOptimizationRules();
        this.initializeCachingStrategies();
        this.startPerformanceMonitoring();
        this._configService.get('PERFORMANCE_MONITORING_ENABLED');
    }
    initializeOptimizationRules() {
        const rules = [
            {
                id: 'high-response-time',
                name: 'High Response Time',
                description: 'Optimize endpoints with response time > 1s',
                condition: 'responseTime.p95 > 1000',
                action: 'enable_caching',
                priority: 'high',
                enabled: true,
                parameters: {
                    cacheTtl: 300,
                    cacheType: 'redis',
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-cpu-usage',
                name: 'High CPU Usage',
                description: 'Optimize services with CPU usage > 80%',
                condition: 'cpuUsage > 80',
                action: 'scale_horizontal',
                priority: 'critical',
                enabled: true,
                parameters: {
                    minReplicas: 2,
                    maxReplicas: 10,
                    targetCpu: 70,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-memory-usage',
                name: 'High Memory Usage',
                description: 'Optimize services with memory usage > 85%',
                condition: 'memoryUsage > 85',
                action: 'optimize_memory',
                priority: 'high',
                enabled: true,
                parameters: {
                    garbageCollection: true,
                    memoryLimit: '2Gi',
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'high-error-rate',
                name: 'High Error Rate',
                description: 'Optimize services with error rate > 5%',
                condition: 'errorRate > 5',
                action: 'circuit_breaker',
                priority: 'critical',
                enabled: true,
                parameters: {
                    failureThreshold: 5,
                    timeout: 30000,
                    resetTimeout: 60000,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'low-throughput',
                name: 'Low Throughput',
                description: 'Optimize services with low throughput',
                condition: 'throughput.requestsPerSecond < 10',
                action: 'connection_pooling',
                priority: 'medium',
                enabled: true,
                parameters: {
                    poolSize: 20,
                    maxConnections: 100,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        rules.forEach(rule => {
            this.optimizationRules.set(rule.id, rule);
        });
        this.logger.log(`Initialized ${rules.length} optimization rules`);
    }
    initializeCachingStrategies() {
        const strategies = [
            {
                id: 'api-response-cache',
                name: 'API Response Cache',
                type: 'redis',
                configuration: {
                    ttl: 300,
                    maxSize: 1000,
                    evictionPolicy: 'lru',
                    compression: true,
                    serialization: 'json',
                },
                targets: ['/api/cards', '/api/users', '/api/config'],
                enabled: true,
                metrics: {
                    hitRate: 0,
                    missRate: 0,
                    evictionRate: 0,
                    memoryUsage: 0,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'database-query-cache',
                name: 'Database Query Cache',
                type: 'memory',
                configuration: {
                    ttl: 600,
                    maxSize: 500,
                    evictionPolicy: 'lfu',
                    compression: false,
                    serialization: 'binary',
                },
                targets: ['user_queries', 'card_queries', 'config_queries'],
                enabled: true,
                metrics: {
                    hitRate: 0,
                    missRate: 0,
                    evictionRate: 0,
                    memoryUsage: 0,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'static-assets-cache',
                name: 'Static Assets Cache',
                type: 'cdn',
                configuration: {
                    ttl: 86400,
                    maxSize: 10000,
                    evictionPolicy: 'ttl',
                    compression: true,
                    serialization: 'binary',
                },
                targets: ['/static/*', '/assets/*', '/images/*'],
                enabled: true,
                metrics: {
                    hitRate: 0,
                    missRate: 0,
                    evictionRate: 0,
                    memoryUsage: 0,
                },
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        strategies.forEach(strategy => {
            this.cachingStrategies.set(strategy.id, strategy);
        });
        this.logger.log(`Initialized ${strategies.length} caching strategies`);
    }
    startPerformanceMonitoring() {
        setInterval(() => {
            void this.collectPerformanceMetrics();
        }, 30000);
        setInterval(() => {
            void this.analyzePerformance();
        }, 300000);
    }
    async collectPerformanceMetrics() {
        try {
            const services = [
                'auth-service',
                'cards-service',
                'monitoring-service',
                'security-service',
            ];
            for (const service of services) {
                const metrics = [
                    {
                        id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: 'response_time',
                        value: Math.random() * 1000 + 100,
                        unit: 'ms',
                        timestamp: new Date(),
                        __service: service,
                        labels: { endpoint: '/api/test' },
                    },
                    {
                        id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: 'cpu_usage',
                        value: Math.random() * 100,
                        unit: '%',
                        timestamp: new Date(),
                        __service: service,
                        labels: {},
                    },
                    {
                        id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: 'memory_usage',
                        value: Math.random() * 100,
                        unit: '%',
                        timestamp: new Date(),
                        __service: service,
                        labels: {},
                    },
                    {
                        id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: 'error_rate',
                        value: Math.random() * 10,
                        unit: '%',
                        timestamp: new Date(),
                        __service: service,
                        labels: {},
                    },
                    {
                        id: `metric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: 'throughput',
                        value: Math.random() * 100 + 10,
                        unit: 'req/s',
                        timestamp: new Date(),
                        __service: service,
                        labels: {},
                    },
                ];
                for (const metric of metrics) {
                    const key = `${service}.${metric.name}`;
                    const existingMetrics = this.performanceMetrics.get(key) ?? [];
                    existingMetrics.push(metric);
                    if (existingMetrics.length > 1000) {
                        existingMetrics.splice(0, existingMetrics.length - 1000);
                    }
                    this.performanceMetrics.set(key, existingMetrics);
                }
            }
            this.logger.debug('Performance metrics collected');
        }
        catch (error) {
            this.logger.error('Error collecting performance metrics:', error);
        }
    }
    async analyzePerformance() {
        try {
            for (const [, rule] of this.optimizationRules) {
                if (!rule.enabled) {
                    continue;
                }
                await this.evaluateOptimizationRule(rule);
            }
        }
        catch (error) {
            this.logger.error('Error analyzing performance:', error);
        }
    }
    async evaluateOptimizationRule(rule) {
        try {
            const recentMetrics = this.getRecentMetrics(5);
            const shouldApply = this.evaluateCondition(rule.condition, recentMetrics);
            if (shouldApply) {
                await this.applyOptimization(rule);
            }
        }
        catch (error) {
            this.logger.error(`Error evaluating rule ${rule.id}:`, error);
        }
    }
    getRecentMetrics(minutes) {
        const cutoffTime = new Date(Date.now() - minutes * 60 * 1000);
        const metrics = {};
        for (const [key, metricList] of this.performanceMetrics) {
            const recentMetrics = metricList.filter(m => m.timestamp > cutoffTime);
            if (recentMetrics.length > 0) {
                const values = recentMetrics.map(m => m.value);
                metrics[key] = {
                    avg: values.reduce((sum, val) => sum + val, 0) / values.length,
                    max: Math.max(...values),
                    min: Math.min(...values),
                    p95: this.calculatePercentile(values, 95),
                    p99: this.calculatePercentile(values, 99),
                };
            }
        }
        return metrics;
    }
    calculatePercentile(values, percentile) {
        const sorted = values.sort((a, b) => a - b);
        const index = Math.ceil((percentile / 100) * sorted.length) - 1;
        return sorted[index] ?? 0;
    }
    evaluateCondition(condition, metrics) {
        if (condition.includes('responseTime.p95 > 1000')) {
            const responseTimeMetrics = Object.keys(metrics)
                .filter(key => key.includes('response_time'))
                .map(key => metrics[key]);
            return responseTimeMetrics.some(m => m.p95 != null &&
                m.p95 > 1000);
        }
        if (condition.includes('cpuUsage > 80')) {
            const cpuMetrics = Object.keys(metrics)
                .filter(key => key.includes('cpu_usage'))
                .map(key => metrics[key]);
            return cpuMetrics.some(m => m.avg != null && m.avg > 80);
        }
        if (condition.includes('memoryUsage > 85')) {
            const memoryMetrics = Object.keys(metrics)
                .filter(key => key.includes('memory_usage'))
                .map(key => metrics[key]);
            return memoryMetrics.some(m => m.avg > 85);
        }
        if (condition.includes('errorRate > 5')) {
            const errorMetrics = Object.keys(metrics)
                .filter(key => key.includes('error_rate'))
                .map(key => metrics[key]);
            return errorMetrics.some(m => m.avg > 5);
        }
        if (condition.includes('throughput.requestsPerSecond < 10')) {
            const throughputMetrics = Object.keys(metrics)
                .filter(key => key.includes('throughput'))
                .map(key => metrics[key]);
            return throughputMetrics.some(m => m.avg < 10);
        }
        return false;
    }
    async applyOptimization(rule) {
        const actionId = `action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const action = {
            id: actionId,
            ruleId: rule.id,
            type: this.getActionType(rule.action),
            description: `Applied optimization: ${rule.name}`,
            status: 'pending',
            impact: rule.priority === 'critical'
                ? 'high'
                : rule.priority === 'high'
                    ? 'medium'
                    : 'low',
            metrics: {
                before: this.getCurrentMetrics(),
                after: {},
                improvement: 0,
            },
            createdAt: new Date(),
            createdBy: 'system',
        };
        this.optimizationActions.set(actionId, action);
        setTimeout(() => {
            void this.completeOptimizationAction(actionId, 'applied');
        }, Math.random() * 10000 + 5000);
        this.logger.log(`Applied optimization: ${rule.name} (${rule.action})`);
    }
    getActionType(action) {
        if (action.includes('cache'))
            return 'cache';
        if (action.includes('database'))
            return 'database';
        if (action.includes('api'))
            return 'api';
        if (action.includes('resource'))
            return 'resource';
        return 'code';
    }
    getCurrentMetrics() {
        const metrics = {};
        for (const [key, metricList] of this.performanceMetrics) {
            if (metricList.length > 0) {
                const latest = metricList[metricList.length - 1];
                metrics[key] = latest?.value ?? 0;
            }
        }
        return metrics;
    }
    async completeOptimizationAction(actionId, status, improvement) {
        const action = this.optimizationActions.get(actionId);
        if (!action) {
            throw new Error(`Optimization action ${actionId} not found`);
        }
        action.status = status;
        if (status === 'applied') {
            action.appliedAt = new Date();
            action.metrics.after = this.getCurrentMetrics();
            action.metrics.improvement = improvement ?? Math.random() * 30 + 10;
        }
        else if (status === 'reverted') {
            action.revertedAt = new Date();
        }
        this.eventEmitter.emit('optimization.action.completed', action);
        this.logger.log(`Optimization action ${actionId} completed with status: ${status}`);
        return action;
    }
    async getPerformanceProfile(__service, endpoint) {
        const key = endpoint != null && endpoint !== ''
            ? `${__service}.${endpoint}`
            : __service;
        return this.performanceProfiles.get(key) ?? null;
    }
    async createPerformanceProfile(__service, endpoint, name, description) {
        const key = endpoint != null && endpoint !== ''
            ? `${__service}.${endpoint}`
            : __service;
        const id = `profile-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const responseTimeMetrics = this.performanceMetrics.get(`${__service}.response_time`) ?? [];
        const throughputMetrics = this.performanceMetrics.get(`${__service}.throughput`) ?? [];
        const errorRateMetrics = this.performanceMetrics.get(`${__service}.error_rate`) ?? [];
        const cpuMetrics = this.performanceMetrics.get(`${__service}.cpu_usage`) ?? [];
        const memoryMetrics = this.performanceMetrics.get(`${__service}.memory_usage`) ?? [];
        const recentMetrics = responseTimeMetrics.slice(-100);
        const responseTimes = recentMetrics.map(m => m.value);
        const profile = {
            id,
            name,
            description,
            __service: __service,
            endpoint: endpoint ?? '',
            metrics: {
                responseTime: {
                    p50: this.calculatePercentile(responseTimes, 50),
                    p95: this.calculatePercentile(responseTimes, 95),
                    p99: this.calculatePercentile(responseTimes, 99),
                    max: Math.max(...responseTimes),
                },
                throughput: {
                    requestsPerSecond: throughputMetrics.length > 0
                        ? (throughputMetrics[throughputMetrics.length - 1]?.value ?? 0)
                        : 0,
                    requestsPerMinute: throughputMetrics.length > 0
                        ? (throughputMetrics[throughputMetrics.length - 1]?.value ?? 0) *
                            60
                        : 0,
                },
                errorRate: errorRateMetrics.length > 0
                    ? (errorRateMetrics[errorRateMetrics.length - 1]?.value ?? 0)
                    : 0,
                cpuUsage: cpuMetrics.length > 0
                    ? (cpuMetrics[cpuMetrics.length - 1]?.value ?? 0)
                    : 0,
                memoryUsage: memoryMetrics.length > 0
                    ? (memoryMetrics[memoryMetrics.length - 1]?.value ?? 0)
                    : 0,
            },
            recommendations: this.generateRecommendations(__service, responseTimes),
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.performanceProfiles.set(key, profile);
        this.logger.log(`Created performance profile: ${id} for ${__service}`);
        return profile;
    }
    generateRecommendations(__service, responseTimes) {
        const recommendations = [];
        const avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
        const p95ResponseTime = this.calculatePercentile(responseTimes, 95);
        if (avgResponseTime > 500) {
            recommendations.push('Consider implementing caching for frequently accessed data');
        }
        if (p95ResponseTime > 1000) {
            recommendations.push('Optimize database queries and consider indexing');
        }
        if (responseTimes.some(time => time > 2000)) {
            recommendations.push('Implement request timeout and circuit breaker patterns');
        }
        recommendations.push('Monitor memory usage and implement garbage collection optimization');
        recommendations.push('Consider horizontal scaling for high-traffic endpoints');
        return recommendations;
    }
    async getOptimizationRules() {
        return Array.from(this.optimizationRules.values());
    }
    async getOptimizationActions(filters) {
        let actions = Array.from(this.optimizationActions.values());
        if (filters) {
            if (filters.status != null) {
                actions = actions.filter(a => a.status === filters.status);
            }
            if (filters.type != null) {
                actions = actions.filter(a => a.type === filters.type);
            }
        }
        actions = actions.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            actions = actions.slice(0, filters.limit);
        }
        return actions;
    }
    async getCachingStrategies() {
        return Array.from(this.cachingStrategies.values());
    }
    async updateCachingStrategy(strategyId, updates) {
        const strategy = this.cachingStrategies.get(strategyId);
        if (strategy == null) {
            return null;
        }
        const updatedStrategy = {
            ...strategy,
            ...updates,
            updatedAt: new Date(),
        };
        this.cachingStrategies.set(strategyId, updatedStrategy);
        this.logger.log(`Updated caching strategy: ${strategyId}`);
        return updatedStrategy;
    }
    async getPerformanceMetrics(service, metricName, timeRange) {
        let allMetrics = [];
        if (service != null && metricName != null) {
            const key = `${service}.${metricName}`;
            allMetrics = this.performanceMetrics.get(key) ?? [];
        }
        else if (service != null) {
            for (const [key, metrics] of this.performanceMetrics) {
                if (key.startsWith(`${service}.`)) {
                    allMetrics.push(...metrics);
                }
            }
        }
        else {
            for (const metrics of this.performanceMetrics.values()) {
                allMetrics.push(...metrics);
            }
        }
        if (timeRange != null) {
            allMetrics = allMetrics.filter(metric => metric.timestamp >= timeRange.from && metric.timestamp <= timeRange.to);
        }
        return allMetrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async getPerformanceSummary() {
        const allMetrics = Array.from(this.performanceMetrics.values()).flat();
        const activeOptimizations = Array.from(this.optimizationActions.values()).filter(a => a.status === 'applied').length;
        const cachingStrategies = this.cachingStrategies.size;
        const responseTimeMetrics = allMetrics.filter(m => m.name === 'response_time');
        const cpuMetrics = allMetrics.filter(m => m.name === 'cpu_usage');
        const memoryMetrics = allMetrics.filter(m => m.name === 'memory_usage');
        const averageResponseTime = responseTimeMetrics.length > 0
            ? responseTimeMetrics.reduce((sum, m) => sum + m.value, 0) /
                responseTimeMetrics.length
            : 0;
        const averageCpuUsage = cpuMetrics.length > 0
            ? cpuMetrics.reduce((sum, m) => sum + m.value, 0) / cpuMetrics.length
            : 0;
        const averageMemoryUsage = memoryMetrics.length > 0
            ? memoryMetrics.reduce((sum, m) => sum + m.value, 0) /
                memoryMetrics.length
            : 0;
        const endpointStats = new Map();
        responseTimeMetrics.forEach(metric => {
            const key = `${metric.__service}.${metric.labels.endpoint ?? 'unknown'}`;
            const stats = endpointStats.get(key) ?? { count: 0, totalTime: 0 };
            stats.count++;
            stats.totalTime += metric.value;
            endpointStats.set(key, stats);
        });
        const topSlowEndpoints = Array.from(endpointStats.entries())
            .map(([key, stats]) => {
            const [_service, endpoint] = key.split('.');
            return {
                __service: _service ?? '',
                endpoint: endpoint ?? '',
                avgResponseTime: stats.totalTime / stats.count,
            };
        })
            .sort((a, b) => b.avgResponseTime - a.avgResponseTime)
            .slice(0, 10);
        return {
            totalMetrics: allMetrics.length,
            activeOptimizations,
            cachingStrategies,
            averageResponseTime,
            averageCpuUsage,
            averageMemoryUsage,
            topSlowEndpoints,
        };
    }
};
PerformanceOptimizationService = PerformanceOptimizationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], PerformanceOptimizationService);



/***/ }),
/* 197 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoScalingService: () => (/* binding */ AutoScalingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AutoScalingService_1;
var _a, _b;



let AutoScalingService = AutoScalingService_1 = class AutoScalingService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AutoScalingService_1.name);
        this.scalingPolicies = new Map();
        this.scalingEvents = new Map();
        this.serviceMetrics = new Map();
        this.lastScalingTime = new Map();
        this.scalingRecommendations = new Map();
        this.initializeDefaultPolicies();
        this.startScalingMonitoring();
        this._configService.get('AUTO_SCALING_ENABLED');
    }
    initializeDefaultPolicies() {
        const defaultPolicies = [
            {
                id: 'api-service-policy',
                name: 'API Service Scaling Policy',
                description: 'Auto-scaling policy for API services',
                _service: 'api-service',
                enabled: true,
                minReplicas: 2,
                maxReplicas: 10,
                targetCpu: 70,
                targetMemory: 80,
                targetRequestsPerSecond: 100,
                scaleUpCooldown: 300,
                scaleDownCooldown: 600,
                scaleUpStep: 2,
                scaleDownStep: 1,
                metrics: {
                    cpu: true,
                    memory: true,
                    requests: true,
                    custom: [],
                },
                conditions: [
                    {
                        metric: 'cpu',
                        operator: 'gt',
                        threshold: 70,
                        duration: 300,
                    },
                    {
                        metric: 'memory',
                        operator: 'gt',
                        threshold: 80,
                        duration: 300,
                    },
                    {
                        metric: 'requests',
                        operator: 'gt',
                        threshold: 100,
                        duration: 180,
                    },
                ],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'database-service-policy',
                name: 'Database Service Scaling Policy',
                description: 'Auto-scaling policy for database services',
                _service: 'database-service',
                enabled: true,
                minReplicas: 1,
                maxReplicas: 5,
                targetCpu: 60,
                targetMemory: 70,
                targetRequestsPerSecond: 50,
                scaleUpCooldown: 600,
                scaleDownCooldown: 1200,
                scaleUpStep: 1,
                scaleDownStep: 1,
                metrics: {
                    cpu: true,
                    memory: true,
                    requests: false,
                    custom: ['connection_pool_usage', 'query_time'],
                },
                conditions: [
                    {
                        metric: 'cpu',
                        operator: 'gt',
                        threshold: 60,
                        duration: 600,
                    },
                    {
                        metric: 'memory',
                        operator: 'gt',
                        threshold: 70,
                        duration: 600,
                    },
                    {
                        metric: 'connection_pool_usage',
                        operator: 'gt',
                        threshold: 80,
                        duration: 300,
                    },
                ],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'cache-service-policy',
                name: 'Cache Service Scaling Policy',
                description: 'Auto-scaling policy for cache services',
                _service: 'cache-service',
                enabled: true,
                minReplicas: 1,
                maxReplicas: 8,
                targetCpu: 50,
                targetMemory: 60,
                targetRequestsPerSecond: 200,
                scaleUpCooldown: 180,
                scaleDownCooldown: 600,
                scaleUpStep: 2,
                scaleDownStep: 1,
                metrics: {
                    cpu: true,
                    memory: true,
                    requests: true,
                    custom: ['hit_rate', 'eviction_rate'],
                },
                conditions: [
                    {
                        metric: 'cpu',
                        operator: 'gt',
                        threshold: 50,
                        duration: 180,
                    },
                    {
                        metric: 'memory',
                        operator: 'gt',
                        threshold: 60,
                        duration: 180,
                    },
                    {
                        metric: 'hit_rate',
                        operator: 'lt',
                        threshold: 80,
                        duration: 300,
                    },
                ],
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultPolicies.forEach(policy => {
            this.scalingPolicies.set(policy.id, policy);
        });
        this.logger.log(`Initialized ${defaultPolicies.length} default scaling policies`);
    }
    startScalingMonitoring() {
        setInterval(() => {
            void this.collectServiceMetrics();
        }, 30000);
        setInterval(() => {
            void this.evaluateScalingConditions();
        }, 60000);
    }
    async collectServiceMetrics() {
        try {
            const services = ['api-service', 'database-service', 'cache-service'];
            for (const service of services) {
                const metrics = {
                    _service: service,
                    timestamp: new Date(),
                    replicas: Math.floor(Math.random() * 5) + 1,
                    cpu: {
                        current: Math.random() * 100,
                        average: Math.random() * 100,
                        peak: Math.random() * 100,
                    },
                    memory: {
                        current: Math.random() * 100,
                        average: Math.random() * 100,
                        peak: Math.random() * 100,
                    },
                    requests: {
                        perSecond: Math.random() * 200,
                        perMinute: Math.random() * 200 * 60,
                        total: Math.floor(Math.random() * 10000),
                    },
                    custom: {
                        connection_pool_usage: Math.random() * 100,
                        query_time: Math.random() * 1000,
                        hit_rate: Math.random() * 100,
                        eviction_rate: Math.random() * 10,
                    },
                };
                const existingMetrics = this.serviceMetrics.get(service) ?? [];
                existingMetrics.push(metrics);
                if (existingMetrics.length > 100) {
                    existingMetrics.splice(0, existingMetrics.length - 100);
                }
                this.serviceMetrics.set(service, existingMetrics);
            }
            this.logger.debug('Service metrics collected');
        }
        catch (error) {
            this.logger.error('Error collecting service metrics:', error);
        }
    }
    async evaluateScalingConditions() {
        try {
            for (const [, policy] of this.scalingPolicies) {
                if (!policy.enabled) {
                    continue;
                }
                await this.evaluatePolicy(policy);
            }
        }
        catch (error) {
            this.logger.error('Error evaluating scaling conditions:', error);
        }
    }
    async evaluatePolicy(policy) {
        try {
            const serviceMetrics = this.serviceMetrics.get(policy._service);
            if (!serviceMetrics || serviceMetrics.length === 0) {
                return;
            }
            const recentMetrics = serviceMetrics.slice(-10);
            const currentMetrics = recentMetrics[recentMetrics.length - 1];
            let shouldScaleUp = false;
            let shouldScaleDown = false;
            const triggeredConditions = [];
            for (const condition of policy.conditions) {
                const metricValue = currentMetrics
                    ? this.getMetricValue(currentMetrics, condition.metric)
                    : 0;
                const conditionMet = this.evaluateCondition(metricValue, condition.operator, condition.threshold);
                if (conditionMet) {
                    triggeredConditions.push(`${condition.metric} ${condition.operator} ${condition.threshold}`);
                    if (condition.operator === 'gt' || condition.operator === 'gte') {
                        shouldScaleUp = true;
                    }
                    else if (condition.operator === 'lt' ||
                        condition.operator === 'lte') {
                        shouldScaleDown = true;
                    }
                }
            }
            const lastScaling = this.lastScalingTime.get(policy._service);
            const now = new Date();
            const cooldownPeriod = shouldScaleUp
                ? policy.scaleUpCooldown
                : policy.scaleDownCooldown;
            if (lastScaling &&
                now.getTime() - lastScaling.getTime() < cooldownPeriod * 1000) {
                return;
            }
            if (shouldScaleUp &&
                currentMetrics &&
                currentMetrics.replicas < policy.maxReplicas) {
                await this.scaleService(policy, 'scale_up', triggeredConditions.join(', '), currentMetrics);
            }
            else if (shouldScaleDown &&
                currentMetrics &&
                currentMetrics.replicas > policy.minReplicas) {
                await this.scaleService(policy, 'scale_down', triggeredConditions.join(', '), currentMetrics);
            }
        }
        catch (error) {
            this.logger.error(`Error evaluating policy ${policy.id}:`, error);
        }
    }
    getMetricValue(metrics, metricName) {
        switch (metricName) {
            case 'cpu':
                return metrics.cpu.current;
            case 'memory':
                return metrics.memory.current;
            case 'requests':
                return metrics.requests.perSecond;
            default:
                return metrics.custom[metricName] ?? 0;
        }
    }
    evaluateCondition(value, operator, threshold) {
        switch (operator) {
            case 'gt':
                return value > threshold;
            case 'lt':
                return value < threshold;
            case 'gte':
                return value >= threshold;
            case 'lte':
                return value <= threshold;
            case 'eq':
                return value === threshold;
            default:
                return false;
        }
    }
    async scaleService(policy, action, reason, currentMetrics) {
        const eventId = `scaling-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        let targetReplicas = currentMetrics.replicas;
        if (action === 'scale_up') {
            targetReplicas = Math.min(currentMetrics.replicas + policy.scaleUpStep, policy.maxReplicas);
        }
        else {
            targetReplicas = Math.max(currentMetrics.replicas - policy.scaleDownStep, policy.minReplicas);
        }
        const scalingEvent = {
            id: eventId,
            policyId: policy.id,
            _service: policy._service,
            action,
            reason,
            currentReplicas: currentMetrics.replicas,
            targetReplicas,
            actualReplicas: currentMetrics.replicas,
            metrics: {
                cpu: currentMetrics.cpu.current,
                memory: currentMetrics.memory.current,
                requests: currentMetrics.requests.perSecond,
                custom: currentMetrics.custom,
            },
            status: 'pending',
            startTime: new Date(),
        };
        this.scalingEvents.set(eventId, scalingEvent);
        this.lastScalingTime.set(policy._service, new Date());
        this.eventEmitter.emit('scaling.started', scalingEvent);
        setTimeout(() => {
            void this.completeScaling(eventId, 'completed');
        }, Math.random() * 30000 + 10000);
        this.logger.log(`Scaling ${action} initiated for ${policy._service}: ${currentMetrics.replicas} -> ${targetReplicas} (${reason})`);
    }
    async completeScaling(eventId, status, error) {
        const event = this.scalingEvents.get(eventId);
        if (!event) {
            throw new Error(`Scaling event ${eventId} not found`);
        }
        event.status = status;
        event.endTime = new Date();
        event.duration = event.endTime.getTime() - event.startTime.getTime();
        if (status === 'completed') {
            event.actualReplicas = event.targetReplicas;
        }
        else {
            event.error = error ?? '';
        }
        this.eventEmitter.emit('scaling.completed', event);
        this.logger.log(`Scaling event ${eventId} completed with status: ${status}`);
        return event;
    }
    async createScalingPolicy(policy) {
        const id = `policy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newPolicy = {
            ...policy,
            id,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.scalingPolicies.set(id, newPolicy);
        this.logger.log(`Created scaling policy: ${id} for service ${policy._service}`);
        return newPolicy;
    }
    async updateScalingPolicy(id, updates) {
        const policy = this.scalingPolicies.get(id);
        if (!policy) {
            return null;
        }
        const updatedPolicy = {
            ...policy,
            ...updates,
            id,
            updatedAt: new Date(),
        };
        this.scalingPolicies.set(id, updatedPolicy);
        this.logger.log(`Updated scaling policy: ${id}`);
        return updatedPolicy;
    }
    async deleteScalingPolicy(id) {
        const deleted = this.scalingPolicies.delete(id);
        if (deleted) {
            this.logger.log(`Deleted scaling policy: ${id}`);
        }
        return deleted;
    }
    async getScalingPolicy(id) {
        return this.scalingPolicies.get(id) ?? null;
    }
    async getAllScalingPolicies() {
        return Array.from(this.scalingPolicies.values());
    }
    async getScalingEvents(filters) {
        let events = Array.from(this.scalingEvents.values());
        if (filters) {
            if (filters.service != null) {
                events = events.filter(e => e._service === filters.service);
            }
            if (filters.action != null) {
                events = events.filter(e => e.action === filters.action);
            }
            if (filters.status != null) {
                events = events.filter(e => e.status === filters.status);
            }
        }
        events = events.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            events = events.slice(0, filters.limit);
        }
        return events;
    }
    async getServiceMetrics(_service, timeRange) {
        let metrics = this.serviceMetrics.get(_service) ?? [];
        if (timeRange != null) {
            metrics = metrics.filter(m => m.timestamp >= timeRange.from && m.timestamp <= timeRange.to);
        }
        return metrics.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    async generateScalingRecommendations(_service) {
        const metrics = this.serviceMetrics.get(_service);
        if (metrics == null || metrics.length === 0) {
            return [];
        }
        const recentMetrics = metrics.slice(-20);
        const avgCpu = recentMetrics.reduce((sum, m) => sum + m.cpu.current, 0) /
            recentMetrics.length;
        const avgMemory = recentMetrics.reduce((sum, m) => sum + m.memory.current, 0) /
            recentMetrics.length;
        const avgRequests = recentMetrics.reduce((sum, m) => sum + m.requests.perSecond, 0) /
            recentMetrics.length;
        const currentReplicas = recentMetrics[recentMetrics.length - 1]?.replicas ?? 1;
        const recommendations = [];
        if (avgCpu > 80) {
            recommendations.push({
                id: `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                _service: _service,
                type: 'scale_up',
                priority: 'high',
                reason: `High CPU usage: ${avgCpu.toFixed(1)}%`,
                currentMetrics: {
                    cpu: avgCpu,
                    memory: avgMemory,
                    requests: avgRequests,
                },
                recommendedAction: `Scale up to ${Math.min(currentReplicas + 2, 10)} replicas`,
                estimatedImpact: 'Reduced response times and improved throughput',
                confidence: 85,
                createdAt: new Date(),
            });
        }
        else if (avgCpu < 30 && currentReplicas > 1) {
            recommendations.push({
                id: `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                _service: _service,
                type: 'scale_down',
                priority: 'medium',
                reason: `Low CPU usage: ${avgCpu.toFixed(1)}%`,
                currentMetrics: {
                    cpu: avgCpu,
                    memory: avgMemory,
                    requests: avgRequests,
                },
                recommendedAction: `Scale down to ${Math.max(currentReplicas - 1, 1)} replicas`,
                estimatedImpact: 'Reduced resource costs',
                confidence: 75,
                createdAt: new Date(),
            });
        }
        if (avgMemory > 85) {
            recommendations.push({
                id: `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                _service: _service,
                type: 'scale_up',
                priority: 'critical',
                reason: `High memory usage: ${avgMemory.toFixed(1)}%`,
                currentMetrics: {
                    cpu: avgCpu,
                    memory: avgMemory,
                    requests: avgRequests,
                },
                recommendedAction: `Scale up to ${Math.min(currentReplicas + 1, 10)} replicas`,
                estimatedImpact: 'Prevented out-of-memory errors',
                confidence: 90,
                createdAt: new Date(),
            });
        }
        if (avgCpu > 60 && avgMemory > 60) {
            recommendations.push({
                id: `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                _service: _service,
                type: 'optimize',
                priority: 'medium',
                reason: 'High resource utilization',
                currentMetrics: {
                    cpu: avgCpu,
                    memory: avgMemory,
                    requests: avgRequests,
                },
                recommendedAction: 'Optimize application code and database queries',
                estimatedImpact: 'Improved efficiency and reduced resource usage',
                confidence: 70,
                createdAt: new Date(),
            });
        }
        recommendations.forEach(rec => {
            this.scalingRecommendations.set(rec.id, rec);
        });
        return recommendations;
    }
    async getScalingRecommendations(service, priority) {
        let recommendations = Array.from(this.scalingRecommendations.values());
        if (service != null) {
            recommendations = recommendations.filter(r => r._service === service);
        }
        if (priority != null) {
            recommendations = recommendations.filter(r => r.priority === priority);
        }
        return recommendations.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    }
    async getScalingSummary() {
        const policies = Array.from(this.scalingPolicies.values());
        const events = Array.from(this.scalingEvents.values());
        const activePolicies = policies.filter(p => p.enabled).length;
        const eventsByAction = events.reduce((acc, event) => {
            acc[event.action] = (acc[event.action] ?? 0) + 1;
            return acc;
        }, {});
        const eventsByStatus = events.reduce((acc, event) => {
            acc[event.status] = (acc[event.status] ?? 0) + 1;
            return acc;
        }, {});
        const completedEvents = events.filter(e => e.duration != null);
        const averageScalingTime = completedEvents.length > 0
            ? completedEvents.reduce((sum, e) => sum + (e.duration ?? 0), 0) /
                completedEvents.length
            : 0;
        const serviceEventCounts = events.reduce((acc, event) => {
            acc[event._service] = (acc[event._service] ?? 0) + 1;
            return acc;
        }, {});
        const topScalingServices = Object.entries(serviceEventCounts)
            .map(([service, eventCount]) => ({ _service: service, eventCount }))
            .sort((a, b) => b.eventCount - a.eventCount)
            .slice(0, 10);
        return {
            totalPolicies: policies.length,
            activePolicies,
            totalEvents: events.length,
            eventsByAction,
            eventsByStatus,
            averageScalingTime,
            topScalingServices,
        };
    }
};
AutoScalingService = AutoScalingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], AutoScalingService);



/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceController: () => (/* binding */ PerformanceController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auto_scaling_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(196);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;




let PerformanceController = class PerformanceController {
    constructor(performanceOptimizationService, autoScalingService) {
        this.performanceOptimizationService = performanceOptimizationService;
        this.autoScalingService = autoScalingService;
    }
    async getPerformanceMetrics(service, metricName, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const metrics = await this.performanceOptimizationService.getPerformanceMetrics(service, metricName, timeRange);
        return {
            success: true,
            data: metrics,
            count: metrics.length,
        };
    }
    async getPerformanceSummary() {
        const summary = await this.performanceOptimizationService.getPerformanceSummary();
        return {
            success: true,
            data: summary,
        };
    }
    async getPerformanceProfiles(_service) {
        return {
            success: true,
            data: [],
            message: 'Performance profiles endpoint - implementation needed',
        };
    }
    async createPerformanceProfile(body) {
        const profile = await this.performanceOptimizationService.createPerformanceProfile(body._service, body.endpoint, body.name, body.description);
        return {
            success: true,
            data: profile,
            message: 'Performance profile created successfully',
        };
    }
    async getOptimizationRules() {
        const rules = await this.performanceOptimizationService.getOptimizationRules();
        return {
            success: true,
            data: rules,
            count: rules.length,
        };
    }
    async getOptimizationActions(status, type, limit) {
        const actions = await this.performanceOptimizationService.getOptimizationActions({
            ...(status != null && { status }),
            ...(type != null && { type }),
            ...(limit != null && { limit: parseInt(limit.toString()) }),
        });
        return {
            success: true,
            data: actions,
            count: actions.length,
        };
    }
    async getCachingStrategies() {
        const strategies = await this.performanceOptimizationService.getCachingStrategies();
        return {
            success: true,
            data: strategies,
            count: strategies.length,
        };
    }
    async updateCachingStrategy(id, updates) {
        const strategy = await this.performanceOptimizationService.updateCachingStrategy(id, updates);
        if (strategy == null) {
            return {
                success: false,
                error: 'Caching strategy not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: strategy,
            message: 'Caching strategy updated successfully',
        };
    }
    async getScalingPolicies() {
        const policies = await this.autoScalingService.getAllScalingPolicies();
        return {
            success: true,
            data: policies,
            count: policies.length,
        };
    }
    async createScalingPolicy(policy) {
        const newPolicy = await this.autoScalingService.createScalingPolicy(policy);
        return {
            success: true,
            data: newPolicy,
            message: 'Scaling policy created successfully',
        };
    }
    async updateScalingPolicy(id, updates) {
        const policy = await this.autoScalingService.updateScalingPolicy(id, updates);
        if (policy == null) {
            return {
                success: false,
                error: 'Scaling policy not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            data: policy,
            message: 'Scaling policy updated successfully',
        };
    }
    async deleteScalingPolicy(id) {
        const deleted = await this.autoScalingService.deleteScalingPolicy(id);
        if (!deleted) {
            return {
                success: false,
                error: 'Scaling policy not found',
                statusCode: _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.HttpStatus.NOT_FOUND,
            };
        }
        return {
            success: true,
            message: 'Scaling policy deleted successfully',
        };
    }
    async getScalingEvents(service, action, status, limit) {
        const events = await this.autoScalingService.getScalingEvents({
            ...(service != null && { service }),
            ...(action != null && { action }),
            ...(status != null && { status }),
            ...(limit != null && { limit: parseInt(limit.toString()) }),
        });
        return {
            success: true,
            data: events,
            count: events.length,
        };
    }
    async getServiceMetrics(_service, from, to) {
        const timeRange = from != null && to != null
            ? {
                from: new Date(from),
                to: new Date(to),
            }
            : undefined;
        const metrics = await this.autoScalingService.getServiceMetrics(_service || '', timeRange);
        return {
            success: true,
            data: metrics,
            count: metrics.length,
        };
    }
    async getScalingRecommendations(service, priority) {
        const recommendations = await this.autoScalingService.getScalingRecommendations(service, priority);
        return {
            success: true,
            data: recommendations,
            count: recommendations.length,
        };
    }
    async generateScalingRecommendations(service) {
        const recommendations = await this.autoScalingService.generateScalingRecommendations(service);
        return {
            success: true,
            data: recommendations,
            count: recommendations.length,
            message: `Generated ${recommendations.length} recommendations for ${service}`,
        };
    }
    async getScalingSummary() {
        const summary = await this.autoScalingService.getScalingSummary();
        return {
            success: true,
            data: summary,
        };
    }
    async getHealth() {
        const performanceSummary = await this.performanceOptimizationService.getPerformanceSummary();
        const scalingSummary = await this.autoScalingService.getScalingSummary();
        return {
            success: true,
            data: {
                status: 'healthy',
                performance: {
                    totalMetrics: performanceSummary.totalMetrics,
                    activeOptimizations: performanceSummary.activeOptimizations,
                    cachingStrategies: performanceSummary.cachingStrategies,
                },
                scaling: {
                    totalPolicies: scalingSummary.totalPolicies,
                    activePolicies: scalingSummary.activePolicies,
                    totalEvents: scalingSummary.totalEvents,
                },
                timestamp: new Date().toISOString(),
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'metricName',
        required: false,
        description: 'Filter by metric name',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance metrics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('metricName')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getPerformanceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('summary'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance summary' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance summary retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getPerformanceSummary", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('profiles'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance profiles' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Performance profiles retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getPerformanceProfiles", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('profiles'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create performance profile' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Performance profile created successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "createPerformanceProfile", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('optimization/rules'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get optimization rules' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Optimization rules retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getOptimizationRules", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('optimization/actions'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get optimization actions' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'status',
        required: false,
        description: 'Filter by status',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'type', required: false, description: 'Filter by type' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, description: 'Limit results' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Optimization actions retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('type')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getOptimizationActions", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('caching/strategies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get caching strategies' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Caching strategies retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getCachingStrategies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('caching/strategies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update caching strategy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Strategy ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Caching strategy updated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_c = typeof Record !== "undefined" && Record) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "updateCachingStrategy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling/policies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get scaling policies' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling policies retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getScalingPolicies", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('scaling/policies'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create scaling policy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Scaling policy created successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "createScalingPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('scaling/policies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update scaling policy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Policy ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling policy updated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "updateScalingPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('scaling/policies/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete scaling policy' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Policy ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling policy deleted successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "deleteScalingPolicy", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling/events'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get scaling events' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'action',
        required: false,
        description: 'Filter by action',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'status',
        required: false,
        description: 'Filter by status',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, description: 'Limit results' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling events retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('action')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, Number]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getScalingEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling/metrics/:service'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get service scaling metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Service name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'from',
        required: false,
        description: 'Start time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'to',
        required: false,
        description: 'End time (ISO string)',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Service metrics retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('from')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('to')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getServiceMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling/recommendations'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get scaling recommendations' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'service',
        required: false,
        description: 'Filter by service',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'priority',
        required: false,
        description: 'Filter by priority',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling recommendations retrieved successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('service')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('priority')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getScalingRecommendations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('scaling/recommendations/:service'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate scaling recommendations for service' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'service', description: 'Service name' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling recommendations generated successfully',
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('service')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "generateScalingRecommendations", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scaling/summary'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get scaling summary' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Scaling summary retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getScalingSummary", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get performance service health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Health status retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PerformanceController.prototype, "getHealth", null);
PerformanceController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Performance Management'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('performance'),
    __metadata("design:paramtypes", [typeof (_a = typeof _performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__.PerformanceOptimizationService !== "undefined" && _performance_optimization_service__WEBPACK_IMPORTED_MODULE_3__.PerformanceOptimizationService) === "function" ? _a : Object, typeof (_b = typeof _auto_scaling_service__WEBPACK_IMPORTED_MODULE_2__.AutoScalingService !== "undefined" && _auto_scaling_service__WEBPACK_IMPORTED_MODULE_2__.AutoScalingService) === "function" ? _b : Object])
], PerformanceController);



/***/ }),
/* 199 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegionalArchitectureModule: () => (/* binding */ RegionalArchitectureModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _local_datacenters_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(200);
/* harmony import */ var _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(201);
/* harmony import */ var _cdn_providers_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(202);
/* harmony import */ var _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(203);
/* harmony import */ var _payment_systems_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(204);
/* harmony import */ var _regional_architecture_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(205);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







let RegionalArchitectureModule = class RegionalArchitectureModule {
};
RegionalArchitectureModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        controllers: [_regional_architecture_controller__WEBPACK_IMPORTED_MODULE_6__.RegionalArchitectureController],
        providers: [
            _local_datacenters_service__WEBPACK_IMPORTED_MODULE_1__.LocalDatacentersService,
            _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_2__.CloudHostingService,
            _cdn_providers_service__WEBPACK_IMPORTED_MODULE_3__.CdnProvidersService,
            _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_4__.HybridArchitectureService,
            _payment_systems_service__WEBPACK_IMPORTED_MODULE_5__.PaymentSystemsService,
        ],
        exports: [
            _local_datacenters_service__WEBPACK_IMPORTED_MODULE_1__.LocalDatacentersService,
            _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_2__.CloudHostingService,
            _cdn_providers_service__WEBPACK_IMPORTED_MODULE_3__.CdnProvidersService,
            _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_4__.HybridArchitectureService,
            _payment_systems_service__WEBPACK_IMPORTED_MODULE_5__.PaymentSystemsService,
        ],
    })
], RegionalArchitectureModule);



/***/ }),
/* 200 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocalDatacentersService: () => (/* binding */ LocalDatacentersService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let LocalDatacentersService = class LocalDatacentersService {
    constructor() {
        this.datacenters = new Map();
        this.healthStatus = new Map();
        this.initializeDatacenters();
    }
    initializeDatacenters() {
        this.datacenters.set('selectel-moscow', {
            provider: 'selectel',
            region: 'Moscow',
            zone: 'ru-1',
            endpoint: 'https://api.selectel.ru',
            credentials: {
                accessKey: process.env.SELECTEL_ACCESS_KEY ?? '',
                secretKey: process.env.SELECTEL_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 8,
                memory: 32,
                storage: 1000,
                network: 1000,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        this.datacenters.set('vk-cloud-spb', {
            provider: 'vk-cloud',
            region: 'Saint Petersburg',
            zone: 'ru-1',
            endpoint: 'https://api.vk.cloud',
            credentials: {
                accessKey: process.env.VK_CLOUD_ACCESS_KEY ?? '',
                secretKey: process.env.VK_CLOUD_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 16,
                memory: 64,
                storage: 2000,
                network: 2000,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        this.datacenters.set('becloud-minsk', {
            provider: 'becloud',
            region: 'Minsk',
            zone: 'by-1',
            endpoint: 'https://api.becloud.by',
            credentials: {
                accessKey: process.env.BECLOUD_ACCESS_KEY ?? '',
                secretKey: process.env.BECLOUD_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 12,
                memory: 48,
                storage: 1500,
                network: 1500,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        this.datacenters.set('activecloud-minsk', {
            provider: 'activecloud',
            region: 'Minsk',
            zone: 'by-1',
            endpoint: 'https://api.activecloud.by',
            credentials: {
                accessKey: process.env.ACTIVECLOUD_ACCESS_KEY ?? '',
                secretKey: process.env.ACTIVECLOUD_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 8,
                memory: 32,
                storage: 1000,
                network: 1000,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        this.datacenters.set('datahata-minsk', {
            provider: 'datahata',
            region: 'Minsk',
            zone: 'by-1',
            endpoint: 'https://api.datahata.by',
            credentials: {
                accessKey: process.env.DATAHATA_ACCESS_KEY ?? '',
                secretKey: process.env.DATAHATA_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 6,
                memory: 24,
                storage: 800,
                network: 800,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        this.datacenters.set('a1-digital-minsk', {
            provider: 'a1-digital',
            region: 'Minsk',
            zone: 'by-1',
            endpoint: 'https://api.a1.by',
            credentials: {
                accessKey: process.env.A1_DIGITAL_ACCESS_KEY ?? '',
                secretKey: process.env.A1_DIGITAL_SECRET_KEY ?? '',
            },
            resources: {
                cpu: 10,
                memory: 40,
                storage: 1200,
                network: 1200,
            },
            compliance: {
                dataResidency: true,
                gdpr: false,
                localLaws: true,
            },
        });
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Local datacenters initialized', 'LocalDatacentersService', {
            count: this.datacenters.size,
            providers: Array.from(this.datacenters.values()).map(dc => dc.provider),
        });
    }
    getDatacenterConfig(id) {
        return this.datacenters.get(id) ?? null;
    }
    getAllDatacenters() {
        return Array.from(this.datacenters.values());
    }
    async checkDatacenterHealth(id) {
        const config = this.getDatacenterConfig(id);
        if (config == null) {
            return null;
        }
        try {
            const latency = Math.random() * 100 + 10;
            const status = latency < 50 ? 'healthy' : latency < 100 ? 'degraded' : 'down';
            const health = {
                provider: config.provider,
                status,
                latency,
                uptime: 99.9,
                lastCheck: new Date(),
            };
            this.healthStatus.set(id, health);
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.debug(`Datacenter health check: ${id}`, 'LocalDatacentersService', {
                provider: config.provider,
                status,
                latency,
            });
            return health;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Datacenter health check failed: ${id}`, error);
            const health = {
                provider: config.provider,
                status: 'down',
                latency: 0,
                uptime: 0,
                lastCheck: new Date(),
            };
            this.healthStatus.set(id, health);
            return health;
        }
    }
    async getAllDatacenterHealth() {
        const healthChecks = await Promise.all(Array.from(this.datacenters.keys()).map(id => this.checkDatacenterHealth(id)));
        return healthChecks.filter((health) => health != null);
    }
    getDatacentersByRegion(region) {
        return Array.from(this.datacenters.values()).filter(dc => {
            if (region === 'RU') {
                return ['selectel', 'vk-cloud'].includes(dc.provider);
            }
            else {
                return ['becloud', 'activecloud', 'datahata', 'a1-digital'].includes(dc.provider);
            }
        });
    }
    selectOptimalDatacenter(region, requirements) {
        const availableDatacenters = Array.from(this.datacenters.values()).filter(dc => {
            const isCorrectRegion = region === 'RU'
                ? ['selectel', 'vk-cloud'].includes(dc.provider)
                : ['becloud', 'activecloud', 'datahata', 'a1-digital'].includes(dc.provider);
            const meetsRequirements = dc.resources.cpu >= requirements.minCpu &&
                dc.resources.memory >= requirements.minMemory &&
                dc.resources.storage >= requirements.minStorage;
            return isCorrectRegion && meetsRequirements;
        });
        if (availableDatacenters.length === 0) {
            return null;
        }
        const sorted = availableDatacenters.sort((a, b) => b.resources.cpu +
            b.resources.memory +
            b.resources.storage -
            (a.resources.cpu + a.resources.memory + a.resources.storage));
        return sorted[0] ?? null;
    }
    async deployResources(datacenterId, resources) {
        const config = this.getDatacenterConfig(datacenterId);
        if (config == null) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Datacenter not found: ${datacenterId}`, 'LocalDatacentersService');
            return false;
        }
        const available = config.resources;
        if (resources.cpu > available.cpu ||
            resources.memory > available.memory ||
            resources.storage > available.storage ||
            resources.network > available.network) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.warn(`Insufficient resources in datacenter: ${datacenterId}`, 'LocalDatacentersService', {
                requested: resources,
                available,
            });
            return false;
        }
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Resources deployed in datacenter: ${datacenterId}`, 'LocalDatacentersService', {
                provider: config.provider,
                resources,
            });
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Resource deployment failed: ${datacenterId}`, error);
            return false;
        }
    }
};
LocalDatacentersService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], LocalDatacentersService);



/***/ }),
/* 201 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CloudHostingService: () => (/* binding */ CloudHostingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let CloudHostingService = class CloudHostingService {
    constructor() {
        this.providers = new Map();
        this.deployments = new Map();
        this.initializeProviders();
    }
    initializeProviders() {
        this.providers.set('hoster-by', {
            name: 'Hoster.by',
            region: 'BY',
            endpoint: 'https://api.hoster.by',
            features: {
                ssl: true,
                cdn: true,
                backup: true,
                monitoring: true,
                support: '24/7',
            },
            plans: [
                {
                    name: 'start',
                    price: { currency: 'BYN', amount: 15, period: 'month' },
                    resources: {
                        storage: 10,
                        bandwidth: 100,
                        domains: 1,
                        databases: 5,
                        email: 10,
                    },
                    performance: {
                        cpu: 1,
                        memory: 1,
                        connections: 100,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        this.providers.set('a1-flex', {
            name: 'Flex от А1',
            region: 'BY',
            endpoint: 'https://api.flex.a1.by',
            features: {
                ssl: true,
                cdn: true,
                backup: true,
                monitoring: true,
                support: '24/7',
            },
            plans: [
                {
                    name: 'Basic',
                    price: { currency: 'BYN', amount: 20, period: 'month' },
                    resources: {
                        storage: 20,
                        bandwidth: 200,
                        domains: 3,
                        databases: 10,
                        email: 20,
                    },
                    performance: {
                        cpu: 1,
                        memory: 2,
                        connections: 200,
                    },
                },
                {
                    name: 'Professional',
                    price: { currency: 'BYN', amount: 50, period: 'month' },
                    resources: {
                        storage: 100,
                        bandwidth: 1000,
                        domains: 10,
                        databases: 50,
                        email: 100,
                    },
                    performance: {
                        cpu: 4,
                        memory: 8,
                        connections: 1000,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        this.providers.set('domain-by', {
            name: 'Domain.by',
            region: 'BY',
            endpoint: 'https://api.domain.by',
            features: {
                ssl: true,
                cdn: false,
                backup: true,
                monitoring: false,
                support: 'business',
            },
            plans: [
                {
                    name: 'Standard',
                    price: { currency: 'BYN', amount: 12, period: 'month' },
                    resources: {
                        storage: 5,
                        bandwidth: 50,
                        domains: 1,
                        databases: 3,
                        email: 5,
                    },
                    performance: {
                        cpu: 1,
                        memory: 1,
                        connections: 50,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        this.providers.set('besthost-by', {
            name: 'BestHost.by',
            region: 'BY',
            endpoint: 'https://api.besthost.by',
            features: {
                ssl: true,
                cdn: true,
                backup: true,
                monitoring: true,
                support: '24/7',
            },
            plans: [
                {
                    name: 'Premium',
                    price: { currency: 'BYN', amount: 25, period: 'month' },
                    resources: {
                        storage: 30,
                        bandwidth: 300,
                        domains: 5,
                        databases: 15,
                        email: 30,
                    },
                    performance: {
                        cpu: 2,
                        memory: 3,
                        connections: 300,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        this.providers.set('hostfly-by', {
            name: 'HostFly.by',
            region: 'BY',
            endpoint: 'https://api.hostfly.by',
            features: {
                ssl: true,
                cdn: false,
                backup: true,
                monitoring: false,
                support: 'business',
            },
            plans: [
                {
                    name: 'Economy',
                    price: { currency: 'BYN', amount: 8, period: 'month' },
                    resources: {
                        storage: 3,
                        bandwidth: 30,
                        domains: 1,
                        databases: 2,
                        email: 3,
                    },
                    performance: {
                        cpu: 1,
                        memory: 1,
                        connections: 30,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        this.providers.set('webhosting-by', {
            name: 'WebHosting.by',
            region: 'BY',
            endpoint: 'https://api.webhosting.by',
            features: {
                ssl: true,
                cdn: true,
                backup: true,
                monitoring: true,
                support: '24/7',
            },
            plans: [
                {
                    name: 'Enterprise',
                    price: { currency: 'BYN', amount: 80, period: 'month' },
                    resources: {
                        storage: 200,
                        bandwidth: 2000,
                        domains: 20,
                        databases: 100,
                        email: 200,
                    },
                    performance: {
                        cpu: 8,
                        memory: 16,
                        connections: 2000,
                    },
                },
            ],
            compliance: {
                dataResidency: true,
                localLaws: true,
                sslCertificates: true,
            },
        });
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Cloud hosting providers initialized', 'CloudHostingService', {
            count: this.providers.size,
            regions: Array.from(this.providers.values()).map(p => p.region),
        });
    }
    getAllProviders() {
        return Array.from(this.providers.values());
    }
    getProvidersByRegion(region) {
        return Array.from(this.providers.values()).filter(provider => provider.region === region);
    }
    getPlansByProvider(providerId) {
        const provider = this.providers.get(providerId);
        return provider?.plans ?? [];
    }
    createHostingDeployment(config) {
        const provider = this.providers.get(config.providerId);
        if (provider == null) {
            throw new Error(`Provider ${config.providerId} not found`);
        }
        const plan = provider.plans.find(p => p.name === config.planId);
        if (plan == null) {
            throw new Error(`Plan ${config.planId} not found for provider ${config.providerId}`);
        }
        const deployment = {
            providerId: config.providerId,
            planId: config.planId,
            domain: config.domain,
            status: 'pending',
            createdAt: new Date(),
            resources: plan.resources,
        };
        const deploymentId = `hosting-${Date.now()}`;
        this.deployments.set(deploymentId, deployment);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hosting deployment created`, 'CloudHostingService', {
            providerId: config.providerId,
            planId: config.planId,
            domain: config.domain,
        });
        return deployment;
    }
    getProvider(id) {
        return this.providers.get(id) ?? null;
    }
    async createHosting(providerId, planId, domain, config) {
        const provider = this.getProvider(providerId);
        if (provider == null) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Hosting provider not found: ${providerId}`, 'CloudHostingService');
            return null;
        }
        const plan = provider.plans.find(p => p.name === planId);
        if (plan == null) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Hosting plan not found: ${planId}`, 'CloudHostingService');
            return null;
        }
        const deploymentId = `hosting-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const deployment = {
            providerId,
            planId,
            domain,
            status: 'pending',
            createdAt: new Date(),
            resources: plan.resources,
        };
        this.deployments.set(deploymentId, deployment);
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hosting created: ${deploymentId}`, 'CloudHostingService', {
                provider: provider.name,
                plan: plan.name,
                domain,
                config,
            });
            setTimeout(() => {
                const deployment = this.deployments.get(deploymentId);
                if (deployment != null) {
                    deployment.status = 'active';
                    _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hosting activated: ${deploymentId}`, 'CloudHostingService');
                }
            }, 5000);
            return deploymentId;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Hosting creation failed: ${deploymentId}`, error);
            this.deployments.delete(deploymentId);
            return null;
        }
    }
    getHostingInfo(deploymentId) {
        return this.deployments.get(deploymentId) ?? null;
    }
    getAllHostings() {
        return Array.from(this.deployments.values());
    }
    updateHostingStatus(deploymentId, status) {
        const deployment = this.deployments.get(deploymentId);
        if (deployment == null) {
            return false;
        }
        deployment.status = status;
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hosting status updated: ${deploymentId}`, 'CloudHostingService', {
            status,
            domain: deployment.domain,
        });
        return true;
    }
    async deleteHosting(deploymentId) {
        const deployment = this.deployments.get(deploymentId);
        if (deployment == null) {
            return false;
        }
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hosting deleted: ${deploymentId}`, 'CloudHostingService', {
                domain: deployment.domain,
            });
            this.deployments.delete(deploymentId);
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Hosting deletion failed: ${deploymentId}`, error);
            return false;
        }
    }
    getProviderStats() {
        const providers = Array.from(this.providers.values());
        const byRegion = {
            RU: providers.filter(p => p.region === 'RU').length,
            BY: providers.filter(p => p.region === 'BY').length,
        };
        const bynPrices = providers
            .flatMap(p => p.plans)
            .filter(plan => plan.price.currency === 'BYN')
            .map(plan => plan.price.amount);
        const averagePrice = {
            RUB: 0,
            BYN: bynPrices.length > 0
                ? bynPrices.reduce((a, b) => a + b, 0) / bynPrices.length
                : 0,
        };
        return {
            totalProviders: providers.length,
            byRegion,
            averagePrice,
        };
    }
};
CloudHostingService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CloudHostingService);



/***/ }),
/* 202 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CdnProvidersService: () => (/* binding */ CdnProvidersService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let CdnProvidersService = class CdnProvidersService {
    constructor() {
        this.providers = new Map();
        this.configurations = new Map();
        this.initializeProviders();
    }
    initializeProviders() {
        this.providers.set('yandex-cloud-cdn', {
            name: 'Яндекс.Cloud CDN',
            type: 'local',
            region: 'RU',
            endpoint: 'https://cdn.yandexcloud.net',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: true,
                videoStreaming: true,
                edgeComputing: false,
            },
            pricing: {
                bandwidth: 0.5,
                requests: 0.1,
                currency: 'RUB',
            },
            performance: {
                averageLatency: 15,
                uptime: 99.9,
                edgeLocations: 50,
            },
        });
        this.providers.set('vk-cloud-cdn', {
            name: 'VK Cloud CDN',
            type: 'local',
            region: 'RU',
            endpoint: 'https://cdn.vk.cloud',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: true,
                videoStreaming: true,
                edgeComputing: true,
            },
            pricing: {
                bandwidth: 0.6,
                requests: 0.12,
                currency: 'RUB',
            },
            performance: {
                averageLatency: 18,
                uptime: 99.8,
                edgeLocations: 30,
            },
        });
        this.providers.set('ngenix', {
            name: 'Ngenix',
            type: 'local',
            region: 'RU',
            endpoint: 'https://cdn.ngenix.net',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: false,
                videoStreaming: true,
                edgeComputing: false,
            },
            pricing: {
                bandwidth: 0.4,
                requests: 0.08,
                currency: 'RUB',
            },
            performance: {
                averageLatency: 20,
                uptime: 99.7,
                edgeLocations: 25,
            },
        });
        this.providers.set('cloudmts-cdn', {
            name: 'CloudMTS CDN',
            type: 'local',
            region: 'RU',
            endpoint: 'https://cdn.cloudmts.ru',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: true,
                videoStreaming: true,
                edgeComputing: false,
            },
            pricing: {
                bandwidth: 0.55,
                requests: 0.11,
                currency: 'RUB',
            },
            performance: {
                averageLatency: 16,
                uptime: 99.9,
                edgeLocations: 40,
            },
        });
        this.providers.set('becloud-cdn', {
            name: 'BeCloud CDN',
            type: 'local',
            region: 'BY',
            endpoint: 'https://cdn.becloud.by',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: false,
                videoStreaming: false,
                edgeComputing: false,
            },
            pricing: {
                bandwidth: 0.3,
                requests: 0.06,
                currency: 'BYN',
            },
            performance: {
                averageLatency: 25,
                uptime: 99.5,
                edgeLocations: 10,
            },
        });
        this.providers.set('akamai', {
            name: 'Akamai',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://cdn.akamai.net',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: true,
                videoStreaming: true,
                edgeComputing: true,
            },
            pricing: {
                bandwidth: 0.08,
                requests: 0.02,
                currency: 'USD',
            },
            performance: {
                averageLatency: 10,
                uptime: 99.99,
                edgeLocations: 4000,
            },
        });
        this.providers.set('amazon-cloudfront', {
            name: 'Amazon CloudFront',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://d.cloudfront.net',
            features: {
                ssl: true,
                compression: true,
                imageOptimization: true,
                videoStreaming: true,
                edgeComputing: true,
            },
            pricing: {
                bandwidth: 0.085,
                requests: 0.0075,
                currency: 'USD',
            },
            performance: {
                averageLatency: 12,
                uptime: 99.9,
                edgeLocations: 450,
            },
        });
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('CDN providers initialized', 'CdnProvidersService', {
            count: this.providers.size,
            local: Array.from(this.providers.values()).filter(p => p.type === 'local')
                .length,
            international: Array.from(this.providers.values()).filter(p => p.type === 'international').length,
        });
    }
    getAllProviders() {
        return Array.from(this.providers.values());
    }
    getProvider(id) {
        return this.providers.get(id) ?? null;
    }
    getProvidersByRegion(region) {
        return Array.from(this.providers.values()).filter(p => p.region === region);
    }
    getLocalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'local');
    }
    getInternationalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'international');
    }
    async createCdnConfiguration(providerId, domain, settings) {
        const provider = this.getProvider(providerId);
        if (provider == null) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`CDN provider not found: ${providerId}`, 'CdnProvidersService');
            return null;
        }
        const configId = `cdn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const configuration = {
            providerId,
            domain,
            settings,
            status: 'pending',
        };
        this.configurations.set(configId, configuration);
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`CDN configuration created: ${configId}`, 'CdnProvidersService', {
                provider: provider.name,
                domain,
                settings,
            });
            setTimeout(() => {
                const config = this.configurations.get(configId);
                if (config != null) {
                    config.status = 'active';
                    _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`CDN configuration activated: ${configId}`, 'CdnProvidersService');
                }
            }, 3000);
            return configId;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`CDN configuration creation failed: ${configId}`, error);
            this.configurations.delete(configId);
            return null;
        }
    }
    getCdnConfiguration(configId) {
        return this.configurations.get(configId) ?? null;
    }
    getAllConfigurations() {
        return Array.from(this.configurations.values());
    }
    updateCdnConfiguration(configId, settings) {
        const config = this.configurations.get(configId);
        if (config == null) {
            return false;
        }
        config.settings = { ...config.settings, ...settings };
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`CDN configuration updated: ${configId}`, 'CdnProvidersService', {
            domain: config.domain,
            settings: config.settings,
        });
        return true;
    }
    async deleteCdnConfiguration(configId) {
        const config = this.configurations.get(configId);
        if (config == null) {
            return false;
        }
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`CDN configuration deleted: ${configId}`, 'CdnProvidersService', {
                domain: config.domain,
            });
            this.configurations.delete(configId);
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`CDN configuration deletion failed: ${configId}`, error);
            return false;
        }
    }
    getOptimalProvider(requirements) {
        const availableProviders = this.getProvidersByRegion(requirements.region);
        const suitableProviders = availableProviders.filter(provider => {
            const hasRequiredFeatures = requirements.features.every(feature => {
                switch (feature) {
                    case 'ssl':
                        return provider.features.ssl;
                    case 'compression':
                        return provider.features.compression;
                    case 'imageOptimization':
                        return provider.features.imageOptimization;
                    case 'videoStreaming':
                        return provider.features.videoStreaming;
                    case 'edgeComputing':
                        return provider.features.edgeComputing;
                    default:
                        return true;
                }
            });
            return hasRequiredFeatures;
        });
        if (suitableProviders.length === 0) {
            return null;
        }
        const sorted = suitableProviders.sort((a, b) => {
            const aScore = (a.performance.uptime * a.performance.edgeLocations) /
                a.pricing.bandwidth;
            const bScore = (b.performance.uptime * b.performance.edgeLocations) /
                b.pricing.bandwidth;
            return bScore - aScore;
        });
        return sorted[0] ?? null;
    }
    getProvidersByType(type) {
        return Array.from(this.providers.values()).filter(provider => provider.type === type);
    }
    createConfiguration(config) {
        const configuration = {
            ...config,
            status: 'pending',
        };
        const configId = `cdn-config-${Date.now()}`;
        this.configurations.set(configId, configuration);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`CDN configuration created`, 'CdnProvidersService', {
            providerId: config.providerId,
            domain: config.domain,
        });
        return configuration;
    }
    getPerformanceMetrics(providerId) {
        const provider = this.providers.get(providerId);
        if (provider == null) {
            return null;
        }
        return {
            averageLatency: provider.performance.averageLatency,
            uptime: provider.performance.uptime,
            edgeLocations: provider.performance.edgeLocations,
        };
    }
};
CdnProvidersService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CdnProvidersService);



/***/ }),
/* 203 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HybridArchitectureService: () => (/* binding */ HybridArchitectureService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let HybridArchitectureService = class HybridArchitectureService {
    constructor() {
        this.providers = new Map();
        this.deployments = new Map();
        this.initializeProviders();
    }
    initializeProviders() {
        this.providers.set('selectel', {
            name: 'Selectel',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.selectel.ru',
            features: {
                kubernetes: true,
                containerRegistry: true,
                loadBalancing: true,
                autoScaling: true,
                monitoring: true,
            },
            pricing: {
                compute: 0.5,
                storage: 0.1,
                network: 0.05,
                currency: 'RUB',
            },
        });
        this.providers.set('vk-cloud', {
            name: 'VK Cloud',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.vk.cloud',
            features: {
                kubernetes: true,
                containerRegistry: true,
                loadBalancing: true,
                autoScaling: true,
                monitoring: true,
            },
            pricing: {
                compute: 0.6,
                storage: 0.12,
                network: 0.06,
                currency: 'RUB',
            },
        });
        this.providers.set('becloud', {
            name: 'BeCloud',
            type: 'local',
            region: 'BY',
            endpoint: 'https://api.becloud.by',
            features: {
                kubernetes: true,
                containerRegistry: true,
                loadBalancing: true,
                autoScaling: false,
                monitoring: true,
            },
            pricing: {
                compute: 0.4,
                storage: 0.08,
                network: 0.04,
                currency: 'BYN',
            },
        });
        this.providers.set('alibaba-cloud', {
            name: 'Alibaba Cloud',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://api.alicloud.com',
            features: {
                kubernetes: true,
                containerRegistry: true,
                loadBalancing: true,
                autoScaling: true,
                monitoring: true,
            },
            pricing: {
                compute: 0.08,
                storage: 0.02,
                network: 0.01,
                currency: 'USD',
            },
        });
        this.providers.set('huawei-cloud', {
            name: 'Huawei Cloud',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://api.huaweicloud.com',
            features: {
                kubernetes: true,
                containerRegistry: true,
                loadBalancing: true,
                autoScaling: true,
                monitoring: true,
            },
            pricing: {
                compute: 0.09,
                storage: 0.025,
                network: 0.012,
                currency: 'USD',
            },
        });
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log('Hybrid architecture providers initialized', 'HybridArchitectureService', {
            count: this.providers.size,
            local: Array.from(this.providers.values()).filter(p => p.type === 'local').length,
            international: Array.from(this.providers.values()).filter(p => p.type === 'international').length,
        });
    }
    getAllProviders() {
        return Array.from(this.providers.values());
    }
    getLocalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'local');
    }
    getInternationalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'international');
    }
    async createHybridDeployment(localProvider, internationalProvider, configuration) {
        const local = this.providers.get(localProvider);
        const international = this.providers.get(internationalProvider);
        if (local == null || international == null) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.errorWithData('Invalid providers for hybrid deployment', { localProvider, internationalProvider }, 'HybridArchitectureService');
            return null;
        }
        if (local.type !== 'local' || international.type !== 'international') {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.errorWithData('Invalid provider types for hybrid deployment', { localType: local.type, internationalType: international.type }, 'HybridArchitectureService');
            return null;
        }
        const deploymentId = `hybrid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const deployment = {
            id: deploymentId,
            localProvider,
            internationalProvider,
            configuration,
            status: 'migrating',
        };
        this.deployments.set(deploymentId, deployment);
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hybrid deployment created: ${deploymentId}`, 'HybridArchitectureService', {
                localProvider: local.name,
                internationalProvider: international.name,
                configuration,
            });
            setTimeout(() => {
                const deployment = this.deployments.get(deploymentId);
                if (deployment != null) {
                    deployment.status = 'active';
                    _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hybrid deployment activated: ${deploymentId}`, 'HybridArchitectureService');
                }
            }, 10000);
            return deploymentId;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Hybrid deployment creation failed: ${deploymentId}`, error);
            this.deployments.delete(deploymentId);
            return null;
        }
    }
    getHybridDeployment(id) {
        return this.deployments.get(id) ?? null;
    }
    getAllDeployments() {
        return Array.from(this.deployments.values());
    }
    async migrateWorkload(deploymentId, workload) {
        const deployment = this.deployments.get(deploymentId);
        if (deployment == null) {
            return false;
        }
        try {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Workload migration started: ${deploymentId}`, 'HybridArchitectureService', {
                workload,
                localProvider: deployment.localProvider,
                internationalProvider: deployment.internationalProvider,
            });
            return true;
        }
        catch (error) {
            _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.error(`Workload migration failed: ${deploymentId}`, error);
            return false;
        }
    }
    getOptimalHybridConfiguration(requirements) {
        const localProviders = this.getLocalProviders().filter(p => p.region === requirements.primaryRegion);
        const internationalProviders = this.getInternationalProviders();
        if (localProviders.length === 0 || internationalProviders.length === 0) {
            return null;
        }
        const sortedLocal = localProviders.sort((a, b) => a.pricing.compute - b.pricing.compute);
        const sortedInternational = internationalProviders.sort((a, b) => a.pricing.compute - b.pricing.compute);
        const localProvider = sortedLocal[0];
        const internationalProvider = sortedInternational[0];
        if (localProvider == null || internationalProvider == null) {
            return null;
        }
        return {
            localProvider,
            internationalProvider,
        };
    }
    getProvidersByType(type) {
        return Array.from(this.providers.values()).filter(provider => provider.type === type);
    }
    createDeployment(config) {
        const deployment = {
            id: `hybrid-${Date.now()}`,
            localProvider: config.localProvider,
            internationalProvider: config.internationalProvider,
            configuration: config.configuration,
            status: 'active',
        };
        this.deployments.set(deployment.id, deployment);
        _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.redactedLogger.log(`Hybrid deployment created`, 'HybridArchitectureService', {
            id: deployment.id,
            localProvider: deployment.localProvider,
            internationalProvider: deployment.internationalProvider,
        });
        return deployment;
    }
    getDeploymentStatus(deploymentId) {
        return this.deployments.get(deploymentId) ?? null;
    }
};
HybridArchitectureService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], HybridArchitectureService);



/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PaymentSystemsService: () => (/* binding */ PaymentSystemsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PaymentSystemsService_1;


let PaymentSystemsService = PaymentSystemsService_1 = class PaymentSystemsService {
    constructor() {
        this.redactedLogger = new _utils_redacted_logger__WEBPACK_IMPORTED_MODULE_1__.RedactedLogger(PaymentSystemsService_1.name);
        this.providers = new Map();
        this.transactions = new Map();
        this.initializeProviders();
    }
    initializeProviders() {
        this.providers.set('erip', {
            name: 'ЕРИП',
            type: 'local',
            region: 'BY',
            endpoint: 'https://api.erip.by',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['BYN'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.02,
                monthlyFee: 0,
                currency: 'BYN',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('bepaid', {
            name: 'bePaid',
            type: 'local',
            region: 'BY',
            endpoint: 'https://api.bepaid.by',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['BYN', 'USD', 'EUR'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.025,
                monthlyFee: 50,
                currency: 'BYN',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('webpay', {
            name: 'WebPay',
            type: 'local',
            region: 'BY',
            endpoint: 'https://api.webpay.by',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['BYN', 'USD', 'EUR'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.03,
                monthlyFee: 30,
                currency: 'BYN',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('oplati', {
            name: 'Оплати',
            type: 'local',
            region: 'BY',
            endpoint: 'https://api.oplati.by',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['BYN'],
            features: {
                recurringPayments: false,
                refunds: true,
                partialRefunds: false,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.015,
                monthlyFee: 0,
                currency: 'BYN',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('cloudpayments', {
            name: 'CloudPayments',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.cloudpayments.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB', 'USD', 'EUR'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.025,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('yukassa', {
            name: 'ЮKassa',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.yookassa.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.03,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('yumoney', {
            name: 'ЮMoney',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.yoomoney.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.025,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('tinkoff-kassa', {
            name: 'Тинькофф Касса',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.tinkoff.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.02,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('sberpay', {
            name: 'СберPay',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.sberpay.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.015,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('spb', {
            name: 'СПБ',
            type: 'local',
            region: 'RU',
            endpoint: 'https://api.spb.ru',
            supportedCards: ['Visa', 'Mastercard', 'МИР'],
            supportedCurrencies: ['RUB'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.02,
                monthlyFee: 0,
                currency: 'RUB',
            },
            compliance: {
                pciDss: true,
                localLaws: true,
                dataResidency: true,
            },
        });
        this.providers.set('apple-pay', {
            name: 'Apple Pay',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://api.apple.com/pay',
            supportedCards: ['Visa', 'Mastercard', 'American Express'],
            supportedCurrencies: ['USD', 'EUR', 'GBP', 'RUB', 'BYN'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.015,
                monthlyFee: 0,
                currency: 'USD',
            },
            compliance: {
                pciDss: true,
                localLaws: false,
                dataResidency: false,
            },
        });
        this.providers.set('google-pay', {
            name: 'Google Pay',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://api.google.com/pay',
            supportedCards: ['Visa', 'Mastercard', 'American Express'],
            supportedCurrencies: ['USD', 'EUR', 'GBP', 'RUB', 'BYN'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.015,
                monthlyFee: 0,
                currency: 'USD',
            },
            compliance: {
                pciDss: true,
                localLaws: false,
                dataResidency: false,
            },
        });
        this.providers.set('samsung-pay', {
            name: 'Samsung Pay',
            type: 'international',
            region: 'GLOBAL',
            endpoint: 'https://api.samsung.com/pay',
            supportedCards: ['Visa', 'Mastercard', 'American Express'],
            supportedCurrencies: ['USD', 'EUR', 'GBP', 'RUB', 'BYN'],
            features: {
                recurringPayments: true,
                refunds: true,
                partialRefunds: true,
                webhooks: true,
                api: true,
            },
            pricing: {
                transactionFee: 0.015,
                monthlyFee: 0,
                currency: 'USD',
            },
            compliance: {
                pciDss: true,
                localLaws: false,
                dataResidency: false,
            },
        });
        this.redactedLogger.log('Payment systems initialized', 'PaymentSystemsService');
    }
    getAllProviders() {
        return Array.from(this.providers.values());
    }
    getProvider(id) {
        return this.providers.get(id) ?? null;
    }
    getProvidersByRegion(region) {
        return Array.from(this.providers.values()).filter(p => p.region === region);
    }
    getLocalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'local');
    }
    getInternationalProviders() {
        return Array.from(this.providers.values()).filter(p => p.type === 'international');
    }
    async processPayment(providerId, amount, currency, cardType) {
        const provider = this.getProvider(providerId);
        if (provider == null) {
            this.redactedLogger.error(`Payment provider not found: ${providerId}`, 'PaymentSystemsService');
            return null;
        }
        if (!provider.supportedCurrencies.includes(currency)) {
            this.handleUnsupportedCurrency(currency, {
                name: provider.name,
                supportedCurrencies: provider.supportedCurrencies,
            });
            return null;
        }
        const transactionId = `payment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const transaction = {
            id: transactionId,
            providerId,
            amount,
            currency,
            status: 'pending',
            ...(cardType !== undefined ? { cardType } : {}),
            createdAt: new Date(),
        };
        this.transactions.set(transactionId, transaction);
        try {
            this.redactedLogger.log(`Payment processed: ${transactionId}`, 'PaymentSystemsService', {
                provider: provider.name,
                amount,
                currency,
                cardType,
            });
            setTimeout(() => {
                const transaction = this.transactions.get(transactionId);
                if (transaction != null) {
                    transaction.status = 'completed';
                    transaction.completedAt = new Date();
                    this.redactedLogger.log(`Payment completed: ${transactionId}`, 'PaymentSystemsService');
                }
            }, 2000);
            return transactionId;
        }
        catch (error) {
            this.redactedLogger.error(`Payment processing failed: ${transactionId}`, error);
            this.transactions.delete(transactionId);
            return null;
        }
    }
    getTransaction(id) {
        return this.transactions.get(id) ?? null;
    }
    getAllTransactions() {
        return Array.from(this.transactions.values());
    }
    async refundPayment(transactionId, amount) {
        const transaction = this.transactions.get(transactionId);
        if (transaction == null) {
            return false;
        }
        const provider = this.getProvider(transaction.providerId);
        if (!this.checkRefunds(provider ?? undefined)) {
            return false;
        }
        try {
            const refundAmount = amount ?? transaction.amount;
            transaction.status = 'refunded';
            this.redactedLogger.log(`Payment refunded: ${transactionId}`, 'PaymentSystemsService', {
                originalAmount: transaction.amount,
                refundAmount,
                provider: provider?.name,
            });
            return true;
        }
        catch (error) {
            this.redactedLogger.error(`Payment refund failed: ${transactionId}`, error);
            return false;
        }
    }
    getOptimalProvider(requirements) {
        const availableProviders = this.getProvidersByRegion(requirements.region);
        const suitableProviders = availableProviders.filter(provider => {
            const supportsCurrency = provider.supportedCurrencies.includes(requirements.currency);
            const supportsCard = requirements.cardType == null ||
                provider.supportedCards.includes(requirements.cardType);
            const hasRequiredFeatures = requirements.features.every(feature => {
                switch (feature) {
                    case 'recurringPayments':
                        return provider.features.recurringPayments;
                    case 'refunds':
                        return provider.features.refunds;
                    case 'partialRefunds':
                        return provider.features.partialRefunds;
                    case 'webhooks':
                        return provider.features.webhooks;
                    case 'api':
                        return provider.features.api;
                    default:
                        return true;
                }
            });
            return supportsCurrency && supportsCard && hasRequiredFeatures;
        });
        if (suitableProviders.length === 0) {
            return null;
        }
        const sorted = suitableProviders.sort((a, b) => a.pricing.transactionFee - b.pricing.transactionFee);
        return sorted[0] ?? null;
    }
    handleUnsupportedCurrency(currency, provider) {
        this.redactedLogger.errorWithData(`Currency not supported: ${currency}`, {
            provider: provider.name,
            supportedCurrencies: provider.supportedCurrencies,
        }, 'PaymentSystemsService');
    }
    createTransaction(transactionId, providerId, amount, currency, cardType) {
        const transaction = {
            id: transactionId,
            providerId,
            amount,
            currency,
            status: 'pending',
            ...(cardType !== undefined ? { cardType } : {}),
            createdAt: new Date(),
        };
        return transaction;
    }
    createTransactionWithAutoId(config) {
        const transactionId = `txn-${Date.now()}`;
        return this.createTransaction(transactionId, config.providerId, config.amount, config.currency, config.cardType);
    }
    checkRefunds(provider) {
        if (provider == null || provider.features?.refunds !== true) {
            return false;
        }
        return true;
    }
    getProvidersByType(type) {
        return Array.from(this.providers.values()).filter(provider => provider.type === type);
    }
    getTransactionHistory(providerId) {
        return Array.from(this.transactions.values()).filter(transaction => transaction.providerId === providerId);
    }
    processRefund(transactionId, amount) {
        const transaction = this.transactions.get(transactionId);
        if (transaction == null) {
            return null;
        }
        if (amount > transaction.amount) {
            return null;
        }
        const refundTransaction = {
            id: `refund-${Date.now()}`,
            providerId: transaction.providerId,
            amount,
            currency: transaction.currency,
            status: 'refunded',
            createdAt: new Date(),
        };
        this.transactions.set(refundTransaction.id, refundTransaction);
        this.redactedLogger.log(`Refund processed`, 'PaymentSystemsService', {
            originalTransaction: transactionId,
            amount,
            currency: transaction.currency,
        });
        return refundTransaction;
    }
};
PaymentSystemsService = PaymentSystemsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], PaymentSystemsService);



/***/ }),
/* 205 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegionalArchitectureController: () => (/* binding */ RegionalArchitectureController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _local_datacenters_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(200);
/* harmony import */ var _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(201);
/* harmony import */ var _cdn_providers_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(202);
/* harmony import */ var _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(203);
/* harmony import */ var _payment_systems_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(204);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e;











let RegionalArchitectureController = class RegionalArchitectureController {
    constructor(localDatacentersService, cloudHostingService, cdnProvidersService, hybridArchitectureService, paymentSystemsService) {
        this.localDatacentersService = localDatacentersService;
        this.cloudHostingService = cloudHostingService;
        this.cdnProvidersService = cdnProvidersService;
        this.hybridArchitectureService = hybridArchitectureService;
        this.paymentSystemsService = paymentSystemsService;
    }
    async getAllDatacenters() {
        return this.localDatacentersService.getAllDatacenters();
    }
    async checkDatacenterHealth(id) {
        return this.localDatacentersService.checkDatacenterHealth(id);
    }
    async getAllDatacenterHealth() {
        return this.localDatacentersService.getAllDatacenterHealth();
    }
    async selectOptimalDatacenter(requirements) {
        return this.localDatacentersService.selectOptimalDatacenter(requirements.region, requirements);
    }
    async getAllHostingProviders() {
        return this.cloudHostingService.getAllProviders();
    }
    async getHostingProvidersByRegion(region) {
        return this.cloudHostingService.getProvidersByRegion(region);
    }
    async createHosting(request) {
        return this.cloudHostingService.createHosting(request.providerId, request.planId, request.domain, request.settings);
    }
    async getAllCdnProviders() {
        return this.cdnProvidersService.getAllProviders();
    }
    async getLocalCdnProviders() {
        return this.cdnProvidersService.getLocalProviders();
    }
    async getInternationalCdnProviders() {
        return this.cdnProvidersService.getInternationalProviders();
    }
    async createCdnConfiguration(request) {
        return this.cdnProvidersService.createCdnConfiguration(request.providerId, request.domain, request.settings);
    }
    async getAllHybridProviders() {
        return this.hybridArchitectureService.getAllProviders();
    }
    async createHybridDeployment(request) {
        return this.hybridArchitectureService.createHybridDeployment(request.localProvider, request.internationalProvider, request.configuration);
    }
    async migrateWorkload(deploymentId, workload) {
        return this.hybridArchitectureService.migrateWorkload(deploymentId, workload);
    }
    async getAllPaymentProviders() {
        return this.paymentSystemsService.getAllProviders();
    }
    async getPaymentProvidersByRegion(region) {
        return this.paymentSystemsService.getProvidersByRegion(region);
    }
    async processPayment(request) {
        return this.paymentSystemsService.processPayment(request.providerId, request.amount, request.currency, request.cardType);
    }
    async refundPayment(transactionId, request) {
        return this.paymentSystemsService.refundPayment(transactionId, request.amount);
    }
    async getRegionalArchitectureOverview() {
        const datacenters = this.localDatacentersService.getAllDatacenters();
        const hostingProviders = this.cloudHostingService.getAllProviders();
        const cdnProviders = this.cdnProvidersService.getAllProviders();
        const hybridProviders = this.hybridArchitectureService.getAllProviders();
        const paymentProviders = this.paymentSystemsService.getAllProviders();
        return {
            datacenters: {
                total: datacenters.length,
                byRegion: {
                    RU: datacenters.filter(dc => dc.region === 'Moscow' || dc.region === 'Saint Petersburg').length,
                    BY: datacenters.filter(dc => dc.region === 'Minsk').length,
                },
            },
            hosting: {
                total: hostingProviders.length,
                byRegion: {
                    RU: hostingProviders.filter(hp => hp.region === 'RU').length,
                    BY: hostingProviders.filter(hp => hp.region === 'BY').length,
                },
            },
            cdn: {
                total: cdnProviders.length,
                local: cdnProviders.filter(cp => cp.type === 'local').length,
                international: cdnProviders.filter(cp => cp.type === 'international')
                    .length,
            },
            hybrid: {
                total: hybridProviders.length,
                local: hybridProviders.filter(hp => hp.type === 'local').length,
                international: hybridProviders.filter(hp => hp.type === 'international')
                    .length,
            },
            payments: {
                total: paymentProviders.length,
                local: paymentProviders.filter(pp => pp.type === 'local').length,
                international: paymentProviders.filter(pp => pp.type === 'international').length,
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('datacenters'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all local datacenters' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of datacenters' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllDatacenters", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('datacenters/:id/health'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check datacenter health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Datacenter health status' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "checkDatacenterHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('datacenters/health/all'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check all datacenters health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'All datacenters health status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllDatacenterHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('datacenters/select-optimal'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Select optimal datacenter' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Optimal datacenter configuration' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "selectOptimalDatacenter", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('hosting/providers'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all hosting providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of hosting providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllHostingProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('hosting/providers/:region'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get hosting providers by region' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Hosting providers by region' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('region')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getHostingProvidersByRegion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('hosting/create'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create hosting deployment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Hosting deployment created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "createHosting", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cdn/providers'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all CDN providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of CDN providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllCdnProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cdn/providers/local'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get local CDN providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Local CDN providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getLocalCdnProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('cdn/providers/international'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get international CDN providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'International CDN providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getInternationalCdnProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('cdn/create-configuration'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create CDN configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'CDN configuration created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "createCdnConfiguration", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('hybrid/providers'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all hybrid providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of hybrid providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllHybridProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('hybrid/create-deployment'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create hybrid deployment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Hybrid deployment created' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "createHybridDeployment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('hybrid/:id/migrate-workload'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Migrate workload in hybrid deployment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Workload migration started' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "migrateWorkload", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('payments/providers'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all payment providers' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of payment providers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getAllPaymentProviders", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('payments/providers/:region'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get payment providers by region' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Payment providers by region' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('region')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getPaymentProvidersByRegion", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('payments/process'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Process payment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Payment processed' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "processPayment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('payments/:id/refund'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Refund payment' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Payment refunded' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "refundPayment", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('analytics/overview'),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_4__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_5__.UserRole.NETWORK_MANAGER),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get regional architecture overview' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Regional architecture overview' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RegionalArchitectureController.prototype, "getRegionalArchitectureOverview", null);
RegionalArchitectureController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Regional Architecture'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('regional-architecture'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_jwt_auth_guard__WEBPACK_IMPORTED_MODULE_2__.JwtAuthGuard, _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_3__.RolesGuard),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _local_datacenters_service__WEBPACK_IMPORTED_MODULE_6__.LocalDatacentersService !== "undefined" && _local_datacenters_service__WEBPACK_IMPORTED_MODULE_6__.LocalDatacentersService) === "function" ? _a : Object, typeof (_b = typeof _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_7__.CloudHostingService !== "undefined" && _cloud_hosting_service__WEBPACK_IMPORTED_MODULE_7__.CloudHostingService) === "function" ? _b : Object, typeof (_c = typeof _cdn_providers_service__WEBPACK_IMPORTED_MODULE_8__.CdnProvidersService !== "undefined" && _cdn_providers_service__WEBPACK_IMPORTED_MODULE_8__.CdnProvidersService) === "function" ? _c : Object, typeof (_d = typeof _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_9__.HybridArchitectureService !== "undefined" && _hybrid_architecture_service__WEBPACK_IMPORTED_MODULE_9__.HybridArchitectureService) === "function" ? _d : Object, typeof (_e = typeof _payment_systems_service__WEBPACK_IMPORTED_MODULE_10__.PaymentSystemsService !== "undefined" && _payment_systems_service__WEBPACK_IMPORTED_MODULE_10__.PaymentSystemsService) === "function" ? _e : Object])
], RegionalArchitectureController);



/***/ }),
/* 206 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecurityModule: () => (/* binding */ SecurityModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _authorization_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(207);
/* harmony import */ var _certificate_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209);
/* harmony import */ var _compliance_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(210);
/* harmony import */ var _controllers_continuous_security_testing_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(212);
/* harmony import */ var _dynamic_rate_limiting_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(214);
/* harmony import */ var _incident_response_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(215);
/* harmony import */ var _jwt_security_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(216);
/* harmony import */ var _kms_integration_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var _secrets_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(218);
/* harmony import */ var _security_audit_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(219);
/* harmony import */ var _security_integration_service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(220);
/* harmony import */ var _security_controller__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(221);
/* harmony import */ var _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(213);
/* harmony import */ var _services_secret_rotation_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(224);
/* harmony import */ var _static_analyzer_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(225);
/* harmony import */ var _unified_auth_service__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(208);
/* harmony import */ var _vulnerability_service__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(222);
/* harmony import */ var _waf_service__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(223);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





















let SecurityModule = class SecurityModule {
};
SecurityModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        imports: [
            _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__.JwtModule.register({
                secret: process.env.JWT_SECRET ?? 'default-secret',
                signOptions: { expiresIn: '1h' },
            }),
            _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitterModule,
        ],
        providers: [
            _waf_service__WEBPACK_IMPORTED_MODULE_20__.WafService,
            _secrets_service__WEBPACK_IMPORTED_MODULE_11__.SecretsService,
            _certificate_service__WEBPACK_IMPORTED_MODULE_4__.CertificateService,
            _vulnerability_service__WEBPACK_IMPORTED_MODULE_19__.VulnerabilityService,
            _incident_response_service__WEBPACK_IMPORTED_MODULE_8__.IncidentResponseService,
            _security_integration_service__WEBPACK_IMPORTED_MODULE_13__.SecurityIntegrationService,
            _jwt_security_service__WEBPACK_IMPORTED_MODULE_9__.JwtSecurityService,
            _compliance_service__WEBPACK_IMPORTED_MODULE_5__.ComplianceService,
            _services_secret_rotation_service__WEBPACK_IMPORTED_MODULE_16__.SecretRotationService,
            _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_15__.ContinuousSecurityTestingService,
            _kms_integration_service__WEBPACK_IMPORTED_MODULE_10__.KmsIntegrationService,
            _dynamic_rate_limiting_service__WEBPACK_IMPORTED_MODULE_7__.DynamicRateLimitingService,
            _static_analyzer_service__WEBPACK_IMPORTED_MODULE_17__.StaticAnalyzerService,
            _unified_auth_service__WEBPACK_IMPORTED_MODULE_18__.UnifiedAuthService,
            _authorization_service__WEBPACK_IMPORTED_MODULE_3__.AuthorizationService,
            _security_audit_service__WEBPACK_IMPORTED_MODULE_12__.SecurityAuditService,
        ],
        controllers: [_security_controller__WEBPACK_IMPORTED_MODULE_14__.SecurityController, _controllers_continuous_security_testing_controller__WEBPACK_IMPORTED_MODULE_6__.ContinuousSecurityTestingController],
        exports: [
            _waf_service__WEBPACK_IMPORTED_MODULE_20__.WafService,
            _secrets_service__WEBPACK_IMPORTED_MODULE_11__.SecretsService,
            _certificate_service__WEBPACK_IMPORTED_MODULE_4__.CertificateService,
            _vulnerability_service__WEBPACK_IMPORTED_MODULE_19__.VulnerabilityService,
            _incident_response_service__WEBPACK_IMPORTED_MODULE_8__.IncidentResponseService,
            _security_integration_service__WEBPACK_IMPORTED_MODULE_13__.SecurityIntegrationService,
            _jwt_security_service__WEBPACK_IMPORTED_MODULE_9__.JwtSecurityService,
            _compliance_service__WEBPACK_IMPORTED_MODULE_5__.ComplianceService,
            _services_secret_rotation_service__WEBPACK_IMPORTED_MODULE_16__.SecretRotationService,
            _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_15__.ContinuousSecurityTestingService,
            _kms_integration_service__WEBPACK_IMPORTED_MODULE_10__.KmsIntegrationService,
            _dynamic_rate_limiting_service__WEBPACK_IMPORTED_MODULE_7__.DynamicRateLimitingService,
            _static_analyzer_service__WEBPACK_IMPORTED_MODULE_17__.StaticAnalyzerService,
            _unified_auth_service__WEBPACK_IMPORTED_MODULE_18__.UnifiedAuthService,
            _authorization_service__WEBPACK_IMPORTED_MODULE_3__.AuthorizationService,
            _security_audit_service__WEBPACK_IMPORTED_MODULE_12__.SecurityAuditService,
        ],
    })
], SecurityModule);



/***/ }),
/* 207 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthorizationService: () => (/* binding */ AuthorizationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _unified_auth_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(208);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AuthorizationService_1;
var _a, _b;



let AuthorizationService = AuthorizationService_1 = class AuthorizationService {
    constructor(_configService, _unifiedAuthService) {
        this._configService = _configService;
        this._unifiedAuthService = _unifiedAuthService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(AuthorizationService_1.name);
        this.permissions = new Map();
        this.roles = new Map();
        this.resources = new Map();
        this.accessControlEntries = new Map();
        this.initializeDefaultPermissions();
        this.initializeDefaultRoles();
        this._configService.get('AUTHORIZATION_ENABLED');
        void this._unifiedAuthService.getUserById('system');
    }
    initializeDefaultPermissions() {
        const defaultPermissions = [
            {
                id: 'read:profile',
                name: 'Read Profile',
                description: 'Read user profile',
                resource: 'profile',
                action: 'read',
            },
            {
                id: 'update:profile',
                name: 'Update Profile',
                description: 'Update user profile',
                resource: 'profile',
                action: 'update',
            },
            {
                id: 'delete:profile',
                name: 'Delete Profile',
                description: 'Delete user profile',
                resource: 'profile',
                action: 'delete',
            },
            {
                id: 'read:users',
                name: 'Read Users',
                description: 'Read user information',
                resource: 'users',
                action: 'read',
            },
            {
                id: 'create:users',
                name: 'Create Users',
                description: 'Create new users',
                resource: 'users',
                action: 'create',
            },
            {
                id: 'update:users',
                name: 'Update Users',
                description: 'Update user information',
                resource: 'users',
                action: 'update',
            },
            {
                id: 'delete:users',
                name: 'Delete Users',
                description: 'Delete users',
                resource: 'users',
                action: 'delete',
            },
            {
                id: 'read:cards',
                name: 'Read Cards',
                description: 'Read cards',
                resource: 'cards',
                action: 'read',
            },
            {
                id: 'create:cards',
                name: 'Create Cards',
                description: 'Create new cards',
                resource: 'cards',
                action: 'create',
            },
            {
                id: 'update:cards',
                name: 'Update Cards',
                description: 'Update cards',
                resource: 'cards',
                action: 'update',
            },
            {
                id: 'delete:cards',
                name: 'Delete Cards',
                description: 'Delete cards',
                resource: 'cards',
                action: 'delete',
            },
            {
                id: 'read:monitoring',
                name: 'Read Monitoring',
                description: 'Read monitoring data',
                resource: 'monitoring',
                action: 'read',
            },
            {
                id: 'update:monitoring',
                name: 'Update Monitoring',
                description: 'Update monitoring settings',
                resource: 'monitoring',
                action: 'update',
            },
            {
                id: 'read:security',
                name: 'Read Security',
                description: 'Read security information',
                resource: 'security',
                action: 'read',
            },
            {
                id: 'update:security',
                name: 'Update Security',
                description: 'Update security settings',
                resource: 'security',
                action: 'update',
            },
            {
                id: 'read:config',
                name: 'Read Config',
                description: 'Read configuration',
                resource: 'config',
                action: 'read',
            },
            {
                id: 'update:config',
                name: 'Update Config',
                description: 'Update configuration',
                resource: 'config',
                action: 'update',
            },
            {
                id: 'admin:all',
                name: 'Admin All',
                description: 'Full administrative access',
                resource: '*',
                action: '*',
            },
        ];
        defaultPermissions.forEach(permission => {
            this.permissions.set(permission.id, permission);
        });
        this.logger.log(`Initialized ${defaultPermissions.length} default permissions`);
    }
    initializeDefaultRoles() {
        const defaultRoles = [
            {
                id: 'user',
                name: 'user',
                displayName: 'User',
                description: 'Basic user role',
                permissions: [
                    'read:profile',
                    'update:profile',
                    'read:cards',
                    'create:cards',
                    'update:cards',
                ],
                isSystem: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'admin',
                name: 'admin',
                displayName: 'Administrator',
                description: 'Administrator role with extended permissions',
                permissions: [
                    'read:profile',
                    'update:profile',
                    'delete:profile',
                    'read:users',
                    'create:users',
                    'update:users',
                    'delete:users',
                    'read:cards',
                    'create:cards',
                    'update:cards',
                    'delete:cards',
                    'read:monitoring',
                    'update:monitoring',
                    'read:security',
                    'update:security',
                    'read:config',
                    'update:config',
                ],
                isSystem: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'super_admin',
                name: 'super_admin',
                displayName: 'Super Administrator',
                description: 'Super administrator with full system access',
                permissions: ['admin:all'],
                isSystem: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
            {
                id: 'moderator',
                name: 'moderator',
                displayName: 'Moderator',
                description: 'Moderator role for content management',
                permissions: [
                    'read:profile',
                    'update:profile',
                    'read:users',
                    'update:users',
                    'read:cards',
                    'create:cards',
                    'update:cards',
                    'delete:cards',
                    'read:monitoring',
                ],
                isSystem: true,
                createdAt: new Date(),
                updatedAt: new Date(),
            },
        ];
        defaultRoles.forEach(role => {
            this.roles.set(role.id, role);
        });
        this.logger.log(`Initialized ${defaultRoles.length} default roles`);
    }
    async checkPermission(user, resource, action, resourceId, context) {
        try {
            if (user.roles.includes('super_admin')) {
                return {
                    allowed: true,
                    userPermissions: user.permissions,
                    conditions: { role: 'super_admin' },
                };
            }
            const requiredPermission = `${action}:${resource}`;
            const wildcardPermission = `admin:all`;
            if (user.permissions.includes(requiredPermission) ||
                user.permissions.includes(wildcardPermission)) {
                return {
                    allowed: true,
                    userPermissions: user.permissions,
                    requiredPermissions: [requiredPermission],
                };
            }
            const rolePermissions = await this.getRolePermissions(user.roles);
            if (rolePermissions.includes(requiredPermission) ||
                rolePermissions.includes(wildcardPermission)) {
                return {
                    allowed: true,
                    userPermissions: user.permissions,
                    requiredPermissions: [requiredPermission],
                    conditions: { roles: user.roles },
                };
            }
            const aclResult = await this.checkACL(user.id, resource, action, resourceId, context);
            if (aclResult.allowed) {
                return aclResult;
            }
            if (resourceId != null &&
                resourceId !== '' &&
                (await this.isResourceOwner(user.id, resource, resourceId))) {
                return {
                    allowed: true,
                    userPermissions: user.permissions,
                    conditions: { ownership: true },
                };
            }
            return {
                allowed: false,
                reason: 'Insufficient permissions',
                requiredPermissions: [requiredPermission],
                userPermissions: user.permissions,
            };
        }
        catch (error) {
            this.logger.error('Authorization check error:', error);
            return {
                allowed: false,
                reason: 'Authorization check failed',
                userPermissions: user.permissions,
            };
        }
    }
    async checkMultiplePermissions(user, permissions, context) {
        const results = {};
        for (const permission of permissions) {
            const key = `${permission.action}:${permission.resource}${permission.resourceId != null && permission.resourceId !== '' ? `:${permission.resourceId}` : ''}`;
            results[key] = await this.checkPermission(user, permission.resource, permission.action, permission.resourceId, context);
        }
        return results;
    }
    async hasPermission(user, permission, context) {
        const [action, resource] = permission.split(':');
        if (action == null ||
            action === '' ||
            resource == null ||
            resource === '') {
            return false;
        }
        const result = await this.checkPermission(user, resource, action, undefined, context);
        return result.allowed;
    }
    async hasAnyPermission(user, permissions, context) {
        for (const permission of permissions) {
            if (await this.hasPermission(user, permission, context)) {
                return true;
            }
        }
        return false;
    }
    async hasAllPermissions(user, permissions, context) {
        for (const permission of permissions) {
            if (!(await this.hasPermission(user, permission, context))) {
                return false;
            }
        }
        return true;
    }
    async getRolePermissions(roleNames) {
        const permissions = new Set();
        for (const roleName of roleNames) {
            const role = this.roles.get(roleName);
            if (role) {
                role.permissions.forEach(permission => permissions.add(permission));
            }
        }
        return Array.from(permissions);
    }
    async createRole(role) {
        const id = `role-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newRole = {
            ...role,
            id,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.roles.set(id, newRole);
        this.logger.log(`Created role: ${id}`);
        return newRole;
    }
    async updateRole(id, updates) {
        const role = this.roles.get(id);
        if (!role) {
            return null;
        }
        if (role.isSystem) {
            throw new Error('Cannot modify system roles');
        }
        const updatedRole = {
            ...role,
            ...updates,
            id,
            updatedAt: new Date(),
        };
        this.roles.set(id, updatedRole);
        this.logger.log(`Updated role: ${id}`);
        return updatedRole;
    }
    async deleteRole(id) {
        const role = this.roles.get(id);
        if (!role) {
            return false;
        }
        if (role.isSystem) {
            throw new Error('Cannot delete system roles');
        }
        this.roles.delete(id);
        this.logger.log(`Deleted role: ${id}`);
        return true;
    }
    async getRole(id) {
        return this.roles.get(id) ?? null;
    }
    async getAllRoles() {
        return Array.from(this.roles.values());
    }
    async createPermission(permission) {
        const id = `perm-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newPermission = {
            ...permission,
            id,
        };
        this.permissions.set(id, newPermission);
        this.logger.log(`Created permission: ${id}`);
        return newPermission;
    }
    async getPermission(id) {
        return this.permissions.get(id) ?? null;
    }
    async getAllPermissions() {
        return Array.from(this.permissions.values());
    }
    async createACLEntry(entry) {
        const id = `acl-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newEntry = {
            ...entry,
            id,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.accessControlEntries.set(id, newEntry);
        this.logger.log(`Created ACL entry: ${id}`);
        return newEntry;
    }
    async getACLEntries(principal, resource) {
        let entries = Array.from(this.accessControlEntries.values());
        if (principal != null) {
            entries = entries.filter(entry => entry.principal === principal);
        }
        if (resource != null) {
            entries = entries.filter(entry => entry.resource === resource);
        }
        return entries;
    }
    async checkACL(userId, resource, action, _resourceId, context) {
        const entries = Array.from(this.accessControlEntries.values()).filter(entry => entry.principal === userId &&
            entry.resource === resource &&
            entry.granted &&
            (!entry.expiresAt || entry.expiresAt > new Date()));
        for (const entry of entries) {
            if (entry.permissions.includes(action) ||
                entry.permissions.includes('*')) {
                if (entry.conditions && context) {
                    const conditionsMet = this.evaluateConditions(entry.conditions, context);
                    if (!conditionsMet) {
                        continue;
                    }
                }
                return {
                    allowed: true,
                    userPermissions: [action],
                    conditions: entry.conditions ?? {},
                };
            }
        }
        return {
            allowed: false,
            reason: 'No matching ACL entry found',
        };
    }
    async isResourceOwner(userId, _resource, resourceId) {
        const resourceEntry = this.resources.get(resourceId);
        return resourceEntry?.owner === userId;
    }
    evaluateConditions(conditions, context) {
        for (const [key, expectedValue] of Object.entries(conditions)) {
            const actualValue = context[key];
            if (actualValue !== expectedValue) {
                return false;
            }
        }
        return true;
    }
};
AuthorizationService = AuthorizationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _unified_auth_service__WEBPACK_IMPORTED_MODULE_2__.UnifiedAuthService !== "undefined" && _unified_auth_service__WEBPACK_IMPORTED_MODULE_2__.UnifiedAuthService) === "function" ? _b : Object])
], AuthorizationService);



/***/ }),
/* 208 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnifiedAuthService: () => (/* binding */ UnifiedAuthService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UnifiedAuthService_1;
var _a, _b, _c;




let UnifiedAuthService = UnifiedAuthService_1 = class UnifiedAuthService {
    constructor(_configService, jwtService, supabaseService) {
        this._configService = _configService;
        this.jwtService = jwtService;
        this.supabaseService = supabaseService;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(UnifiedAuthService_1.name);
        this.activeSessions = new Map();
        this.userCache = new Map();
        this._configService.get('JWT_SECRET');
    }
    async login(credentials) {
        try {
            this.logger.log(`Login attempt for email: ${credentials.email}`);
            const supabaseResult = await this.supabaseService.auth.signInWithPassword({
                email: credentials.email,
                password: credentials.password,
            });
            if (supabaseResult.error != null) {
                this.logger.warn(`Login failed for ${credentials.email}: ${supabaseResult.error.message}`);
                return {
                    success: false,
                    error: supabaseResult.error.message,
                };
            }
            const supabaseUser = supabaseResult.data.user;
            let user = await this.getUserById(supabaseUser.id);
            user ??= await this.createUserFromSupabase(supabaseUser, {
                email: supabaseUser.email,
            });
            user.lastLogin = new Date();
            await this.updateUser(user);
            const session = await this.createSession(user, {
                ipAddress: credentials.ipAddress ?? 'unknown',
                userAgent: credentials.userAgent ?? 'unknown',
                rememberMe: credentials.rememberMe ?? false,
            });
            const token = await this.generateJwtToken(user, session);
            session.token = token;
            this.activeSessions.set(session.id, session);
            this.logger.log(`Login successful for user: ${user.email}`);
            return {
                success: true,
                user,
                session,
            };
        }
        catch (error) {
            this.logger.error(`Login error for ${credentials.email}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Login failed',
            };
        }
    }
    async register(data) {
        try {
            this.logger.log(`Registration attempt for email: ${data.email}`);
            const supabaseResult = await this.supabaseService.auth.signUp({
                email: data.email,
                password: data.password,
                options: {
                    data: {
                        first_name: data.firstName,
                        last_name: data.lastName,
                        timezone: data.timezone,
                        locale: data.locale,
                        ...data.metadata,
                    },
                },
            });
            if (supabaseResult.error != null) {
                this.logger.warn(`Registration failed for ${data.email}: ${supabaseResult.error.message}`);
                return {
                    success: false,
                    error: supabaseResult.error.message,
                };
            }
            const supabaseUser = supabaseResult.data.user;
            if (supabaseUser == null) {
                return {
                    success: false,
                    error: 'User creation failed',
                };
            }
            const user = await this.createUserFromSupabase(supabaseUser, {
                email: supabaseUser.email,
                firstName: data.firstName,
                lastName: data.lastName,
                timezone: data.timezone,
                locale: data.locale,
                ...data.metadata,
            });
            this.logger.log(`Registration successful for user: ${user.email}`);
            return {
                success: true,
                user,
            };
        }
        catch (error) {
            this.logger.error(`Registration error for ${data.email}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Registration failed',
            };
        }
    }
    async logout(sessionId) {
        try {
            const session = this.activeSessions.get(sessionId);
            if (!session) {
                return false;
            }
            session.isActive = false;
            this.activeSessions.delete(sessionId);
            await this.supabaseService.auth.signOut();
            this.logger.log(`Logout successful for session: ${sessionId}`);
            return true;
        }
        catch (error) {
            this.logger.error(`Logout error for session ${sessionId}:`, error);
            return false;
        }
    }
    async validateToken(token) {
        try {
            const payload = this.jwtService.verify(token);
            const session = this.activeSessions.get(payload.sessionId);
            if (!session || !session.isActive || session.expiresAt < new Date()) {
                return null;
            }
            const user = await this.getUserById(session.userId);
            if (!user) {
                return null;
            }
            session.lastActivity = new Date();
            this.activeSessions.set(session.id, session);
            return user;
        }
        catch (error) {
            this.logger.error('Token validation error:', error);
            return null;
        }
    }
    async refreshToken(refreshToken) {
        try {
            const session = Array.from(this.activeSessions.values()).find(s => s.refreshToken === refreshToken && s.isActive);
            if (!session || session.refreshExpiresAt < new Date()) {
                return {
                    success: false,
                    error: 'Invalid or expired refresh token',
                };
            }
            const user = await this.getUserById(session.userId);
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                };
            }
            const newToken = await this.generateJwtToken(user, session);
            session.token = newToken;
            session.lastActivity = new Date();
            this.activeSessions.set(session.id, session);
            return {
                success: true,
                user,
                session,
            };
        }
        catch (error) {
            this.logger.error('Token refresh error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Token refresh failed',
            };
        }
    }
    async getUserById(userId) {
        const cachedUser = this.userCache.get(userId);
        if (cachedUser) {
            return cachedUser;
        }
        try {
            const { data: profile } = await this.supabaseService
                .from('profiles')
                .select('*')
                .eq('id', userId)
                .single();
            const { data: userRoles, error: rolesError } = await this.supabaseService
                .from('user_roles')
                .select('role')
                .eq('user_id', userId);
            const roles = rolesError != null
                ? ['user']
                : userRoles.map((ur) => ur.role);
            const permissions = await this.getUserPermissions(roles);
            const supabaseProfile = profile;
            const user = {
                id: supabaseProfile.id,
                email: supabaseProfile.email,
                roles,
                permissions,
                profile: {
                    firstName: supabaseProfile.first_name ?? '',
                    lastName: supabaseProfile.last_name ?? '',
                    avatar: supabaseProfile.avatar_url ?? '',
                    timezone: supabaseProfile.timezone ?? 'UTC',
                    locale: supabaseProfile.locale ?? 'en',
                },
                metadata: supabaseProfile.metadata ?? {},
                lastLogin: supabaseProfile.last_login != null
                    ? new Date(supabaseProfile.last_login)
                    : new Date(),
                createdAt: new Date(supabaseProfile.created_at),
                updatedAt: new Date(supabaseProfile.updated_at),
            };
            this.userCache.set(userId, user);
            return user;
        }
        catch (error) {
            this.logger.error(`Error getting user ${userId}:`, error);
            return null;
        }
    }
    async updateUser(user) {
        try {
            const { error } = await this.supabaseService
                .from('profiles')
                .update({
                first_name: user.profile.firstName,
                last_name: user.profile.lastName,
                avatar_url: user.profile.avatar,
                timezone: user.profile.timezone,
                locale: user.profile.locale,
                metadata: user.metadata,
                last_login: user.lastLogin?.toISOString(),
                updated_at: new Date().toISOString(),
            })
                .eq('id', user.id);
            if (error != null) {
                throw new Error(`Failed to update user: ${error.message}`);
            }
            this.userCache.set(user.id, user);
            return user;
        }
        catch (error) {
            this.logger.error(`Error updating user ${user.id}:`, error);
            throw error;
        }
    }
    async getActiveSessions(userId) {
        return Array.from(this.activeSessions.values()).filter(session => session.userId === userId && session.isActive);
    }
    async revokeSession(sessionId) {
        const session = this.activeSessions.get(sessionId);
        if (!session) {
            return false;
        }
        session.isActive = false;
        this.activeSessions.delete(sessionId);
        this.logger.log(`Session revoked: ${sessionId}`);
        return true;
    }
    async revokeAllUserSessions(userId) {
        const userSessions = Array.from(this.activeSessions.values()).filter(session => session.userId === userId && session.isActive);
        for (const session of userSessions) {
            session.isActive = false;
            this.activeSessions.delete(session.id);
        }
        this.logger.log(`Revoked ${userSessions.length} sessions for user: ${userId}`);
        return userSessions.length;
    }
    async createUserFromSupabase(supabaseUser, additionalData) {
        const user = {
            id: supabaseUser.id,
            email: supabaseUser.email || '',
            roles: ['user'],
            permissions: await this.getUserPermissions(['user']),
            profile: {
                firstName: supabaseUser.user_metadata?.first_name ||
                    additionalData?.firstName ||
                    '',
                lastName: supabaseUser.user_metadata?.last_name ||
                    additionalData?.lastName ||
                    '',
                timezone: supabaseUser.user_metadata?.timezone ||
                    additionalData?.timezone ||
                    'UTC',
                locale: supabaseUser.user_metadata?.locale ||
                    additionalData?.locale ||
                    'en',
            },
            metadata: {
                ...supabaseUser.user_metadata,
                ...additionalData,
            },
            createdAt: new Date(supabaseUser.created_at),
            updatedAt: new Date(),
        };
        this.userCache.set(user.id, user);
        return user;
    }
    async createSession(user, options) {
        const sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const refreshToken = `refresh-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date();
        const expiresAt = new Date(now.getTime() +
            (options.rememberMe ? 30 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000));
        const refreshExpiresAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        const session = {
            id: sessionId,
            userId: user.id,
            token: '',
            refreshToken,
            expiresAt,
            refreshExpiresAt,
            ipAddress: options.ipAddress,
            userAgent: options.userAgent,
            isActive: true,
            createdAt: now,
            lastActivity: now,
        };
        return session;
    }
    async generateJwtToken(user, session) {
        const payload = {
            sub: user.id,
            email: user.email,
            roles: user.roles,
            permissions: user.permissions,
            sessionId: session.id,
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(session.expiresAt.getTime() / 1000),
        };
        return this.jwtService.sign(payload);
    }
    async getUserPermissions(roles) {
        const rolePermissions = {
            user: ['read:profile', 'update:profile'],
            admin: ['read:profile', 'update:profile', 'read:users', 'update:users'],
            super_admin: ['*'],
        };
        const permissions = new Set();
        for (const role of roles) {
            const rolePerms = rolePermissions[role] ?? [];
            rolePerms.forEach(perm => permissions.add(perm));
        }
        return Array.from(permissions);
    }
};
UnifiedAuthService = UnifiedAuthService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__.JwtService !== "undefined" && _nestjs_jwt__WEBPACK_IMPORTED_MODULE_2__.JwtService) === "function" ? _b : Object, typeof (_c = typeof _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_3__.SupabaseService !== "undefined" && _supabase_supabase_service__WEBPACK_IMPORTED_MODULE_3__.SupabaseService) === "function" ? _c : Object])
], UnifiedAuthService);



/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CertificateService: () => (/* binding */ CertificateService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CertificateService_1;



const CertificateSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    domain: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['ssl', 'tls', 'code_signing', 'client', 'ca']),
    issuer: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    subject: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    serialNumber: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    validFrom: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    validTo: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    status: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['active', 'expired', 'revoked', 'pending', 'error']),
    autoRenewal: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    renewalThreshold: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    certificateData: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    privateKey: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    chain: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
    tags: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    lastRenewal: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
    renewalAttempts: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    lastRenewalError: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
});
const CertificateRequestSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    certificateId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['renewal', 'revocation', 'new']),
    status: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['pending', 'processing', 'completed', 'failed']),
    requestedBy: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    requestedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    completedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
    error: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    details: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.unknown()).optional(),
});
const AcmeConfigSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    server: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['production', 'staging']),
    email: zod__WEBPACK_IMPORTED_MODULE_2__.string().email(),
    accountKey: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    challengeType: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['http-01', 'dns-01', 'tls-alpn-01']),
    webrootPath: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    dnsProvider: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    dnsCredentials: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
});
let CertificateService = CertificateService_1 = class CertificateService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(CertificateService_1.name);
        this.certificates = [];
        this.requests = [];
        this.initializeCertificateService();
    }
    initializeCertificateService() {
        const acmeConfigData = {
            enabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_ENABLED', 'boolean', { default: false }),
            server: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_SERVER', 'string', {
                default: 'https://acme-v02.api.letsencrypt.org/directory',
            }),
            email: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_EMAIL', 'string', { default: '' }),
            accountKey: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_ACCOUNT_KEY', 'string', { default: '' }),
            challengeType: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_CHALLENGE_TYPE', 'string', {
                default: 'http-01',
            }),
            webrootPath: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_WEBROOT_PATH', 'string', { default: '' }),
            dnsProvider: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('ACME_DNS_PROVIDER', 'string', { default: '' }),
            dnsCredentials: {},
        };
        this.acmeConfig = AcmeConfigSchema.parse(acmeConfigData);
        this.logger.log('Certificate service initialized');
    }
    async createCertificate(certData) {
        const validatedCert = CertificateSchema.parse(certData);
        if (this.certificates.some(c => c.domain === validatedCert.domain && c.type === validatedCert.type)) {
            throw new Error(`Certificate for domain '${validatedCert.domain}' and type '${validatedCert.type}' already exists`);
        }
        const validation = await this.validateCertificate(validatedCert);
        if (!validation.isValid) {
            throw new Error(`Invalid certificate: ${validation.errors.join(', ')}`);
        }
        this.certificates.push(validatedCert);
        this.logger.log(`Certificate created: ${validatedCert.name} for ${validatedCert.domain}`);
        return validatedCert;
    }
    async getCertificateById(certId) {
        return this.certificates.find(c => c.id === certId) ?? null;
    }
    async getCertificateByDomain(domain, type) {
        return (this.certificates.find(c => c.domain === domain && (type == null || c.type === type)) ?? null);
    }
    async getAllCertificates() {
        return this.certificates;
    }
    async getActiveCertificates() {
        return this.certificates.filter(c => c.status === 'active');
    }
    async getExpiringCertificates(daysThreshold = 30) {
        const thresholdDate = new Date();
        thresholdDate.setDate(thresholdDate.getDate() + daysThreshold);
        return this.certificates.filter(c => c.status === 'active' && c.validTo <= thresholdDate);
    }
    async updateCertificate(certId, updates) {
        const cert = this.certificates.find(c => c.id === certId);
        if (!cert) {
            return null;
        }
        Object.assign(cert, updates, { updatedAt: new Date() });
        this.logger.log(`Certificate updated: ${certId}`);
        return cert;
    }
    async revokeCertificate(certId, reason = 'Manual revocation') {
        const cert = this.certificates.find(c => c.id === certId);
        if (cert) {
            cert.status = 'revoked';
            cert.updatedAt = new Date();
            this.logger.log(`Certificate revoked: ${certId} - ${reason}`);
        }
    }
    async renewCertificate(certId) {
        const cert = this.certificates.find(c => c.id === certId);
        if (!cert) {
            return null;
        }
        if (!cert.autoRenewal) {
            throw new Error(`Auto-renewal is disabled for certificate ${certId}`);
        }
        try {
            const request = {
                id: `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                certificateId: certId,
                type: 'renewal',
                status: 'processing',
                requestedBy: 'system',
                requestedAt: new Date(),
                details: { reason: 'Auto-renewal' },
            };
            this.requests.push(request);
            await this.simulateRenewal(cert);
            cert.lastRenewal = new Date();
            cert.renewalAttempts += 1;
            cert.validFrom = new Date();
            cert.validTo = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000);
            cert.status = 'active';
            cert.updatedAt = new Date();
            request.status = 'completed';
            request.completedAt = new Date();
            this.logger.log(`Certificate renewed: ${certId}`);
            return cert;
        }
        catch (error) {
            cert.renewalAttempts += 1;
            cert.lastRenewalError =
                error instanceof Error ? error.message : 'Unknown error';
            cert.updatedAt = new Date();
            const request = this.requests.find(r => r.certificateId === certId && r.status === 'processing');
            if (request) {
                request.status = 'failed';
                request.error =
                    error instanceof Error ? error.message : 'Unknown error';
                request.completedAt = new Date();
            }
            this.logger.error(`Certificate renewal failed: ${certId} - ${error instanceof Error ? error.message : 'Unknown error'}`);
            throw error;
        }
    }
    async simulateRenewal(cert) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        if (!this.acmeConfig.enabled) {
            throw new Error('ACME is not enabled');
        }
        this.logger.debug(`Simulating ACME renewal for ${cert.domain}`);
    }
    async validateCertificate(cert) {
        const errors = [];
        const warnings = [];
        let isValid = true;
        const now = new Date();
        if (cert.validFrom > now) {
            errors.push('Certificate is not yet valid');
            isValid = false;
        }
        if (cert.validTo <= now) {
            errors.push('Certificate has expired');
            isValid = false;
        }
        const daysToExpiry = Math.ceil((cert.validTo.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        if (daysToExpiry <= 30 && daysToExpiry > 0) {
            warnings.push(`Certificate expires in ${daysToExpiry} days`);
        }
        if (!cert.certificateData) {
            errors.push('Certificate data is missing');
            isValid = false;
        }
        if (!cert.domain) {
            errors.push('Domain is missing');
            isValid = false;
        }
        if (!cert.certificateData.includes('-----BEGIN CERTIFICATE-----')) {
            errors.push('Invalid certificate format (PEM expected)');
            isValid = false;
        }
        return {
            isValid,
            errors,
            warnings,
            expiryDays: daysToExpiry,
            chainValid: true,
            revocationStatus: 'valid',
            ocspStatus: 'valid',
            crlStatus: 'valid',
        };
    }
    async getRequests(limit = 100) {
        return this.requests
            .sort((a, b) => b.requestedAt.getTime() - a.requestedAt.getTime())
            .slice(0, limit);
    }
    async getRequestsByCertificate(certId, limit = 50) {
        return this.requests
            .filter(r => r.certificateId === certId)
            .sort((a, b) => b.requestedAt.getTime() - a.requestedAt.getTime())
            .slice(0, limit);
    }
    async getAcmeConfig() {
        return this.acmeConfig;
    }
    async updateAcmeConfig(updates) {
        Object.assign(this.acmeConfig, updates);
        this.logger.log('ACME configuration updated');
        return this.acmeConfig;
    }
    async getCertificateStats() {
        const now = new Date();
        const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        const activeCertificates = this.certificates.filter(c => c.status === 'active');
        const expiredCertificates = this.certificates.filter(c => c.status === 'expired');
        const expiringSoon = this.certificates.filter(c => c.status === 'active' && c.validTo <= thirtyDaysFromNow);
        const revokedCertificates = this.certificates.filter(c => c.status === 'revoked');
        const autoRenewalEnabled = this.certificates.filter(c => c.autoRenewal).length;
        const certificatesByType = this.certificates.reduce((acc, cert) => {
            acc[cert.type] = (acc[cert.type] ?? 0) + 1;
            return acc;
        }, {});
        const certificatesByStatus = this.certificates.reduce((acc, cert) => {
            acc[cert.status] = (acc[cert.status] ?? 0) + 1;
            return acc;
        }, {});
        const domainCounts = this.certificates.reduce((acc, cert) => {
            acc[cert.domain] = (acc[cert.domain] ?? 0) + 1;
            return acc;
        }, {});
        const topDomains = Object.entries(domainCounts)
            .map(([domain, count]) => ({ domain, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const averageDaysToExpiry = activeCertificates.length > 0
            ? activeCertificates.reduce((sum, cert) => {
                const daysToExpiry = Math.ceil((cert.validTo.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                return sum + Math.max(0, daysToExpiry);
            }, 0) / activeCertificates.length
            : 0;
        const renewalRequests = this.requests.filter(r => r.type === 'renewal');
        const successfulRenewals = renewalRequests.filter(r => r.status === 'completed').length;
        const renewalSuccessRate = renewalRequests.length > 0
            ? (successfulRenewals / renewalRequests.length) * 100
            : 0;
        return {
            totalCertificates: this.certificates.length,
            activeCertificates: activeCertificates.length,
            expiredCertificates: expiredCertificates.length,
            expiringSoon: expiringSoon.length,
            revokedCertificates: revokedCertificates.length,
            certificatesByType,
            certificatesByStatus,
            autoRenewalEnabled,
            renewalSuccessRate,
            averageDaysToExpiry,
            topDomains,
        };
    }
    async checkExpiringCertificates() {
        const expiringCerts = await this.getExpiringCertificates(30);
        for (const cert of expiringCerts) {
            if (cert.autoRenewal) {
                try {
                    await this.renewCertificate(cert.id);
                    this.logger.log(`Auto-renewed certificate: ${cert.id}`);
                }
                catch (error) {
                    this.logger.error(`Auto-renewal failed for certificate: ${cert.id} - ${error instanceof Error ? error.message : 'Unknown error'}`);
                }
            }
            else {
                this.logger.warn(`Certificate ${cert.id} expires soon but auto-renewal is disabled`);
            }
        }
        return expiringCerts;
    }
    async healthCheck() {
        const expiringCerts = await this.getExpiringCertificates(30);
        return {
            status: 'healthy',
            certificates: this.certificates.length,
            acme: this.acmeConfig.enabled ? 'enabled' : 'disabled',
            expiring: expiringCerts.length,
        };
    }
};
CertificateService = CertificateService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], CertificateService);



/***/ }),
/* 210 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComplianceService: () => (/* binding */ ComplianceService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(211);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ComplianceService_1;



const ComplianceConfigSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    gdprEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    pciDssEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    soxEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    hipaaEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(false),
    auditLogging: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    dataRetention: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(30).max(2555).default(2555),
    encryptionRequired: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    accessControl: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
});
const ComplianceRequirementSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    standard: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['GDPR', 'PCI_DSS', 'SOX', 'HIPAA', 'ISO_27001', 'SOC_2']),
    requirement: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    status: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'compliant',
        'non_compliant',
        'in_progress',
        'not_applicable',
    ]),
    lastAssessment: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    nextAssessment: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    evidence: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
    notes: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
});
const ComplianceAuditSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    timestamp: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    action: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    userId: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid().optional(),
    resource: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    dataType: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'personal',
        'financial',
        'health',
        'business',
        'technical',
    ]),
    accessType: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['read', 'write', 'delete', 'export']),
    compliance: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    violations: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
});
let ComplianceService = ComplianceService_1 = class ComplianceService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ComplianceService_1.name);
        this.requirements = [];
        this.audits = [];
        this.dataSubjects = [];
        this.config = ComplianceConfigSchema.parse({
            enabled: true,
            gdprEnabled: true,
            pciDssEnabled: true,
            soxEnabled: true,
            hipaaEnabled: false,
            auditLogging: true,
            dataRetention: 2555,
            encryptionRequired: true,
            accessControl: true,
        });
        this.stats = {
            totalRequirements: 0,
            compliantRequirements: 0,
            nonCompliantRequirements: 0,
            inProgressRequirements: 0,
            lastAudit: new Date(),
            violationsThisMonth: 0,
            dataBreaches: 0,
        };
        this.initializeDefaultRequirements();
        this.logger.log('Compliance Service initialized');
    }
    getConfig() {
        return { ...this.config };
    }
    updateConfig(updates) {
        const newConfig = { ...this.config, ...updates };
        this.config = ComplianceConfigSchema.parse(newConfig);
        this.logger.log(`Compliance config updated: ${JSON.stringify(updates)}`);
        return this.getConfig();
    }
    addRequirement(requirement) {
        const now = new Date();
        const newRequirement = {
            ...requirement,
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            lastAssessment: now,
            nextAssessment: new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000),
        };
        const validatedRequirement = ComplianceRequirementSchema.parse(newRequirement);
        this.requirements.push(validatedRequirement);
        this.updateStats();
        this.logger.log(`Compliance requirement added: ${requirement.requirement}`);
        return validatedRequirement;
    }
    updateRequirementStatus(requirementId, status, evidence) {
        const requirement = this.requirements.find(r => r.id === requirementId);
        if (!requirement) {
            return null;
        }
        requirement.status = status;
        requirement.lastAssessment = new Date();
        requirement.nextAssessment = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000);
        if (evidence) {
            requirement.evidence = evidence;
        }
        this.updateStats();
        this.logger.log(`Requirement status updated: ${requirement.requirement} -> ${status}`);
        return requirement;
    }
    getRequirements(filters) {
        let filteredRequirements = [...this.requirements];
        if (filters?.standard) {
            filteredRequirements = filteredRequirements.filter(r => r.standard === filters.standard);
        }
        if (filters?.status) {
            filteredRequirements = filteredRequirements.filter(r => r.status === filters.status);
        }
        return filteredRequirements.sort((a, b) => b.lastAssessment.getTime() - a.lastAssessment.getTime());
    }
    logAudit(audit) {
        const now = new Date();
        const isCompliant = this.checkCompliance(audit);
        const newAudit = {
            ...audit,
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            timestamp: now,
            compliance: isCompliant,
        };
        const validatedAudit = ComplianceAuditSchema.parse(newAudit);
        this.audits.push(validatedAudit);
        this.stats.lastAudit = now;
        if (!isCompliant) {
            this.stats.violationsThisMonth++;
        }
        this.logger.log(`Compliance audit logged: ${audit.action} - ${isCompliant ? 'compliant' : 'non-compliant'}`);
        return validatedAudit;
    }
    getAudits(filters) {
        let filteredAudits = [...this.audits];
        if (filters?.compliance !== undefined) {
            filteredAudits = filteredAudits.filter(a => a.compliance === filters.compliance);
        }
        if (filters?.dataType) {
            filteredAudits = filteredAudits.filter(a => a.dataType === filters.dataType);
        }
        if (filters?.accessType) {
            filteredAudits = filteredAudits.filter(a => a.accessType === filters.accessType);
        }
        if (filters?.userId != null && filters.userId !== '') {
            filteredAudits = filteredAudits.filter(a => a.userId === filters.userId);
        }
        if (filters?.limit != null && filters.limit > 0) {
            filteredAudits = filteredAudits.slice(-filters.limit);
        }
        return filteredAudits.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    addDataSubject(subject) {
        const now = new Date();
        const newSubject = {
            ...subject,
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            consentDate: now,
            lastAccess: now,
        };
        this.dataSubjects.push(newSubject);
        this.logger.log(`Data subject added: ${subject.email}`);
        return newSubject;
    }
    getDataSubjects() {
        return [...this.dataSubjects];
    }
    updateDataSubjectConsent(subjectId, consentGiven) {
        const subject = this.dataSubjects.find(s => s.id === subjectId);
        if (!subject) {
            return null;
        }
        subject.consentGiven = consentGiven;
        subject.consentDate = new Date();
        this.logger.log(`Data subject consent updated: ${subject.email} -> ${consentGiven}`);
        return subject;
    }
    deleteDataSubject(subjectId) {
        const index = this.dataSubjects.findIndex(s => s.id === subjectId);
        if (index === -1) {
            return false;
        }
        const subject = this.dataSubjects[index];
        if (subject == null) {
            return false;
        }
        this.dataSubjects.splice(index, 1);
        this.logger.log(`Data subject deleted (right to be forgotten): ${subject.email}`);
        return true;
    }
    getStats() {
        return { ...this.stats };
    }
    healthCheck() {
        const complianceRate = this.stats.totalRequirements > 0
            ? this.stats.compliantRequirements / this.stats.totalRequirements
            : 1;
        if (complianceRate < 0.8) {
            return {
                status: 'unhealthy',
                details: `Low compliance rate: ${(complianceRate * 100).toFixed(1)}%`,
            };
        }
        if (this.stats.violationsThisMonth > 10) {
            return {
                status: 'degraded',
                details: `High number of violations this month: ${this.stats.violationsThisMonth}`,
            };
        }
        return {
            status: 'healthy',
            details: `Compliance rate: ${(complianceRate * 100).toFixed(1)}%`,
        };
    }
    generateComplianceReport() {
        const recentAudits = this.getAudits({ limit: 100 });
        return {
            summary: this.getStats(),
            requirements: this.getRequirements(),
            recentAudits,
            dataSubjects: this.getDataSubjects(),
        };
    }
    checkCompliance(audit) {
        if (this.config.gdprEnabled && audit.dataType === 'personal') {
            if (audit.accessType === 'delete' || audit.accessType === 'export') {
                return true;
            }
            const subject = this.dataSubjects.find(s => s.email === audit.resource);
            if (subject && !subject.consentGiven) {
                return false;
            }
        }
        if (this.config.pciDssEnabled && audit.dataType === 'financial') {
            if (!this.config.encryptionRequired) {
                return false;
            }
            if (audit.accessType === 'read' && !this.config.accessControl) {
                return false;
            }
        }
        if (this.config.soxEnabled && audit.dataType === 'business') {
            if (audit.accessType === 'delete') {
                return false;
            }
        }
        return true;
    }
    updateStats() {
        this.stats.totalRequirements = this.requirements.length;
        this.stats.compliantRequirements = this.requirements.filter(r => r.status === 'compliant').length;
        this.stats.nonCompliantRequirements = this.requirements.filter(r => r.status === 'non_compliant').length;
        this.stats.inProgressRequirements = this.requirements.filter(r => r.status === 'in_progress').length;
    }
    initializeDefaultRequirements() {
        const defaultRequirements = [
            {
                standard: 'GDPR',
                requirement: 'Data Protection by Design',
                description: 'Implement data protection measures from the start of system design',
                status: 'compliant',
            },
            {
                standard: 'GDPR',
                requirement: 'Right to be Forgotten',
                description: 'Allow data subjects to request deletion of their personal data',
                status: 'compliant',
            },
            {
                standard: 'PCI_DSS',
                requirement: 'Encrypt Cardholder Data',
                description: 'Encrypt all cardholder data in transit and at rest',
                status: 'compliant',
            },
            {
                standard: 'PCI_DSS',
                requirement: 'Access Control',
                description: 'Implement strong access controls for cardholder data',
                status: 'compliant',
            },
            {
                standard: 'SOX',
                requirement: 'Financial Data Integrity',
                description: 'Ensure integrity and accuracy of financial data',
                status: 'compliant',
            },
            {
                standard: 'SOX',
                requirement: 'Audit Trail',
                description: 'Maintain comprehensive audit trails for financial transactions',
                status: 'compliant',
            },
        ];
        defaultRequirements.forEach(req => this.addRequirement(req));
    }
};
ComplianceService = ComplianceService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ComplianceService);



/***/ }),
/* 211 */
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),
/* 212 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContinuousSecurityTestingController: () => (/* binding */ ContinuousSecurityTestingController),
/* harmony export */   GenerateReportDto: () => (/* binding */ GenerateReportDto),
/* harmony export */   RunAllSecurityTestsDto: () => (/* binding */ RunAllSecurityTestsDto),
/* harmony export */   RunSecurityTestDto: () => (/* binding */ RunSecurityTestDto)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(213);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;



class RunSecurityTestDto {
}
class RunAllSecurityTestsDto {
}
class GenerateReportDto {
}
let ContinuousSecurityTestingController = class ContinuousSecurityTestingController {
    constructor(continuousSecurityTestingService) {
        this.continuousSecurityTestingService = continuousSecurityTestingService;
    }
    async runSecurityTest(request) {
        return this.continuousSecurityTestingService.runSecurityTest(request);
    }
    async runAllSecurityTests(request) {
        return this.continuousSecurityTestingService.runAllSecurityTests(request.target, request.configuration);
    }
    async generateSecurityReport(request) {
        return this.continuousSecurityTestingService.generateSecurityReport(request.testIds);
    }
    async getActiveTests() {
        return this.continuousSecurityTestingService.getActiveTests();
    }
    async getTestHistory(limit) {
        return this.continuousSecurityTestingService.getTestHistory(limit);
    }
    async getTestById(testId) {
        return this.continuousSecurityTestingService.getTestById(testId);
    }
    async stopTest(testId) {
        const stopped = await this.continuousSecurityTestingService.stopTest(testId);
        return { success: stopped };
    }
    async getHealth() {
        const activeTests = this.continuousSecurityTestingService.getActiveTests();
        const testHistory = this.continuousSecurityTestingService.getTestHistory();
        return {
            status: 'healthy',
            activeTests: activeTests.length,
            totalTests: testHistory.length,
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('run-test'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Run a single security test' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'Security test started successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Invalid test configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: RunSecurityTestDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [RunSecurityTestDto]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], ContinuousSecurityTestingController.prototype, "runSecurityTest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('run-all-tests'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Run all security tests for a target' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 201,
        description: 'All security tests started successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 400, description: 'Invalid configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: RunAllSecurityTestsDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [RunAllSecurityTestsDto]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], ContinuousSecurityTestingController.prototype, "runAllSecurityTests", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('generate-report'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate security test report' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Report generated successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Tests not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBody)({ type: GenerateReportDto }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GenerateReportDto]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], ContinuousSecurityTestingController.prototype, "generateSecurityReport", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('active-tests'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get all active security tests' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Active tests retrieved successfully',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], ContinuousSecurityTestingController.prototype, "getActiveTests", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('test-history'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get security test history' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Test history retrieved successfully',
    }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({
        name: 'limit',
        required: false,
        description: 'Number of tests to return',
        type: Number,
    }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], ContinuousSecurityTestingController.prototype, "getTestHistory", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('test/:testId'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get security test by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test retrieved successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Test not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'testId', description: 'Security test ID' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('testId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], ContinuousSecurityTestingController.prototype, "getTestById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('test/:testId/stop'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Stop a running security test' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Test stopped successfully' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 404, description: 'Test not found' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'testId', description: 'Security test ID' }),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('testId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], ContinuousSecurityTestingController.prototype, "stopTest", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get security testing service health' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Service health status' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], ContinuousSecurityTestingController.prototype, "getHealth", null);
ContinuousSecurityTestingController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Continuous Security Testing'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('security/testing'),
    __metadata("design:paramtypes", [typeof (_a = typeof _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_2__.ContinuousSecurityTestingService !== "undefined" && _services_continuous_security_testing_service__WEBPACK_IMPORTED_MODULE_2__.ContinuousSecurityTestingService) === "function" ? _a : Object])
], ContinuousSecurityTestingController);



/***/ }),
/* 213 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContinuousSecurityTestingService: () => (/* binding */ ContinuousSecurityTestingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ContinuousSecurityTestingService_1;

let ContinuousSecurityTestingService = ContinuousSecurityTestingService_1 = class ContinuousSecurityTestingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(ContinuousSecurityTestingService_1.name);
        this.activeTests = new Map();
        this.testHistory = [];
    }
    async runSecurityTest(request) {
        this.logger.log(`Starting security test: ${request.type} for target: ${request.target}`);
        const test = {
            id: this.generateTestId(),
            type: request.type,
            status: 'PENDING',
            target: request.target,
            startedAt: new Date().toISOString(),
            results: [],
            configuration: this.getDefaultConfig(request.configuration),
            metadata: request.metadata ?? {},
        };
        this.activeTests.set(test.id, test);
        try {
            test.status = 'RUNNING';
            const results = await this.executeTest(test);
            test.results = results;
            test.status = 'COMPLETED';
            test.completedAt = new Date().toISOString();
            test.duration =
                new Date(test.completedAt).getTime() -
                    new Date(test.startedAt).getTime();
            this.logger.log(`Security test completed: ${test.id} with ${results.length} findings`);
        }
        catch (error) {
            test.status = 'FAILED';
            test.completedAt = new Date().toISOString();
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            this.logger.error(`Security test failed: ${test.id} - ${errorMessage}`);
        }
        this.activeTests.delete(test.id);
        this.testHistory.push(test);
        return test;
    }
    async runAllSecurityTests(target, config) {
        this.logger.log(`Running all security tests for target: ${target}`);
        const testTypes = [
            'OWASP',
            'FUZZING',
            'TRIVY',
            'SNYK',
            'DEPENDENCY_CHECK',
        ];
        const tests = [];
        for (const type of testTypes) {
            const testRequest = {
                type,
                target,
            };
            if (config != null) {
                testRequest.configuration = config;
            }
            const test = await this.runSecurityTest(testRequest);
            tests.push(test);
        }
        return tests;
    }
    async generateSecurityReport(testIds) {
        const tests = testIds
            .map(id => this.testHistory.find(t => t.id === id))
            .filter(Boolean);
        if (tests.length === 0) {
            throw new Error('No tests found for the provided IDs');
        }
        const allResults = tests.flatMap(test => test.results);
        const totalDuration = tests.reduce((sum, test) => sum + (test.duration ?? 0), 0);
        const summary = {
            totalTests: tests.length,
            passed: tests.filter(t => t.status === 'COMPLETED' && t.results.length === 0).length,
            failed: tests.filter(t => t.status === 'FAILED' ||
                (t.status === 'COMPLETED' && t.results.length > 0)).length,
            vulnerabilities: {
                critical: allResults.filter(r => r.severity === 'CRITICAL').length,
                high: allResults.filter(r => r.severity === 'HIGH').length,
                medium: allResults.filter(r => r.severity === 'MEDIUM').length,
                low: allResults.filter(r => r.severity === 'LOW').length,
            },
            duration: totalDuration,
        };
        const recommendations = this.generateRecommendations(allResults);
        const compliance = this.checkCompliance(allResults);
        return {
            testId: testIds.join(','),
            summary,
            results: allResults,
            recommendations,
            compliance,
        };
    }
    getActiveTests() {
        return Array.from(this.activeTests.values());
    }
    getTestHistory(limit = 100) {
        return this.testHistory.slice(-limit);
    }
    getTestById(testId) {
        return (this.activeTests.get(testId) ??
            this.testHistory.find(t => t.id === testId));
    }
    async stopTest(testId) {
        const test = this.activeTests.get(testId);
        if (!test) {
            return false;
        }
        test.status = 'TIMEOUT';
        test.completedAt = new Date().toISOString();
        this.activeTests.delete(testId);
        this.testHistory.push(test);
        this.logger.log(`Test stopped: ${testId}`);
        return true;
    }
    async executeTest(test) {
        switch (test.type) {
            case 'OWASP':
                return this.runOwaspTest();
            case 'FUZZING':
                return this.runFuzzingTest();
            case 'TRIVY':
                return this.runTrivyTest();
            case 'SNYK':
                return this.runSnykTest();
            case 'DEPENDENCY_CHECK':
                return this.runDependencyCheckTest();
            case 'SAST':
                return this.runSastTest();
            case 'DAST':
                return this.runDastTest();
            case 'IAST':
                return this.runIastTest();
            default:
                throw new Error(`Unsupported test type: ${test.type}`);
        }
    }
    async runOwaspTest() {
        await this.delay(2000);
        return [
            {
                id: `owasp-${Date.now()}-1`,
                severity: 'HIGH',
                title: 'SQL Injection Vulnerability',
                description: 'Potential SQL injection found in user input validation',
                cve: 'CVE-2023-1234',
                cvss: 8.5,
                location: '/api/users/search',
                recommendation: 'Use parameterized queries and input validation',
                references: ['https://owasp.org/www-community/attacks/SQL_Injection'],
                tags: ['sql-injection', 'owasp-top-10'],
            },
            {
                id: `owasp-${Date.now()}-2`,
                severity: 'MEDIUM',
                title: 'XSS Vulnerability',
                description: 'Cross-site scripting vulnerability detected',
                cve: 'CVE-2023-5678',
                cvss: 6.1,
                location: '/api/comments',
                recommendation: 'Implement proper output encoding and CSP headers',
                references: ['https://owasp.org/www-community/attacks/xss/'],
                tags: ['xss', 'owasp-top-10'],
            },
        ];
    }
    async runFuzzingTest() {
        await this.delay(3000);
        return [
            {
                id: `fuzzing-${Date.now()}-1`,
                severity: 'CRITICAL',
                title: 'Buffer Overflow',
                description: 'Buffer overflow detected during fuzzing test',
                cve: 'CVE-2023-9012',
                cvss: 9.8,
                location: '/api/upload',
                recommendation: 'Implement proper bounds checking and input validation',
                references: [
                    'https://owasp.org/www-community/vulnerabilities/Buffer_Overflow',
                ],
                tags: ['buffer-overflow', 'fuzzing'],
            },
        ];
    }
    async runTrivyTest() {
        await this.delay(1500);
        return [
            {
                id: `trivy-${Date.now()}-1`,
                severity: 'HIGH',
                title: 'Vulnerable Dependency',
                description: 'Found vulnerable dependency in package.json',
                cve: 'CVE-2023-3456',
                cvss: 7.5,
                location: 'package.json:lodash@4.17.15',
                recommendation: 'Update lodash to version 4.17.21 or later',
                references: ['https://nvd.nist.gov/vuln/detail/CVE-2023-3456'],
                tags: ['dependency', 'trivy'],
            },
        ];
    }
    async runSnykTest() {
        await this.delay(2000);
        return [
            {
                id: `snyk-${Date.now()}-1`,
                severity: 'MEDIUM',
                title: 'License Violation',
                description: 'Found license violation in dependencies',
                location: 'package.json:some-package@1.0.0',
                recommendation: 'Replace with compatible license package',
                tags: ['license', 'snyk'],
            },
        ];
    }
    async runDependencyCheckTest() {
        await this.delay(1000);
        return [
            {
                id: `depcheck-${Date.now()}-1`,
                severity: 'LOW',
                title: 'Unused Dependency',
                description: 'Found unused dependency in project',
                location: 'package.json:unused-package@1.0.0',
                recommendation: 'Remove unused dependency to reduce attack surface',
                tags: ['dependency', 'unused'],
            },
        ];
    }
    async runSastTest() {
        await this.delay(2500);
        return [
            {
                id: `sast-${Date.now()}-1`,
                severity: 'HIGH',
                title: 'Hardcoded Credentials',
                description: 'Found hardcoded credentials in source code',
                location: 'src/config/database.ts:15',
                recommendation: 'Use environment variables for sensitive data',
                tags: ['credentials', 'sast'],
            },
        ];
    }
    async runDastTest() {
        await this.delay(3000);
        return [
            {
                id: `dast-${Date.now()}-1`,
                severity: 'MEDIUM',
                title: 'Information Disclosure',
                description: 'Server information disclosure in headers',
                location: 'HTTP Headers',
                recommendation: 'Remove or modify server headers',
                tags: ['information-disclosure', 'dast'],
            },
        ];
    }
    async runIastTest() {
        await this.delay(2000);
        return [
            {
                id: `iast-${Date.now()}-1`,
                severity: 'HIGH',
                title: 'Runtime Vulnerability',
                description: 'Runtime vulnerability detected during execution',
                location: 'Runtime',
                recommendation: 'Implement proper runtime protection',
                tags: ['runtime', 'iast'],
            },
        ];
    }
    generateRecommendations(results) {
        const recommendations = [];
        const criticalCount = results.filter(r => r.severity === 'CRITICAL').length;
        const highCount = results.filter(r => r.severity === 'HIGH').length;
        if (criticalCount > 0) {
            recommendations.push(`Immediate action required: ${criticalCount} critical vulnerabilities found`);
        }
        if (highCount > 0) {
            recommendations.push(`High priority: ${highCount} high severity vulnerabilities need attention`);
        }
        if (results.some(r => r.tags.includes('sql-injection'))) {
            recommendations.push('Implement parameterized queries and input validation');
        }
        if (results.some(r => r.tags.includes('xss'))) {
            recommendations.push('Add Content Security Policy headers and output encoding');
        }
        if (results.some(r => r.tags.includes('dependency'))) {
            recommendations.push('Update vulnerable dependencies and implement dependency scanning in CI/CD');
        }
        return recommendations;
    }
    checkCompliance(results) {
        const hasCriticalVulnerabilities = results.some(r => r.severity === 'CRITICAL');
        const hasHighVulnerabilities = results.some(r => r.severity === 'HIGH');
        const hasDataExposure = results.some(r => r.tags.includes('information-disclosure'));
        return {
            owasp: !hasCriticalVulnerabilities && !hasHighVulnerabilities,
            gdpr: !hasDataExposure,
            pciDss: !hasCriticalVulnerabilities && !hasDataExposure,
            sox: !hasCriticalVulnerabilities,
        };
    }
    getDefaultConfig(overrides) {
        return {
            timeout: 300000,
            maxConcurrentTests: 3,
            excludePatterns: ['node_modules/**', 'dist/**', '.git/**'],
            includePatterns: ['**/*.ts', '**/*.js', '**/*.json'],
            failOnHighSeverity: true,
            generateReport: true,
            notifyOnFailure: true,
            ...overrides,
        };
    }
    generateTestId() {
        return `security-test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
};
ContinuousSecurityTestingService = ContinuousSecurityTestingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], ContinuousSecurityTestingService);



/***/ }),
/* 214 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicRateLimitingService: () => (/* binding */ DynamicRateLimitingService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DynamicRateLimitingService_1;

let DynamicRateLimitingService = DynamicRateLimitingService_1 = class DynamicRateLimitingService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(DynamicRateLimitingService_1.name);
        this.rules = new Map();
        this.counters = new Map();
        this.stats = new Map();
        this.initializeDefaultRules();
    }
    initializeDefaultRules() {
        const defaultRules = [
            {
                id: 'default_api',
                name: 'Default API Rate Limit',
                pattern: '/api/**',
                type: 'url',
                limit: 100,
                window: 60000,
                enabled: true,
                priority: 1,
                actions: ['throttle', 'log'],
            },
            {
                id: 'auth_endpoints',
                name: 'Authentication Endpoints',
                pattern: '/api/auth/**',
                type: 'url',
                limit: 10,
                window: 300000,
                enabled: true,
                priority: 2,
                actions: ['block', 'log'],
            },
            {
                id: 'admin_endpoints',
                name: 'Admin Endpoints',
                pattern: '/api/admin/**',
                type: 'url',
                limit: 50,
                window: 60000,
                enabled: true,
                priority: 3,
                actions: ['throttle', 'log'],
            },
            {
                id: 'suspicious_ip',
                name: 'Suspicious IP Block',
                pattern: '192.168.1.100',
                type: 'ip',
                limit: 1,
                window: 3600000,
                enabled: true,
                priority: 10,
                actions: ['block', 'log'],
            },
        ];
        for (const rule of defaultRules) {
            this.addRule(rule);
        }
        this.logger.log('Dynamic rate limiting initialized with default rules', {
            ruleCount: defaultRules.length,
        });
    }
    addRule(rule) {
        this.rules.set(rule.id, rule);
        this.stats.set(rule.id, {
            ruleId: rule.id,
            totalRequests: 0,
            blockedRequests: 0,
            throttledRequests: 0,
            averageResponseTime: 0,
            lastReset: new Date(),
        });
        this.logger.log(`Added rate limit rule: ${rule.id}`, {
            name: rule.name,
            pattern: rule.pattern,
            limit: rule.limit,
            window: rule.window,
        });
    }
    updateRule(ruleId, updates) {
        const rule = this.rules.get(ruleId);
        if (!rule) {
            throw new Error(`Rate limit rule not found: ${ruleId}`);
        }
        const updatedRule = { ...rule, ...updates };
        this.rules.set(ruleId, updatedRule);
        this.logger.log(`Updated rate limit rule: ${ruleId}`, updates);
        return updatedRule;
    }
    removeRule(ruleId) {
        const rule = this.rules.get(ruleId);
        if (!rule) {
            throw new Error(`Rate limit rule not found: ${ruleId}`);
        }
        this.rules.delete(ruleId);
        this.stats.delete(ruleId);
        this.logger.log(`Removed rate limit rule: ${ruleId}`);
    }
    checkRateLimit(path, ip, userAgent) {
        this.logger.debug(`=== checkRateLimit called ===`);
        this.logger.debug(`Path: ${path}, IP: ${ip}, UserAgent: ${userAgent}`);
        this.logger.debug(`Total rules in service: ${this.rules.size}`);
        this.logger.debug(`All rules:`, Array.from(this.rules.values()).map(r => ({
            id: r.id,
            name: r.name,
            pattern: r.pattern,
            type: r.type,
            enabled: r.enabled,
        })));
        const ipRules = this.getApplicableRules(ip, 'ip');
        this.logger.debug(`IP rules for ${ip}:`, ipRules.map(r => ({
            id: r.id,
            pattern: r.pattern,
            limit: r.limit,
            priority: r.priority,
        })));
        if (ipRules.length > 0) {
            ipRules.sort((a, b) => a.priority - b.priority);
            const selectedRule = ipRules[0];
            if (!selectedRule)
                return this.createDefaultResult();
            this.logger.debug(`Selected IP rule: ${selectedRule.id} (${selectedRule.name}) with priority ${selectedRule.priority}`);
            const result = this.evaluateRule(selectedRule, ip);
            this.updateStats(selectedRule.id, result);
            this.logger.debug(`Applied IP rule ${selectedRule.id}, result:`, result);
            return result;
        }
        const urlRules = this.getApplicableRules(path, 'url', path);
        this.logger.debug(`URL rules for ${path}:`, urlRules.map(r => ({
            id: r.id,
            pattern: r.pattern,
            limit: r.limit,
            priority: r.priority,
        })));
        if (urlRules.length > 0) {
            urlRules.sort((a, b) => a.priority - b.priority);
            const selectedRule = urlRules[0];
            if (!selectedRule)
                return this.createDefaultResult();
            const result = this.evaluateRule(selectedRule, path);
            this.updateStats(selectedRule.id, result);
            this.logger.debug(`Applied URL rule ${selectedRule.id}, result:`, result);
            return result;
        }
        this.logger.debug(`No applicable rules found for path: ${path}, ip: ${ip}`);
        return {
            allowed: true,
            remaining: -1,
            resetTime: Date.now(),
            limit: -1,
            ruleId: '',
            action: 'log',
        };
    }
    createDefaultResult() {
        return {
            allowed: true,
            remaining: -1,
            resetTime: Date.now(),
            limit: -1,
            ruleId: '',
            action: 'log',
        };
    }
    getApplicableRules(identifier, type, url) {
        this.logger.debug(`=== getApplicableRules called ===`);
        this.logger.debug(`Identifier: ${identifier}, Type: ${type}, URL: ${url}`);
        const applicableRules = [];
        for (const rule of this.rules.values()) {
            this.logger.debug(`Checking rule: ${rule.id} (${rule.name}) - Type: ${rule.type}, Enabled: ${rule.enabled}, Pattern: ${rule.pattern}`);
            if (!rule.enabled) {
                this.logger.debug(`Rule ${rule.id} skipped: not enabled`);
                continue;
            }
            if (rule.type !== type) {
                this.logger.debug(`Rule ${rule.id} skipped: type mismatch (${rule.type} vs ${type})`);
                continue;
            }
            let matches = false;
            switch (rule.type) {
                case 'url':
                    if (url != null &&
                        url !== '' &&
                        this.matchesPattern(url, rule.pattern)) {
                        matches = true;
                        this.logger.debug(`URL pattern match: ${url} vs ${rule.pattern} = true`);
                    }
                    else {
                        this.logger.debug(`URL pattern match: ${url} vs ${rule.pattern} = false`);
                    }
                    break;
                case 'ip':
                    if (this.matchesPattern(identifier, rule.pattern)) {
                        matches = true;
                        this.logger.debug(`IP pattern match: ${identifier} vs ${rule.pattern} = true`);
                    }
                    else {
                        this.logger.debug(`IP pattern match: ${identifier} vs ${rule.pattern} = false`);
                    }
                    break;
                case 'user':
                case 'api_key':
                    if (identifier === rule.pattern) {
                        matches = true;
                        this.logger.debug(`Exact match: ${identifier} vs ${rule.pattern} = true`);
                    }
                    else {
                        this.logger.debug(`Exact match: ${identifier} vs ${rule.pattern} = false`);
                    }
                    break;
            }
            if (matches && this.evaluateConditions(rule)) {
                this.logger.debug(`Rule ${rule.id} is applicable and conditions passed`);
                applicableRules.push(rule);
            }
            else {
                this.logger.debug(`Rule ${rule.id} conditions failed or pattern didn't match`);
            }
        }
        this.logger.debug(`Found ${applicableRules.length} applicable rules:`, applicableRules.map(r => ({ id: r.id, name: r.name, pattern: r.pattern })));
        return applicableRules;
    }
    matchesPattern(value, pattern) {
        this.logger.debug(`=== matchesPattern called ===`);
        this.logger.debug(`Value: ${value}, Pattern: ${pattern}`);
        if (pattern.includes('**')) {
            const regexPattern = pattern.replace(/\*\*/g, '.*');
            const regex = new RegExp(`^${regexPattern}$`);
            const result = regex.test(value);
            this.logger.debug(`Wildcard pattern: ${pattern} -> ${regexPattern}, Result: ${result}`);
            return result;
        }
        if (this.isValidIP(value)) {
            const result = value === pattern;
            this.logger.debug(`IP exact match: ${value} === ${pattern} = ${result}`);
            return result;
        }
        if (pattern.startsWith('/')) {
            const basePattern = pattern.replace(/\*\*$/, '');
            const result = value.startsWith(basePattern);
            this.logger.debug(`URL pattern: ${pattern} -> base: ${basePattern}, ${value}.startsWith(${basePattern}) = ${result}`);
            return result;
        }
        const result = value.includes(pattern) || pattern.includes(value);
        this.logger.debug(`Default includes check: ${value}.includes(${pattern}) || ${pattern}.includes(${value}) = ${result}`);
        return result;
    }
    evaluateConditions(rule) {
        if (!rule.conditions)
            return true;
        const now = new Date();
        const currentHour = now.getHours();
        const currentDay = now.getDay();
        if (rule.conditions.timeOfDay) {
            const { start, end } = rule.conditions.timeOfDay;
            const startParts = start.split(':');
            const endParts = end.split(':');
            const startHour = parseInt(startParts[0] ?? '0');
            const endHour = parseInt(endParts[0] ?? '0');
            if (currentHour < startHour || currentHour > endHour) {
                return false;
            }
        }
        if (rule.conditions.dayOfWeek &&
            !rule.conditions.dayOfWeek.includes(currentDay)) {
            return false;
        }
        return true;
    }
    evaluateRule(rule, identifier) {
        this.logger.debug(`=== evaluateRule called ===`);
        this.logger.debug(`Rule: ${rule.id} (${rule.name}), Identifier: ${identifier}`);
        const key = `${rule.id}:${identifier}`;
        const now = Date.now();
        let counter = this.counters.get(key);
        this.logger.debug(`Current counter for key ${key}:`, counter);
        if (!counter || now > counter.resetTime) {
            counter = {
                count: 0,
                resetTime: now + rule.window,
            };
            this.logger.debug(`Reset counter for ${key}`);
        }
        counter.count++;
        this.logger.debug(`Counter for ${key} increased to ${counter.count}, limit: ${rule.limit}`);
        this.counters.set(key, counter);
        const remaining = Math.max(0, rule.limit - counter.count);
        const allowed = counter.count <= rule.limit;
        this.logger.debug(`Rule evaluation: count=${counter.count}, limit=${rule.limit}, allowed=${allowed}, remaining=${remaining}`);
        let action = 'log';
        if (!allowed) {
            if (rule.actions.includes('block')) {
                action = 'block';
            }
            else if (rule.actions.includes('throttle')) {
                action = 'throttle';
            }
        }
        const result = {
            allowed,
            remaining,
            resetTime: counter.resetTime,
            limit: rule.limit,
            ruleId: rule.id,
            action,
            reason: !allowed ? `Rate limit exceeded: ${rule.name}` : '',
        };
        this.logger.debug(`Rule evaluation result:`, result);
        this.logger.debug(`Final counter state:`, this.counters.get(key));
        return result;
    }
    updateStats(ruleId, result) {
        this.logger.debug(`=== updateStats called ===`);
        this.logger.debug(`RuleId: ${ruleId}, Result:`, result);
        const stats = this.stats.get(ruleId);
        this.logger.debug(`Current stats for rule ${ruleId}:`, stats);
        if (!stats) {
            this.logger.debug(`No stats found for rule ${ruleId}, skipping update`);
            return;
        }
        stats.totalRequests++;
        this.logger.debug(`Updated totalRequests to ${stats.totalRequests}`);
        if (!result.allowed) {
            if (result.action === 'block') {
                stats.blockedRequests++;
                this.logger.debug(`Updated blockedRequests to ${stats.blockedRequests}`);
            }
            else if (result.action === 'throttle') {
                stats.throttledRequests++;
                this.logger.debug(`Updated throttledRequests to ${stats.throttledRequests}`);
            }
        }
        this.stats.set(ruleId, stats);
        this.logger.debug(`Stats saved for rule ${ruleId}:`, stats);
    }
    getRule(ruleId) {
        return this.rules.get(ruleId);
    }
    getAllRules() {
        return Array.from(this.rules.values());
    }
    getRuleStats(ruleId) {
        return this.stats.get(ruleId);
    }
    getAllStats() {
        return Array.from(this.stats.values());
    }
    resetCounters(ruleId) {
        const rule = this.rules.get(ruleId);
        if (!rule) {
            throw new Error(`Rate limit rule not found: ${ruleId}`);
        }
        for (const [key] of this.counters.entries()) {
            if (key.startsWith(`${ruleId}:`)) {
                this.counters.delete(key);
            }
        }
        this.logger.log(`Reset counters for rule: ${ruleId}`);
    }
    resetAllCounters() {
        this.counters.clear();
        this.logger.log('Reset all rate limit counters');
    }
    createRuleFromAnalytics(pattern, type, analytics) {
        let limit = 100;
        let window = 60000;
        let actions = ['throttle', 'log'];
        if (analytics.errorRate > 0.1) {
            limit = Math.floor(analytics.requestCount * 0.5);
            window = 300000;
            actions = ['block', 'log'];
        }
        else if (analytics.averageResponseTime > 1000) {
            limit = Math.floor(analytics.requestCount * 0.8);
            window = 120000;
            actions = ['throttle', 'log'];
        }
        const rule = {
            id: `auto_${Date.now()}`,
            name: `Auto-generated rule for ${pattern}`,
            pattern,
            type,
            limit,
            window,
            enabled: true,
            priority: 5,
            actions,
        };
        this.addRule(rule);
        return rule;
    }
    optimizeRules() {
        for (const [ruleId, stats] of this.stats.entries()) {
            const rule = this.rules.get(ruleId);
            if (!rule)
                continue;
            const blockRate = stats.blockedRequests / stats.totalRequests;
            const throttleRate = stats.throttledRequests / stats.totalRequests;
            if (blockRate > 0.2) {
                const newLimit = Math.floor(rule.limit * 1.5);
                this.updateRule(ruleId, { limit: newLimit });
                this.logger.log(`Optimized rule ${ruleId}: increased limit to ${newLimit}`, {
                    blockRate,
                    throttleRate,
                });
            }
            if (throttleRate > 0.3) {
                const newLimit = Math.floor(rule.limit * 1.2);
                this.updateRule(ruleId, { limit: newLimit });
                this.logger.log(`Optimized rule ${ruleId}: increased limit to ${newLimit}`, {
                    blockRate,
                    throttleRate,
                });
            }
        }
    }
    createRule(ruleData) {
        if (!ruleData.name || ruleData.name.trim() === '') {
            throw new Error('Rule name cannot be empty');
        }
        if (!ruleData.pattern || ruleData.pattern.trim() === '') {
            throw new Error('Rule pattern cannot be empty');
        }
        if (ruleData.limit <= 0) {
            throw new Error('Rule limit must be greater than 0');
        }
        if (ruleData.window <= 0) {
            throw new Error('Rule window must be greater than 0');
        }
        if (ruleData.priority < 0) {
            throw new Error('Rule priority must be non-negative');
        }
        if (ruleData.actions.length === 0) {
            throw new Error('Rule must have at least one action');
        }
        const rule = {
            id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            ...ruleData,
        };
        this.addRule(rule);
        this.stats.set(rule.id, {
            ruleId: rule.id,
            totalRequests: 0,
            blockedRequests: 0,
            throttledRequests: 0,
            averageResponseTime: 0,
            lastReset: new Date(),
        });
        return rule;
    }
    deleteRule(ruleId) {
        this.removeRule(ruleId);
    }
    getRulesByType(type) {
        return Array.from(this.rules.values()).filter(rule => rule.type === type);
    }
    addWhitelistedIP(ip) {
        const rule = {
            id: `whitelist_${ip}`,
            name: `Whitelist IP: ${ip}`,
            pattern: ip,
            type: 'ip',
            limit: 10000,
            window: 60000,
            enabled: true,
            priority: 1,
            actions: ['log'],
        };
        this.addRule(rule);
        this.logger.log(`Added IP to whitelist: ${ip}`);
    }
    addBlacklistedIP(ip) {
        const rule = {
            id: `blacklist_${ip}`,
            name: `Blacklist IP: ${ip}`,
            pattern: ip,
            type: 'ip',
            limit: 0,
            window: 60000,
            enabled: true,
            priority: 1,
            actions: ['block', 'log'],
        };
        this.addRule(rule);
        this.logger.log(`Added IP to blacklist: ${ip}`);
    }
    setUserQuota(userId, limit, window) {
        const rule = {
            id: `user_quota_${userId}`,
            name: `User Quota: ${userId}`,
            pattern: userId,
            type: 'user',
            limit,
            window,
            enabled: true,
            priority: 5,
            actions: ['throttle', 'log'],
        };
        this.addRule(rule);
        this.logger.log(`Set user quota for ${userId}: ${limit} requests per ${window}ms`);
    }
    checkUserRateLimit(userId) {
        const userRules = this.getApplicableRules(userId, 'user');
        if (userRules.length > 0) {
            const selectedRule = userRules[0];
            if (!selectedRule)
                return this.createDefaultResult();
            const result = this.evaluateRule(selectedRule, userId);
            this.updateStats(selectedRule.id, result);
            return result;
        }
        return {
            allowed: true,
            remaining: -1,
            resetTime: Date.now(),
            limit: -1,
            ruleId: '',
            action: 'log',
        };
    }
    updateLoadMetrics(ruleId, metrics) {
        const rule = this.rules.get(ruleId);
        if (!rule) {
            this.logger.warn(`Cannot update load metrics: rule ${ruleId} not found`);
            return;
        }
        if (metrics.cpuUsage > 80 || metrics.memoryUsage > 80) {
            const newLimit = Math.floor(rule.limit * 0.7);
            this.updateRule(ruleId, { limit: newLimit });
            this.logger.log(`Reduced rate limit for rule ${ruleId} due to high load: ${newLimit}`);
        }
        else if (metrics.cpuUsage < 30 && metrics.memoryUsage < 30) {
            const newLimit = Math.floor(rule.limit * 1.2);
            this.updateRule(ruleId, { limit: newLimit });
            this.logger.log(`Increased rate limit for rule ${ruleId} due to low load: ${newLimit}`);
        }
    }
    getOverallStats() {
        const allStats = this.getAllStats();
        const totalRequests = allStats.reduce((sum, stat) => sum + stat.totalRequests, 0);
        const blockedRequests = allStats.reduce((sum, stat) => sum + stat.blockedRequests, 0);
        const throttledRequests = allStats.reduce((sum, stat) => sum + stat.throttledRequests, 0);
        const activeRules = Array.from(this.rules.values()).filter(rule => rule.enabled).length;
        return {
            totalRules: this.rules.size,
            totalRequests,
            blockedRequests,
            throttledRequests,
            activeRules,
        };
    }
    getPerformanceMetrics() {
        const metrics = [];
        const now = Date.now();
        for (const [ruleId, stats] of this.stats.entries()) {
            const rule = this.rules.get(ruleId);
            if (!rule)
                continue;
            const timeWindow = (now - stats.lastReset.getTime()) / 1000;
            const requestRate = timeWindow > 0 ? stats.totalRequests / timeWindow : 0;
            const blockRate = stats.totalRequests > 0
                ? stats.blockedRequests / stats.totalRequests
                : 0;
            const throttleRate = stats.totalRequests > 0
                ? stats.throttledRequests / stats.totalRequests
                : 0;
            metrics.push({
                ruleId,
                ruleName: rule.name,
                requestRate,
                blockRate,
                throttleRate,
                averageResponseTime: stats.averageResponseTime,
            });
        }
        return metrics;
    }
    cleanupExpiredCounters() {
        const now = Date.now();
        let cleanedCount = 0;
        for (const [key, counter] of this.counters.entries()) {
            if (now > counter.resetTime) {
                this.counters.delete(key);
                cleanedCount++;
            }
        }
        if (cleanedCount > 0) {
            this.logger.log(`Cleaned up ${cleanedCount} expired rate limit counters`);
        }
    }
    isValidIP(ip) {
        const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        const result = ipRegex.test(ip);
        this.logger.debug(`isValidIP(${ip}) = ${result}`);
        return result;
    }
};
DynamicRateLimitingService = DynamicRateLimitingService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], DynamicRateLimitingService);



/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IncidentResponseService: () => (/* binding */ IncidentResponseService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var IncidentResponseService_1;


const SecurityIncidentSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    title: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    severity: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['low', 'medium', 'high', 'critical']),
    status: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['open', 'investigating', 'contained', 'resolved', 'closed']),
    type: zod__WEBPACK_IMPORTED_MODULE_1__["enum"]([
        'data_breach',
        'malware',
        'ddos',
        'phishing',
        'insider_threat',
        'vulnerability_exploit',
        'unauthorized_access',
        'other',
    ]),
    source: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    affectedSystems: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.string()),
    affectedUsers: zod__WEBPACK_IMPORTED_MODULE_1__.number(),
    discoveredAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
    reportedBy: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    assignedTo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),
    priority: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['low', 'medium', 'high', 'critical']),
    tags: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.string()).optional(),
    evidence: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.object({
        type: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        description: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        timestamp: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
        source: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    }))
        .optional(),
    timeline: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.object({
        timestamp: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
        action: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        actor: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        details: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    }))
        .optional(),
    resolution: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),
    lessonsLearned: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
});
const IncidentResponseSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    incidentId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['containment', 'eradication', 'recovery', 'lessons_learned']),
    responseType: zod__WEBPACK_IMPORTED_MODULE_1__["enum"]([
        'containment',
        'eradication',
        'recovery',
        'lessons_learned',
    ]),
    status: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['planned', 'in_progress', 'completed', 'failed']),
    assignedTo: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    priority: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['low', 'medium', 'high', 'critical']),
    description: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    action: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    executedBy: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    executedAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
    actions: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.object({
        action: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        status: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['pending', 'in_progress', 'completed', 'failed']),
        assignedTo: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        dueDate: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
        completedAt: zod__WEBPACK_IMPORTED_MODULE_1__.date().optional(),
        notes: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),
    }))
        .optional(),
    startDate: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
    endDate: zod__WEBPACK_IMPORTED_MODULE_1__.date().optional(),
    success: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().optional(),
    lessonsLearned: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_1__.date(),
});
const EscalationPolicySchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
    severity: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['low', 'medium', 'high', 'critical']),
    timeToEscalate: zod__WEBPACK_IMPORTED_MODULE_1__.number(),
    escalationLevels: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.object({
        level: zod__WEBPACK_IMPORTED_MODULE_1__.number(),
        role: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        contact: zod__WEBPACK_IMPORTED_MODULE_1__.string(),
        notificationMethod: zod__WEBPACK_IMPORTED_MODULE_1__["enum"](['email', 'sms', 'slack', 'phone']),
        timeToRespond: zod__WEBPACK_IMPORTED_MODULE_1__.number(),
    })),
    enabled: zod__WEBPACK_IMPORTED_MODULE_1__.boolean(),
});
let IncidentResponseService = IncidentResponseService_1 = class IncidentResponseService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(IncidentResponseService_1.name);
        this.incidents = [];
        this.responses = [];
        this.escalationPolicies = [];
        this.initializeIncidentResponse();
    }
    initializeIncidentResponse() {
        this.logger.log('Incident Response service initialized');
    }
    async createIncident(incidentData) {
        const validatedIncident = SecurityIncidentSchema.parse(incidentData);
        validatedIncident.priority = validatedIncident.severity;
        this.incidents.push(validatedIncident);
        this.logger.warn(`Security incident created: ${validatedIncident.title} (${validatedIncident.id}) - ${validatedIncident.severity}`);
        await this.triggerAutomaticResponse(validatedIncident);
        return validatedIncident;
    }
    async getIncidentById(incidentId) {
        return this.incidents.find(i => i.id === incidentId) ?? null;
    }
    async getAllIncidents() {
        return this.incidents;
    }
    async getOpenIncidents() {
        return this.incidents.filter(i => i.status !== 'closed');
    }
    async getIncidentsBySeverity(severity) {
        return this.incidents.filter(i => i.severity === severity);
    }
    async getIncidentsByType(type) {
        return this.incidents.filter(i => i.type === type);
    }
    async updateIncident(incidentId, updates) {
        const incident = this.incidents.find(i => i.id === incidentId);
        if (!incident) {
            return null;
        }
        Object.assign(incident, updates, { updatedAt: new Date() });
        this.logger.log(`Incident updated: ${incidentId}`);
        if (incident.timeline) {
            incident.timeline.push({
                timestamp: new Date(),
                action: 'Incident updated',
                actor: 'system',
                details: `Updated fields: ${Object.keys(updates).join(', ')}`,
            });
        }
        return incident;
    }
    async assignIncident(incidentId, assignedTo) {
        const incident = this.incidents.find(i => i.id === incidentId);
        if (incident) {
            incident.assignedTo = assignedTo;
            incident.updatedAt = new Date();
            if (incident.timeline) {
                incident.timeline.push({
                    timestamp: new Date(),
                    action: 'Incident assigned',
                    actor: 'system',
                    details: `Assigned to: ${assignedTo}`,
                });
            }
            this.logger.log(`Incident assigned: ${incidentId} to ${assignedTo}`);
        }
    }
    async updateIncidentStatus(incidentId, status, actor, details) {
        const incident = this.incidents.find(i => i.id === incidentId);
        if (incident) {
            incident.status = status;
            incident.updatedAt = new Date();
            if (incident.timeline) {
                incident.timeline.push({
                    timestamp: new Date(),
                    action: `Status changed to ${status}`,
                    actor,
                    details: details ?? `Status updated to ${status}`,
                });
            }
            this.logger.log(`Incident status updated: ${incidentId} -> ${status}`);
        }
    }
    async addResponse(incidentId, responseData) {
        const response = {
            id: `response-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            incidentId,
            type: responseData.responseType,
            responseType: responseData.responseType,
            status: 'completed',
            assignedTo: responseData.executedBy,
            priority: 'medium',
            description: responseData.description,
            action: responseData.action,
            executedBy: responseData.executedBy,
            executedAt: new Date(),
            startDate: new Date(),
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.responses.push(response);
        this.logger.log(`Response added to incident ${incidentId}: ${responseData.action}`);
        const incident = this.incidents.find(i => i.id === incidentId);
        if (incident?.timeline) {
            incident.timeline.push({
                timestamp: new Date(),
                action: responseData.action,
                actor: responseData.executedBy,
                details: responseData.description,
            });
        }
        return response;
    }
    async getResponsesForIncident(incidentId) {
        return this.responses.filter(r => r.incidentId === incidentId);
    }
    async triggerAutomaticResponse(incident) {
        switch (incident.type) {
            case 'data_breach':
                await this.handleDataBreach(incident);
                break;
            case 'ddos':
                await this.handleDdosAttack(incident);
                break;
            case 'malware':
                await this.handleMalwareIncident(incident);
                break;
            case 'unauthorized_access':
                await this.handleUnauthorizedAccess(incident);
                break;
            default:
                await this.handleGenericIncident(incident);
        }
        await this.checkEscalation(incident);
    }
    async handleDataBreach(incident) {
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Isolate affected systems',
            description: 'Automatically isolated systems to prevent further data exposure',
            executedBy: 'system',
        });
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Block suspicious IP addresses',
            description: 'Blocked IP addresses associated with the breach',
            executedBy: 'system',
        });
        this.logger.warn(`Data breach response triggered for incident: ${incident.id}`);
    }
    async handleDdosAttack(incident) {
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Enable DDoS protection',
            description: 'Activated DDoS mitigation services',
            executedBy: 'system',
        });
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Scale up resources',
            description: 'Automatically scaled up infrastructure to handle traffic',
            executedBy: 'system',
        });
        this.logger.warn(`DDoS response triggered for incident: ${incident.id}`);
    }
    async handleMalwareIncident(incident) {
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Quarantine affected systems',
            description: 'Automatically quarantined systems with detected malware',
            executedBy: 'system',
        });
        await this.addResponse(incident.id, {
            responseType: 'eradication',
            action: 'Initiate malware scan',
            description: 'Started comprehensive malware scan across all systems',
            executedBy: 'system',
        });
        this.logger.warn(`Malware response triggered for incident: ${incident.id}`);
    }
    async handleUnauthorizedAccess(incident) {
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Revoke suspicious sessions',
            description: 'Automatically revoked all suspicious user sessions',
            executedBy: 'system',
        });
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Enable enhanced monitoring',
            description: 'Activated enhanced security monitoring for affected systems',
            executedBy: 'system',
        });
        this.logger.warn(`Unauthorized access response triggered for incident: ${incident.id}`);
    }
    async handleGenericIncident(incident) {
        await this.addResponse(incident.id, {
            responseType: 'containment',
            action: 'Create incident ticket',
            description: 'Automatically created incident ticket for tracking',
            executedBy: 'system',
        });
        this.logger.warn(`Generic response triggered for incident: ${incident.id}`);
    }
    async checkEscalation(incident) {
        const policy = this.escalationPolicies.find(p => p.severity === incident.severity && p.enabled);
        if (policy) {
            this.logger.warn(`Escalation triggered for incident ${incident.id} - ${policy.name}`);
            await this.addResponse(incident.id, {
                responseType: 'containment',
                action: 'Escalate incident',
                description: `Incident escalated according to policy: ${policy.name}`,
                executedBy: 'system',
            });
        }
    }
    async createEscalationPolicy(policyData) {
        const validatedPolicy = EscalationPolicySchema.parse(policyData);
        this.escalationPolicies.push(validatedPolicy);
        this.logger.log(`Escalation policy created: ${validatedPolicy.name}`);
        return validatedPolicy;
    }
    async getEscalationPolicies() {
        return this.escalationPolicies;
    }
    async updateEscalationPolicy(policyId, updates) {
        const policy = this.escalationPolicies.find(p => p.id === policyId);
        if (policy) {
            Object.assign(policy, updates);
            this.logger.log(`Escalation policy updated: ${policyId}`);
            return policy;
        }
        return null;
    }
    async getIncidentStats() {
        const openIncidents = this.incidents.filter(i => i.status !== 'closed');
        const resolvedIncidents = this.incidents.filter(i => i.status === 'resolved' || i.status === 'closed');
        const incidentsBySeverity = this.incidents.reduce((acc, incident) => {
            acc[incident.severity] = (acc[incident.severity] ?? 0) + 1;
            return acc;
        }, {});
        const incidentsByType = this.incidents.reduce((acc, incident) => {
            acc[incident.type] = (acc[incident.type] ?? 0) + 1;
            return acc;
        }, {});
        const incidentsByStatus = this.incidents.reduce((acc, incident) => {
            acc[incident.status] = (acc[incident.status] ?? 0) + 1;
            return acc;
        }, {});
        const systemCounts = this.incidents.reduce((acc, incident) => {
            incident.affectedSystems.forEach(system => {
                acc[system] = (acc[system] ?? 0) + 1;
            });
            return acc;
        }, {});
        const topAffectedSystems = Object.entries(systemCounts)
            .map(([system, count]) => ({ system, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const recentIncidents = this.incidents
            .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
            .slice(0, 20);
        const resolvedIncidentsWithDuration = resolvedIncidents;
        const averageResolutionTime = resolvedIncidentsWithDuration.length > 0
            ? resolvedIncidentsWithDuration.reduce((sum, incident) => {
                const duration = incident.updatedAt.getTime() - incident.createdAt.getTime();
                return sum + duration;
            }, 0) /
                resolvedIncidentsWithDuration.length /
                (1000 * 60 * 60)
            : 0;
        return {
            totalIncidents: this.incidents.length,
            openIncidents: openIncidents.length,
            resolvedIncidents: resolvedIncidents.length,
            incidentsBySeverity,
            incidentsByType,
            incidentsByStatus,
            averageResolutionTime,
            mttr: averageResolutionTime,
            mtta: 0,
            topAffectedSystems,
            recentIncidents,
        };
    }
    async getIncidentMetrics() {
        const now = new Date();
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const criticalIncidents = this.incidents.filter(i => i.severity === 'critical').length;
        const highIncidents = this.incidents.filter(i => i.severity === 'high').length;
        const mediumIncidents = this.incidents.filter(i => i.severity === 'medium').length;
        const lowIncidents = this.incidents.filter(i => i.severity === 'low').length;
        const openIncidents = this.incidents.filter(i => i.status !== 'closed').length;
        const resolvedIncidents = this.incidents.filter(i => i.status === 'resolved' || i.status === 'closed').length;
        const incidentsToday = this.incidents.filter(i => i.createdAt >= oneDayAgo).length;
        const incidentsThisWeek = this.incidents.filter(i => i.createdAt >= oneWeekAgo).length;
        const incidentsThisMonth = this.incidents.filter(i => i.createdAt >= oneMonthAgo).length;
        const resolvedIncidentsWithDuration = this.incidents.filter(i => i.status === 'resolved' || i.status === 'closed');
        const averageResolutionTime = resolvedIncidentsWithDuration.length > 0
            ? resolvedIncidentsWithDuration.reduce((sum, incident) => {
                const duration = incident.updatedAt.getTime() - incident.createdAt.getTime();
                return sum + duration;
            }, 0) /
                resolvedIncidentsWithDuration.length /
                (1000 * 60 * 60)
            : 0;
        return {
            totalIncidents: this.incidents.length,
            criticalIncidents,
            highIncidents,
            mediumIncidents,
            lowIncidents,
            openIncidents,
            resolvedIncidents,
            averageResolutionTime,
            incidentsThisMonth,
            incidentsThisWeek,
            incidentsToday,
        };
    }
    async sendIncidentNotification(incident, channel) {
        this.logger.warn(`Incident notification sent via ${channel}: ${incident.title} - ${incident.severity}`);
    }
    async healthCheck() {
        return {
            status: 'healthy',
            incidents: this.incidents.length,
            responses: this.responses.length,
            policies: this.escalationPolicies.length,
        };
    }
};
IncidentResponseService = IncidentResponseService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], IncidentResponseService);



/***/ }),
/* 216 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JwtSecurityService: () => (/* binding */ JwtSecurityService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(211);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var JwtSecurityService_1;



const JwtSecurityConfigSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    tokenRotation: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    refreshTokenExpiry: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(3600).max(2592000).default(604800),
    accessTokenExpiry: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(300).max(3600).default(900),
    maxRefreshTokens: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(1).max(10).default(5),
    blacklistEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    rateLimitEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    maxAttempts: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(1).max(100).default(10),
    blockDuration: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(300).max(3600).default(900),
});
const JwtTokenSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    userId: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    tokenType: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['access', 'refresh']),
    tokenHash: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    issuedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    expiresAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    revokedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
    deviceInfo: zod__WEBPACK_IMPORTED_MODULE_2__.object({
        userAgent: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
        ipAddress: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
        deviceId: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    })
        .optional(),
});
const JwtSecurityEventSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    timestamp: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    eventType: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'token_issued',
        'token_refreshed',
        'token_revoked',
        'token_expired',
        'suspicious_activity',
        'rate_limit_exceeded',
    ]),
    userId: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid().optional(),
    tokenId: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid().optional(),
    ipAddress: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    userAgent: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    severity: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['low', 'medium', 'high', 'critical']),
    details: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
});
let JwtSecurityService = JwtSecurityService_1 = class JwtSecurityService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(JwtSecurityService_1.name);
        this.tokens = [];
        this.events = [];
        this.rateLimits = new Map();
        this.blacklist = new Set();
        this.config = JwtSecurityConfigSchema.parse({
            enabled: true,
            tokenRotation: true,
            refreshTokenExpiry: 604800,
            accessTokenExpiry: 900,
            maxRefreshTokens: 5,
            blacklistEnabled: true,
            rateLimitEnabled: true,
            maxAttempts: 10,
            blockDuration: 900,
        });
        this.stats = {
            totalTokens: 0,
            activeTokens: 0,
            revokedTokens: 0,
            suspiciousActivities: 0,
            rateLimitBlocks: 0,
            lastEvent: new Date(),
        };
        this.logger.log('JWT Security Service initialized');
    }
    getConfig() {
        return { ...this.config };
    }
    updateConfig(updates) {
        const newConfig = { ...this.config, ...updates };
        this.config = JwtSecurityConfigSchema.parse(newConfig);
        this.logger.log(`JWT security config updated: ${JSON.stringify(updates)}`);
        return this.getConfig();
    }
    createToken(userId, tokenType, deviceInfo) {
        const now = new Date();
        const expiresAt = new Date(now.getTime() +
            (tokenType === 'access'
                ? this.config.accessTokenExpiry
                : this.config.refreshTokenExpiry) *
                1000);
        const token = {
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            userId,
            tokenType,
            tokenHash: this.generateTokenHash(),
            issuedAt: now,
            expiresAt,
            deviceInfo,
        };
        const validatedToken = JwtTokenSchema.parse(token);
        this.tokens.push(validatedToken);
        this.stats.totalTokens++;
        this.stats.activeTokens++;
        this.stats.lastEvent = now;
        this.registerEvent({
            eventType: 'token_issued',
            userId,
            tokenId: token.id,
            ipAddress: deviceInfo?.ipAddress,
            userAgent: deviceInfo?.userAgent,
            severity: 'low',
            details: `${tokenType} token issued for user ${userId}`,
        });
        this.logger.log(`${tokenType} token created for user ${userId}`);
        return validatedToken;
    }
    refreshToken(refreshTokenId, userId) {
        const refreshToken = this.tokens.find(t => t.id === refreshTokenId &&
            t.userId === userId &&
            t.tokenType === 'refresh' &&
            !t.revokedAt &&
            t.expiresAt > new Date());
        if (!refreshToken) {
            this.registerEvent({
                eventType: 'suspicious_activity',
                userId,
                tokenId: refreshTokenId,
                severity: 'medium',
                details: 'Invalid refresh token attempt',
            });
            return null;
        }
        const userTokens = this.tokens.filter(t => t.userId === userId &&
            t.tokenType === 'refresh' &&
            !t.revokedAt &&
            t.expiresAt > new Date());
        if (userTokens.length >= this.config.maxRefreshTokens) {
            const oldestToken = userTokens.sort((a, b) => a.issuedAt.getTime() - b.issuedAt.getTime())[0];
            if (oldestToken) {
                this.revokeToken(oldestToken.id, 'token_rotation');
            }
        }
        const deviceInfo = refreshToken.deviceInfo
            ? {
                userAgent: refreshToken.deviceInfo.userAgent,
                ipAddress: refreshToken.deviceInfo.ipAddress,
                ...(refreshToken.deviceInfo.deviceId != null &&
                    refreshToken.deviceInfo.deviceId !== '' && {
                    deviceId: refreshToken.deviceInfo.deviceId,
                }),
            }
            : undefined;
        const newAccessToken = this.createToken(userId, 'access', deviceInfo);
        this.revokeToken(refreshTokenId, 'token_refresh');
        this.registerEvent({
            eventType: 'token_refreshed',
            userId,
            tokenId: refreshTokenId,
            severity: 'low',
            details: 'Token refreshed successfully',
        });
        return newAccessToken;
    }
    revokeToken(tokenId, reason = 'manual_revocation') {
        const token = this.tokens.find(t => t.id === tokenId);
        if (!token || token.revokedAt) {
            return false;
        }
        token.revokedAt = new Date();
        this.stats.activeTokens--;
        this.stats.revokedTokens++;
        this.stats.lastEvent = new Date();
        if (this.config.blacklistEnabled) {
            this.blacklist.add(token.tokenHash);
        }
        this.registerEvent({
            eventType: 'token_revoked',
            userId: token.userId,
            tokenId: token.id,
            severity: 'medium',
            details: `Token revoked: ${reason}`,
        });
        this.logger.log(`Token ${tokenId} revoked: ${reason}`);
        return true;
    }
    validateToken(tokenId, userId) {
        const token = this.tokens.find(t => t.id === tokenId && t.userId === userId);
        if (!token) {
            return false;
        }
        if (token.revokedAt) {
            this.registerEvent({
                eventType: 'suspicious_activity',
                userId,
                tokenId,
                severity: 'high',
                details: 'Attempt to use revoked token',
            });
            return false;
        }
        if (token.expiresAt <= new Date()) {
            this.registerEvent({
                eventType: 'token_expired',
                userId,
                tokenId,
                severity: 'low',
                details: 'Token expired',
            });
            return false;
        }
        if (this.config.blacklistEnabled && this.blacklist.has(token.tokenHash)) {
            this.registerEvent({
                eventType: 'suspicious_activity',
                userId,
                tokenId,
                severity: 'high',
                details: 'Attempt to use blacklisted token',
            });
            return false;
        }
        return true;
    }
    checkRateLimit(identifier) {
        if (!this.config.rateLimitEnabled) {
            return { allowed: true, remainingAttempts: this.config.maxAttempts };
        }
        const now = new Date();
        const rateLimit = this.rateLimits.get(identifier);
        if (!rateLimit) {
            this.rateLimits.set(identifier, {
                attempts: 1,
                lastAttempt: now,
                blockedUntil: null,
            });
            return { allowed: true, remainingAttempts: this.config.maxAttempts - 1 };
        }
        if (rateLimit.blockedUntil && rateLimit.blockedUntil > now) {
            return {
                allowed: false,
                remainingAttempts: 0,
                blockedUntil: rateLimit.blockedUntil,
            };
        }
        if (rateLimit.blockedUntil && rateLimit.blockedUntil <= now) {
            rateLimit.blockedUntil = null;
            rateLimit.attempts = 0;
        }
        rateLimit.attempts++;
        rateLimit.lastAttempt = now;
        if (rateLimit.attempts > this.config.maxAttempts) {
            rateLimit.blockedUntil = new Date(now.getTime() + this.config.blockDuration * 1000);
            this.stats.rateLimitBlocks++;
            this.registerEvent({
                eventType: 'rate_limit_exceeded',
                severity: 'medium',
                details: `Rate limit exceeded for ${identifier}`,
            });
            return {
                allowed: false,
                remainingAttempts: 0,
                blockedUntil: rateLimit.blockedUntil,
            };
        }
        return {
            allowed: true,
            remainingAttempts: this.config.maxAttempts - rateLimit.attempts,
        };
    }
    getStats() {
        return { ...this.stats };
    }
    getEvents(filters) {
        let filteredEvents = [...this.events];
        if (filters?.eventType != null) {
            filteredEvents = filteredEvents.filter(e => e.eventType === filters.eventType);
        }
        if (filters?.severity != null) {
            filteredEvents = filteredEvents.filter(e => e.severity === filters.severity);
        }
        if (filters?.userId != null) {
            filteredEvents = filteredEvents.filter(e => e.userId === filters.userId);
        }
        if (filters?.limit != null) {
            filteredEvents = filteredEvents.slice(-filters.limit);
        }
        return filteredEvents.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    healthCheck() {
        const now = new Date();
        const timeSinceLastEvent = now.getTime() - this.stats.lastEvent.getTime();
        if (timeSinceLastEvent > 600000) {
            return {
                status: 'unhealthy',
                details: 'No recent JWT security events detected',
            };
        }
        if (this.stats.suspiciousActivities > 50) {
            return {
                status: 'degraded',
                details: `High number of suspicious activities: ${this.stats.suspiciousActivities}`,
            };
        }
        return {
            status: 'healthy',
            details: 'JWT security operating normally',
        };
    }
    cleanup(maxAge = 30 * 24 * 60 * 60 * 1000) {
        const cutoff = new Date(Date.now() - maxAge);
        const initialTokens = this.tokens.length;
        this.tokens = this.tokens.filter(token => token.issuedAt > cutoff);
        const tokensRemoved = initialTokens - this.tokens.length;
        const initialEvents = this.events.length;
        this.events = this.events.filter(event => event.timestamp > cutoff);
        const eventsRemoved = initialEvents - this.events.length;
        this.logger.log(`Cleanup completed: ${tokensRemoved} tokens, ${eventsRemoved} events removed`);
        return { tokensRemoved, eventsRemoved };
    }
    registerEvent(event) {
        const newEvent = {
            ...event,
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            timestamp: new Date(),
        };
        const validatedEvent = JwtSecurityEventSchema.parse(newEvent);
        this.events.push(validatedEvent);
        this.stats.lastEvent = new Date();
        if (event.severity === 'high' || event.severity === 'critical') {
            this.stats.suspiciousActivities++;
        }
    }
    generateTokenHash() {
        return crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID().replace(/-/g, '');
    }
};
JwtSecurityService = JwtSecurityService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], JwtSecurityService);



/***/ }),
/* 217 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KmsIntegrationService: () => (/* binding */ KmsIntegrationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var KmsIntegrationService_1;


let KmsIntegrationService = KmsIntegrationService_1 = class KmsIntegrationService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(KmsIntegrationService_1.name);
        this.providers = new Map();
        this.keys = new Map();
        this.operations = [];
        this.initializeProviders();
        if (this.providers.size === 0) {
            this.providers.set('aws', {
                name: 'aws',
                config: {
                    region: 'us-east-1',
                    accessKeyId: 'test-access-key',
                    secretAccessKey: 'test-secret-key',
                },
            });
            this.logger.log('Added mock AWS KMS provider for testing');
        }
    }
    initializeProviders() {
        if (process.env.AWS_REGION != null && process.env.AWS_REGION !== '') {
            this.providers.set('aws', {
                name: 'aws',
                config: {
                    region: process.env.AWS_REGION,
                    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
                    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
                },
            });
        }
        if (process.env.AZURE_TENANT_ID != null &&
            process.env.AZURE_TENANT_ID !== '') {
            this.providers.set('azure', {
                name: 'azure',
                config: {
                    tenantId: process.env.AZURE_TENANT_ID,
                    clientId: process.env.AZURE_CLIENT_ID,
                    clientSecret: process.env.AZURE_CLIENT_SECRET,
                    vaultUrl: process.env.AZURE_KEY_VAULT_URL,
                },
            });
        }
        if (process.env.GOOGLE_CLOUD_PROJECT != null &&
            process.env.GOOGLE_CLOUD_PROJECT !== '') {
            this.providers.set('google', {
                name: 'google',
                config: {
                    projectId: process.env.GOOGLE_CLOUD_PROJECT,
                    keyRing: process.env.GOOGLE_KMS_KEY_RING,
                    location: process.env.GOOGLE_KMS_LOCATION,
                },
            });
        }
        if (process.env.VAULT_URL != null && process.env.VAULT_URL !== '') {
            this.providers.set('vault', {
                name: 'vault',
                config: {
                    url: process.env.VAULT_URL,
                    token: process.env.VAULT_TOKEN,
                    namespace: process.env.VAULT_NAMESPACE,
                },
            });
        }
        this.logger.log('KMS providers initialized', {
            providers: Array.from(this.providers.keys()),
        });
    }
    async createKey(keyData) {
        const { name, provider, algorithm, keySize } = keyData;
        const kmsProvider = this.providers.get(provider);
        if (!kmsProvider) {
            throw new Error(`KMS provider not found: ${provider}`);
        }
        const key = {
            id: this.generateKeyId(provider),
            name,
            provider,
            algorithm,
            keySize,
            enabled: true,
            createdAt: new Date(),
        };
        this.keys.set(key.id, key);
        this.logger.log(`Created KMS key: ${key.id}`, {
            name,
            provider,
            algorithm,
        });
        return key;
    }
    async encrypt(keyId, data) {
        const startTime = Date.now();
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        if (!key.enabled) {
            throw new Error(`KMS key is disabled: ${keyId}`);
        }
        try {
            const encryptedData = this.mockEncrypt(data, key);
            const operation = {
                operation: 'encrypt',
                keyId,
                data,
                result: encryptedData,
                success: true,
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            key.lastUsed = new Date();
            this.logger.log(`Encrypted data with key: ${keyId}`, {
                dataLength: data.length,
                duration: operation.duration,
            });
            return encryptedData;
        }
        catch {
            const operation = {
                operation: 'encrypt',
                keyId,
                data,
                success: false,
                error: 'Unknown error',
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            throw new Error('KMS operation failed');
        }
    }
    async decrypt(keyId, encryptedData) {
        const startTime = Date.now();
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        if (!key.enabled) {
            throw new Error(`KMS key is disabled: ${keyId}`);
        }
        try {
            const decryptedData = this.mockDecrypt(encryptedData, key);
            const operation = {
                operation: 'decrypt',
                keyId,
                data: encryptedData,
                result: decryptedData,
                success: true,
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            key.lastUsed = new Date();
            this.logger.log(`Decrypted data with key: ${keyId}`, {
                dataLength: encryptedData.length,
                duration: operation.duration,
            });
            return decryptedData;
        }
        catch {
            const operation = {
                operation: 'decrypt',
                keyId,
                data: encryptedData,
                success: false,
                error: 'Unknown error',
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            throw new Error('KMS operation failed');
        }
    }
    async sign(keyId, data, algorithm) {
        const startTime = Date.now();
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        if (!key.enabled) {
            throw new Error(`KMS key is disabled: ${keyId}`);
        }
        try {
            const signature = this.mockSign(data, key, algorithm);
            const operation = {
                operation: 'sign',
                keyId,
                data,
                algorithm: algorithm ?? 'RS256',
                result: signature,
                success: true,
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            key.lastUsed = new Date();
            this.logger.log(`Signed data with key: ${keyId}`, {
                dataLength: data.length,
                algorithm,
                duration: operation.duration,
            });
            return signature;
        }
        catch {
            const operation = {
                operation: 'sign',
                keyId,
                data,
                algorithm: algorithm ?? 'RS256',
                success: false,
                error: 'Unknown error',
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            throw new Error('KMS operation failed');
        }
    }
    async verify(keyId, data, signature, algorithm) {
        const startTime = Date.now();
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        if (!key.enabled) {
            throw new Error(`KMS key is disabled: ${keyId}`);
        }
        try {
            const isValid = this.mockVerify(data, signature, key, algorithm);
            const operation = {
                operation: 'verify',
                keyId,
                data,
                algorithm: algorithm ?? 'RS256',
                result: isValid.toString(),
                success: true,
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            key.lastUsed = new Date();
            this.logger.log(`Verified signature with key: ${keyId}`, {
                dataLength: data.length,
                algorithm,
                isValid,
                duration: operation.duration,
            });
            return isValid;
        }
        catch {
            const operation = {
                operation: 'verify',
                keyId,
                data,
                algorithm: algorithm ?? 'RS256',
                success: false,
                error: 'Unknown error',
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            throw new Error('KMS operation failed');
        }
    }
    async generateKey(provider, algorithm = 'RSA', keySize = 2048) {
        const startTime = Date.now();
        const kmsProvider = this.providers.get(provider);
        if (!kmsProvider) {
            throw new Error(`KMS provider not found: ${provider}`);
        }
        try {
            const key = await this.createKey({
                name: `generated_${Date.now()}`,
                provider,
                algorithm,
                keySize,
            });
            const operation = {
                operation: 'generate',
                keyId: key.id,
                algorithm,
                success: true,
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            this.logger.log(`Generated KMS key: ${key.id}`, {
                provider,
                algorithm,
                keySize,
                duration: operation.duration,
            });
            return key;
        }
        catch {
            const operation = {
                operation: 'generate',
                keyId: '',
                algorithm,
                success: false,
                error: 'Unknown error',
                timestamp: new Date(),
                duration: Date.now() - startTime,
            };
            this.operations.push(operation);
            throw new Error('KMS operation failed');
        }
    }
    async getKey(keyId) {
        const key = this.keys.get(keyId);
        return key ?? null;
    }
    async listKeys() {
        return Array.from(this.keys.values());
    }
    async updateKey(keyId, updates) {
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        const updatedKey = { ...key, ...updates };
        this.keys.set(keyId, updatedKey);
        this.logger.log(`Updated KMS key: ${keyId}`, updates);
        return updatedKey;
    }
    async deleteKey(keyId) {
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        this.keys.delete(keyId);
        this.logger.log(`Deleted KMS key: ${keyId}`);
    }
    async rotateKey(keyId) {
        const key = this.keys.get(keyId);
        if (!key) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        const newKey = await this.createKey({
            name: key.name,
            provider: key.provider,
            algorithm: key.algorithm,
            keySize: key.keySize,
        });
        key.enabled = false;
        this.logger.log(`Rotated KMS key: ${keyId} -> ${newKey.id}`);
        return newKey;
    }
    async getOperationsHistory() {
        return [...this.operations];
    }
    async getOperationsByKey(keyId) {
        return this.operations.filter(op => op.keyId === keyId);
    }
    async checkHealth() {
        const providerStatuses = {};
        let healthyCount = 0;
        let totalCount = 0;
        for (const [name, provider] of this.providers.entries()) {
            totalCount++;
            try {
                if (Object.keys(provider.config).length > 0) {
                    providerStatuses[name] = 'healthy';
                    healthyCount++;
                }
                else {
                    providerStatuses[name] = 'degraded';
                }
            }
            catch {
                providerStatuses[name] = 'unhealthy';
            }
        }
        let status = 'healthy';
        if (healthyCount === 0) {
            status = 'unhealthy';
        }
        else if (healthyCount < totalCount) {
            status = 'degraded';
        }
        return {
            status,
            providers: providerStatuses,
            timestamp: new Date(),
        };
    }
    getAvailableProviders() {
        return Array.from(this.providers.keys());
    }
    getProvider(providerName) {
        return this.providers.get(providerName);
    }
    getAllProviders() {
        return Array.from(this.providers.values());
    }
    getOperations(keyId) {
        if (keyId != null && keyId !== '') {
            return this.operations.filter(op => op.keyId === keyId);
        }
        return this.operations;
    }
    disableKey(keyId) {
        const key = this.keys.get(keyId);
        if (key == null) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        key.enabled = false;
        this.logger.log(`Disabled KMS key: ${keyId}`);
    }
    enableKey(keyId) {
        const key = this.keys.get(keyId);
        if (key == null) {
            throw new Error(`KMS key not found: ${keyId}`);
        }
        key.enabled = true;
        this.logger.log(`Enabled KMS key: ${keyId}`);
    }
    mockEncrypt(data, key) {
        const _keyId = key.id;
        this.logger.debug(`Mock encrypting data with key: ${_keyId}`);
        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data).toString('base64') + '_encrypted';
    }
    mockDecrypt(encryptedData, key) {
        const _keyId = key.id;
        this.logger.debug(`Mock decrypting data with key: ${_keyId}`);
        const base64Data = encryptedData.replace('_encrypted', '');
        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(base64Data, 'base64').toString();
    }
    mockSign(data, key, algorithm) {
        const _algorithmName = algorithm;
        this.logger.debug(`Mock signing data with algorithm: ${_algorithmName ?? 'default'}`);
        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data + key.id).toString('base64') + '_signed';
    }
    mockVerify(data, signature, key, algorithm) {
        const _algorithmName = algorithm;
        this.logger.debug(`Mock verifying data with algorithm: ${_algorithmName ?? 'default'}`);
        const expectedSignature = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(data + key.id).toString('base64') + '_signed';
        return signature === expectedSignature;
    }
    generateKeyId(provider) {
        return `${provider}_key_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
};
KmsIntegrationService = KmsIntegrationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], KmsIntegrationService);



/***/ }),
/* 218 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretsService: () => (/* binding */ SecretsService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(118);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SecretsService_1;




const SecretSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_3__["enum"]([
        'password',
        'api_key',
        'certificate',
        'private_key',
        'token',
        'database_url',
    ]),
    value: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    encrypted: zod__WEBPACK_IMPORTED_MODULE_3__.boolean(),
    tags: zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.string()).optional(),
    expiresAt: zod__WEBPACK_IMPORTED_MODULE_3__.date().optional(),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_3__.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_3__.date(),
    createdBy: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    lastAccessed: zod__WEBPACK_IMPORTED_MODULE_3__.date().optional(),
    accessCount: zod__WEBPACK_IMPORTED_MODULE_3__.number(),
});
const SecretAccessSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    secretId: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    userId: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    userRole: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    action: zod__WEBPACK_IMPORTED_MODULE_3__["enum"](['read', 'write', 'delete']),
    timestamp: zod__WEBPACK_IMPORTED_MODULE_3__.date(),
    ipAddress: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    userAgent: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    success: zod__WEBPACK_IMPORTED_MODULE_3__.boolean(),
    details: zod__WEBPACK_IMPORTED_MODULE_3__.record(zod__WEBPACK_IMPORTED_MODULE_3__.string(), zod__WEBPACK_IMPORTED_MODULE_3__.unknown()).optional(),
});
const VaultConfigSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_3__.boolean(),
    url: zod__WEBPACK_IMPORTED_MODULE_3__.string().url(),
    token: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    namespace: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional(),
    engine: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    mountPath: zod__WEBPACK_IMPORTED_MODULE_3__.string(),
    timeout: zod__WEBPACK_IMPORTED_MODULE_3__.number(),
    retries: zod__WEBPACK_IMPORTED_MODULE_3__.number(),
});
let SecretsService = SecretsService_1 = class SecretsService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(SecretsService_1.name);
        this.secrets = [];
        this.accessLog = [];
        this.rotationSchedules = new Map();
        this.initializeSecrets();
    }
    initializeSecrets() {
        const configData = {
            enabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_ENABLED', 'boolean', { default: false }),
            url: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_URL', 'string', { default: 'http://localhost:8200' }),
            token: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_TOKEN', 'string', { default: '' }),
            namespace: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_NAMESPACE', 'string', { default: '' }),
            engine: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_ENGINE', 'string', { default: 'kv' }),
            mountPath: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_MOUNT_PATH', 'string', { default: 'secret' }),
            timeout: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_TIMEOUT', 'number', { default: 5000 }),
            retries: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_2__.getEnv)('VAULT_RETRIES', 'number', { default: 3 }),
        };
        this.config = VaultConfigSchema.parse(configData);
        this.logger.log('Secrets service initialized');
    }
    async createSecret(secretData) {
        const validatedSecret = SecretSchema.parse(secretData);
        if (this.secrets.some(s => s.name === validatedSecret.name)) {
            throw new Error(`Secret with name '${validatedSecret.name}' already exists`);
        }
        if (!validatedSecret.encrypted) {
            validatedSecret.value = await this.encryptValue(validatedSecret.value);
            validatedSecret.encrypted = true;
        }
        this.secrets.push(validatedSecret);
        this.logger.log(`Secret created: ${validatedSecret.name} (${validatedSecret.id})`);
        return validatedSecret;
    }
    async getSecretById(secretId, userId, userRole) {
        const secret = this.secrets.find(s => s.id === secretId);
        if (!secret) {
            return null;
        }
        await this.logAccess(secretId, userId, userRole, 'read', true);
        secret.lastAccessed = new Date();
        secret.accessCount += 1;
        return secret;
    }
    async getSecretByName(name, userId, userRole) {
        const secret = this.secrets.find(s => s.name === name);
        if (!secret) {
            return null;
        }
        await this.logAccess(secret.id, userId, userRole, 'read', true);
        secret.lastAccessed = new Date();
        secret.accessCount += 1;
        return secret;
    }
    async getAllSecrets(userId, userRole) {
        await this.logAccess('all', userId, userRole, 'read', true);
        return this.secrets.map(secret => ({
            ...secret,
            value: '***REDACTED***',
        }));
    }
    async updateSecret(secretId, updates, userId, userRole) {
        const secret = this.secrets.find(s => s.id === secretId);
        if (!secret) {
            return null;
        }
        await this.logAccess(secretId, userId, userRole, 'write', true);
        if (updates.value != null &&
            updates.value !== '' &&
            updates.encrypted !== true) {
            updates.value = await this.encryptValue(updates.value);
            updates.encrypted = true;
        }
        Object.assign(secret, updates, { updatedAt: new Date() });
        this.logger.log(`Secret updated: ${secretId} by ${userId}`);
        return secret;
    }
    async deleteSecret(secretId, userId, userRole) {
        const index = this.secrets.findIndex(s => s.id === secretId);
        if (index !== -1) {
            await this.logAccess(secretId, userId, userRole, 'delete', true);
            this.secrets.splice(index, 1);
            this.logger.log(`Secret deleted: ${secretId} by ${userId}`);
        }
    }
    async encryptValue(value) {
        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(value).toString('base64');
    }
    async decryptValue(encryptedValue) {
        return buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(encryptedValue, 'base64').toString('utf-8');
    }
    async setupSecretRotation(secretId, rotationData) {
        const secret = this.secrets.find(s => s.id === secretId);
        if (!secret) {
            throw new Error(`Secret ${secretId} not found`);
        }
        const nextRotation = this.calculateNextRotation(rotationData.schedule);
        const rotation = {
            secretId,
            rotationSchedule: rotationData.schedule,
            lastRotation: new Date(),
            nextRotation,
            autoRotation: rotationData.autoRotation,
            rotationHistory: [],
        };
        this.rotationSchedules.set(secretId, rotation);
        this.logger.log(`Secret rotation setup: ${secretId} - ${rotationData.schedule}`);
    }
    async rotateSecret(secretId, userId) {
        const secret = this.secrets.find(s => s.id === secretId);
        const rotation = this.rotationSchedules.get(secretId);
        if (!secret || !rotation) {
            throw new Error(`Secret or rotation schedule not found: ${secretId}`);
        }
        try {
            const newValue = await this.generateNewSecretValue(secret.type);
            const encryptedValue = await this.encryptValue(newValue);
            secret.value = encryptedValue;
            secret.updatedAt = new Date();
            rotation.lastRotation = new Date();
            rotation.nextRotation = this.calculateNextRotation(rotation.rotationSchedule);
            rotation.rotationHistory.push({
                timestamp: new Date(),
                rotatedBy: userId,
                success: true,
            });
            this.logger.log(`Secret rotated: ${secretId} by ${userId}`);
        }
        catch (error) {
            rotation.rotationHistory.push({
                timestamp: new Date(),
                rotatedBy: userId,
                success: false,
                details: error instanceof Error ? error.message : 'Unknown error',
            });
            throw error;
        }
    }
    calculateNextRotation(schedule) {
        const now = new Date();
        switch (schedule) {
            case 'daily':
                return new Date(now.getTime() + 24 * 60 * 60 * 1000);
            case 'weekly':
                return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
            case 'monthly':
                return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate());
            case 'quarterly':
                return new Date(now.getFullYear(), now.getMonth() + 3, now.getDate());
            case 'yearly':
                return new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
            default:
                return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        }
    }
    async generateNewSecretValue(type) {
        const randomBytes = Math.random().toString(36).substring(2, 15);
        const timestamp = Date.now().toString();
        switch (type) {
            case 'password':
                return `pwd_${randomBytes}_${timestamp}`;
            case 'api_key':
                return `api_${randomBytes}_${timestamp}`;
            case 'token':
                return `tok_${randomBytes}_${timestamp}`;
            case 'certificate':
                return `cert_${randomBytes}_${timestamp}`;
            case 'private_key':
                return `key_${randomBytes}_${timestamp}`;
            case 'database_url':
                return `db_${randomBytes}_${timestamp}`;
            default:
                return `secret_${randomBytes}_${timestamp}`;
        }
    }
    async logAccess(secretId, userId, userRole, action, success, ipAddress = '127.0.0.1', userAgent = 'SecretsService', details) {
        const access = {
            id: `access-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            secretId,
            userId,
            userRole,
            action,
            timestamp: new Date(),
            ipAddress,
            userAgent,
            success,
            details,
        };
        this.accessLog.push(access);
        this.logger.debug(`Secret access logged: ${action} on ${secretId} by ${userId} - ${success ? 'SUCCESS' : 'FAILED'}`);
    }
    async getAccessLogs(limit = 100) {
        return this.accessLog
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getAccessLogsBySecret(secretId, limit = 50) {
        return this.accessLog
            .filter(a => a.secretId === secretId)
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getAccessLogsByUser(userId, limit = 50) {
        return this.accessLog
            .filter(a => a.userId === userId)
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getSecretsStats() {
        const now = new Date();
        const activeSecrets = this.secrets.filter(s => s.expiresAt == null || s.expiresAt > now);
        const expiredSecrets = this.secrets.filter(s => s.expiresAt != null && s.expiresAt <= now);
        const encryptedSecrets = this.secrets.filter(s => s.encrypted === true);
        const secretsByType = this.secrets.reduce((acc, secret) => {
            acc[secret.type] = (acc[secret.type] ?? 0) + 1;
            return acc;
        }, {});
        const topAccessedSecrets = this.secrets
            .sort((a, b) => b.accessCount - a.accessCount)
            .slice(0, 10)
            .map(s => ({
            secretId: s.id,
            secretName: s.name,
            accessCount: s.accessCount,
        }));
        const recentAccesses = this.accessLog
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, 20);
        return {
            totalSecrets: this.secrets.length,
            activeSecrets: activeSecrets.length,
            expiredSecrets: expiredSecrets.length,
            encryptedSecrets: encryptedSecrets.length,
            secretsByType,
            topAccessedSecrets,
            recentAccesses,
            vaultStatus: this.config.enabled ? 'connected' : 'disconnected',
        };
    }
    async getVaultConfig() {
        return this.config;
    }
    async updateVaultConfig(updates) {
        Object.assign(this.config, updates);
        this.logger.log('Vault configuration updated');
        return this.config;
    }
    async getRotationSchedules() {
        return Array.from(this.rotationSchedules.values());
    }
    async getRotationSchedule(secretId) {
        return this.rotationSchedules.get(secretId) ?? null;
    }
    async healthCheck() {
        return {
            status: 'healthy',
            secrets: this.secrets.length,
            vault: this.config.enabled ? 'enabled' : 'disabled',
            rotations: this.rotationSchedules.size,
        };
    }
};
SecretsService = SecretsService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SecretsService);



/***/ }),
/* 219 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecurityAuditService: () => (/* binding */ SecurityAuditService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _nestjs_config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_config__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SecurityAuditService_1;
var _a, _b;



let SecurityAuditService = SecurityAuditService_1 = class SecurityAuditService {
    constructor(_configService, eventEmitter) {
        this._configService = _configService;
        this.eventEmitter = eventEmitter;
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(SecurityAuditService_1.name);
        this.securityEvents = new Map();
        this.securityViolations = new Map();
        this.auditRules = new Map();
        this.initializeAuditRules();
        this.startAuditMonitoring();
        this._configService.get('AUDIT_ENABLED');
    }
    initializeAuditRules() {
        const rules = [
            {
                id: 'failed_login_threshold',
                name: 'Failed Login Threshold',
                description: 'Alert on multiple failed login attempts',
                condition: {
                    type: 'authentication',
                    result: 'failure',
                    count: 5,
                    window: '15m',
                },
                action: 'create_violation',
                severity: 'high',
            },
            {
                id: 'unauthorized_access',
                name: 'Unauthorized Access',
                description: 'Alert on unauthorized access attempts',
                condition: { type: 'authorization', result: 'failure' },
                action: 'create_violation',
                severity: 'critical',
            },
            {
                id: 'privilege_escalation',
                name: 'Privilege Escalation',
                description: 'Alert on privilege escalation attempts',
                condition: { type: 'authorization', action: 'escalate' },
                action: 'create_violation',
                severity: 'critical',
            },
            {
                id: 'suspicious_ip',
                name: 'Suspicious IP',
                description: 'Alert on access from suspicious IP addresses',
                condition: { ipAddress: 'blacklist' },
                action: 'block_and_alert',
                severity: 'high',
            },
            {
                id: 'data_export_anomaly',
                name: 'Data Export Anomaly',
                description: 'Alert on unusual data export patterns',
                condition: { type: 'data_access', action: 'export', volume: 'high' },
                action: 'create_violation',
                severity: 'medium',
            },
        ];
        rules.forEach(rule => {
            this.auditRules.set(rule.id, rule);
        });
        this.logger.log(`Initialized ${rules.length} audit rules`);
    }
    startAuditMonitoring() {
        setInterval(() => {
            void this.processAuditEvents();
        }, 10000);
    }
    async logSecurityEvent(event) {
        const id = `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const securityEvent = {
            ...event,
            id,
            timestamp: new Date(),
        };
        this.securityEvents.set(id, securityEvent);
        this.eventEmitter.emit('security.event', securityEvent);
        this.logger.log(`Security event logged: ${event.type} - ${event.description}`);
        return securityEvent;
    }
    async logAuthenticationEvent(userId, result, details) {
        return this.logSecurityEvent({
            type: 'authentication',
            severity: result === 'failure' ? 'medium' : 'low',
            category: 'login',
            description: result === 'success'
                ? `Successful login for user ${details.email ?? userId}`
                : `Failed login attempt for ${details.email ?? userId}: ${details.reason ?? 'Invalid credentials'}`,
            userId,
            sessionId: details.sessionId ?? '',
            ipAddress: details.ipAddress ?? '',
            userAgent: details.userAgent ?? '',
            result,
            details: {
                email: details.email,
                reason: details.reason,
            },
            tags: ['authentication', result],
        });
    }
    async logAuthorizationEvent(userId, resource, action, result, details) {
        return this.logSecurityEvent({
            type: 'authorization',
            severity: result === 'failure' ? 'high' : 'low',
            category: 'access_control',
            description: result === 'success'
                ? `Authorized access to ${resource} for action ${action}`
                : `Unauthorized access attempt to ${resource} for action ${action}: ${details.reason ?? 'Insufficient permissions'}`,
            userId,
            sessionId: details.sessionId ?? '',
            ipAddress: details.ipAddress ?? '',
            userAgent: details.userAgent ?? '',
            resource,
            action,
            result,
            details: {
                reason: details.reason,
            },
            tags: ['authorization', result, resource, action],
        });
    }
    async logDataAccessEvent(userId, resource, action, details) {
        return this.logSecurityEvent({
            type: 'data_access',
            severity: 'low',
            category: 'data_operation',
            description: `Data access: ${action} on ${resource}`,
            userId,
            sessionId: details.sessionId ?? '',
            ipAddress: details.ipAddress ?? '',
            userAgent: details.userAgent ?? '',
            resource,
            action,
            result: 'success',
            details: {
                dataType: details.dataType,
                recordCount: details.recordCount,
            },
            tags: ['data_access', resource, action],
        });
    }
    async logConfigurationEvent(userId, configKey, action, details) {
        return this.logSecurityEvent({
            type: 'configuration',
            severity: 'medium',
            category: 'config_change',
            description: `Configuration change: ${action} on ${configKey}`,
            userId,
            sessionId: details.sessionId ?? '',
            ipAddress: details.ipAddress ?? '',
            userAgent: details.userAgent ?? '',
            resource: configKey,
            action,
            result: 'success',
            details: {
                oldValue: details.oldValue,
                newValue: details.newValue,
            },
            tags: ['configuration', configKey, action],
        });
    }
    async createSecurityViolation(eventId, type, severity, description, evidence, userId, ipAddress, resource, action) {
        const id = `violation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const violation = {
            id,
            eventId,
            type,
            severity,
            description,
            userId: userId ?? '',
            ipAddress: ipAddress ?? '',
            resource: resource ?? '',
            action: action ?? '',
            evidence,
            status: 'open',
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        this.securityViolations.set(id, violation);
        this.eventEmitter.emit('security.violation', violation);
        this.logger.warn(`Security violation created: ${type} - ${description}`);
        return violation;
    }
    async getSecurityEvents(filters) {
        let events = Array.from(this.securityEvents.values());
        if (filters) {
            if (filters.type != null) {
                events = events.filter(e => e.type === filters.type);
            }
            if (filters.severity != null) {
                events = events.filter(e => e.severity === filters.severity);
            }
            if (filters.userId != null) {
                events = events.filter(e => e.userId === filters.userId);
            }
            if (filters.from != null) {
                events = events.filter(e => e.timestamp >= (filters.from ?? 0));
            }
            if (filters.to != null) {
                events = events.filter(e => e.timestamp <= (filters.to ?? Date.now()));
            }
        }
        events = events.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            events = events.slice(0, filters.limit);
        }
        return events;
    }
    async getSecurityViolations(filters) {
        let violations = Array.from(this.securityViolations.values());
        if (filters) {
            if (filters.type != null) {
                violations = violations.filter(v => v.type === filters.type);
            }
            if (filters.severity != null) {
                violations = violations.filter(v => v.severity === filters.severity);
            }
            if (filters.status != null) {
                violations = violations.filter(v => v.status === filters.status);
            }
            if (filters.userId != null) {
                violations = violations.filter(v => v.userId === filters.userId);
            }
            if (filters.from != null) {
                violations = violations.filter(v => v.createdAt >= (filters.from ?? new Date(0)));
            }
            if (filters.to != null) {
                violations = violations.filter(v => v.createdAt <= (filters.to ?? new Date()));
            }
        }
        violations = violations.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        if (filters?.limit != null && filters.limit > 0) {
            violations = violations.slice(0, filters.limit);
        }
        return violations;
    }
    async updateViolationStatus(violationId, status, updatedBy, notes) {
        const violation = this.securityViolations.get(violationId);
        if (!violation) {
            return null;
        }
        violation.status = status;
        violation.updatedAt = new Date();
        if (status === 'resolved') {
            violation.resolvedAt = new Date();
            violation.resolvedBy = updatedBy;
        }
        if (notes != null && notes !== '') {
            violation.evidence.notes = notes;
        }
        this.logger.log(`Violation ${violationId} status updated to ${status} by ${updatedBy}`);
        return violation;
    }
    async generateSecurityReport(type, period, generatedBy) {
        const events = await this.getSecurityEvents({
            from: period.from,
            to: period.to,
        });
        const violations = await this.getSecurityViolations({
            from: period.from,
            to: period.to,
        });
        const summary = {
            totalEvents: events.length,
            totalViolations: violations.length,
            criticalViolations: violations.filter(v => v.severity === 'critical')
                .length,
            resolvedViolations: violations.filter(v => v.status === 'resolved')
                .length,
            openViolations: violations.filter(v => v.status === 'open').length,
        };
        const recommendations = this.generateRecommendations(events, violations);
        const report = {
            id: `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            type,
            period,
            summary,
            events,
            violations,
            recommendations,
            generatedAt: new Date(),
            generatedBy,
        };
        this.logger.log(`Security report generated: ${type} for period ${period.from.toISOString()} - ${period.to.toISOString()}`);
        return report;
    }
    async getSecurityMetrics(timeRange) {
        const events = await this.getSecurityEvents({
            from: timeRange.from,
            to: timeRange.to,
        });
        const violations = await this.getSecurityViolations({
            from: timeRange.from,
            to: timeRange.to,
        });
        const eventsByType = events.reduce((acc, event) => {
            acc[event.type] = (acc[event.type] ?? 0) + 1;
            return acc;
        }, {});
        const eventsBySeverity = events.reduce((acc, event) => {
            acc[event.severity] = (acc[event.severity] ?? 0) + 1;
            return acc;
        }, {});
        const eventsByResult = events.reduce((acc, event) => {
            acc[event.result] = (acc[event.result] ?? 0) + 1;
            return acc;
        }, {});
        const violationsByType = violations.reduce((acc, violation) => {
            acc[violation.type] = (acc[violation.type] ?? 0) + 1;
            return acc;
        }, {});
        const violationsByStatus = violations.reduce((acc, violation) => {
            acc[violation.status] = (acc[violation.status] ?? 0) + 1;
            return acc;
        }, {});
        const userStats = events.reduce((acc, event) => {
            if (event.userId != null) {
                acc[event.userId] ??= { eventCount: 0, violationCount: 0 };
                const userStat = acc[event.userId];
                if (userStat)
                    userStat.eventCount++;
            }
            return acc;
        }, {});
        violations.forEach(violation => {
            if (violation.userId != null) {
                userStats[violation.userId] ??= { eventCount: 0, violationCount: 0 };
                const userStat = userStats[violation.userId];
                if (userStat)
                    userStat.violationCount++;
            }
        });
        const topUsers = Object.entries(userStats)
            .map(([userId, stats]) => ({ userId, ...stats }))
            .sort((a, b) => b.eventCount - a.eventCount)
            .slice(0, 10);
        const resourceStats = events.reduce((acc, event) => {
            if (event.resource != null && event.resource !== '') {
                acc[event.resource] ??= { accessCount: 0, violationCount: 0 };
                const resourceStat = acc[event.resource];
                if (resourceStat)
                    resourceStat.accessCount++;
            }
            return acc;
        }, {});
        violations.forEach(violation => {
            if (violation.resource != null && violation.resource !== '') {
                resourceStats[violation.resource] ??= {
                    accessCount: 0,
                    violationCount: 0,
                };
                const resourceStat = resourceStats[violation.resource];
                if (resourceStat)
                    resourceStat.violationCount++;
            }
        });
        const topResources = Object.entries(resourceStats)
            .map(([resource, stats]) => ({ _resource: resource, ...stats }))
            .sort((a, b) => b.accessCount - a.accessCount)
            .slice(0, 10);
        const ipStats = events.reduce((acc, event) => {
            if (event.ipAddress != null && event.ipAddress !== '') {
                acc[event.ipAddress] ??= { eventCount: 0, violationCount: 0 };
                const ipStat = acc[event.ipAddress];
                if (ipStat)
                    ipStat.eventCount++;
            }
            return acc;
        }, {});
        violations.forEach(violation => {
            if (violation.ipAddress != null && violation.ipAddress !== '') {
                ipStats[violation.ipAddress] ??= { eventCount: 0, violationCount: 0 };
                const ipStat = ipStats[violation.ipAddress];
                if (ipStat)
                    ipStat.violationCount++;
            }
        });
        const topIPs = Object.entries(ipStats)
            .map(([ipAddress, stats]) => ({ ipAddress, ...stats }))
            .sort((a, b) => b.eventCount - a.eventCount)
            .slice(0, 10);
        return {
            totalEvents: events.length,
            eventsByType,
            eventsBySeverity,
            eventsByResult,
            totalViolations: violations.length,
            violationsByType,
            violationsByStatus,
            topUsers,
            topResources,
            topIPs,
            timeRange,
        };
    }
    async processAuditEvents() {
        const recentEvents = Array.from(this.securityEvents.values())
            .filter(event => event.timestamp > new Date(Date.now() - 300000))
            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
        for (const rule of this.auditRules.values()) {
            await this.evaluateRule(rule, recentEvents);
        }
    }
    async evaluateRule(rule, events) {
        if (rule.id === 'failed_login_threshold') {
            const failedLogins = events.filter(e => e.type === 'authentication' &&
                e.result === 'failure' &&
                e.timestamp > new Date(Date.now() - 15 * 60 * 1000));
            if (failedLogins.length >= 5) {
                const userId = failedLogins[0]?.userId;
                if (userId != null &&
                    userId !== '' &&
                    !this.hasRecentViolation(userId, 'failed_login_threshold')) {
                    await this.createSecurityViolation(failedLogins[0]?.id ?? '', 'suspicious_activity', 'high', `Multiple failed login attempts detected for user ${userId}`, { failedAttempts: failedLogins.length, timeWindow: '15m' }, userId, failedLogins[0]?.ipAddress ?? '');
                }
            }
        }
        if (rule.id === 'unauthorized_access') {
            const unauthorizedAccess = events.filter(e => e.type === 'authorization' && e.result === 'failure');
            for (const event of unauthorizedAccess) {
                if (!this.hasRecentViolation(event.userId ?? 'unknown', 'unauthorized_access')) {
                    await this.createSecurityViolation(event.id, 'unauthorized_access', 'critical', `Unauthorized access attempt detected`, { resource: event.resource, action: event.action }, event.userId, event.ipAddress, event.resource, event.action);
                }
            }
        }
    }
    hasRecentViolation(userId, type) {
        const recentViolations = Array.from(this.securityViolations.values()).filter(v => v.userId === userId &&
            v.type === type &&
            v.createdAt > new Date(Date.now() - 60 * 60 * 1000));
        return recentViolations.length > 0;
    }
    generateRecommendations(events, violations) {
        const recommendations = [];
        const failedLogins = events.filter(e => e.type === 'authentication' && e.result === 'failure');
        if (failedLogins.length > 10) {
            recommendations.push('Consider implementing account lockout after multiple failed login attempts');
        }
        const unauthorizedAccess = violations.filter(v => v.type === 'unauthorized_access');
        if (unauthorizedAccess.length > 5) {
            recommendations.push('Review and strengthen access control policies');
        }
        const criticalViolations = violations.filter(v => v.severity === 'critical');
        if (criticalViolations.length > 0) {
            recommendations.push('Immediate attention required for critical security violations');
        }
        const openViolations = violations.filter(v => v.status === 'open');
        if (openViolations.length > 10) {
            recommendations.push('Address open security violations to reduce risk exposure');
        }
        return recommendations;
    }
};
SecurityAuditService = SecurityAuditService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService !== "undefined" && _nestjs_config__WEBPACK_IMPORTED_MODULE_1__.ConfigService) === "function" ? _a : Object, typeof (_b = typeof _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2 !== "undefined" && _nestjs_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter2) === "function" ? _b : Object])
], SecurityAuditService);



/***/ }),
/* 220 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecurityIntegrationService: () => (/* binding */ SecurityIntegrationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(211);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SecurityIntegrationService_1;



const SecurityIntegrationConfigSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    autoResponse: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    threatIntelligence: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().default(true),
    complianceMode: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['strict', 'moderate', 'relaxed']).default('moderate'),
    integrationTimeout: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(1000).max(30000).default(5000),
});
const SecurityEventSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string().uuid(),
    timestamp: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    source: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'waf',
        'secrets',
        'certificates',
        'vulnerability',
        'incident',
    ]),
    severity: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['low', 'medium', 'high', 'critical']),
    eventType: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    metadata: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.unknown()).optional(),
});
const SecurityMetricsSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    totalEvents: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    eventsBySeverity: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.number()),
    eventsBySource: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.number()),
    responseTime: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    uptime: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    lastIncident: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
});
let SecurityIntegrationService = SecurityIntegrationService_1 = class SecurityIntegrationService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(SecurityIntegrationService_1.name);
        this.events = [];
        const configData = {
            enabled: true,
            autoResponse: true,
            threatIntelligence: true,
            complianceMode: 'moderate',
            integrationTimeout: 5000,
        };
        this.config = SecurityIntegrationConfigSchema.parse(configData);
        this.stats = {
            totalEvents: 0,
            activeIncidents: 0,
            vulnerabilitiesFound: 0,
            certificatesExpiring: 0,
            secretsRotated: 0,
            wafBlocks: 0,
            lastUpdate: new Date(),
        };
        this.logger.log('Security Integration Service initialized');
    }
    getConfig() {
        return { ...this.config };
    }
    updateConfig(updates) {
        const newConfig = { ...this.config, ...updates };
        this.config = SecurityIntegrationConfigSchema.parse(newConfig);
        this.logger.log(`Security integration config updated: ${JSON.stringify(updates)}`);
        return this.getConfig();
    }
    registerEvent(event) {
        const newEvent = {
            ...event,
            id: crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID(),
            timestamp: new Date(),
        };
        const validatedEvent = SecurityEventSchema.parse(newEvent);
        this.events.push(validatedEvent);
        this.stats.totalEvents++;
        this.stats.lastUpdate = new Date();
        this.logger.log(`Security event registered: ${event.eventType} (${event.severity})`);
        if (this.config.autoResponse && event.severity === 'critical') {
            this.handleCriticalEvent(validatedEvent);
        }
        return validatedEvent;
    }
    getEvents(filters) {
        let filteredEvents = [...this.events];
        if (filters?.severity) {
            filteredEvents = filteredEvents.filter(e => e.severity === filters.severity);
        }
        if (filters?.source) {
            filteredEvents = filteredEvents.filter(e => e.source === filters.source);
        }
        if (filters?.limit != null && filters.limit > 0) {
            filteredEvents = filteredEvents.slice(-filters.limit);
        }
        return filteredEvents.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    }
    getMetrics() {
        const eventsBySeverity = this.events.reduce((acc, event) => {
            acc[event.severity] = (acc[event.severity] ?? 0) + 1;
            return acc;
        }, {});
        const eventsBySource = this.events.reduce((acc, event) => {
            acc[event.source] = (acc[event.source] ?? 0) + 1;
            return acc;
        }, {});
        const lastIncident = this.events
            .filter(e => e.source === 'incident')
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0]?.timestamp;
        return SecurityMetricsSchema.parse({
            totalEvents: this.stats.totalEvents,
            eventsBySeverity,
            eventsBySource,
            responseTime: this.config.integrationTimeout,
            uptime: Date.now() - this.stats.lastUpdate.getTime(),
            lastIncident,
        });
    }
    getStats() {
        return { ...this.stats };
    }
    updateStats(updates) {
        this.stats = { ...this.stats, ...updates, lastUpdate: new Date() };
    }
    healthCheck() {
        const now = new Date();
        const timeSinceLastUpdate = now.getTime() - this.stats.lastUpdate.getTime();
        if (timeSinceLastUpdate > 300000) {
            return {
                status: 'unhealthy',
                details: 'No recent security events detected',
            };
        }
        if (this.stats.activeIncidents > 10) {
            return {
                status: 'degraded',
                details: `High number of active incidents: ${this.stats.activeIncidents}`,
            };
        }
        return {
            status: 'healthy',
            details: 'Security integration operating normally',
        };
    }
    handleCriticalEvent(event) {
        this.logger.warn(`Handling critical security event: ${event.eventType}`);
        switch (event.source) {
            case 'waf':
                this.logger.warn('Automatically blocking suspicious IP addresses');
                break;
            case 'secrets':
                this.logger.warn('Automatically rotating compromised secrets');
                break;
            case 'certificates':
                this.logger.warn('Automatically renewing expiring certificates');
                break;
            case 'vulnerability':
                this.logger.warn('Automatically patching critical vulnerabilities');
                break;
            case 'incident':
                this.logger.warn('Automatically escalating security incident');
                break;
        }
    }
    cleanupOldEvents(maxAge = 30 * 24 * 60 * 60 * 1000) {
        const cutoff = new Date(Date.now() - maxAge);
        const initialCount = this.events.length;
        this.events = this.events.filter(event => event.timestamp > cutoff);
        const removedCount = initialCount - this.events.length;
        this.logger.log(`Cleaned up ${removedCount} old security events`);
        return removedCount;
    }
};
SecurityIntegrationService = SecurityIntegrationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SecurityIntegrationService);



/***/ }),
/* 221 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecurityController: () => (/* binding */ SecurityController)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _types_roles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _certificate_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(209);
/* harmony import */ var _compliance_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(210);
/* harmony import */ var _incident_response_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(215);
/* harmony import */ var _jwt_security_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(216);
/* harmony import */ var _secrets_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(218);
/* harmony import */ var _security_integration_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(220);
/* harmony import */ var _vulnerability_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(222);
/* harmony import */ var _waf_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(223);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;













let SecurityController = class SecurityController {
    constructor(wafService, secretsService, certificateService, vulnerabilityService, incidentResponseService, securityIntegrationService, jwtSecurityService, complianceService) {
        this.wafService = wafService;
        this.secretsService = secretsService;
        this.certificateService = certificateService;
        this.vulnerabilityService = vulnerabilityService;
        this.incidentResponseService = incidentResponseService;
        this.securityIntegrationService = securityIntegrationService;
        this.jwtSecurityService = jwtSecurityService;
        this.complianceService = complianceService;
    }
    async getWafHealth() {
        return this.wafService.healthCheck();
    }
    async getWafConfig() {
        return this.wafService.getWafConfig();
    }
    async updateWafConfig(config) {
        return this.wafService.updateWafConfig(config);
    }
    async getAllWafRules() {
        return this.wafService.getAllRules();
    }
    async createWafRule(ruleData) {
        return this.wafService.createRule(ruleData);
    }
    async getWafStats() {
        return this.wafService.getWafStats();
    }
    async getWafEvents(limit = 100) {
        return this.wafService.getEvents(limit);
    }
    async getSecretsHealth() {
        return this.secretsService.healthCheck();
    }
    async getAllSecrets() {
        return this.secretsService.getAllSecrets('system', 'super_admin');
    }
    async createSecret(secretData) {
        return this.secretsService.createSecret(secretData);
    }
    async getSecretById(id) {
        return this.secretsService.getSecretById(id, 'system', 'super_admin');
    }
    async updateSecret(id, updates) {
        return this.secretsService.updateSecret(id, updates, 'system', 'super_admin');
    }
    async deleteSecret(id) {
        return this.secretsService.deleteSecret(id, 'system', 'super_admin');
    }
    async getSecretsStats() {
        return this.secretsService.getSecretsStats();
    }
    async rotateSecret(id) {
        return this.secretsService.rotateSecret(id, 'system');
    }
    async getCertificateHealth() {
        return this.certificateService.healthCheck();
    }
    async getAllCertificates() {
        return this.certificateService.getAllCertificates();
    }
    async createCertificate(certData) {
        return this.certificateService.createCertificate(certData);
    }
    async getCertificateById(id) {
        return this.certificateService.getCertificateById(id);
    }
    async updateCertificate(id, updates) {
        return this.certificateService.updateCertificate(id, updates);
    }
    async renewCertificate(id) {
        return this.certificateService.renewCertificate(id);
    }
    async revokeCertificate(id, data) {
        return this.certificateService.revokeCertificate(id, data.reason);
    }
    async getCertificateStats() {
        return this.certificateService.getCertificateStats();
    }
    async getExpiringCertificates(days = 30) {
        return this.certificateService.getExpiringCertificates(days);
    }
    async getVulnerabilityHealth() {
        return this.vulnerabilityService.healthCheck();
    }
    async getAllVulnerabilities() {
        return this.vulnerabilityService.getAllVulnerabilities();
    }
    async getOpenVulnerabilities() {
        return this.vulnerabilityService.getOpenVulnerabilities();
    }
    async createVulnerability(vulnData) {
        return this.vulnerabilityService.createVulnerability(vulnData);
    }
    async getVulnerabilityById(id) {
        return this.vulnerabilityService.getVulnerabilityById(id);
    }
    async updateVulnerability(id, updates) {
        return this.vulnerabilityService.updateVulnerability(id, updates);
    }
    async markVulnerabilityAsFixed(id, data) {
        return this.vulnerabilityService.markVulnerabilityAsFixed(id, data.fixedVersion, data.assignedTo);
    }
    async getVulnerabilityStats() {
        return this.vulnerabilityService.getVulnerabilityStats();
    }
    async startSecurityScan(scanData) {
        return this.vulnerabilityService.startSecurityScan(scanData);
    }
    async getAllScans() {
        return this.vulnerabilityService.getAllScans();
    }
    async getScanById(id) {
        return this.vulnerabilityService.getScanById(id);
    }
    async cancelScan(id) {
        return this.vulnerabilityService.cancelScan(id);
    }
    async getIncidentHealth() {
        return this.incidentResponseService.healthCheck();
    }
    async getAllIncidents() {
        return this.incidentResponseService.getAllIncidents();
    }
    async getOpenIncidents() {
        return this.incidentResponseService.getOpenIncidents();
    }
    async createIncident(incidentData) {
        return this.incidentResponseService.createIncident(incidentData);
    }
    async getIncidentById(id) {
        return this.incidentResponseService.getIncidentById(id);
    }
    async updateIncident(id, updates) {
        return this.incidentResponseService.updateIncident(id, updates);
    }
    async assignIncident(id, data) {
        return this.incidentResponseService.assignIncident(id, data.assignedTo);
    }
    async updateIncidentStatus(id, data) {
        return this.incidentResponseService.updateIncidentStatus(id, data.status, data.actor, data.details);
    }
    async addResponse(id, data) {
        return this.incidentResponseService.addResponse(id, data);
    }
    async getResponsesForIncident(id) {
        return this.incidentResponseService.getResponsesForIncident(id);
    }
    async getIncidentStats() {
        return this.incidentResponseService.getIncidentStats();
    }
    async getIncidentMetrics() {
        return this.incidentResponseService.getIncidentMetrics();
    }
    async getIntegrationHealth() {
        return this.securityIntegrationService.healthCheck();
    }
    async getIntegrationConfig() {
        return this.securityIntegrationService.getConfig();
    }
    async updateIntegrationConfig(config) {
        return this.securityIntegrationService.updateConfig(config);
    }
    async getIntegrationEvents(severity, source, limit) {
        const params = {};
        if (severity != null && severity !== '')
            params.severity = severity;
        if (source != null && source !== '')
            params.source = source;
        if (limit != null && limit > 0)
            params.limit = limit;
        return this.securityIntegrationService.getEvents(params);
    }
    async getIntegrationMetrics() {
        return this.securityIntegrationService.getMetrics();
    }
    async getIntegrationStats() {
        return this.securityIntegrationService.getStats();
    }
    async getJwtHealth() {
        return this.jwtSecurityService.healthCheck();
    }
    async getJwtConfig() {
        return this.jwtSecurityService.getConfig();
    }
    async updateJwtConfig(config) {
        return this.jwtSecurityService.updateConfig(config);
    }
    async createJwtToken(tokenData) {
        return this.jwtSecurityService.createToken(tokenData.userId, tokenData.tokenType, tokenData.deviceInfo);
    }
    async refreshJwtToken(data) {
        return this.jwtSecurityService.refreshToken(data.refreshTokenId, data.userId);
    }
    async revokeJwtToken(id, data) {
        return this.jwtSecurityService.revokeToken(id, data.reason);
    }
    async validateJwtToken(data) {
        return {
            valid: this.jwtSecurityService.validateToken(data.tokenId, data.userId),
        };
    }
    async checkRateLimit(data) {
        return this.jwtSecurityService.checkRateLimit(data.identifier);
    }
    async getJwtStats() {
        return this.jwtSecurityService.getStats();
    }
    async getJwtEvents(eventType, severity, userId, limit) {
        const params = {};
        if (eventType != null && eventType !== '')
            params.eventType = eventType;
        if (severity != null && severity !== '')
            params.severity = severity;
        if (userId != null && userId !== '')
            params.userId = userId;
        if (limit != null && limit > 0)
            params.limit = limit;
        return this.jwtSecurityService.getEvents(params);
    }
    async getComplianceHealth() {
        return this.complianceService.healthCheck();
    }
    async getComplianceConfig() {
        return this.complianceService.getConfig();
    }
    async updateComplianceConfig(config) {
        return this.complianceService.updateConfig(config);
    }
    async getComplianceRequirements(standard, status) {
        const params = {};
        if (standard != null && standard !== '')
            params.standard = standard;
        if (status != null && status !== '')
            params.status = status;
        return this.complianceService.getRequirements(params);
    }
    async addComplianceRequirement(requirementData) {
        return this.complianceService.addRequirement(requirementData);
    }
    async updateRequirementStatus(id, data) {
        return this.complianceService.updateRequirementStatus(id, data.status, data.evidence);
    }
    async getComplianceAudits(compliance, dataType, accessType, userId, limit) {
        const params = {};
        if (compliance !== undefined)
            params.compliance = compliance;
        if (dataType != null && dataType !== '')
            params.dataType = dataType;
        if (accessType != null && accessType !== '')
            params.accessType = accessType;
        if (userId != null && userId !== '')
            params.userId = userId;
        if (limit != null && limit > 0)
            params.limit = limit;
        return this.complianceService.getAudits(params);
    }
    async logComplianceAudit(auditData) {
        return this.complianceService.logAudit(auditData);
    }
    async getDataSubjects() {
        return this.complianceService.getDataSubjects();
    }
    async addDataSubject(subjectData) {
        const { ...dataWithoutDates } = subjectData;
        return this.complianceService.addDataSubject(dataWithoutDates);
    }
    async updateDataSubjectConsent(id, data) {
        return this.complianceService.updateDataSubjectConsent(id, data.consentGiven);
    }
    async deleteDataSubject(id) {
        return this.complianceService.deleteDataSubject(id);
    }
    async getComplianceStats() {
        return this.complianceService.getStats();
    }
    async generateComplianceReport() {
        return this.complianceService.generateComplianceReport();
    }
    async getSecurityDashboard() {
        const [wafHealth, wafStats, secretsHealth, secretsStats, certificateHealth, certificateStats, vulnerabilityHealth, vulnerabilityStats, incidentHealth, incidentStats, integrationHealth, integrationStats, jwtHealth, jwtStats, complianceHealth, complianceStats,] = await Promise.all([
            this.wafService.healthCheck(),
            this.wafService.getWafStats(),
            this.secretsService.healthCheck(),
            this.secretsService.getSecretsStats(),
            this.certificateService.healthCheck(),
            this.certificateService.getCertificateStats(),
            this.vulnerabilityService.healthCheck(),
            this.vulnerabilityService.getVulnerabilityStats(),
            this.incidentResponseService.healthCheck(),
            this.incidentResponseService.getIncidentStats(),
            this.securityIntegrationService.healthCheck(),
            this.securityIntegrationService.getStats(),
            this.jwtSecurityService.healthCheck(),
            this.jwtSecurityService.getStats(),
            this.complianceService.healthCheck(),
            this.complianceService.getStats(),
        ]);
        return {
            timestamp: new Date(),
            overallStatus: 'healthy',
            services: {
                waf: wafHealth,
                secrets: secretsHealth,
                certificates: certificateHealth,
                vulnerabilities: vulnerabilityHealth,
                incidents: incidentHealth,
                integration: integrationHealth,
                jwt: jwtHealth,
                compliance: complianceHealth,
            },
            statistics: {
                waf: wafStats,
                secrets: secretsStats,
                certificates: certificateStats,
                vulnerabilities: vulnerabilityStats,
                incidents: incidentStats,
                integration: integrationStats,
                jwt: jwtStats,
                compliance: complianceStats,
            },
            summary: {
                totalBlockedRequests: wafStats.blockedRequests,
                totalSecrets: secretsStats.totalSecrets,
                activeCertificates: certificateStats.activeCertificates,
                openVulnerabilities: vulnerabilityStats.openVulnerabilities,
                openIncidents: incidentStats.openIncidents,
                totalSecurityEvents: integrationStats.totalEvents,
                activeTokens: jwtStats.activeTokens,
                complianceRate: complianceStats.compliantRequirements /
                    complianceStats.totalRequirements,
            },
        };
    }
};
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('waf/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'WAF Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'WAF health status' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getWafHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('waf/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get WAF Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'WAF configuration' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getWafConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('waf/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update WAF Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'WAF configuration updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_j = typeof Record !== "undefined" && Record) === "function" ? _j : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateWafConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('waf/rules'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All WAF Rules' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of WAF rules' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllWafRules", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('waf/rules'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create WAF Rule' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'WAF rule created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_k = typeof Record !== "undefined" && Record) === "function" ? _k : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createWafRule", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('waf/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get WAF Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'WAF statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getWafStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('waf/events'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get WAF Events' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'WAF events' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getWafEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Secrets Service Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secrets service health status' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getSecretsHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All Secrets' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'List of secrets (values redacted)',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllSecrets", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('secrets'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create Secret' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Secret created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_l = typeof Record !== "undefined" && Record) === "function" ? _l : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Secret by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Secret ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret details' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getSecretById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('secrets/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Secret' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Secret ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_m = typeof Record !== "undefined" && Record) === "function" ? _m : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('secrets/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete Secret' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Secret ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret deleted' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "deleteSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('secrets/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Secrets Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secrets statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getSecretsStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('secrets/:id/rotate'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Rotate Secret' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Secret ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Secret rotated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "rotateSecret", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('certificates/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Certificate Service Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Certificate service health status',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getCertificateHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('certificates'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All Certificates' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of certificates' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllCertificates", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('certificates'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create Certificate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Certificate created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createCertificate", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('certificates/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Certificate by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Certificate ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate details' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getCertificateById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('certificates/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Certificate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Certificate ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_o = typeof Record !== "undefined" && Record) === "function" ? _o : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateCertificate", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('certificates/:id/renew'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Renew Certificate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Certificate ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate renewed' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "renewCertificate", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('certificates/:id/revoke'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Revoke Certificate' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Certificate ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate revoked' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "revokeCertificate", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('certificates/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Certificate Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Certificate statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getCertificateStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('certificates/expiring'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Expiring Certificates' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'days', required: false, type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Expiring certificates' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('days')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getExpiringCertificates", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vulnerabilities/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Vulnerability Service Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Vulnerability service health status',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getVulnerabilityHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vulnerabilities'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All Vulnerabilities' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of vulnerabilities' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllVulnerabilities", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vulnerabilities/open'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Open Vulnerabilities' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of open vulnerabilities' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getOpenVulnerabilities", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('vulnerabilities'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create Vulnerability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Vulnerability created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_p = typeof Record !== "undefined" && Record) === "function" ? _p : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createVulnerability", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vulnerabilities/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Vulnerability by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Vulnerability ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Vulnerability details' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getVulnerabilityById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('vulnerabilities/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Vulnerability' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Vulnerability ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Vulnerability updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_q = typeof Record !== "undefined" && Record) === "function" ? _q : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateVulnerability", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('vulnerabilities/:id/fix'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Mark Vulnerability as Fixed' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Vulnerability ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Vulnerability marked as fixed' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "markVulnerabilityAsFixed", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('vulnerabilities/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Vulnerability Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Vulnerability statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getVulnerabilityStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('scans'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Start Security Scan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Security scan started' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "startSecurityScan", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scans'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All Security Scans' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of security scans' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllScans", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('scans/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Security Scan by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Scan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security scan details' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getScanById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('scans/:id/cancel'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Cancel Security Scan' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Scan ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security scan cancelled' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "cancelScan", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Incident Response Service Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Incident response service health status',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIncidentHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get All Incidents' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of security incidents' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getAllIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/open'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Open Incidents' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'List of open incidents' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getOpenIncidents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create Security Incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Security incident created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_r = typeof Record !== "undefined" && Record) === "function" ? _r : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Incident by ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident details' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIncidentById", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('incidents/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_s = typeof Record !== "undefined" && Record) === "function" ? _s : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents/:id/assign'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Assign Incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident assigned' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "assignIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents/:id/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Incident Status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident status updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateIncidentStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('incidents/:id/responses'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add Response to Incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Response added to incident' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "addResponse", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/:id/responses'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Responses for Incident' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Incident ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident responses' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getResponsesForIncident", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Incident Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIncidentStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('incidents/metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Incident Metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Incident metrics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIncidentMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('integration/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Security Integration Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Security integration health status',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIntegrationHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('integration/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Security Integration Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Security integration configuration',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIntegrationConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('integration/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Security Integration Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'Security integration configuration updated',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_t = typeof Record !== "undefined" && Record) === "function" ? _t : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateIntegrationConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('integration/events'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Security Integration Events' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'severity', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'source', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security integration events' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('severity')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('source')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIntegrationEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('integration/metrics'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Security Integration Metrics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security integration metrics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIntegrationMetrics", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('integration/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Security Integration Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security integration statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getIntegrationStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jwt/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'JWT Security Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT security health status' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getJwtHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jwt/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get JWT Security Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT security configuration' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getJwtConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('jwt/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update JWT Security Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({
        status: 200,
        description: 'JWT security configuration updated',
    }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_u = typeof Record !== "undefined" && Record) === "function" ? _u : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateJwtConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jwt/tokens'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Create JWT Token' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'JWT token created' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "createJwtToken", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jwt/tokens/refresh'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Refresh JWT Token' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT token refreshed' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "refreshJwtToken", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jwt/tokens/:id/revoke'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Revoke JWT Token' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Token ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT token revoked' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "revokeJwtToken", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jwt/tokens/validate'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Validate JWT Token' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT token validation result' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "validateJwtToken", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('jwt/rate-limit/check'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Check Rate Limit' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Rate limit check result' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "checkRateLimit", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jwt/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get JWT Security Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT security statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getJwtStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('jwt/events'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get JWT Security Events' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'eventType', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'severity', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'userId', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'JWT security events' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('eventType')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('severity')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('userId')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, Number]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getJwtEvents", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/health'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Compliance Service Health Check' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance service health status' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getComplianceHealth", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Compliance Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance configuration' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getComplianceConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('compliance/config'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Compliance Configuration' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance configuration updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_v = typeof Record !== "undefined" && Record) === "function" ? _v : Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateComplianceConfig", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/requirements'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Compliance Requirements' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'standard', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'status', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance requirements' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('standard')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getComplianceRequirements", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('compliance/requirements'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add Compliance Requirement' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Compliance requirement added' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "addComplianceRequirement", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('compliance/requirements/:id/status'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Requirement Status' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Requirement ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Requirement status updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateRequirementStatus", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/audits'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Compliance Audits' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'compliance', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'dataType', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'accessType', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'userId', required: false }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance audits' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('compliance')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('dataType')),
    __param(2, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('accessType')),
    __param(3, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('userId')),
    __param(4, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean, String, String, String, Number]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getComplianceAudits", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('compliance/audits'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Log Compliance Audit' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Compliance audit logged' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "logComplianceAudit", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/data-subjects'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Data Subjects' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Data subjects (GDPR)' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getDataSubjects", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Post)('compliance/data-subjects'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Add Data Subject' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 201, description: 'Data subject added' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "addDataSubject", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Put)('compliance/data-subjects/:id/consent'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Update Data Subject Consent' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data Subject ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Data subject consent updated' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __param(1, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "updateDataSubjectConsent", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Delete)('compliance/data-subjects/:id'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Delete Data Subject (Right to be Forgotten)' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiParam)({ name: 'id', description: 'Data Subject ID' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Data subject deleted' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __param(0, (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "deleteDataSubject", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/stats'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Get Compliance Statistics' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance statistics' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getComplianceStats", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('compliance/report'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Generate Compliance Report' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Compliance report' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "generateComplianceReport", null);
__decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Get)('dashboard'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiOperation)({ summary: 'Security Dashboard' }),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiResponse)({ status: 200, description: 'Security dashboard data' }),
    (0,_auth_decorators_roles_decorator__WEBPACK_IMPORTED_MODULE_2__.Roles)(_types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.SUPER_ADMIN, _types_roles__WEBPACK_IMPORTED_MODULE_4__.UserRole.NETWORK_MANAGER),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecurityController.prototype, "getSecurityDashboard", null);
SecurityController = __decorate([
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiTags)('Security'),
    (0,_nestjs_swagger__WEBPACK_IMPORTED_MODULE_1__.ApiBearerAuth)(),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Controller)('api/v1/security'),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.UseGuards)(_auth_guards_roles_guard__WEBPACK_IMPORTED_MODULE_3__.RolesGuard),
    __metadata("design:paramtypes", [typeof (_a = typeof _waf_service__WEBPACK_IMPORTED_MODULE_12__.WafService !== "undefined" && _waf_service__WEBPACK_IMPORTED_MODULE_12__.WafService) === "function" ? _a : Object, typeof (_b = typeof _secrets_service__WEBPACK_IMPORTED_MODULE_9__.SecretsService !== "undefined" && _secrets_service__WEBPACK_IMPORTED_MODULE_9__.SecretsService) === "function" ? _b : Object, typeof (_c = typeof _certificate_service__WEBPACK_IMPORTED_MODULE_5__.CertificateService !== "undefined" && _certificate_service__WEBPACK_IMPORTED_MODULE_5__.CertificateService) === "function" ? _c : Object, typeof (_d = typeof _vulnerability_service__WEBPACK_IMPORTED_MODULE_11__.VulnerabilityService !== "undefined" && _vulnerability_service__WEBPACK_IMPORTED_MODULE_11__.VulnerabilityService) === "function" ? _d : Object, typeof (_e = typeof _incident_response_service__WEBPACK_IMPORTED_MODULE_7__.IncidentResponseService !== "undefined" && _incident_response_service__WEBPACK_IMPORTED_MODULE_7__.IncidentResponseService) === "function" ? _e : Object, typeof (_f = typeof _security_integration_service__WEBPACK_IMPORTED_MODULE_10__.SecurityIntegrationService !== "undefined" && _security_integration_service__WEBPACK_IMPORTED_MODULE_10__.SecurityIntegrationService) === "function" ? _f : Object, typeof (_g = typeof _jwt_security_service__WEBPACK_IMPORTED_MODULE_8__.JwtSecurityService !== "undefined" && _jwt_security_service__WEBPACK_IMPORTED_MODULE_8__.JwtSecurityService) === "function" ? _g : Object, typeof (_h = typeof _compliance_service__WEBPACK_IMPORTED_MODULE_6__.ComplianceService !== "undefined" && _compliance_service__WEBPACK_IMPORTED_MODULE_6__.ComplianceService) === "function" ? _h : Object])
], SecurityController);



/***/ }),
/* 222 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VulnerabilityService: () => (/* binding */ VulnerabilityService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var VulnerabilityService_1;



const VulnerabilitySchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    severity: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['low', 'medium', 'high', 'critical']),
    cvssScore: zod__WEBPACK_IMPORTED_MODULE_2__.number().min(0).max(10),
    cvssVector: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    cveId: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    affectedComponent: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    affectedVersion: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    fixedVersion: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    status: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'open',
        'in_progress',
        'fixed',
        'false_positive',
        'accepted',
    ]),
    discoveredAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    fixedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
    assignedTo: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    remediation: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    references: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string().url()).optional(),
    tags: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()).optional(),
});
const ScanResultSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    scanId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    vulnerabilityId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    target: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    port: zod__WEBPACK_IMPORTED_MODULE_2__.number().optional(),
    protocol: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    evidence: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    confidence: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['low', 'medium', 'high']),
    falsePositive: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    notes: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    discoveredAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
});
const SecurityScanSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'dependency',
        'container',
        'infrastructure',
        'application',
        'network',
    ]),
    target: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    status: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['pending', 'running', 'completed', 'failed', 'cancelled']),
    startedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    completedAt: zod__WEBPACK_IMPORTED_MODULE_2__.date().optional(),
    duration: zod__WEBPACK_IMPORTED_MODULE_2__.number().optional(),
    totalVulnerabilities: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    criticalVulnerabilities: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    highVulnerabilities: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    mediumVulnerabilities: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    lowVulnerabilities: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    scanConfig: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.unknown()),
    results: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    error: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
});
let VulnerabilityService = VulnerabilityService_1 = class VulnerabilityService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(VulnerabilityService_1.name);
        this.vulnerabilities = [];
        this.scanResults = [];
        this.scans = [];
        this.initializeVulnerabilityService();
    }
    initializeVulnerabilityService() {
        const configData = {
            enabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('VULNERABILITY_SCAN_ENABLED', 'boolean', {
                default: false,
            }),
            schedule: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('VULNERABILITY_SCAN_SCHEDULE', 'string', {
                default: '0 2 * * *',
            }),
            scanTypes: ['dependency', 'container', 'infrastructure'],
            targets: ['localhost', '127.0.0.1'],
            severityThreshold: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('VULNERABILITY_SEVERITY_THRESHOLD', 'string', {
                default: 'medium',
            }),
            autoRemediation: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('VULNERABILITY_AUTO_REMEDIATION', 'boolean', {
                default: false,
            }),
            notificationChannels: ['email', 'slack'],
            retentionDays: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('VULNERABILITY_RETENTION_DAYS', 'number', {
                default: 90,
            }),
        };
        this.config = configData;
        this.logger.log('Vulnerability service initialized');
    }
    async createVulnerability(vulnData) {
        const validatedVuln = VulnerabilitySchema.parse(vulnData);
        if (this.vulnerabilities.some(v => v.cveId === validatedVuln.cveId && validatedVuln.cveId != null)) {
            throw new Error(`Vulnerability with CVE ID '${validatedVuln.cveId}' already exists`);
        }
        this.vulnerabilities.push(validatedVuln);
        this.logger.log(`Vulnerability created: ${validatedVuln.name} (${validatedVuln.id})`);
        return validatedVuln;
    }
    async getVulnerabilityById(vulnId) {
        return this.vulnerabilities.find(v => v.id === vulnId) ?? null;
    }
    async getVulnerabilityByCve(cveId) {
        return this.vulnerabilities.find(v => v.cveId === cveId) ?? null;
    }
    async getAllVulnerabilities() {
        return this.vulnerabilities;
    }
    async getOpenVulnerabilities() {
        return this.vulnerabilities.filter(v => v.status === 'open');
    }
    async getVulnerabilitiesBySeverity(severity) {
        return this.vulnerabilities.filter(v => v.severity === severity);
    }
    async getVulnerabilitiesByComponent(component) {
        return this.vulnerabilities.filter(v => v.affectedComponent === component);
    }
    async updateVulnerability(vulnId, updates) {
        const vuln = this.vulnerabilities.find(v => v.id === vulnId);
        if (!vuln) {
            return null;
        }
        Object.assign(vuln, updates);
        this.logger.log(`Vulnerability updated: ${vulnId}`);
        return vuln;
    }
    async markVulnerabilityAsFixed(vulnId, fixedVersion, assignedTo) {
        const vuln = this.vulnerabilities.find(v => v.id === vulnId);
        if (vuln) {
            vuln.status = 'fixed';
            vuln.fixedVersion = fixedVersion;
            vuln.assignedTo = assignedTo;
            vuln.fixedAt = new Date();
            this.logger.log(`Vulnerability marked as fixed: ${vulnId}`);
        }
    }
    async startSecurityScan(scanData) {
        const scan = {
            id: `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: scanData.name,
            type: scanData.type,
            target: scanData.target,
            status: 'running',
            startedAt: new Date(),
            totalVulnerabilities: 0,
            criticalVulnerabilities: 0,
            highVulnerabilities: 0,
            mediumVulnerabilities: 0,
            lowVulnerabilities: 0,
            scanConfig: scanData.config ?? {},
            results: [],
        };
        this.scans.push(scan);
        this.logger.log(`Security scan started: ${scan.name} (${scan.id})`);
        this.runScan(scan).catch(error => {
            this.logger.error(`Scan failed: ${scan.id} - ${error instanceof Error ? error.message : 'Unknown error'}`);
        });
        return scan;
    }
    async runScan(scan) {
        try {
            await this.simulateScan(scan);
            scan.status = 'completed';
            scan.completedAt = new Date();
            scan.duration = scan.completedAt.getTime() - scan.startedAt.getTime();
            this.logger.log(`Security scan completed: ${scan.name} (${scan.id})`);
        }
        catch (error) {
            scan.status = 'failed';
            scan.error = error instanceof Error ? error.message : 'Unknown error';
            scan.completedAt = new Date();
            throw error;
        }
    }
    async simulateScan(scan) {
        switch (scan.type) {
            case 'dependency':
                await this.simulateDependencyScan(scan);
                break;
            case 'container':
                await this.simulateContainerScan(scan);
                break;
            case 'infrastructure':
                await this.simulateInfrastructureScan(scan);
                break;
            case 'application':
                await this.simulateApplicationScan(scan);
                break;
            case 'network':
                await this.simulateNetworkScan(scan);
                break;
            default:
                throw new Error(`Unknown scan type: ${scan.type}`);
        }
    }
    async simulateDependencyScan(scan) {
        await new Promise(resolve => setTimeout(resolve, 5000));
        const mockVulnerabilities = [
            { severity: 'critical', count: 2 },
            { severity: 'high', count: 5 },
            { severity: 'medium', count: 8 },
            { severity: 'low', count: 12 },
        ];
        for (const vuln of mockVulnerabilities) {
            for (let i = 0; i < vuln.count; i++) {
                const vulnerability = {
                    id: `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: `Mock ${vuln.severity} vulnerability ${i + 1}`,
                    description: `This is a mock ${vuln.severity} vulnerability for testing purposes`,
                    severity: vuln.severity,
                    cvssScore: this.getCvssScoreForSeverity(vuln.severity),
                    cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                    cveId: `CVE-2024-${Math.floor(Math.random() * 9999)}`,
                    affectedComponent: 'package.json',
                    affectedVersion: '1.0.0',
                    status: 'open',
                    discoveredAt: new Date(),
                    remediation: 'Update to the latest version',
                    references: ['https://example.com/vulnerability'],
                };
                this.vulnerabilities.push(vulnerability);
                const scanResult = {
                    id: `result-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    scanId: scan.id,
                    vulnerabilityId: vulnerability.id,
                    target: scan.target,
                    evidence: `Found in ${vulnerability.affectedComponent}`,
                    confidence: 'high',
                    falsePositive: false,
                    discoveredAt: new Date(),
                };
                this.scanResults.push(scanResult);
                scan.results.push(scanResult.id);
            }
        }
        scan.totalVulnerabilities = mockVulnerabilities.reduce((sum, v) => sum + v.count, 0);
        scan.criticalVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'critical')?.count ?? 0;
        scan.highVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'high')?.count ?? 0;
        scan.mediumVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'medium')?.count ?? 0;
        scan.lowVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'low')?.count ?? 0;
    }
    async simulateContainerScan(scan) {
        await new Promise(resolve => setTimeout(resolve, 3000));
        const mockVulnerabilities = [
            { severity: 'critical', count: 1 },
            { severity: 'high', count: 3 },
            { severity: 'medium', count: 6 },
            { severity: 'low', count: 10 },
        ];
        for (const vuln of mockVulnerabilities) {
            for (let i = 0; i < vuln.count; i++) {
                const vulnerability = {
                    id: `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: `Container ${vuln.severity} vulnerability ${i + 1}`,
                    description: `This is a mock ${vuln.severity} container vulnerability`,
                    severity: vuln.severity,
                    cvssScore: this.getCvssScoreForSeverity(vuln.severity),
                    cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                    cveId: `CVE-2024-${Math.floor(Math.random() * 9999)}`,
                    affectedComponent: 'docker-image',
                    affectedVersion: 'latest',
                    status: 'open',
                    discoveredAt: new Date(),
                    remediation: 'Update base image',
                    references: ['https://example.com/container-vulnerability'],
                };
                this.vulnerabilities.push(vulnerability);
                const scanResult = {
                    id: `result-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    scanId: scan.id,
                    vulnerabilityId: vulnerability.id,
                    target: scan.target,
                    evidence: `Found in container layer`,
                    confidence: 'high',
                    falsePositive: false,
                    discoveredAt: new Date(),
                };
                this.scanResults.push(scanResult);
                scan.results.push(scanResult.id);
            }
        }
        scan.totalVulnerabilities = mockVulnerabilities.reduce((sum, v) => sum + v.count, 0);
        scan.criticalVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'critical')?.count ?? 0;
        scan.highVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'high')?.count ?? 0;
        scan.mediumVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'medium')?.count ?? 0;
        scan.lowVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'low')?.count ?? 0;
    }
    async simulateInfrastructureScan(scan) {
        await new Promise(resolve => setTimeout(resolve, 4000));
        const mockVulnerabilities = [
            { severity: 'critical', count: 0 },
            { severity: 'high', count: 2 },
            { severity: 'medium', count: 4 },
            { severity: 'low', count: 8 },
        ];
        for (const vuln of mockVulnerabilities) {
            for (let i = 0; i < vuln.count; i++) {
                const vulnerability = {
                    id: `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: `Infrastructure ${vuln.severity} vulnerability ${i + 1}`,
                    description: `This is a mock ${vuln.severity} infrastructure vulnerability`,
                    severity: vuln.severity,
                    cvssScore: this.getCvssScoreForSeverity(vuln.severity),
                    cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                    cveId: `CVE-2024-${Math.floor(Math.random() * 9999)}`,
                    affectedComponent: 'kubernetes-cluster',
                    affectedVersion: '1.24.0',
                    status: 'open',
                    discoveredAt: new Date(),
                    remediation: 'Apply security patches',
                    references: ['https://example.com/infrastructure-vulnerability'],
                };
                this.vulnerabilities.push(vulnerability);
                const scanResult = {
                    id: `result-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    scanId: scan.id,
                    vulnerabilityId: vulnerability.id,
                    target: scan.target,
                    evidence: `Found in infrastructure component`,
                    confidence: 'medium',
                    falsePositive: false,
                    discoveredAt: new Date(),
                };
                this.scanResults.push(scanResult);
                scan.results.push(scanResult.id);
            }
        }
        scan.totalVulnerabilities = mockVulnerabilities.reduce((sum, v) => sum + v.count, 0);
        scan.criticalVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'critical')?.count ?? 0;
        scan.highVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'high')?.count ?? 0;
        scan.mediumVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'medium')?.count ?? 0;
        scan.lowVulnerabilities =
            mockVulnerabilities.find(v => v.severity === 'low')?.count ?? 0;
    }
    async simulateApplicationScan(_scan) {
        await new Promise(resolve => setTimeout(resolve, 6000));
    }
    async simulateNetworkScan(_scan) {
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    getCvssScoreForSeverity(severity) {
        switch (severity) {
            case 'critical':
                return 9.0 + Math.random() * 1.0;
            case 'high':
                return 7.0 + Math.random() * 2.0;
            case 'medium':
                return 4.0 + Math.random() * 3.0;
            case 'low':
                return 0.1 + Math.random() * 3.9;
            default:
                return 5.0;
        }
    }
    async getScanResults(scanId) {
        return this.scanResults.filter(r => r.scanId === scanId);
    }
    async getAllScanResults(limit = 100) {
        return this.scanResults
            .sort((a, b) => b.discoveredAt.getTime() - a.discoveredAt.getTime())
            .slice(0, limit);
    }
    async getScanById(scanId) {
        return this.scans.find(s => s.id === scanId) ?? null;
    }
    async getAllScans(limit = 50) {
        return this.scans
            .sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime())
            .slice(0, limit);
    }
    async cancelScan(scanId) {
        const scan = this.scans.find(s => s.id === scanId);
        if (scan != null && scan.status === 'running') {
            scan.status = 'cancelled';
            scan.completedAt = new Date();
            this.logger.log(`Scan cancelled: ${scanId}`);
        }
    }
    async getVulnerabilityStats() {
        const openVulnerabilities = this.vulnerabilities.filter(v => v.status === 'open');
        const fixedVulnerabilities = this.vulnerabilities.filter(v => v.status === 'fixed');
        const vulnerabilitiesBySeverity = this.vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.severity] = (acc[vuln.severity] ?? 0) + 1;
            return acc;
        }, {});
        const vulnerabilitiesByStatus = this.vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.status] = (acc[vuln.status] ?? 0) + 1;
            return acc;
        }, {});
        const vulnerabilitiesByComponent = this.vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.affectedComponent] = (acc[vuln.affectedComponent] ?? 0) + 1;
            return acc;
        }, {});
        const topAffectedComponents = Object.entries(vulnerabilitiesByComponent)
            .map(([component, count]) => ({ component, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const averageCvssScore = this.vulnerabilities.length > 0
            ? this.vulnerabilities.reduce((sum, vuln) => sum + vuln.cvssScore, 0) /
                this.vulnerabilities.length
            : 0;
        const recentVulnerabilities = this.vulnerabilities
            .sort((a, b) => b.discoveredAt.getTime() - a.discoveredAt.getTime())
            .slice(0, 20);
        return {
            totalVulnerabilities: this.vulnerabilities.length,
            openVulnerabilities: openVulnerabilities.length,
            fixedVulnerabilities: fixedVulnerabilities.length,
            vulnerabilitiesBySeverity,
            vulnerabilitiesByStatus,
            vulnerabilitiesByComponent,
            averageCvssScore,
            criticalVulnerabilities: vulnerabilitiesBySeverity.critical ?? 0,
            highVulnerabilities: vulnerabilitiesBySeverity.high ?? 0,
            mediumVulnerabilities: vulnerabilitiesBySeverity.medium ?? 0,
            lowVulnerabilities: vulnerabilitiesBySeverity.low ?? 0,
            topAffectedComponents,
            recentVulnerabilities,
        };
    }
    async getScanConfig() {
        return this.config;
    }
    async updateScanConfig(updates) {
        Object.assign(this.config, updates);
        this.logger.log('Vulnerability scan configuration updated');
        return this.config;
    }
    async runScheduledScans() {
        if (!this.config.enabled) {
            return;
        }
        for (const target of this.config.targets) {
            for (const scanType of this.config.scanTypes) {
                try {
                    await this.startSecurityScan({
                        name: `Scheduled ${scanType} scan`,
                        type: scanType,
                        target,
                    });
                }
                catch (error) {
                    this.logger.error(`Scheduled scan failed: ${scanType} on ${target} - ${error instanceof Error ? error.message : 'Unknown error'}`);
                }
            }
        }
    }
    async healthCheck() {
        return {
            status: 'healthy',
            vulnerabilities: this.vulnerabilities.length,
            scans: this.scans.length,
            config: this.config.enabled ? 'enabled' : 'disabled',
        };
    }
};
VulnerabilityService = VulnerabilityService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], VulnerabilityService);



/***/ }),
/* 223 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WafService: () => (/* binding */ WafService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _utils_getEnv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var WafService_1;



const WafRuleSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    name: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    description: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_2__["enum"]([
        'sql_injection',
        'xss',
        'path_traversal',
        'command_injection',
        'file_upload',
        'rate_limit',
        'geo_block',
    ]),
    pattern: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    action: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['block', 'challenge', 'log', 'redirect']),
    severity: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['low', 'medium', 'high', 'critical']),
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    priority: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    conditions: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.object({
        field: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
        operator: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['equals', 'contains', 'regex', 'ip_range', 'geo']),
        value: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    }))
        .optional(),
});
const WafEventSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    id: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    timestamp: zod__WEBPACK_IMPORTED_MODULE_2__.date(),
    ruleId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    ruleName: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    ruleType: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    action: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    severity: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    sourceIp: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    userAgent: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    requestUrl: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    requestMethod: zod__WEBPACK_IMPORTED_MODULE_2__.string(),
    requestHeaders: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    requestBody: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),
    responseStatus: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    responseTime: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    blocked: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    details: zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), zod__WEBPACK_IMPORTED_MODULE_2__.unknown()).optional(),
});
const WafConfigSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({
    enabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    mode: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['block', 'monitor', 'challenge']),
    defaultAction: zod__WEBPACK_IMPORTED_MODULE_2__["enum"](['block', 'challenge', 'log']),
    maxRequestSize: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    maxUrlLength: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    maxHeaderCount: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    allowedFileTypes: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    blockedFileTypes: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    rateLimitEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    rateLimitRequests: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    rateLimitWindow: zod__WEBPACK_IMPORTED_MODULE_2__.number(),
    geoBlockingEnabled: zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),
    allowedCountries: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    blockedCountries: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    ipWhitelist: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
    ipBlacklist: zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.string()),
});
let WafService = WafService_1 = class WafService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(WafService_1.name);
        this.rules = [];
        this.events = [];
        this.initializeWaf();
    }
    initializeWaf() {
        const configData = {
            enabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_ENABLED', 'boolean', { default: false }),
            mode: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_MODE', 'string', {
                default: 'monitor',
            }),
            defaultAction: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_DEFAULT_ACTION', 'string', {
                default: 'block',
            }),
            maxRequestSize: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_MAX_REQUEST_SIZE', 'number', {
                default: 10485760,
            }),
            maxUrlLength: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_MAX_URL_LENGTH', 'number', { default: 2048 }),
            maxHeaderCount: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_MAX_HEADER_COUNT', 'number', { default: 50 }),
            allowedFileTypes: ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'doc', 'docx'],
            blockedFileTypes: ['exe', 'bat', 'cmd', 'com', 'pif', 'scr', 'vbs', 'js'],
            rateLimitEnabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_RATE_LIMIT_ENABLED', 'boolean', {
                default: false,
            }),
            rateLimitRequests: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_RATE_LIMIT_REQUESTS', 'number', {
                default: 100,
            }),
            rateLimitWindow: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_RATE_LIMIT_WINDOW', 'number', {
                default: 60000,
            }),
            geoBlockingEnabled: (0,_utils_getEnv__WEBPACK_IMPORTED_MODULE_1__.getEnv)('WAF_GEO_BLOCKING_ENABLED', 'boolean', {
                default: false,
            }),
            allowedCountries: ['BY', 'RU', 'US', 'GB', 'DE'],
            blockedCountries: [],
            ipWhitelist: [],
            ipBlacklist: [],
        };
        this.config = WafConfigSchema.parse(configData);
        this.threatIntel = {
            maliciousIps: [],
            suspiciousPatterns: [
                'union select',
                'script>',
                '../',
                'cmd.exe',
                'eval(',
                'document.cookie',
            ],
            knownAttackSignatures: ['sqlmap', 'nikto', 'nmap', 'burp', 'owasp'],
            reputationScores: {},
            threatFeeds: [
                {
                    name: 'AbuseIPDB',
                    url: 'https://api.abuseipdb.com/api/v2/blacklist',
                    lastUpdate: new Date(),
                    status: 'active',
                },
                {
                    name: 'Tor Exit Nodes',
                    url: 'https://check.torproject.org/exit-addresses',
                    lastUpdate: new Date(),
                    status: 'active',
                },
            ],
        };
        this.initializeDefaultRules();
        this.logger.log('WAF service initialized');
    }
    initializeDefaultRules() {
        const defaultRules = [
            {
                id: 'sql-injection-1',
                name: 'SQL Injection Detection',
                description: 'Detect common SQL injection patterns',
                type: 'sql_injection',
                pattern: '(union|select|insert|update|delete|drop|create|alter)\\s+(select|from|where|into|table|database)',
                action: 'block',
                severity: 'high',
                enabled: true,
                priority: 1,
            },
            {
                id: 'xss-1',
                name: 'XSS Detection',
                description: 'Detect cross-site scripting attempts',
                type: 'xss',
                pattern: '<script[^>]*>.*?</script>|<script[^>]*>|javascript:|vbscript:|onload=|onerror=',
                action: 'block',
                severity: 'high',
                enabled: true,
                priority: 2,
            },
            {
                id: 'path-traversal-1',
                name: 'Path Traversal Detection',
                description: 'Detect directory traversal attempts',
                type: 'path_traversal',
                pattern: '\\.\\./|\\.\\.\\\\|%2e%2e%2f|%2e%2e%5c',
                action: 'block',
                severity: 'medium',
                enabled: true,
                priority: 3,
            },
            {
                id: 'command-injection-1',
                name: 'Command Injection Detection',
                description: 'Detect command injection attempts',
                type: 'command_injection',
                pattern: ';\\s*(ls|cat|rm|wget|curl|nc|telnet|ssh|ftp|ping|nslookup)',
                action: 'block',
                severity: 'critical',
                enabled: true,
                priority: 1,
            },
            {
                id: 'file-upload-1',
                name: 'Malicious File Upload Detection',
                description: 'Detect malicious file uploads',
                type: 'file_upload',
                pattern: '\\.(exe|bat|cmd|com|pif|scr|vbs|js|php|asp|aspx)$',
                action: 'block',
                severity: 'high',
                enabled: true,
                priority: 2,
            },
        ];
        this.rules.push(...defaultRules);
    }
    async createRule(ruleData) {
        const validatedRule = WafRuleSchema.parse(ruleData);
        this.rules.push(validatedRule);
        this.logger.log(`WAF rule created: ${validatedRule.name} (${validatedRule.id})`);
        return validatedRule;
    }
    async getRuleById(ruleId) {
        return this.rules.find(r => r.id === ruleId) ?? null;
    }
    async getAllRules() {
        return this.rules.filter(r => r.enabled);
    }
    async updateRule(ruleId, updates) {
        const rule = this.rules.find(r => r.id === ruleId);
        if (rule) {
            Object.assign(rule, updates);
            this.logger.log(`WAF rule updated: ${ruleId}`);
            return rule;
        }
        return null;
    }
    async deleteRule(ruleId) {
        const index = this.rules.findIndex(r => r.id === ruleId);
        if (index !== -1) {
            this.rules.splice(index, 1);
            this.logger.log(`WAF rule deleted: ${ruleId}`);
        }
    }
    async inspectRequest(requestData) {
        if (!this.config.enabled) {
            return { allowed: true, action: 'allow' };
        }
        if (this.config.ipWhitelist.length > 0 &&
            !this.config.ipWhitelist.includes(requestData.sourceIp)) {
            return {
                allowed: false,
                action: 'block',
                reason: 'IP not in whitelist',
            };
        }
        if (this.config.ipBlacklist.includes(requestData.sourceIp)) {
            return {
                allowed: false,
                action: 'block',
                reason: 'IP in blacklist',
            };
        }
        if (this.config.geoBlockingEnabled &&
            requestData.country != null &&
            requestData.country !== '') {
            if (this.config.blockedCountries.includes(requestData.country)) {
                return {
                    allowed: false,
                    action: 'block',
                    reason: `Country ${requestData.country} is blocked`,
                };
            }
        }
        const requestSize = JSON.stringify(requestData).length;
        if (requestSize > this.config.maxRequestSize) {
            return {
                allowed: false,
                action: 'block',
                reason: 'Request too large',
            };
        }
        if (requestData.url.length > this.config.maxUrlLength) {
            return {
                allowed: false,
                action: 'block',
                reason: 'URL too long',
            };
        }
        if (Object.keys(requestData.headers).length > this.config.maxHeaderCount) {
            return {
                allowed: false,
                action: 'block',
                reason: 'Too many headers',
            };
        }
        const sortedRules = this.rules
            .filter(r => r.enabled)
            .sort((a, b) => a.priority - b.priority);
        for (const rule of sortedRules) {
            const isMatch = this.checkRuleMatch(rule, requestData);
            if (isMatch) {
                const event = {
                    id: `waf-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: new Date(),
                    ruleId: rule.id,
                    ruleName: rule.name,
                    ruleType: rule.type,
                    action: rule.action,
                    severity: rule.severity,
                    sourceIp: requestData.sourceIp,
                    userAgent: requestData.userAgent,
                    requestUrl: requestData.url,
                    requestMethod: requestData.method,
                    requestHeaders: requestData.headers,
                    requestBody: requestData.body,
                    responseStatus: 0,
                    responseTime: 0,
                    blocked: rule.action === 'block',
                    details: { matchedPattern: rule.pattern },
                };
                this.events.push(event);
                this.logger.warn(`WAF rule triggered: ${rule.name} for IP ${requestData.sourceIp}`);
                return {
                    allowed: rule.action !== 'block',
                    action: rule.action,
                    ruleId: rule.id,
                    ruleName: rule.name,
                    severity: rule.severity,
                    reason: `Matched rule: ${rule.name}`,
                };
            }
        }
        return { allowed: true, action: 'allow' };
    }
    checkRuleMatch(rule, requestData) {
        const searchText = [
            requestData.url,
            requestData.userAgent,
            requestData.body ?? '',
            JSON.stringify(requestData.headers),
        ]
            .join(' ')
            .toLowerCase();
        const regex = new RegExp(rule.pattern, 'i');
        return regex.test(searchText);
    }
    async getEvents(limit = 100) {
        return this.events
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getEventsByIp(ip, limit = 50) {
        return this.events
            .filter(e => e.sourceIp === ip)
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getEventsByRule(ruleId, limit = 50) {
        return this.events
            .filter(e => e.ruleId === ruleId)
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, limit);
    }
    async getWafStats() {
        const totalRequests = this.events.length;
        const blockedRequests = this.events.filter(e => e.blocked).length;
        const allowedRequests = totalRequests - blockedRequests;
        const blockedRate = totalRequests > 0 ? (blockedRequests / totalRequests) * 100 : 0;
        const ipCounts = this.events
            .filter(e => e.blocked)
            .reduce((acc, event) => {
            acc[event.sourceIp] = (acc[event.sourceIp] ?? 0) + 1;
            return acc;
        }, {});
        const topBlockedIps = Object.entries(ipCounts)
            .map(([ip, count]) => ({ ip, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const ruleCounts = this.events
            .filter(e => e.blocked)
            .reduce((acc, event) => {
            acc[event.ruleId] = (acc[event.ruleId] ?? 0) + 1;
            return acc;
        }, {});
        const topBlockedRules = Object.entries(ruleCounts)
            .map(([ruleId, count]) => {
            const rule = this.rules.find(r => r.id === ruleId);
            return { ruleId, ruleName: rule?.name ?? 'Unknown', count };
        })
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
        const eventsBySeverity = this.events.reduce((acc, event) => {
            acc[event.severity] = (acc[event.severity] ?? 0) + 1;
            return acc;
        }, {});
        const eventsByType = this.events.reduce((acc, event) => {
            acc[event.ruleType] = (acc[event.ruleType] ?? 0) + 1;
            return acc;
        }, {});
        return {
            totalRequests,
            blockedRequests,
            allowedRequests,
            blockedRate,
            topBlockedIps,
            topBlockedRules,
            topBlockedCountries: [],
            averageResponseTime: 0,
            eventsBySeverity,
            eventsByType,
        };
    }
    async getWafConfig() {
        return this.config;
    }
    async updateWafConfig(updates) {
        Object.assign(this.config, updates);
        this.logger.log('WAF configuration updated');
        return this.config;
    }
    async getThreatIntel() {
        return this.threatIntel;
    }
    async addMaliciousIp(ip) {
        if (!this.threatIntel.maliciousIps.includes(ip)) {
            this.threatIntel.maliciousIps.push(ip);
            this.logger.log(`Malicious IP added: ${ip}`);
        }
    }
    async removeMaliciousIp(ip) {
        const index = this.threatIntel.maliciousIps.indexOf(ip);
        if (index !== -1) {
            this.threatIntel.maliciousIps.splice(index, 1);
            this.logger.log(`Malicious IP removed: ${ip}`);
        }
    }
    async healthCheck() {
        return {
            status: 'healthy',
            rules: this.rules.filter(r => r.enabled).length,
            events: this.events.length,
            config: this.config.enabled ? 'enabled' : 'disabled',
        };
    }
};
WafService = WafService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], WafService);



/***/ }),
/* 224 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretRotationService: () => (/* binding */ SecretRotationService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _nestjs_schedule__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(211);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SecretRotationService_1;



let SecretRotationService = SecretRotationService_1 = class SecretRotationService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(SecretRotationService_1.name);
        this.lastRotationTime = new Date();
        this.rotationCount = 0;
        this.config = {
            enabled: process.env.SECRET_ROTATION_ENABLED === 'true',
            rotationInterval: parseInt(process.env.SECRET_ROTATION_INTERVAL ?? '60'),
            secrets: [
                'JWT_SECRET',
                'ENCRYPTION_KEY',
                'API_KEY_SECRET',
                'SUPABASE_KEY',
                'SUPABASE_SERVICE_ROLE_KEY',
            ],
            providers: {
                ...(process.env.AWS_REGION != null && process.env.AWS_REGION !== ''
                    ? {
                        aws: {
                            region: process.env.AWS_REGION,
                            accessKeyId: process.env.AWS_ACCESS_KEY_ID ?? '',
                            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY ?? '',
                        },
                    }
                    : {}),
                ...(process.env.VAULT_URL != null &&
                    process.env.VAULT_URL !== '' &&
                    process.env.VAULT_TOKEN != null &&
                    process.env.VAULT_TOKEN !== ''
                    ? {
                        vault: {
                            url: process.env.VAULT_URL,
                            token: process.env.VAULT_TOKEN,
                        },
                    }
                    : {}),
                ...(process.env.DOPPLER_PROJECT != null &&
                    process.env.DOPPLER_PROJECT !== '' &&
                    process.env.DOPPLER_CONFIG != null &&
                    process.env.DOPPLER_CONFIG !== '' &&
                    process.env.DOPPLER_TOKEN != null &&
                    process.env.DOPPLER_TOKEN !== ''
                    ? {
                        doppler: {
                            project: process.env.DOPPLER_PROJECT,
                            config: process.env.DOPPLER_CONFIG,
                            token: process.env.DOPPLER_TOKEN,
                        },
                    }
                    : {}),
            },
        };
        if (this.config.enabled) {
            this.logger.log('Secret rotation service initialized', {
                interval: this.config.rotationInterval,
                secrets: this.config.secrets,
                providers: Object.keys(this.config.providers),
            });
        }
    }
    async handleSecretRotation() {
        if (!this.config.enabled)
            return;
        const now = new Date();
        const timeSinceLastRotation = (now.getTime() - this.lastRotationTime.getTime()) / (1000 * 60);
        if (timeSinceLastRotation >= this.config.rotationInterval) {
            await this.rotateSecrets();
        }
    }
    async rotateSecrets() {
        try {
            this.logger.log('Starting secret rotation...');
            for (const secretName of this.config.secrets) {
                await this.rotateSecret(secretName);
            }
            this.lastRotationTime = new Date();
            this.rotationCount++;
            this.logger.log(`Secret rotation completed successfully. Total rotations: ${this.rotationCount}`);
        }
        catch (error) {
            this.logger.error('Secret rotation failed', error);
            throw error;
        }
    }
    async rotateSecret(secretName) {
        try {
            await this.generateNewSecret(secretName);
            await this.updateSecretInProvider(secretName, 'new-secret');
            await this.updateSecretInEnvironment(secretName, 'new-secret');
            this.logger.log(`Secret ${secretName} rotated successfully`);
        }
        catch (error) {
            this.logger.error(`Failed to rotate secret ${secretName}`, error);
            throw error;
        }
    }
    async generateNewSecret(secretName) {
        const length = secretName.includes('JWT') ? 64 : 32;
        return (0,crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes)(length).toString('hex');
    }
    async updateSecretInProvider(secretName, newSecret) {
        if (this.config.providers.aws) {
            await this.updateSecretInAWS(secretName, newSecret);
        }
        else if (this.config.providers.vault) {
            await this.updateSecretInVault(secretName, newSecret);
        }
        else if (this.config.providers.doppler) {
            await this.updateSecretInDoppler(secretName, newSecret);
        }
        else {
            this.logger.warn(`No external provider configured for ${secretName}, using local update`);
        }
    }
    async updateSecretInAWS(secretName, _newSecret) {
        if (!this.config.providers.aws)
            return;
        this.logger.debug(`Updating secret ${secretName} in AWS with new value: ${_newSecret.substring(0, 8)}...`);
        try {
            this.logger.log(`Secret ${secretName} updated in AWS Secrets Manager`);
        }
        catch (error) {
            this.logger.error(`Failed to update secret ${secretName} in AWS`, error);
            throw error;
        }
    }
    async updateSecretInVault(secretName, _newSecret) {
        if (!this.config.providers.vault)
            return;
        this.logger.debug(`Updating secret ${secretName} in Vault with new value: ${_newSecret.substring(0, 8)}...`);
        try {
            this.logger.log(`Secret ${secretName} updated in Vault`);
        }
        catch (error) {
            this.logger.error(`Failed to update secret ${secretName} in Vault`, error);
            throw error;
        }
    }
    async updateSecretInDoppler(secretName, _newSecret) {
        if (!this.config.providers.doppler)
            return;
        this.logger.debug(`Updating secret ${secretName} in Doppler with new value: ${_newSecret.substring(0, 8)}...`);
        try {
            this.logger.log(`Secret ${secretName} updated in Doppler`);
        }
        catch (error) {
            this.logger.error(`Failed to update secret ${secretName} in Doppler`, error);
            throw error;
        }
    }
    async updateSecretInEnvironment(secretName, newSecret) {
        if (process.env.NODE_ENV === 'development') {
            process.env[secretName] = newSecret;
            this.logger.log(`Secret ${secretName} updated in environment (development mode)`);
        }
    }
    async forceRotateSecret(secretName) {
        if (!this.config.secrets.includes(secretName)) {
            throw new Error(`Secret ${secretName} is not configured for rotation`);
        }
        await this.rotateSecret(secretName);
    }
    getRotationStats() {
        return {
            enabled: this.config.enabled,
            lastRotation: this.lastRotationTime,
            rotationCount: this.rotationCount,
            interval: this.config.rotationInterval,
            secrets: this.config.secrets,
        };
    }
    getRotationStatus() {
        const now = new Date();
        const timeSinceLastRotation = (now.getTime() - this.lastRotationTime.getTime()) / (1000 * 60);
        const nextRotationIn = this.config.rotationInterval - timeSinceLastRotation;
        return {
            enabled: this.config.enabled,
            lastRotation: this.lastRotationTime,
            nextRotationIn: Math.max(0, nextRotationIn),
            rotationCount: this.rotationCount,
        };
    }
};
__decorate([
    (0,_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.Cron)(_nestjs_schedule__WEBPACK_IMPORTED_MODULE_1__.CronExpression.EVERY_MINUTE),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SecretRotationService.prototype, "handleSecretRotation", null);
SecretRotationService = SecretRotationService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], SecretRotationService);



/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaticAnalyzerService: () => (/* binding */ StaticAnalyzerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var StaticAnalyzerService_1;

let StaticAnalyzerService = StaticAnalyzerService_1 = class StaticAnalyzerService {
    constructor() {
        this.logger = new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Logger(StaticAnalyzerService_1.name);
        this.analysisResults = new Map();
        this.config = {
            enabled: process.env.STATIC_ANALYSIS_ENABLED === 'true',
            rules: {
                security: true,
                performance: true,
                maintainability: true,
                bestPractices: true,
            },
            thresholds: {
                maxComplexity: 10,
                minMaintainability: 65,
                maxDuplication: 15,
                minSecurityScore: 80,
            },
            excludedPaths: [
                'node_modules',
                'dist',
                'build',
                'coverage',
                '.git',
                '*.spec.ts',
                '*.test.ts',
            ],
        };
        if (this.config.enabled) {
            this.logger.log('Static analyzer initialized', {
                rules: this.config.rules,
                thresholds: this.config.thresholds,
            });
        }
    }
    async analyzeFile(filePath, content) {
        const issues = [];
        const metrics = this.calculateMetrics(content);
        if (this.config.rules.security) {
            issues.push(...this.analyzeSecurity(content));
        }
        if (this.config.rules.performance) {
            issues.push(...this.analyzePerformance(content));
        }
        if (this.config.rules.maintainability) {
            issues.push(...this.analyzeMaintainability(content, filePath, metrics));
        }
        if (this.config.rules.bestPractices) {
            issues.push(...this.analyzeBestPractices(content));
        }
        const score = this.calculateScore(issues, metrics);
        const result = {
            filePath,
            issues,
            metrics,
            score,
        };
        this.analysisResults.set(filePath, result);
        return result;
    }
    analyzeSecurity(content) {
        const issues = [];
        if (content.includes('SELECT') &&
            content.includes('${') &&
            !content.includes('parameterized')) {
            issues.push({
                type: 'error',
                severity: 'critical',
                message: 'Potential SQL injection detected',
                line: this.findLineNumber(content, 'SELECT'),
                rule: 'security-sql-injection',
                suggestion: 'Use parameterized queries or ORM methods',
            });
        }
        if (content.includes('innerHTML') || content.includes('outerHTML')) {
            issues.push({
                type: 'warning',
                severity: 'high',
                message: 'Potential XSS vulnerability detected',
                line: this.findLineNumber(content, 'innerHTML'),
                rule: 'security-xss',
                suggestion: 'Use textContent or sanitize HTML content',
            });
        }
        const secretPatterns = [
            /password\s*[:=]\s*['"][^'"]+['"]/i,
            /secret\s*[:=]\s*['"][^'"]+['"]/i,
            /key\s*[:=]\s*['"][^'"]+['"]/i,
            /token\s*[:=]\s*['"][^'"]+['"]/i,
        ];
        for (const pattern of secretPatterns) {
            if (pattern.test(content)) {
                issues.push({
                    type: 'error',
                    severity: 'critical',
                    message: 'Hardcoded secret detected',
                    line: this.findLineNumber(content, pattern.source),
                    rule: 'security-hardcoded-secret',
                    suggestion: 'Use environment variables or secure configuration',
                });
            }
        }
        const unsafeCrypto = ['md5', 'sha1', 'crypto.createHash', 'Math.random()'];
        for (const crypto of unsafeCrypto) {
            if (content.includes(crypto)) {
                issues.push({
                    type: 'warning',
                    severity: 'high',
                    message: `Unsafe cryptographic function: ${crypto}`,
                    line: this.findLineNumber(content, crypto),
                    rule: 'security-unsafe-crypto',
                    suggestion: 'Use crypto.randomBytes() or bcrypt for hashing',
                });
            }
        }
        return issues;
    }
    analyzePerformance(content) {
        const issues = [];
        if (content.includes('findOne') && content.includes('forEach')) {
            issues.push({
                type: 'warning',
                severity: 'medium',
                message: 'Potential N+1 query pattern detected',
                line: this.findLineNumber(content, 'findOne'),
                rule: 'performance-n-plus-one',
                suggestion: 'Use include or join to fetch related data',
            });
        }
        if (content.includes('WHERE') && !content.includes('INDEX')) {
            issues.push({
                type: 'info',
                severity: 'low',
                message: 'Consider adding database indexes for WHERE clauses',
                line: this.findLineNumber(content, 'WHERE'),
                rule: 'performance-missing-index',
                suggestion: 'Add database indexes for frequently queried columns',
            });
        }
        const syncOperations = [
            'fs.readFileSync',
            'fs.writeFileSync',
            'fs.existsSync',
        ];
        for (const syncOp of syncOperations) {
            if (content.includes(syncOp)) {
                issues.push({
                    type: 'warning',
                    severity: 'medium',
                    message: `Synchronous operation detected: ${syncOp}`,
                    line: this.findLineNumber(content, syncOp),
                    rule: 'performance-sync-operation',
                    suggestion: 'Use async/await with promise-based operations',
                });
            }
        }
        if (content.includes('setInterval') && !content.includes('clearInterval')) {
            issues.push({
                type: 'error',
                severity: 'high',
                message: 'Potential memory leak: setInterval without clearInterval',
                line: this.findLineNumber(content, 'setInterval'),
                rule: 'performance-memory-leak',
                suggestion: 'Always clear intervals when component unmounts',
            });
        }
        return issues;
    }
    analyzeMaintainability(content, _filePath, metrics) {
        const issues = [];
        if (metrics.cyclomaticComplexity > this.config.thresholds.maxComplexity) {
            issues.push({
                type: 'warning',
                severity: 'medium',
                message: `High cyclomatic complexity: ${metrics.cyclomaticComplexity}`,
                rule: 'maintainability-complexity',
                suggestion: 'Break down complex functions into smaller ones',
            });
        }
        if (metrics.maintainabilityIndex < this.config.thresholds.minMaintainability) {
            issues.push({
                type: 'warning',
                severity: 'medium',
                message: `Low maintainability index: ${metrics.maintainabilityIndex}`,
                rule: 'maintainability-index',
                suggestion: 'Refactor code to improve maintainability',
            });
        }
        if (metrics.codeDuplication > this.config.thresholds.maxDuplication) {
            issues.push({
                type: 'warning',
                severity: 'medium',
                message: `High code duplication: ${metrics.codeDuplication}%`,
                rule: 'maintainability-duplication',
                suggestion: 'Extract common code into reusable functions',
            });
        }
        const lines = content.split('\n');
        let functionLines = 0;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line != null && (line.includes('function') || line.includes('=>'))) {
                if (functionLines > 50) {
                    issues.push({
                        type: 'warning',
                        severity: 'low',
                        message: `Long function detected: ${functionLines} lines`,
                        line: i + 1,
                        rule: 'maintainability-function-length',
                        suggestion: 'Break down long functions into smaller ones',
                    });
                }
                functionLines = 0;
            }
            else {
                functionLines++;
            }
        }
        return issues;
    }
    analyzeBestPractices(content) {
        const issues = [];
        if (content.includes('console.log') && !content.includes('NODE_ENV')) {
            const lineNumber = this.findLineNumber(content, 'console.log');
            if (lineNumber) {
                issues.push({
                    type: 'warning',
                    severity: 'low',
                    message: 'console.log detected in production code',
                    line: lineNumber,
                    rule: 'best-practices-console-log',
                    suggestion: 'Use proper logging library or remove console.log',
                });
            }
        }
        const importMatches = content.match(/import\s+{([^}]+)}\s+from/g);
        if (importMatches) {
            for (const match of importMatches) {
                const importsMatch = match.match(/{([^}]+)}/);
                if (importsMatch?.[1] !== undefined && importsMatch[1] !== '') {
                    const importList = importsMatch[1].split(',').map(i => i.trim());
                    for (const imp of importList) {
                        const impParts = imp.split(' as ');
                        const impName = impParts[0];
                        if (impName != null &&
                            impName !== '' &&
                            !content.includes(imp) &&
                            !content.includes(impName)) {
                            const lineNumber = this.findLineNumber(content, imp);
                            if (lineNumber) {
                                issues.push({
                                    type: 'info',
                                    severity: 'low',
                                    message: `Unused import: ${imp}`,
                                    line: lineNumber,
                                    rule: 'best-practices-unused-import',
                                    suggestion: 'Remove unused imports',
                                });
                            }
                        }
                    }
                }
            }
        }
        const magicNumbers = content.match(/\b\d{3,}\b/g);
        if (magicNumbers) {
            for (const number of magicNumbers) {
                if (parseInt(number) > 100) {
                    const lineNumber = this.findLineNumber(content, number);
                    if (lineNumber) {
                        issues.push({
                            type: 'info',
                            severity: 'low',
                            message: `Magic number detected: ${number}`,
                            line: lineNumber,
                            rule: 'best-practices-magic-number',
                            suggestion: 'Define constants for magic numbers',
                        });
                    }
                }
            }
        }
        return issues;
    }
    calculateMetrics(content) {
        const lines = content.split('\n');
        const linesOfCode = lines.length;
        let cyclomaticComplexity = 1;
        const complexityKeywords = [
            'if',
            'else',
            'for',
            'while',
            'do',
            'case',
            'catch',
            '&&',
            '||',
            '?',
        ];
        for (const keyword of complexityKeywords) {
            const regex = new RegExp(`\\b${keyword}\\b`, 'g');
            const matches = content.match(regex);
            if (matches) {
                cyclomaticComplexity += matches.length;
            }
        }
        const maintainabilityIndex = Math.max(0, 171 - 5.2 * Math.log(cyclomaticComplexity) - 0.23 * Math.log(linesOfCode));
        const codeDuplication = this.calculateCodeDuplication(content);
        const securityScore = this.calculateSecurityScore(content);
        const performanceScore = this.calculatePerformanceScore(content);
        return {
            linesOfCode,
            cyclomaticComplexity,
            maintainabilityIndex: Math.round(maintainabilityIndex),
            codeDuplication,
            securityScore,
            performanceScore,
        };
    }
    calculateCodeDuplication(content) {
        const lines = content.split('\n').filter(line => line.trim().length > 0);
        const duplicates = new Set();
        for (let i = 0; i < lines.length; i++) {
            for (let j = i + 1; j < lines.length; j++) {
                const lineI = lines[i];
                const lineJ = lines[j];
                if (lineI != null && lineJ != null && lineI === lineJ) {
                    duplicates.add(lineI);
                }
            }
        }
        return Math.round((duplicates.size / lines.length) * 100);
    }
    calculateSecurityScore(content) {
        let score = 100;
        if (content.includes('innerHTML'))
            score -= 20;
        if (content.includes('eval('))
            score -= 30;
        if (content.includes('md5'))
            score -= 15;
        if (content.includes('sha1'))
            score -= 10;
        return Math.max(0, score);
    }
    calculatePerformanceScore(content) {
        let score = 100;
        if (content.includes('setInterval') && !content.includes('clearInterval'))
            score -= 25;
        if (content.includes('readFileSync'))
            score -= 15;
        if (content.includes('findOne') && content.includes('forEach'))
            score -= 20;
        return Math.max(0, score);
    }
    calculateScore(issues, metrics) {
        let score = 100;
        for (const issue of issues) {
            switch (issue.severity) {
                case 'critical':
                    score -= 20;
                    break;
                case 'high':
                    score -= 10;
                    break;
                case 'medium':
                    score -= 5;
                    break;
                case 'low':
                    score -= 2;
                    break;
            }
        }
        if (metrics.cyclomaticComplexity > this.config.thresholds.maxComplexity) {
            score -= 10;
        }
        if (metrics.maintainabilityIndex < this.config.thresholds.minMaintainability) {
            score -= 10;
        }
        if (metrics.securityScore < this.config.thresholds.minSecurityScore) {
            score -= 15;
        }
        return Math.max(0, score);
    }
    findLineNumber(content, pattern) {
        const lines = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line != null && line.includes(pattern)) {
                return i + 1;
            }
        }
        return 1;
    }
    getAnalysisResult(filePath) {
        return this.analysisResults.get(filePath);
    }
    getAllAnalysisResults() {
        return Array.from(this.analysisResults.values());
    }
    clearAnalysisResults() {
        this.analysisResults.clear();
    }
    updateConfig(updates) {
        Object.assign(this.config, updates);
        this.logger.log('Static analyzer config updated', updates);
    }
};
StaticAnalyzerService = StaticAnalyzerService_1 = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)(),
    __metadata("design:paramtypes", [])
], StaticAnalyzerService);



/***/ }),
/* 226 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrismaModule: () => (/* binding */ PrismaModule)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prisma_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(227);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let PrismaModule = class PrismaModule {
};
PrismaModule = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Global)(),
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Module)({
        providers: [_prisma_service__WEBPACK_IMPORTED_MODULE_1__.PrismaService],
        exports: [_prisma_service__WEBPACK_IMPORTED_MODULE_1__.PrismaService],
    })
], PrismaModule);



/***/ }),
/* 227 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrismaService: () => (/* binding */ PrismaService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(228);
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let PrismaService = class PrismaService extends _prisma_client__WEBPACK_IMPORTED_MODULE_1__.PrismaClient {
    async onModuleInit() {
        await this.$connect();
    }
    async onModuleDestroy() {
        await this.$disconnect();
    }
};
PrismaService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], PrismaService);



/***/ }),
/* 228 */
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sentry: () => (/* reexport module object */ _sentry_node__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   initSentry: () => (/* binding */ initSentry)
/* harmony export */ });
/* harmony import */ var _sentry_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(230);
/* harmony import */ var _sentry_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sentry_node__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _env_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);


function initSentry() {
    const config = (0,_env_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)();
    const monitoring = (0,_env_config__WEBPACK_IMPORTED_MODULE_1__.getMonitoringConfig)();
    if (monitoring.sentryDsn != null && monitoring.sentryDsn !== '') {
        _sentry_node__WEBPACK_IMPORTED_MODULE_0__.init({
            dsn: monitoring.sentryDsn,
            environment: config.NODE_ENV,
            tracesSampleRate: config.NODE_ENV === 'production' ? 0.1 : 1.0,
            profilesSampleRate: config.NODE_ENV === 'production' ? 0.1 : 1.0,
            debug: config.NODE_ENV === 'development',
        });
    }
}



/***/ }),
/* 230 */
/***/ ((module) => {

module.exports = require("@sentry/node");

/***/ }),
/* 231 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoggerService: () => (/* binding */ LoggerService)
/* harmony export */ });
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pino__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let LoggerService = class LoggerService {
    constructor() {
        this.logger = pino__WEBPACK_IMPORTED_MODULE_1___default()({
            transport: {
                target: 'pino-pretty',
                options: { colorize: true },
            },
        });
    }
    log(message, ...meta) {
        this.logger.info({ meta }, message);
    }
    error(message, trace, ...meta) {
        this.logger.error({ trace, meta }, message);
    }
    warn(message, ...meta) {
        this.logger.warn({ meta }, message);
    }
    debug(message, ...meta) {
        this.logger.debug({ meta }, message);
    }
    verbose(message, ...meta) {
        this.logger.trace({ meta }, message);
    }
};
LoggerService = __decorate([
    (0,_nestjs_common__WEBPACK_IMPORTED_MODULE_0__.Injectable)()
], LoggerService);



/***/ }),
/* 232 */
/***/ ((module) => {

module.exports = require("pino");

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _nestjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nestjs_common__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _nestjs_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nestjs_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _nestjs_swagger__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_nestjs_swagger__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var compression__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var compression__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(compression__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var helmet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);
/* harmony import */ var helmet__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(helmet__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
/* harmony import */ var reflect_metadata__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(reflect_metadata__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _app_module__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
/* harmony import */ var _config_env_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(117);
/* harmony import */ var _config_sentry_config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(229);
/* harmony import */ var _logger_logger_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(231);












async function bootstrap() {
    (0,_config_env_config__WEBPACK_IMPORTED_MODULE_9__.validateAndLoadConfig)();
    (0,_config_env_config__WEBPACK_IMPORTED_MODULE_9__.validateProductionEnv)();
    const config = (0,_config_env_config__WEBPACK_IMPORTED_MODULE_9__.getConfig)();
    (0,_config_sentry_config__WEBPACK_IMPORTED_MODULE_10__.initSentry)();
    const app = await _nestjs_core__WEBPACK_IMPORTED_MODULE_1__.NestFactory.create(_app_module__WEBPACK_IMPORTED_MODULE_8__.AppModule, {
        logger: new _logger_logger_service__WEBPACK_IMPORTED_MODULE_11__.LoggerService(),
    });
    app.use(helmet__WEBPACK_IMPORTED_MODULE_5___default()());
    app.use(compression__WEBPACK_IMPORTED_MODULE_3___default()());
    app.enableCors({
        origin: ['http://localhost:3000', 'http://127.0.0.1:3000'],
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    });
    app.useGlobalPipes(new _nestjs_common__WEBPACK_IMPORTED_MODULE_0__.ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
            enableImplicitConversion: true,
        },
    }));
    const swaggerConfig = new _nestjs_swagger__WEBPACK_IMPORTED_MODULE_2__.DocumentBuilder()
        .setTitle('SaleSpot BY API')
        .setDescription('API для управления картами лояльности и маркетинговыми кампаниями')
        .setVersion('1.0')
        .addBearerAuth()
        .addTag('auth', 'Аутентификация и авторизация')
        .addTag('cards', 'Карты лояльности')
        .addTag('networks', 'Сети магазинов')
        .addTag('stores', 'Магазины')
        .addTag('brands', 'Бренды')
        .addTag('analytics', 'Аналитика')
        .addServer('http://localhost:3001', 'Development server')
        .addServer('https://api.salespot.by', 'Production server')
        .build();
    const document = _nestjs_swagger__WEBPACK_IMPORTED_MODULE_2__.SwaggerModule.createDocument(app, swaggerConfig);
    const openApiPath = path__WEBPACK_IMPORTED_MODULE_6__.join(__dirname, '../../openapi.json');
    fs__WEBPACK_IMPORTED_MODULE_4__.writeFileSync(openApiPath, JSON.stringify(document, null, 2));
    _nestjs_swagger__WEBPACK_IMPORTED_MODULE_2__.SwaggerModule.setup('docs', app, document);
    app.setGlobalPrefix('api/v1');
    const port = config.PORT;
    try {
        await app.listen(port);
        console.log(`🚀 API запущен на порту ${port}`);
        console.log(`📚 Swagger документация: http://localhost:${port}/docs`);
        console.log(`📄 OpenAPI спецификация: http://localhost:${port}/api-json`);
        console.log(`💾 OpenAPI файл сохранен: ${openApiPath}`);
    }
    catch (error) {
        if (typeof error === 'object' &&
            error != null &&
            'code' in error &&
            error.code === 'EADDRINUSE') {
            console.error(`❌ Порт ${port} уже занят. Остановите процесс на этом порту и попробуйте снова.`);
            console.error(`💡 Команда для освобождения порта: lsof -ti:${port} | xargs kill -9`);
        }
        else {
            console.error('❌ Ошибка запуска API:', error instanceof Error ? error.message : String(error));
        }
        process.exit(1);
    }
}
void bootstrap();

})();

/******/ })()
;